{"version":3,"sources":["../../../src/generated/svm/LinearSVC.ts","../../../src/generated/svm/LinearSVR.ts","../../../src/generated/svm/NuSVC.ts","../../../src/generated/svm/NuSVR.ts","../../../src/generated/svm/OneClassSVM.ts","../../../src/generated/svm/SVC.ts","../../../src/generated/svm/SVR.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear Support Vector Classification.\n\n  Similar to SVC with parameter kernel=’linear’, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.\n\n  The main differences between [`LinearSVC`](#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\") and [`SVC`](sklearn.svm.SVC.html#sklearn.svm.SVC \"sklearn.svm.SVC\") lie in the loss function used by default, and in the handling of intercept regularization between those two implementations.\n\n  This class supports both dense and sparse input and the multiclass support is handled according to a one-vs-the-rest scheme.\n\n  Read more in the [User Guide](../svm.html#svm-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html)\n */\nexport class LinearSVC {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Specifies the norm used in the penalization. The ‘l2’ penalty is the standard used in SVC. The ‘l1’ leads to `coef\\_` vectors that are sparse.\n\n      @defaultValue `'l2'`\n     */\n    penalty?: 'l1' | 'l2'\n\n    /**\n      Specifies the loss function. ‘hinge’ is the standard SVM loss (used e.g. by the SVC class) while ‘squared\\_hinge’ is the square of the hinge loss. The combination of `penalty='l1'` and `loss='hinge'` is not supported.\n\n      @defaultValue `'squared_hinge'`\n     */\n    loss?: 'hinge' | 'squared_hinge'\n\n    /**\n      Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=`false` when n\\_samples > n\\_features. `dual=\"auto\"` will choose the value of the parameter automatically, based on the values of `n\\_samples`, `n\\_features`, `loss`, `multi\\_class` and `penalty`. If `n\\_samples` < `n\\_features` and optimizer supports chosen `loss`, `multi\\_class` and `penalty`, then dual will be set to `true`, otherwise it will be set to `false`.\n\n      @defaultValue `true`\n     */\n    dual?: 'auto' | boolean\n\n    /**\n      Tolerance for stopping criteria.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Determines the multi-class strategy if `y` contains more than two classes. `\"ovr\"` trains n\\_classes one-vs-rest classifiers, while `\"crammer\\_singer\"` optimizes a joint objective over all classes. While `crammer\\_singer` is interesting from a theoretical perspective as it is consistent, it is seldom used in practice as it rarely leads to better accuracy and is more expensive to compute. If `\"crammer\\_singer\"` is chosen, the options loss, penalty and dual will be ignored.\n\n      @defaultValue `'ovr'`\n     */\n    multi_class?: 'ovr' | 'crammer_singer'\n\n    /**\n      Whether or not to fit an intercept. If set to `true`, the feature vector is extended to include an intercept term: `\\[x\\_1, ..., x\\_n, 1\\]`, where 1 corresponds to the intercept. If set to `false`, no intercept will be used in calculations (i.e. data is expected to be already centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      When `fit\\_intercept` is `true`, the instance vector x becomes `\\[x\\_1, ..., x\\_n, intercept\\_scaling\\]`, i.e. a “synthetic” feature with a constant value equal to `intercept\\_scaling` is appended to the instance vector. The intercept becomes intercept\\_scaling \\* synthetic feature weight. Note that liblinear internally penalizes the intercept, treating it like any other term in the feature vector. To reduce the impact of the regularization on the intercept, the `intercept\\_scaling` parameter can be set to a value greater than 1; the higher the value of `intercept\\_scaling`, the lower the impact of regularization on it. Then, the weights become `\\[w\\_x\\_1, ..., w\\_x\\_n, w\\_intercept\\*intercept\\_scaling\\]`, where `w\\_x\\_1, ..., w\\_x\\_n` represent the feature weights and the intercept weight is scaled by `intercept\\_scaling`. This scaling allows the intercept term to have a different regularization behavior compared to the other features.\n\n      @defaultValue `1`\n     */\n    intercept_scaling?: number\n\n    /**\n      Set the parameter C of class i to `class\\_weight\\[i\\]\\*C` for SVC. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in liblinear that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Controls the pseudo random number generation for shuffling the data for the dual coordinate descent (if `dual=True`). When `dual=False` the underlying implementation of [`LinearSVC`](#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\") is not random and `random\\_state` has no effect on the results. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The maximum number of iterations to be run.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n  }) {\n    this.id = `LinearSVC${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LinearSVC.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import LinearSVC\ntry: bridgeLinearSVC\nexcept NameError: bridgeLinearSVC = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LinearSVC = {'penalty': ${\n      this.opts['penalty'] ?? undefined\n    }, 'loss': ${this.opts['loss'] ?? undefined}, 'dual': ${\n      this.opts['dual'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'C': ${\n      this.opts['C'] ?? undefined\n    }, 'multi_class': ${\n      this.opts['multi_class'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'intercept_scaling': ${\n      this.opts['intercept_scaling'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }}\n\nctor_LinearSVC = {k: v for k, v in ctor_LinearSVC.items() if v is not None}`\n\n    await this._py.ex`bridgeLinearSVC[${this.id}] = LinearSVC(**ctor_LinearSVC)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLinearSVC[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LinearSVC_decision_function = {k: v for k, v in pms_LinearSVC_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_decision_function = bridgeLinearSVC[${this.id}].decision_function(**pms_LinearSVC_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_decision_function.tolist() if hasattr(res_LinearSVC_decision_function, 'tolist') else res_LinearSVC_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_densify = {}\n\npms_LinearSVC_densify = {k: v for k, v in pms_LinearSVC_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_densify = bridgeLinearSVC[${this.id}].densify(**pms_LinearSVC_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_densify.tolist() if hasattr(res_LinearSVC_densify, 'tolist') else res_LinearSVC_densify`\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target vector relative to X.\n     */\n    y?: ArrayLike\n\n    /**\n      Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearSVC_fit = {k: v for k, v in pms_LinearSVC_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_fit = bridgeLinearSVC[${this.id}].fit(**pms_LinearSVC_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_fit.tolist() if hasattr(res_LinearSVC_fit, 'tolist') else res_LinearSVC_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVC must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LinearSVC_get_metadata_routing = {k: v for k, v in pms_LinearSVC_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_get_metadata_routing = bridgeLinearSVC[${this.id}].get_metadata_routing(**pms_LinearSVC_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_get_metadata_routing.tolist() if hasattr(res_LinearSVC_get_metadata_routing, 'tolist') else res_LinearSVC_get_metadata_routing`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LinearSVC_predict = {k: v for k, v in pms_LinearSVC_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_predict = bridgeLinearSVC[${this.id}].predict(**pms_LinearSVC_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_predict.tolist() if hasattr(res_LinearSVC_predict, 'tolist') else res_LinearSVC_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearSVC_score = {k: v for k, v in pms_LinearSVC_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_score = bridgeLinearSVC[${this.id}].score(**pms_LinearSVC_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_score.tolist() if hasattr(res_LinearSVC_score, 'tolist') else res_LinearSVC_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearSVC_set_fit_request = {k: v for k, v in pms_LinearSVC_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_set_fit_request = bridgeLinearSVC[${this.id}].set_fit_request(**pms_LinearSVC_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_set_fit_request.tolist() if hasattr(res_LinearSVC_set_fit_request, 'tolist') else res_LinearSVC_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearSVC_set_score_request = {k: v for k, v in pms_LinearSVC_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_set_score_request = bridgeLinearSVC[${this.id}].set_score_request(**pms_LinearSVC_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_set_score_request.tolist() if hasattr(res_LinearSVC_set_score_request, 'tolist') else res_LinearSVC_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVC_sparsify = {}\n\npms_LinearSVC_sparsify = {k: v for k, v in pms_LinearSVC_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVC_sparsify = bridgeLinearSVC[${this.id}].sparsify(**pms_LinearSVC_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVC_sparsify.tolist() if hasattr(res_LinearSVC_sparsify, 'tolist') else res_LinearSVC_sparsify`\n  }\n\n  /**\n    Weights assigned to the features (coefficients in the primal problem).\n\n    `coef\\_` is a readonly property derived from `raw\\_coef\\_` that follows the internal memory layout of liblinear.\n   */\n  get coef_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_coef_ = bridgeLinearSVC[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_coef_.tolist() if hasattr(attr_LinearSVC_coef_, 'tolist') else attr_LinearSVC_coef_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_intercept_ = bridgeLinearSVC[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_intercept_.tolist() if hasattr(attr_LinearSVC_intercept_, 'tolist') else attr_LinearSVC_intercept_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before accessing classes_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_classes_ = bridgeLinearSVC[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_classes_.tolist() if hasattr(attr_LinearSVC_classes_, 'tolist') else attr_LinearSVC_classes_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVC must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_n_features_in_ = bridgeLinearSVC[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_n_features_in_.tolist() if hasattr(attr_LinearSVC_n_features_in_, 'tolist') else attr_LinearSVC_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVC must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_feature_names_in_ = bridgeLinearSVC[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_feature_names_in_.tolist() if hasattr(attr_LinearSVC_feature_names_in_, 'tolist') else attr_LinearSVC_feature_names_in_`\n    })()\n  }\n\n  /**\n    Maximum number of iterations run across all classes.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVC must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVC_n_iter_ = bridgeLinearSVC[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVC_n_iter_.tolist() if hasattr(attr_LinearSVC_n_iter_, 'tolist') else attr_LinearSVC_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear Support Vector Regression.\n\n  Similar to SVR with parameter kernel=’linear’, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.\n\n  The main differences between [`LinearSVR`](#sklearn.svm.LinearSVR \"sklearn.svm.LinearSVR\") and [`SVR`](sklearn.svm.SVR.html#sklearn.svm.SVR \"sklearn.svm.SVR\") lie in the loss function used by default, and in the handling of intercept regularization between those two implementations.\n\n  This class supports both dense and sparse input.\n\n  Read more in the [User Guide](../svm.html#svm-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVR.html)\n */\nexport class LinearSVR {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y. If unsure, set `epsilon=0`.\n\n      @defaultValue `0`\n     */\n    epsilon?: number\n\n    /**\n      Tolerance for stopping criteria.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Specifies the loss function. The epsilon-insensitive loss (standard SVR) is the L1 loss, while the squared epsilon-insensitive loss (‘squared\\_epsilon\\_insensitive’) is the L2 loss.\n\n      @defaultValue `'epsilon_insensitive'`\n     */\n    loss?: 'epsilon_insensitive' | 'squared_epsilon_insensitive'\n\n    /**\n      Whether or not to fit an intercept. If set to `true`, the feature vector is extended to include an intercept term: `\\[x\\_1, ..., x\\_n, 1\\]`, where 1 corresponds to the intercept. If set to `false`, no intercept will be used in calculations (i.e. data is expected to be already centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      When `fit\\_intercept` is `true`, the instance vector x becomes `\\[x\\_1, ..., x\\_n, intercept\\_scaling\\]`, i.e. a “synthetic” feature with a constant value equal to `intercept\\_scaling` is appended to the instance vector. The intercept becomes intercept\\_scaling \\* synthetic feature weight. Note that liblinear internally penalizes the intercept, treating it like any other term in the feature vector. To reduce the impact of the regularization on the intercept, the `intercept\\_scaling` parameter can be set to a value greater than 1; the higher the value of `intercept\\_scaling`, the lower the impact of regularization on it. Then, the weights become `\\[w\\_x\\_1, ..., w\\_x\\_n, w\\_intercept\\*intercept\\_scaling\\]`, where `w\\_x\\_1, ..., w\\_x\\_n` represent the feature weights and the intercept weight is scaled by `intercept\\_scaling`. This scaling allows the intercept term to have a different regularization behavior compared to the other features.\n\n      @defaultValue `1`\n     */\n    intercept_scaling?: number\n\n    /**\n      Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=`false` when n\\_samples > n\\_features. `dual=\"auto\"` will choose the value of the parameter automatically, based on the values of `n\\_samples`, `n\\_features` and `loss`. If `n\\_samples` < `n\\_features` and optimizer supports chosen `loss`, then dual will be set to `true`, otherwise it will be set to `false`.\n\n      @defaultValue `true`\n     */\n    dual?: 'auto' | boolean\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in liblinear that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Controls the pseudo random number generation for shuffling the data. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The maximum number of iterations to be run.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n  }) {\n    this.id = `LinearSVR${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LinearSVR.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import LinearSVR\ntry: bridgeLinearSVR\nexcept NameError: bridgeLinearSVR = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LinearSVR = {'epsilon': ${\n      this.opts['epsilon'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'C': ${\n      this.opts['C'] ?? undefined\n    }, 'loss': ${this.opts['loss'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'intercept_scaling': ${\n      this.opts['intercept_scaling'] ?? undefined\n    }, 'dual': ${this.opts['dual'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }}\n\nctor_LinearSVR = {k: v for k, v in ctor_LinearSVR.items() if v is not None}`\n\n    await this._py.ex`bridgeLinearSVR[${this.id}] = LinearSVR(**ctor_LinearSVR)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLinearSVR[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target vector relative to X.\n     */\n    y?: ArrayLike\n\n    /**\n      Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearSVR_fit = {k: v for k, v in pms_LinearSVR_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_fit = bridgeLinearSVR[${this.id}].fit(**pms_LinearSVR_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_fit.tolist() if hasattr(res_LinearSVR_fit, 'tolist') else res_LinearSVR_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVR must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LinearSVR_get_metadata_routing = {k: v for k, v in pms_LinearSVR_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_get_metadata_routing = bridgeLinearSVR[${this.id}].get_metadata_routing(**pms_LinearSVR_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_get_metadata_routing.tolist() if hasattr(res_LinearSVR_get_metadata_routing, 'tolist') else res_LinearSVR_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LinearSVR_predict = {k: v for k, v in pms_LinearSVR_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_predict = bridgeLinearSVR[${this.id}].predict(**pms_LinearSVR_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_predict.tolist() if hasattr(res_LinearSVR_predict, 'tolist') else res_LinearSVR_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearSVR_score = {k: v for k, v in pms_LinearSVR_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_score = bridgeLinearSVR[${this.id}].score(**pms_LinearSVR_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_score.tolist() if hasattr(res_LinearSVR_score, 'tolist') else res_LinearSVR_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearSVR_set_fit_request = {k: v for k, v in pms_LinearSVR_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_set_fit_request = bridgeLinearSVR[${this.id}].set_fit_request(**pms_LinearSVR_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_set_fit_request.tolist() if hasattr(res_LinearSVR_set_fit_request, 'tolist') else res_LinearSVR_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearSVR_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearSVR_set_score_request = {k: v for k, v in pms_LinearSVR_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearSVR_set_score_request = bridgeLinearSVR[${this.id}].set_score_request(**pms_LinearSVR_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearSVR_set_score_request.tolist() if hasattr(res_LinearSVR_set_score_request, 'tolist') else res_LinearSVR_set_score_request`\n  }\n\n  /**\n    Weights assigned to the features (coefficients in the primal problem).\n\n    `coef\\_` is a readonly property derived from `raw\\_coef\\_` that follows the internal memory layout of liblinear.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVR_coef_ = bridgeLinearSVR[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVR_coef_.tolist() if hasattr(attr_LinearSVR_coef_, 'tolist') else attr_LinearSVR_coef_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVR_intercept_ = bridgeLinearSVR[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVR_intercept_.tolist() if hasattr(attr_LinearSVR_intercept_, 'tolist') else attr_LinearSVR_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVR must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVR_n_features_in_ = bridgeLinearSVR[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVR_n_features_in_.tolist() if hasattr(attr_LinearSVR_n_features_in_, 'tolist') else attr_LinearSVR_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearSVR must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVR_feature_names_in_ = bridgeLinearSVR[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVR_feature_names_in_.tolist() if hasattr(attr_LinearSVR_feature_names_in_, 'tolist') else attr_LinearSVR_feature_names_in_`\n    })()\n  }\n\n  /**\n    Maximum number of iterations run across all classes.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LinearSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearSVR must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearSVR_n_iter_ = bridgeLinearSVR[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearSVR_n_iter_.tolist() if hasattr(attr_LinearSVR_n_iter_, 'tolist') else attr_LinearSVR_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Nu-Support Vector Classification.\n\n  Similar to SVC but uses a parameter to control the number of support vectors.\n\n  The implementation is based on libsvm.\n\n  Read more in the [User Guide](../svm.html#svm-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVC.html)\n */\nexport class NuSVC {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An upper bound on the fraction of margin errors (see [User Guide](../svm.html#nu-svc)) and a lower bound of the fraction of support vectors. Should be in the interval (0, 1\\].\n\n      @defaultValue `0.5`\n     */\n    nu?: number\n\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix. For an intuitive visualization of different kernel types see [Plot classification boundaries with different SVM Kernels](../../auto_examples/svm/plot_svm_kernels.html#sphx-glr-auto-examples-svm-plot-svm-kernels-py).\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Whether to enable probability estimates. This must be enabled prior to calling `fit`, will slow down that method as it internally uses 5-fold cross-validation, and `predict\\_proba` may be inconsistent with `predict`. Read more in the [User Guide](../svm.html#scores-probabilities).\n\n      @defaultValue `false`\n     */\n    probability?: boolean\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Set the parameter C of class i to class\\_weight\\[i\\]\\*C for SVC. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n\n    /**\n      Whether to return a one-vs-rest (‘ovr’) decision function of shape (n\\_samples, n\\_classes) as all other classifiers, or the original one-vs-one (‘ovo’) decision function of libsvm which has shape (n\\_samples, n\\_classes \\* (n\\_classes - 1) / 2). However, one-vs-one (‘ovo’) is always used as multi-class strategy. The parameter is ignored for binary classification.\n\n      @defaultValue `'ovr'`\n     */\n    decision_function_shape?: 'ovo' | 'ovr'\n\n    /**\n      If true, `decision\\_function\\_shape='ovr'`, and number of classes > 2, [predict](../../glossary.html#term-predict) will break ties according to the confidence values of [decision\\_function](../../glossary.html#term-decision_function); otherwise the first class among the tied classes is returned. Please note that breaking ties comes at a relatively high computational cost compared to a simple predict.\n\n      @defaultValue `false`\n     */\n    break_ties?: boolean\n\n    /**\n      Controls the pseudo random number generation for shuffling the data for probability estimates. Ignored when `probability` is `false`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `NuSVC${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NuSVC.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import NuSVC\ntry: bridgeNuSVC\nexcept NameError: bridgeNuSVC = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NuSVC = {'nu': ${\n      this.opts['nu'] ?? undefined\n    }, 'kernel': ${this.opts['kernel'] ?? undefined}, 'degree': ${\n      this.opts['degree'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'shrinking': ${this.opts['shrinking'] ?? undefined}, 'probability': ${\n      this.opts['probability'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'cache_size': ${\n      this.opts['cache_size'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'decision_function_shape': ${\n      this.opts['decision_function_shape'] ?? undefined\n    }, 'break_ties': ${this.opts['break_ties'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_NuSVC = {k: v for k, v in ctor_NuSVC.items() if v is not None}`\n\n    await this._py.ex`bridgeNuSVC[${this.id}] = NuSVC(**ctor_NuSVC)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNuSVC[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Evaluate the decision function for the samples in X.\n   */\n  async decision_function(opts: {\n    /**\n      The input samples.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_decision_function = {k: v for k, v in pms_NuSVC_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_decision_function = bridgeNuSVC[${this.id}].decision_function(**pms_NuSVC_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_decision_function.tolist() if hasattr(res_NuSVC_decision_function, 'tolist') else res_NuSVC_decision_function`\n  }\n\n  /**\n    Fit the SVM model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. For kernel=”precomputed”, the expected shape of X is (n\\_samples, n\\_samples).\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVC_fit = {k: v for k, v in pms_NuSVC_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_fit = bridgeNuSVC[${this.id}].fit(**pms_NuSVC_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_fit.tolist() if hasattr(res_NuSVC_fit, 'tolist') else res_NuSVC_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NuSVC_get_metadata_routing = {k: v for k, v in pms_NuSVC_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_get_metadata_routing = bridgeNuSVC[${this.id}].get_metadata_routing(**pms_NuSVC_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_get_metadata_routing.tolist() if hasattr(res_NuSVC_get_metadata_routing, 'tolist') else res_NuSVC_get_metadata_routing`\n  }\n\n  /**\n    Perform classification on samples in X.\n\n    For an one-class model, +1 or -1 is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict = {k: v for k, v in pms_NuSVC_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict = bridgeNuSVC[${this.id}].predict(**pms_NuSVC_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict.tolist() if hasattr(res_NuSVC_predict, 'tolist') else res_NuSVC_predict`\n  }\n\n  /**\n    Compute log probabilities of possible outcomes for samples in X.\n\n    The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_log_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict_log_proba = {k: v for k, v in pms_NuSVC_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict_log_proba = bridgeNuSVC[${this.id}].predict_log_proba(**pms_NuSVC_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict_log_proba.tolist() if hasattr(res_NuSVC_predict_log_proba, 'tolist') else res_NuSVC_predict_log_proba`\n  }\n\n  /**\n    Compute probabilities of possible outcomes for samples in X.\n\n    The model needs to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict_proba = {k: v for k, v in pms_NuSVC_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict_proba = bridgeNuSVC[${this.id}].predict_proba(**pms_NuSVC_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict_proba.tolist() if hasattr(res_NuSVC_predict_proba, 'tolist') else res_NuSVC_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVC_score = {k: v for k, v in pms_NuSVC_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_score = bridgeNuSVC[${this.id}].score(**pms_NuSVC_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_score.tolist() if hasattr(res_NuSVC_score, 'tolist') else res_NuSVC_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_NuSVC_set_fit_request = {k: v for k, v in pms_NuSVC_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_set_fit_request = bridgeNuSVC[${this.id}].set_fit_request(**pms_NuSVC_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_set_fit_request.tolist() if hasattr(res_NuSVC_set_fit_request, 'tolist') else res_NuSVC_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_NuSVC_set_score_request = {k: v for k, v in pms_NuSVC_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_set_score_request = bridgeNuSVC[${this.id}].set_score_request(**pms_NuSVC_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_set_score_request.tolist() if hasattr(res_NuSVC_set_score_request, 'tolist') else res_NuSVC_set_score_request`\n  }\n\n  /**\n    Multipliers of parameter C of each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing class_weight_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_class_weight_ = bridgeNuSVC[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_class_weight_.tolist() if hasattr(attr_NuSVC_class_weight_, 'tolist') else attr_NuSVC_class_weight_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing classes_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_classes_ = bridgeNuSVC[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_classes_.tolist() if hasattr(attr_NuSVC_classes_, 'tolist') else attr_NuSVC_classes_`\n    })()\n  }\n\n  /**\n    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_dual_coef_ = bridgeNuSVC[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_dual_coef_.tolist() if hasattr(attr_NuSVC_dual_coef_, 'tolist') else attr_NuSVC_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 if the algorithm did not converge.\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing fit_status_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_fit_status_ = bridgeNuSVC[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_fit_status_.tolist() if hasattr(attr_NuSVC_fit_status_, 'tolist') else attr_NuSVC_fit_status_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_intercept_ = bridgeNuSVC[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_intercept_.tolist() if hasattr(attr_NuSVC_intercept_, 'tolist') else attr_NuSVC_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_n_features_in_ = bridgeNuSVC[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_n_features_in_.tolist() if hasattr(attr_NuSVC_n_features_in_, 'tolist') else attr_NuSVC_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVC must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_feature_names_in_ = bridgeNuSVC[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_feature_names_in_.tolist() if hasattr(attr_NuSVC_feature_names_in_, 'tolist') else attr_NuSVC_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_n_iter_ = bridgeNuSVC[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_n_iter_.tolist() if hasattr(attr_NuSVC_n_iter_, 'tolist') else attr_NuSVC_n_iter_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_support_ = bridgeNuSVC[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_support_.tolist() if hasattr(attr_NuSVC_support_, 'tolist') else attr_NuSVC_support_`\n    })()\n  }\n\n  /**\n    Support vectors.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVC must call init() before accessing support_vectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_support_vectors_ = bridgeNuSVC[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_support_vectors_.tolist() if hasattr(attr_NuSVC_support_vectors_, 'tolist') else attr_NuSVC_support_vectors_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing shape_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_shape_fit_ = bridgeNuSVC[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_shape_fit_.tolist() if hasattr(attr_NuSVC_shape_fit_, 'tolist') else attr_NuSVC_shape_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Nu Support Vector Regression.\n\n  Similar to NuSVC, for regression, uses a parameter nu to control the number of support vectors. However, unlike NuSVC, where nu replaces C, here nu replaces the parameter epsilon of epsilon-SVR.\n\n  The implementation is based on libsvm.\n\n  Read more in the [User Guide](../svm.html#svm-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVR.html)\n */\nexport class NuSVR {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1\\]. By default 0.5 will be taken.\n\n      @defaultValue `0.5`\n     */\n    nu?: number\n\n    /**\n      Penalty parameter C of the error term.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n  }) {\n    this.id = `NuSVR${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NuSVR.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import NuSVR\ntry: bridgeNuSVR\nexcept NameError: bridgeNuSVR = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NuSVR = {'nu': ${\n      this.opts['nu'] ?? undefined\n    }, 'C': ${this.opts['C'] ?? undefined}, 'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'coef0': ${this.opts['coef0'] ?? undefined}, 'shrinking': ${\n      this.opts['shrinking'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'cache_size': ${\n      this.opts['cache_size'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }}\n\nctor_NuSVR = {k: v for k, v in ctor_NuSVR.items() if v is not None}`\n\n    await this._py.ex`bridgeNuSVR[${this.id}] = NuSVR(**ctor_NuSVR)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNuSVR[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the SVM model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. For kernel=”precomputed”, the expected shape of X is (n\\_samples, n\\_samples).\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVR_fit = {k: v for k, v in pms_NuSVR_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_fit = bridgeNuSVR[${this.id}].fit(**pms_NuSVR_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_fit.tolist() if hasattr(res_NuSVR_fit, 'tolist') else res_NuSVR_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NuSVR_get_metadata_routing = {k: v for k, v in pms_NuSVR_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_get_metadata_routing = bridgeNuSVR[${this.id}].get_metadata_routing(**pms_NuSVR_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_get_metadata_routing.tolist() if hasattr(res_NuSVR_get_metadata_routing, 'tolist') else res_NuSVR_get_metadata_routing`\n  }\n\n  /**\n    Perform regression on samples in X.\n\n    For an one-class model, +1 (inlier) or -1 (outlier) is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVR_predict = {k: v for k, v in pms_NuSVR_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_predict = bridgeNuSVR[${this.id}].predict(**pms_NuSVR_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_predict.tolist() if hasattr(res_NuSVR_predict, 'tolist') else res_NuSVR_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVR_score = {k: v for k, v in pms_NuSVR_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_score = bridgeNuSVR[${this.id}].score(**pms_NuSVR_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_score.tolist() if hasattr(res_NuSVR_score, 'tolist') else res_NuSVR_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_NuSVR_set_fit_request = {k: v for k, v in pms_NuSVR_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_set_fit_request = bridgeNuSVR[${this.id}].set_fit_request(**pms_NuSVR_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_set_fit_request.tolist() if hasattr(res_NuSVR_set_fit_request, 'tolist') else res_NuSVR_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVR_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_NuSVR_set_score_request = {k: v for k, v in pms_NuSVR_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVR_set_score_request = bridgeNuSVR[${this.id}].set_score_request(**pms_NuSVR_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVR_set_score_request.tolist() if hasattr(res_NuSVR_set_score_request, 'tolist') else res_NuSVR_set_score_request`\n  }\n\n  /**\n    Multipliers of parameter C for each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing class_weight_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_class_weight_ = bridgeNuSVR[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_class_weight_.tolist() if hasattr(attr_NuSVR_class_weight_, 'tolist') else attr_NuSVR_class_weight_`\n    })()\n  }\n\n  /**\n    Coefficients of the support vector in the decision function.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_dual_coef_ = bridgeNuSVR[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_dual_coef_.tolist() if hasattr(attr_NuSVR_dual_coef_, 'tolist') else attr_NuSVR_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 otherwise (will raise warning)\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing fit_status_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_fit_status_ = bridgeNuSVR[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_fit_status_.tolist() if hasattr(attr_NuSVR_fit_status_, 'tolist') else attr_NuSVR_fit_status_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_intercept_ = bridgeNuSVR[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_intercept_.tolist() if hasattr(attr_NuSVR_intercept_, 'tolist') else attr_NuSVR_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_n_features_in_ = bridgeNuSVR[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_n_features_in_.tolist() if hasattr(attr_NuSVR_n_features_in_, 'tolist') else attr_NuSVR_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVR must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_feature_names_in_ = bridgeNuSVR[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_feature_names_in_.tolist() if hasattr(attr_NuSVR_feature_names_in_, 'tolist') else attr_NuSVR_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVR_n_iter_ = bridgeNuSVR[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_n_iter_.tolist() if hasattr(attr_NuSVR_n_iter_, 'tolist') else attr_NuSVR_n_iter_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing shape_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_shape_fit_ = bridgeNuSVR[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_shape_fit_.tolist() if hasattr(attr_NuSVR_shape_fit_, 'tolist') else attr_NuSVR_shape_fit_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVR must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVR_support_ = bridgeNuSVR[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_support_.tolist() if hasattr(attr_NuSVR_support_, 'tolist') else attr_NuSVR_support_`\n    })()\n  }\n\n  /**\n    Support vectors.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVR must call init() before accessing support_vectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVR_support_vectors_ = bridgeNuSVR[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVR_support_vectors_.tolist() if hasattr(attr_NuSVR_support_vectors_, 'tolist') else attr_NuSVR_support_vectors_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Unsupervised Outlier Detection.\n\n  Estimate the support of a high-dimensional distribution.\n\n  The implementation is based on libsvm.\n\n  Read more in the [User Guide](../outlier_detection.html#outlier-detection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.OneClassSVM.html)\n */\nexport class OneClassSVM {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1\\]. By default 0.5 will be taken.\n\n      @defaultValue `0.5`\n     */\n    nu?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n  }) {\n    this.id = `OneClassSVM${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('OneClassSVM.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import OneClassSVM\ntry: bridgeOneClassSVM\nexcept NameError: bridgeOneClassSVM = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OneClassSVM = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'coef0': ${this.opts['coef0'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'nu': ${this.opts['nu'] ?? undefined}, 'shrinking': ${\n      this.opts['shrinking'] ?? undefined\n    }, 'cache_size': ${this.opts['cache_size'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}}\n\nctor_OneClassSVM = {k: v for k, v in ctor_OneClassSVM.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOneClassSVM[${this.id}] = OneClassSVM(**ctor_OneClassSVM)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOneClassSVM[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Signed distance to the separating hyperplane.\n\n    Signed distance is positive for an inlier and negative for an outlier.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneClassSVM_decision_function = {k: v for k, v in pms_OneClassSVM_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_decision_function = bridgeOneClassSVM[${this.id}].decision_function(**pms_OneClassSVM_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_decision_function.tolist() if hasattr(res_OneClassSVM_decision_function, 'tolist') else res_OneClassSVM_decision_function`\n  }\n\n  /**\n    Detect the soft boundary of the set of samples X.\n   */\n  async fit(opts: {\n    /**\n      Set of samples, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_OneClassSVM_fit = {k: v for k, v in pms_OneClassSVM_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_fit = bridgeOneClassSVM[${this.id}].fit(**pms_OneClassSVM_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_fit.tolist() if hasattr(res_OneClassSVM_fit, 'tolist') else res_OneClassSVM_fit`\n  }\n\n  /**\n    Perform fit on X and returns labels for X.\n\n    Returns -1 for outliers and 1 for inliers.\n   */\n  async fit_predict(opts: {\n    /**\n      The input samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OneClassSVM_fit_predict = {k: v for k, v in pms_OneClassSVM_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_fit_predict = bridgeOneClassSVM[${this.id}].fit_predict(**pms_OneClassSVM_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_fit_predict.tolist() if hasattr(res_OneClassSVM_fit_predict, 'tolist') else res_OneClassSVM_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OneClassSVM_get_metadata_routing = {k: v for k, v in pms_OneClassSVM_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_get_metadata_routing = bridgeOneClassSVM[${this.id}].get_metadata_routing(**pms_OneClassSVM_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_get_metadata_routing.tolist() if hasattr(res_OneClassSVM_get_metadata_routing, 'tolist') else res_OneClassSVM_get_metadata_routing`\n  }\n\n  /**\n    Perform classification on samples in X.\n\n    For a one-class model, +1 or -1 is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneClassSVM_predict = {k: v for k, v in pms_OneClassSVM_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_predict = bridgeOneClassSVM[${this.id}].predict(**pms_OneClassSVM_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_predict.tolist() if hasattr(res_OneClassSVM_predict, 'tolist') else res_OneClassSVM_predict`\n  }\n\n  /**\n    Raw scoring function of the samples.\n   */\n  async score_samples(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneClassSVM_score_samples = {k: v for k, v in pms_OneClassSVM_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_score_samples = bridgeOneClassSVM[${this.id}].score_samples(**pms_OneClassSVM_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_score_samples.tolist() if hasattr(res_OneClassSVM_score_samples, 'tolist') else res_OneClassSVM_score_samples`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneClassSVM_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OneClassSVM_set_fit_request = {k: v for k, v in pms_OneClassSVM_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneClassSVM_set_fit_request = bridgeOneClassSVM[${this.id}].set_fit_request(**pms_OneClassSVM_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneClassSVM_set_fit_request.tolist() if hasattr(res_OneClassSVM_set_fit_request, 'tolist') else res_OneClassSVM_set_fit_request`\n  }\n\n  /**\n    Multipliers of parameter C for each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing class_weight_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_class_weight_ = bridgeOneClassSVM[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_class_weight_.tolist() if hasattr(attr_OneClassSVM_class_weight_, 'tolist') else attr_OneClassSVM_class_weight_`\n    })()\n  }\n\n  /**\n    Coefficients of the support vectors in the decision function.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing dual_coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_dual_coef_ = bridgeOneClassSVM[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_dual_coef_.tolist() if hasattr(attr_OneClassSVM_dual_coef_, 'tolist') else attr_OneClassSVM_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 otherwise (will raise warning)\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing fit_status_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_fit_status_ = bridgeOneClassSVM[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_fit_status_.tolist() if hasattr(attr_OneClassSVM_fit_status_, 'tolist') else attr_OneClassSVM_fit_status_`\n    })()\n  }\n\n  /**\n    Constant in the decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_intercept_ = bridgeOneClassSVM[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_intercept_.tolist() if hasattr(attr_OneClassSVM_intercept_, 'tolist') else attr_OneClassSVM_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_n_features_in_ = bridgeOneClassSVM[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_n_features_in_.tolist() if hasattr(attr_OneClassSVM_n_features_in_, 'tolist') else attr_OneClassSVM_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_feature_names_in_ = bridgeOneClassSVM[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_feature_names_in_.tolist() if hasattr(attr_OneClassSVM_feature_names_in_, 'tolist') else attr_OneClassSVM_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_n_iter_ = bridgeOneClassSVM[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_n_iter_.tolist() if hasattr(attr_OneClassSVM_n_iter_, 'tolist') else attr_OneClassSVM_n_iter_`\n    })()\n  }\n\n  /**\n    Offset used to define the decision function from the raw scores. We have the relation: decision\\_function = score\\_samples - `offset\\_`. The offset is the opposite of `intercept\\_` and is provided for consistency with other outlier detection algorithms.\n   */\n  get offset_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before accessing offset_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_offset_ = bridgeOneClassSVM[${this.id}].offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_offset_.tolist() if hasattr(attr_OneClassSVM_offset_, 'tolist') else attr_OneClassSVM_offset_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing shape_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_shape_fit_ = bridgeOneClassSVM[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_shape_fit_.tolist() if hasattr(attr_OneClassSVM_shape_fit_, 'tolist') else attr_OneClassSVM_shape_fit_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneClassSVM must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_support_ = bridgeOneClassSVM[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_support_.tolist() if hasattr(attr_OneClassSVM_support_, 'tolist') else attr_OneClassSVM_support_`\n    })()\n  }\n\n  /**\n    Support vectors.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneClassSVM must call init() before accessing support_vectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneClassSVM_support_vectors_ = bridgeOneClassSVM[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneClassSVM_support_vectors_.tolist() if hasattr(attr_OneClassSVM_support_vectors_, 'tolist') else attr_OneClassSVM_support_vectors_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  C-Support Vector Classification.\n\n  The implementation is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. For large datasets consider using [`LinearSVC`](sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\") or [`SGDClassifier`](sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier \"sklearn.linear_model.SGDClassifier\") instead, possibly after a [`Nystroem`](sklearn.kernel_approximation.Nystroem.html#sklearn.kernel_approximation.Nystroem \"sklearn.kernel_approximation.Nystroem\") transformer or other [Kernel Approximation](../kernel_approximation.html#kernel-approximation).\n\n  The multiclass support is handled according to a one-vs-one scheme.\n\n  For details on the precise mathematical formulation of the provided kernel functions and how `gamma`, `coef0` and `degree` affect each other, see the corresponding section in the narrative documentation: [Kernel functions](../svm.html#svm-kernels).\n\n  Read more in the [User Guide](../svm.html#svm-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html)\n */\nexport class SVC {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive. The penalty is a squared l2 penalty.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to pre-compute the kernel matrix from data matrices; that matrix should be an array of shape `(n\\_samples, n\\_samples)`. For an intuitive visualization of different kernel types see [Plot classification boundaries with different SVM Kernels](../../auto_examples/svm/plot_svm_kernels.html#sphx-glr-auto-examples-svm-plot-svm-kernels-py).\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Whether to enable probability estimates. This must be enabled prior to calling `fit`, will slow down that method as it internally uses 5-fold cross-validation, and `predict\\_proba` may be inconsistent with `predict`. Read more in the [User Guide](../svm.html#scores-probabilities).\n\n      @defaultValue `false`\n     */\n    probability?: boolean\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Set the parameter C of class i to class\\_weight\\[i\\]\\*C for SVC. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n\n    /**\n      Whether to return a one-vs-rest (‘ovr’) decision function of shape (n\\_samples, n\\_classes) as all other classifiers, or the original one-vs-one (‘ovo’) decision function of libsvm which has shape (n\\_samples, n\\_classes \\* (n\\_classes - 1) / 2). However, note that internally, one-vs-one (‘ovo’) is always used as a multi-class strategy to train models; an ovr matrix is only constructed from the ovo matrix. The parameter is ignored for binary classification.\n\n      @defaultValue `'ovr'`\n     */\n    decision_function_shape?: 'ovo' | 'ovr'\n\n    /**\n      If true, `decision\\_function\\_shape='ovr'`, and number of classes > 2, [predict](../../glossary.html#term-predict) will break ties according to the confidence values of [decision\\_function](../../glossary.html#term-decision_function); otherwise the first class among the tied classes is returned. Please note that breaking ties comes at a relatively high computational cost compared to a simple predict.\n\n      @defaultValue `false`\n     */\n    break_ties?: boolean\n\n    /**\n      Controls the pseudo random number generation for shuffling the data for probability estimates. Ignored when `probability` is `false`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SVC${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SVC.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import SVC\ntry: bridgeSVC\nexcept NameError: bridgeSVC = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SVC = {'C': ${\n      this.opts['C'] ?? undefined\n    }, 'kernel': ${this.opts['kernel'] ?? undefined}, 'degree': ${\n      this.opts['degree'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'shrinking': ${this.opts['shrinking'] ?? undefined}, 'probability': ${\n      this.opts['probability'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'cache_size': ${\n      this.opts['cache_size'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'decision_function_shape': ${\n      this.opts['decision_function_shape'] ?? undefined\n    }, 'break_ties': ${this.opts['break_ties'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_SVC = {k: v for k, v in ctor_SVC.items() if v is not None}`\n\n    await this._py.ex`bridgeSVC[${this.id}] = SVC(**ctor_SVC)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSVC[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Evaluate the decision function for the samples in X.\n   */\n  async decision_function(opts: {\n    /**\n      The input samples.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SVC_decision_function = {k: v for k, v in pms_SVC_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_decision_function = bridgeSVC[${this.id}].decision_function(**pms_SVC_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_decision_function.tolist() if hasattr(res_SVC_decision_function, 'tolist') else res_SVC_decision_function`\n  }\n\n  /**\n    Fit the SVM model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. For kernel=”precomputed”, the expected shape of X is (n\\_samples, n\\_samples).\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SVC_fit = {k: v for k, v in pms_SVC_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_SVC_fit = bridgeSVC[${this.id}].fit(**pms_SVC_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_fit.tolist() if hasattr(res_SVC_fit, 'tolist') else res_SVC_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SVC_get_metadata_routing = {k: v for k, v in pms_SVC_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_get_metadata_routing = bridgeSVC[${this.id}].get_metadata_routing(**pms_SVC_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_get_metadata_routing.tolist() if hasattr(res_SVC_get_metadata_routing, 'tolist') else res_SVC_get_metadata_routing`\n  }\n\n  /**\n    Perform classification on samples in X.\n\n    For an one-class model, +1 or -1 is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SVC_predict = {k: v for k, v in pms_SVC_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_predict = bridgeSVC[${this.id}].predict(**pms_SVC_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_predict.tolist() if hasattr(res_SVC_predict, 'tolist') else res_SVC_predict`\n  }\n\n  /**\n    Compute log probabilities of possible outcomes for samples in X.\n\n    The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_log_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SVC_predict_log_proba = {k: v for k, v in pms_SVC_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_predict_log_proba = bridgeSVC[${this.id}].predict_log_proba(**pms_SVC_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_predict_log_proba.tolist() if hasattr(res_SVC_predict_log_proba, 'tolist') else res_SVC_predict_log_proba`\n  }\n\n  /**\n    Compute probabilities of possible outcomes for samples in X.\n\n    The model needs to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SVC_predict_proba = {k: v for k, v in pms_SVC_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_predict_proba = bridgeSVC[${this.id}].predict_proba(**pms_SVC_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_predict_proba.tolist() if hasattr(res_SVC_predict_proba, 'tolist') else res_SVC_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SVC_score = {k: v for k, v in pms_SVC_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_score = bridgeSVC[${this.id}].score(**pms_SVC_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_score.tolist() if hasattr(res_SVC_score, 'tolist') else res_SVC_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SVC_set_fit_request = {k: v for k, v in pms_SVC_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_set_fit_request = bridgeSVC[${this.id}].set_fit_request(**pms_SVC_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_set_fit_request.tolist() if hasattr(res_SVC_set_fit_request, 'tolist') else res_SVC_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVC_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SVC_set_score_request = {k: v for k, v in pms_SVC_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVC_set_score_request = bridgeSVC[${this.id}].set_score_request(**pms_SVC_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVC_set_score_request.tolist() if hasattr(res_SVC_set_score_request, 'tolist') else res_SVC_set_score_request`\n  }\n\n  /**\n    Multipliers of parameter C for each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing class_weight_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVC_class_weight_ = bridgeSVC[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_class_weight_.tolist() if hasattr(attr_SVC_class_weight_, 'tolist') else attr_SVC_class_weight_`\n    })()\n  }\n\n  /**\n    The classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing classes_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_classes_ = bridgeSVC[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_classes_.tolist() if hasattr(attr_SVC_classes_, 'tolist') else attr_SVC_classes_`\n    })()\n  }\n\n  /**\n    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_dual_coef_ = bridgeSVC[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_dual_coef_.tolist() if hasattr(attr_SVC_dual_coef_, 'tolist') else attr_SVC_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 otherwise (will raise warning)\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing fit_status_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVC_fit_status_ = bridgeSVC[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_fit_status_.tolist() if hasattr(attr_SVC_fit_status_, 'tolist') else attr_SVC_fit_status_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_intercept_ = bridgeSVC[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_intercept_.tolist() if hasattr(attr_SVC_intercept_, 'tolist') else attr_SVC_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVC_n_features_in_ = bridgeSVC[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_n_features_in_.tolist() if hasattr(attr_SVC_n_features_in_, 'tolist') else attr_SVC_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVC_feature_names_in_ = bridgeSVC[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_feature_names_in_.tolist() if hasattr(attr_SVC_feature_names_in_, 'tolist') else attr_SVC_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_n_iter_ = bridgeSVC[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_n_iter_.tolist() if hasattr(attr_SVC_n_iter_, 'tolist') else attr_SVC_n_iter_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_support_ = bridgeSVC[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_support_.tolist() if hasattr(attr_SVC_support_, 'tolist') else attr_SVC_support_`\n    })()\n  }\n\n  /**\n    Support vectors. An empty array if kernel is precomputed.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing support_vectors_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVC_support_vectors_ = bridgeSVC[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_support_vectors_.tolist() if hasattr(attr_SVC_support_vectors_, 'tolist') else attr_SVC_support_vectors_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVC must call init() before accessing shape_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVC_shape_fit_ = bridgeSVC[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVC_shape_fit_.tolist() if hasattr(attr_SVC_shape_fit_, 'tolist') else attr_SVC_shape_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Epsilon-Support Vector Regression.\n\n  The free parameters in the model are C and epsilon.\n\n  The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples. For large datasets consider using [`LinearSVR`](sklearn.svm.LinearSVR.html#sklearn.svm.LinearSVR \"sklearn.svm.LinearSVR\") or [`SGDRegressor`](sklearn.linear_model.SGDRegressor.html#sklearn.linear_model.SGDRegressor \"sklearn.linear_model.SGDRegressor\") instead, possibly after a [`Nystroem`](sklearn.kernel_approximation.Nystroem.html#sklearn.kernel_approximation.Nystroem \"sklearn.kernel_approximation.Nystroem\") transformer or other [Kernel Approximation](../kernel_approximation.html#kernel-approximation).\n\n  Read more in the [User Guide](../svm.html#svm-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html)\n */\nexport class SVR {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive. The penalty is a squared l2 penalty.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value. Must be non-negative.\n\n      @defaultValue `0.1`\n     */\n    epsilon?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n  }) {\n    this.id = `SVR${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SVR.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import SVR\ntry: bridgeSVR\nexcept NameError: bridgeSVR = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SVR = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'coef0': ${this.opts['coef0'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'C': ${this.opts['C'] ?? undefined}, 'epsilon': ${\n      this.opts['epsilon'] ?? undefined\n    }, 'shrinking': ${this.opts['shrinking'] ?? undefined}, 'cache_size': ${\n      this.opts['cache_size'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }}\n\nctor_SVR = {k: v for k, v in ctor_SVR.items() if v is not None}`\n\n    await this._py.ex`bridgeSVR[${this.id}] = SVR(**ctor_SVR)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSVR[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the SVM model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. For kernel=”precomputed”, the expected shape of X is (n\\_samples, n\\_samples).\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SVR_fit = {k: v for k, v in pms_SVR_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_SVR_fit = bridgeSVR[${this.id}].fit(**pms_SVR_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_fit.tolist() if hasattr(res_SVR_fit, 'tolist') else res_SVR_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SVR_get_metadata_routing = {k: v for k, v in pms_SVR_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVR_get_metadata_routing = bridgeSVR[${this.id}].get_metadata_routing(**pms_SVR_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_get_metadata_routing.tolist() if hasattr(res_SVR_get_metadata_routing, 'tolist') else res_SVR_get_metadata_routing`\n  }\n\n  /**\n    Perform regression on samples in X.\n\n    For an one-class model, +1 (inlier) or -1 (outlier) is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SVR_predict = {k: v for k, v in pms_SVR_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVR_predict = bridgeSVR[${this.id}].predict(**pms_SVR_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_predict.tolist() if hasattr(res_SVR_predict, 'tolist') else res_SVR_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SVR_score = {k: v for k, v in pms_SVR_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVR_score = bridgeSVR[${this.id}].score(**pms_SVR_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_score.tolist() if hasattr(res_SVR_score, 'tolist') else res_SVR_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SVR_set_fit_request = {k: v for k, v in pms_SVR_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVR_set_fit_request = bridgeSVR[${this.id}].set_fit_request(**pms_SVR_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_set_fit_request.tolist() if hasattr(res_SVR_set_fit_request, 'tolist') else res_SVR_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SVR_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SVR_set_score_request = {k: v for k, v in pms_SVR_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SVR_set_score_request = bridgeSVR[${this.id}].set_score_request(**pms_SVR_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SVR_set_score_request.tolist() if hasattr(res_SVR_set_score_request, 'tolist') else res_SVR_set_score_request`\n  }\n\n  /**\n    Multipliers of parameter C for each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing class_weight_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVR_class_weight_ = bridgeSVR[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_class_weight_.tolist() if hasattr(attr_SVR_class_weight_, 'tolist') else attr_SVR_class_weight_`\n    })()\n  }\n\n  /**\n    Coefficients of the support vector in the decision function.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVR_dual_coef_ = bridgeSVR[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_dual_coef_.tolist() if hasattr(attr_SVR_dual_coef_, 'tolist') else attr_SVR_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 otherwise (will raise warning)\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing fit_status_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVR_fit_status_ = bridgeSVR[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_fit_status_.tolist() if hasattr(attr_SVR_fit_status_, 'tolist') else attr_SVR_fit_status_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVR_intercept_ = bridgeSVR[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_intercept_.tolist() if hasattr(attr_SVR_intercept_, 'tolist') else attr_SVR_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVR_n_features_in_ = bridgeSVR[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_n_features_in_.tolist() if hasattr(attr_SVR_n_features_in_, 'tolist') else attr_SVR_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVR_feature_names_in_ = bridgeSVR[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_feature_names_in_.tolist() if hasattr(attr_SVR_feature_names_in_, 'tolist') else attr_SVR_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVR_n_iter_ = bridgeSVR[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_n_iter_.tolist() if hasattr(attr_SVR_n_iter_, 'tolist') else attr_SVR_n_iter_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing shape_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVR_shape_fit_ = bridgeSVR[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_shape_fit_.tolist() if hasattr(attr_SVR_shape_fit_, 'tolist') else attr_SVR_shape_fit_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_SVR_support_ = bridgeSVR[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_support_.tolist() if hasattr(attr_SVR_support_, 'tolist') else attr_SVR_support_`\n    })()\n  }\n\n  /**\n    Support vectors.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SVR instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SVR must call init() before accessing support_vectors_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SVR_support_vectors_ = bridgeSVR[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SVR_support_vectors_.tolist() if hasattr(attr_SVR_support_vectors_, 'tolist') else attr_SVR_support_vectors_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto"]}