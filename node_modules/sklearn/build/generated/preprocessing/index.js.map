{"version":3,"sources":["../../../src/generated/preprocessing/Binarizer.ts","../../../src/generated/preprocessing/FunctionTransformer.ts","../../../src/generated/preprocessing/KBinsDiscretizer.ts","../../../src/generated/preprocessing/KernelCenterer.ts","../../../src/generated/preprocessing/LabelBinarizer.ts","../../../src/generated/preprocessing/LabelEncoder.ts","../../../src/generated/preprocessing/MaxAbsScaler.ts","../../../src/generated/preprocessing/MinMaxScaler.ts","../../../src/generated/preprocessing/MultiLabelBinarizer.ts","../../../src/generated/preprocessing/Normalizer.ts","../../../src/generated/preprocessing/OneHotEncoder.ts","../../../src/generated/preprocessing/OrdinalEncoder.ts","../../../src/generated/preprocessing/PolynomialFeatures.ts","../../../src/generated/preprocessing/PowerTransformer.ts","../../../src/generated/preprocessing/QuantileTransformer.ts","../../../src/generated/preprocessing/RobustScaler.ts","../../../src/generated/preprocessing/SplineTransformer.ts","../../../src/generated/preprocessing/StandardScaler.ts","../../../src/generated/preprocessing/TargetEncoder.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Binarize data (set feature values to 0 or 1) according to a threshold.\n\n  Values greater than the threshold map to 1, while values less than or equal to the threshold map to 0. With the default threshold of 0, only positive values map to 1.\n\n  Binarization is a common operation on text count data where the analyst can decide to only consider the presence or absence of a feature rather than a quantified number of occurrences for instance.\n\n  It can also be used as a pre-processing step for estimators that consider boolean random variables (e.g. modelled using the Bernoulli distribution in a Bayesian setting).\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-binarization).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html)\n */\nexport class Binarizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Feature values below or equal to this are replaced by 0, above it by 1. Threshold may not be less than 0 for operations on sparse matrices.\n\n      @defaultValue `0`\n     */\n    threshold?: number\n\n    /**\n      Set to `false` to perform inplace binarization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix).\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `Binarizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Binarizer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import Binarizer\ntry: bridgeBinarizer\nexcept NameError: bridgeBinarizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Binarizer = {'threshold': ${\n      this.opts['threshold'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}}\n\nctor_Binarizer = {k: v for k, v in ctor_Binarizer.items() if v is not None}`\n\n    await this._py.ex`bridgeBinarizer[${this.id}] = Binarizer(**ctor_Binarizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeBinarizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Only validates estimator’s parameters.\n\n    This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.\n   */\n  async fit(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Binarizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_Binarizer_fit = {k: v for k, v in pms_Binarizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_fit = bridgeBinarizer[${this.id}].fit(**pms_Binarizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_fit.tolist() if hasattr(res_Binarizer_fit, 'tolist') else res_Binarizer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Binarizer must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_Binarizer_fit_transform = {k: v for k, v in pms_Binarizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_fit_transform = bridgeBinarizer[${this.id}].fit_transform(**pms_Binarizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_fit_transform.tolist() if hasattr(res_Binarizer_fit_transform, 'tolist') else res_Binarizer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Binarizer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Binarizer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Binarizer_get_feature_names_out = {k: v for k, v in pms_Binarizer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_get_feature_names_out = bridgeBinarizer[${this.id}].get_feature_names_out(**pms_Binarizer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_get_feature_names_out.tolist() if hasattr(res_Binarizer_get_feature_names_out, 'tolist') else res_Binarizer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Binarizer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Binarizer_get_metadata_routing = {k: v for k, v in pms_Binarizer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_get_metadata_routing = bridgeBinarizer[${this.id}].get_metadata_routing(**pms_Binarizer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_get_metadata_routing.tolist() if hasattr(res_Binarizer_get_metadata_routing, 'tolist') else res_Binarizer_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Binarizer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Binarizer_set_output = {k: v for k, v in pms_Binarizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_set_output = bridgeBinarizer[${this.id}].set_output(**pms_Binarizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_set_output.tolist() if hasattr(res_Binarizer_set_output, 'tolist') else res_Binarizer_set_output`\n  }\n\n  /**\n    Request metadata passed to the `transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Binarizer must call init() before set_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_set_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_Binarizer_set_transform_request = {k: v for k, v in pms_Binarizer_set_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_set_transform_request = bridgeBinarizer[${this.id}].set_transform_request(**pms_Binarizer_set_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_set_transform_request.tolist() if hasattr(res_Binarizer_set_transform_request, 'tolist') else res_Binarizer_set_transform_request`\n  }\n\n  /**\n    Binarize each element of X.\n   */\n  async transform(opts: {\n    /**\n      The data to binarize, element by element. scipy.sparse matrices should be in CSR format to avoid an un-necessary copy.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Copy the input X or not.\n     */\n    copy?: boolean\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Binarizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Binarizer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_Binarizer_transform = {k: v for k, v in pms_Binarizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Binarizer_transform = bridgeBinarizer[${this.id}].transform(**pms_Binarizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Binarizer_transform.tolist() if hasattr(res_Binarizer_transform, 'tolist') else res_Binarizer_transform`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Binarizer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Binarizer_n_features_in_ = bridgeBinarizer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Binarizer_n_features_in_.tolist() if hasattr(attr_Binarizer_n_features_in_, 'tolist') else attr_Binarizer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Binarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Binarizer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Binarizer_feature_names_in_ = bridgeBinarizer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Binarizer_feature_names_in_.tolist() if hasattr(attr_Binarizer_feature_names_in_, 'tolist') else attr_Binarizer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Constructs a transformer from an arbitrary callable.\n\n  A FunctionTransformer forwards its X (and optionally y) arguments to a user-defined function or function object and returns the result of this function. This is useful for stateless transformations such as taking the log of frequencies, doing custom scaling, etc.\n\n  Note: If a lambda is used as the function, then the resulting transformer will not be pickleable.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html)\n */\nexport class FunctionTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The callable to use for the transformation. This will be passed the same arguments as transform, with args and kwargs forwarded. If func is `undefined`, then func will be the identity function.\n     */\n    func?: any\n\n    /**\n      The callable to use for the inverse transformation. This will be passed the same arguments as inverse transform, with args and kwargs forwarded. If inverse\\_func is `undefined`, then inverse\\_func will be the identity function.\n     */\n    inverse_func?: any\n\n    /**\n      Indicate that the input X array should be checked before calling `func`. The possibilities are:\n\n      @defaultValue `false`\n     */\n    validate?: boolean\n\n    /**\n      Indicate that func accepts a sparse matrix as input. If validate is `false`, this has no effect. Otherwise, if accept\\_sparse is false, sparse matrix inputs will cause an exception to be raised.\n\n      @defaultValue `false`\n     */\n    accept_sparse?: boolean\n\n    /**\n      Whether to check that or `func` followed by `inverse\\_func` leads to the original inputs. It can be used for a sanity check, raising a warning when the condition is not fulfilled.\n\n      @defaultValue `true`\n     */\n    check_inverse?: boolean\n\n    /**\n      Determines the list of feature names that will be returned by the `get\\_feature\\_names\\_out` method. If it is ‘one-to-one’, then the output feature names will be equal to the input feature names. If it is a callable, then it must take two positional arguments: this `FunctionTransformer` (`self`) and an array-like of input feature names (`input\\_features`). It must return an array-like of output feature names. The `get\\_feature\\_names\\_out` method is only defined if `feature\\_names\\_out` is not `undefined`.\n\n      See `get\\_feature\\_names\\_out` for more details.\n     */\n    feature_names_out?: 'one-to-one'\n\n    /**\n      Dictionary of additional keyword arguments to pass to func.\n     */\n    kw_args?: any\n\n    /**\n      Dictionary of additional keyword arguments to pass to inverse\\_func.\n     */\n    inv_kw_args?: any\n  }) {\n    this.id = `FunctionTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'FunctionTransformer.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import FunctionTransformer\ntry: bridgeFunctionTransformer\nexcept NameError: bridgeFunctionTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_FunctionTransformer = {'func': ${\n      this.opts['func'] ?? undefined\n    }, 'inverse_func': ${this.opts['inverse_func'] ?? undefined}, 'validate': ${\n      this.opts['validate'] ?? undefined\n    }, 'accept_sparse': ${\n      this.opts['accept_sparse'] ?? undefined\n    }, 'check_inverse': ${\n      this.opts['check_inverse'] ?? undefined\n    }, 'feature_names_out': ${\n      this.opts['feature_names_out'] ?? undefined\n    }, 'kw_args': ${this.opts['kw_args'] ?? undefined}, 'inv_kw_args': ${\n      this.opts['inv_kw_args'] ?? undefined\n    }}\n\nctor_FunctionTransformer = {k: v for k, v in ctor_FunctionTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeFunctionTransformer[${this.id}] = FunctionTransformer(**ctor_FunctionTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeFunctionTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit transformer by checking X.\n\n    If `validate` is `true`, `X` will be checked.\n   */\n  async fit(opts: {\n    /**\n      Input array.\n     */\n    X?: any\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FunctionTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FunctionTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FunctionTransformer_fit = {k: v for k, v in pms_FunctionTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_fit = bridgeFunctionTransformer[${this.id}].fit(**pms_FunctionTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_fit.tolist() if hasattr(res_FunctionTransformer_fit, 'tolist') else res_FunctionTransformer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FunctionTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_FunctionTransformer_fit_transform = {k: v for k, v in pms_FunctionTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_fit_transform = bridgeFunctionTransformer[${this.id}].fit_transform(**pms_FunctionTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_fit_transform.tolist() if hasattr(res_FunctionTransformer_fit_transform, 'tolist') else res_FunctionTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    This method is only defined if `feature\\_names\\_out` is not `undefined`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input feature names.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FunctionTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_FunctionTransformer_get_feature_names_out = {k: v for k, v in pms_FunctionTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_get_feature_names_out = bridgeFunctionTransformer[${this.id}].get_feature_names_out(**pms_FunctionTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_get_feature_names_out.tolist() if hasattr(res_FunctionTransformer_get_feature_names_out, 'tolist') else res_FunctionTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FunctionTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_FunctionTransformer_get_metadata_routing = {k: v for k, v in pms_FunctionTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_get_metadata_routing = bridgeFunctionTransformer[${this.id}].get_metadata_routing(**pms_FunctionTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_get_metadata_routing.tolist() if hasattr(res_FunctionTransformer_get_metadata_routing, 'tolist') else res_FunctionTransformer_get_metadata_routing`\n  }\n\n  /**\n    Transform X using the inverse function.\n   */\n  async inverse_transform(opts: {\n    /**\n      Input array.\n     */\n    X?: any\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FunctionTransformer_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_FunctionTransformer_inverse_transform = {k: v for k, v in pms_FunctionTransformer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_inverse_transform = bridgeFunctionTransformer[${this.id}].inverse_transform(**pms_FunctionTransformer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_inverse_transform.tolist() if hasattr(res_FunctionTransformer_inverse_transform, 'tolist') else res_FunctionTransformer_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FunctionTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_FunctionTransformer_set_output = {k: v for k, v in pms_FunctionTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_set_output = bridgeFunctionTransformer[${this.id}].set_output(**pms_FunctionTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_set_output.tolist() if hasattr(res_FunctionTransformer_set_output, 'tolist') else res_FunctionTransformer_set_output`\n  }\n\n  /**\n    Transform X using the forward function.\n   */\n  async transform(opts: {\n    /**\n      Input array.\n     */\n    X?: any\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FunctionTransformer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FunctionTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_FunctionTransformer_transform = {k: v for k, v in pms_FunctionTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FunctionTransformer_transform = bridgeFunctionTransformer[${this.id}].transform(**pms_FunctionTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FunctionTransformer_transform.tolist() if hasattr(res_FunctionTransformer_transform, 'tolist') else res_FunctionTransformer_transform`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FunctionTransformer_n_features_in_ = bridgeFunctionTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FunctionTransformer_n_features_in_.tolist() if hasattr(attr_FunctionTransformer_n_features_in_, 'tolist') else attr_FunctionTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FunctionTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FunctionTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FunctionTransformer_feature_names_in_ = bridgeFunctionTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FunctionTransformer_feature_names_in_.tolist() if hasattr(attr_FunctionTransformer_feature_names_in_, 'tolist') else attr_FunctionTransformer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Bin continuous data into intervals.\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-discretization).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html)\n */\nexport class KBinsDiscretizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of bins to produce. Raises ValueError if `n\\_bins < 2`.\n\n      @defaultValue `5`\n     */\n    n_bins?: number | ArrayLike\n\n    /**\n      Method used to encode the transformed result.\n\n      @defaultValue `'onehot'`\n     */\n    encode?: 'onehot' | 'onehot-dense' | 'ordinal'\n\n    /**\n      Strategy used to define the widths of the bins.\n\n      @defaultValue `'quantile'`\n     */\n    strategy?: 'uniform' | 'quantile' | 'kmeans'\n\n    /**\n      The desired data-type for the output. If `undefined`, output dtype is consistent with input dtype. Only np.float32 and np.float64 are supported.\n     */\n    dtype?: any\n\n    /**\n      Maximum number of samples, used to fit the model, for computational efficiency. Defaults to 200\\_000 when `strategy='quantile'` and to `undefined` when `strategy='uniform'` or `strategy='kmeans'`. `subsample=None` means that all the training samples are used when computing the quantiles that determine the binning thresholds. Since quantile computation relies on sorting each column of `X` and that sorting has an `n log(n)` time complexity, it is recommended to use subsampling on datasets with a very large number of samples.\n\n      @defaultValue `'warn'`\n     */\n    subsample?: number\n\n    /**\n      Determines random number generation for subsampling. Pass an int for reproducible results across multiple function calls. See the `subsample` parameter for more details. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `KBinsDiscretizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KBinsDiscretizer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import KBinsDiscretizer\ntry: bridgeKBinsDiscretizer\nexcept NameError: bridgeKBinsDiscretizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KBinsDiscretizer = {'n_bins': np.array(${\n      this.opts['n_bins'] ?? undefined\n    }) if ${this.opts['n_bins'] !== undefined} else None, 'encode': ${\n      this.opts['encode'] ?? undefined\n    }, 'strategy': ${this.opts['strategy'] ?? undefined}, 'dtype': ${\n      this.opts['dtype'] ?? undefined\n    }, 'subsample': ${this.opts['subsample'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_KBinsDiscretizer = {k: v for k, v in ctor_KBinsDiscretizer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKBinsDiscretizer[${this.id}] = KBinsDiscretizer(**ctor_KBinsDiscretizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKBinsDiscretizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the estimator.\n   */\n  async fit(opts: {\n    /**\n      Data to be discretized.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\").\n     */\n    y?: any\n\n    /**\n      Contains weight values to be associated with each sample. Only possible when `strategy` is set to `\"quantile\"`.\n     */\n    sample_weight?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KBinsDiscretizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KBinsDiscretizer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KBinsDiscretizer_fit = {k: v for k, v in pms_KBinsDiscretizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_fit = bridgeKBinsDiscretizer[${this.id}].fit(**pms_KBinsDiscretizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_fit.tolist() if hasattr(res_KBinsDiscretizer_fit, 'tolist') else res_KBinsDiscretizer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KBinsDiscretizer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_KBinsDiscretizer_fit_transform = {k: v for k, v in pms_KBinsDiscretizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_fit_transform = bridgeKBinsDiscretizer[${this.id}].fit_transform(**pms_KBinsDiscretizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_fit_transform.tolist() if hasattr(res_KBinsDiscretizer_fit_transform, 'tolist') else res_KBinsDiscretizer_fit_transform`\n  }\n\n  /**\n    Get output feature names.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KBinsDiscretizer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KBinsDiscretizer_get_feature_names_out = {k: v for k, v in pms_KBinsDiscretizer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_get_feature_names_out = bridgeKBinsDiscretizer[${this.id}].get_feature_names_out(**pms_KBinsDiscretizer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_get_feature_names_out.tolist() if hasattr(res_KBinsDiscretizer_get_feature_names_out, 'tolist') else res_KBinsDiscretizer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KBinsDiscretizer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KBinsDiscretizer_get_metadata_routing = {k: v for k, v in pms_KBinsDiscretizer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_get_metadata_routing = bridgeKBinsDiscretizer[${this.id}].get_metadata_routing(**pms_KBinsDiscretizer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_get_metadata_routing.tolist() if hasattr(res_KBinsDiscretizer_get_metadata_routing, 'tolist') else res_KBinsDiscretizer_get_metadata_routing`\n  }\n\n  /**\n    Transform discretized data back to original feature space.\n\n    Note that this function does not regenerate the original data due to discretization rounding.\n   */\n  async inverse_transform(opts: {\n    /**\n      Transformed data in the binned space.\n     */\n    Xt?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KBinsDiscretizer_inverse_transform = {'Xt': np.array(${\n      opts['Xt'] ?? undefined\n    }) if ${opts['Xt'] !== undefined} else None}\n\npms_KBinsDiscretizer_inverse_transform = {k: v for k, v in pms_KBinsDiscretizer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_inverse_transform = bridgeKBinsDiscretizer[${this.id}].inverse_transform(**pms_KBinsDiscretizer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_inverse_transform.tolist() if hasattr(res_KBinsDiscretizer_inverse_transform, 'tolist') else res_KBinsDiscretizer_inverse_transform`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KBinsDiscretizer_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KBinsDiscretizer_set_fit_request = {k: v for k, v in pms_KBinsDiscretizer_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_set_fit_request = bridgeKBinsDiscretizer[${this.id}].set_fit_request(**pms_KBinsDiscretizer_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_set_fit_request.tolist() if hasattr(res_KBinsDiscretizer_set_fit_request, 'tolist') else res_KBinsDiscretizer_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KBinsDiscretizer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KBinsDiscretizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KBinsDiscretizer_set_output = {k: v for k, v in pms_KBinsDiscretizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_set_output = bridgeKBinsDiscretizer[${this.id}].set_output(**pms_KBinsDiscretizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_set_output.tolist() if hasattr(res_KBinsDiscretizer_set_output, 'tolist') else res_KBinsDiscretizer_set_output`\n  }\n\n  /**\n    Discretize the data.\n   */\n  async transform(opts: {\n    /**\n      Data to be discretized.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KBinsDiscretizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KBinsDiscretizer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KBinsDiscretizer_transform = {k: v for k, v in pms_KBinsDiscretizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KBinsDiscretizer_transform = bridgeKBinsDiscretizer[${this.id}].transform(**pms_KBinsDiscretizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KBinsDiscretizer_transform.tolist() if hasattr(res_KBinsDiscretizer_transform, 'tolist') else res_KBinsDiscretizer_transform`\n  }\n\n  /**\n    The edges of each bin. Contain arrays of varying shapes `(n\\_bins\\_, )` Ignored features will have empty arrays.\n   */\n  get bin_edges_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before accessing bin_edges_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KBinsDiscretizer_bin_edges_ = bridgeKBinsDiscretizer[${this.id}].bin_edges_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KBinsDiscretizer_bin_edges_.tolist() if hasattr(attr_KBinsDiscretizer_bin_edges_, 'tolist') else attr_KBinsDiscretizer_bin_edges_`\n    })()\n  }\n\n  /**\n    Number of bins per feature. Bins whose width are too small (i.e., <= 1e-8) are removed with a warning.\n   */\n  get n_bins_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before accessing n_bins_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KBinsDiscretizer_n_bins_ = bridgeKBinsDiscretizer[${this.id}].n_bins_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KBinsDiscretizer_n_bins_.tolist() if hasattr(attr_KBinsDiscretizer_n_bins_, 'tolist') else attr_KBinsDiscretizer_n_bins_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KBinsDiscretizer_n_features_in_ = bridgeKBinsDiscretizer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KBinsDiscretizer_n_features_in_.tolist() if hasattr(attr_KBinsDiscretizer_n_features_in_, 'tolist') else attr_KBinsDiscretizer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KBinsDiscretizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KBinsDiscretizer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KBinsDiscretizer_feature_names_in_ = bridgeKBinsDiscretizer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KBinsDiscretizer_feature_names_in_.tolist() if hasattr(attr_KBinsDiscretizer_feature_names_in_, 'tolist') else attr_KBinsDiscretizer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Center an arbitrary kernel matrix \\\\(K\\\\).\n\n  Let define a kernel \\\\(K\\\\) such that:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KernelCenterer.html)\n */\nexport class KernelCenterer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Average of each column of kernel matrix.\n     */\n    K_fit_rows_?: NDArray\n\n    /**\n      Average of kernel matrix.\n     */\n    K_fit_all_?: number\n\n    /**\n      Number of features seen during [fit](../../glossary.html#term-fit).\n     */\n    n_features_in_?: number\n\n    /**\n      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n     */\n    feature_names_in_?: NDArray\n  }) {\n    this.id = `KernelCenterer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KernelCenterer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import KernelCenterer\ntry: bridgeKernelCenterer\nexcept NameError: bridgeKernelCenterer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KernelCenterer = {'K_fit_rows_': np.array(${\n      this.opts['K_fit_rows_'] ?? undefined\n    }) if ${this.opts['K_fit_rows_'] !== undefined} else None, 'K_fit_all_': ${\n      this.opts['K_fit_all_'] ?? undefined\n    }, 'n_features_in_': ${\n      this.opts['n_features_in_'] ?? undefined\n    }, 'feature_names_in_': np.array(${\n      this.opts['feature_names_in_'] ?? undefined\n    }) if ${this.opts['feature_names_in_'] !== undefined} else None}\n\nctor_KernelCenterer = {k: v for k, v in ctor_KernelCenterer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKernelCenterer[${this.id}] = KernelCenterer(**ctor_KernelCenterer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKernelCenterer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit KernelCenterer.\n   */\n  async fit(opts: {\n    /**\n      Kernel matrix.\n     */\n    K?: NDArray[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelCenterer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_fit = {'K': np.array(${\n      opts['K'] ?? undefined\n    }) if ${opts['K'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KernelCenterer_fit = {k: v for k, v in pms_KernelCenterer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_fit = bridgeKernelCenterer[${this.id}].fit(**pms_KernelCenterer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_fit.tolist() if hasattr(res_KernelCenterer_fit, 'tolist') else res_KernelCenterer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelCenterer must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_KernelCenterer_fit_transform = {k: v for k, v in pms_KernelCenterer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_fit_transform = bridgeKernelCenterer[${this.id}].fit_transform(**pms_KernelCenterer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_fit_transform.tolist() if hasattr(res_KernelCenterer_fit_transform, 'tolist') else res_KernelCenterer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelCenterer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KernelCenterer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KernelCenterer_get_feature_names_out = {k: v for k, v in pms_KernelCenterer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_get_feature_names_out = bridgeKernelCenterer[${this.id}].get_feature_names_out(**pms_KernelCenterer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_get_feature_names_out.tolist() if hasattr(res_KernelCenterer_get_feature_names_out, 'tolist') else res_KernelCenterer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelCenterer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KernelCenterer_get_metadata_routing = {k: v for k, v in pms_KernelCenterer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_get_metadata_routing = bridgeKernelCenterer[${this.id}].get_metadata_routing(**pms_KernelCenterer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_get_metadata_routing.tolist() if hasattr(res_KernelCenterer_get_metadata_routing, 'tolist') else res_KernelCenterer_get_metadata_routing`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `K` parameter in `fit`.\n     */\n    K?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelCenterer must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_set_fit_request = {'K': ${\n      opts['K'] ?? undefined\n    }}\n\npms_KernelCenterer_set_fit_request = {k: v for k, v in pms_KernelCenterer_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_set_fit_request = bridgeKernelCenterer[${this.id}].set_fit_request(**pms_KernelCenterer_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_set_fit_request.tolist() if hasattr(res_KernelCenterer_set_fit_request, 'tolist') else res_KernelCenterer_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelCenterer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KernelCenterer_set_output = {k: v for k, v in pms_KernelCenterer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_set_output = bridgeKernelCenterer[${this.id}].set_output(**pms_KernelCenterer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_set_output.tolist() if hasattr(res_KernelCenterer_set_output, 'tolist') else res_KernelCenterer_set_output`\n  }\n\n  /**\n    Request metadata passed to the `transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_transform_request(opts: {\n    /**\n      Metadata routing for `K` parameter in `transform`.\n     */\n    K?: string | boolean\n\n    /**\n      Metadata routing for `copy` parameter in `transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelCenterer must call init() before set_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_set_transform_request = {'K': ${\n      opts['K'] ?? undefined\n    }, 'copy': ${opts['copy'] ?? undefined}}\n\npms_KernelCenterer_set_transform_request = {k: v for k, v in pms_KernelCenterer_set_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_set_transform_request = bridgeKernelCenterer[${this.id}].set_transform_request(**pms_KernelCenterer_set_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_set_transform_request.tolist() if hasattr(res_KernelCenterer_set_transform_request, 'tolist') else res_KernelCenterer_set_transform_request`\n  }\n\n  /**\n    Center kernel matrix.\n   */\n  async transform(opts: {\n    /**\n      Kernel matrix.\n     */\n    K?: NDArray[]\n\n    /**\n      Set to `false` to perform inplace computation.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelCenterer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelCenterer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelCenterer_transform = {'K': np.array(${\n      opts['K'] ?? undefined\n    }) if ${opts['K'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_KernelCenterer_transform = {k: v for k, v in pms_KernelCenterer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelCenterer_transform = bridgeKernelCenterer[${this.id}].transform(**pms_KernelCenterer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelCenterer_transform.tolist() if hasattr(res_KernelCenterer_transform, 'tolist') else res_KernelCenterer_transform`\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Binarize labels in a one-vs-all fashion.\n\n  Several regression and binary classification algorithms are available in scikit-learn. A simple way to extend these algorithms to the multi-class classification case is to use the so-called one-vs-all scheme.\n\n  At learning time, this simply consists in learning one regressor or binary classifier per class. In doing so, one needs to convert multi-class labels to binary labels (belong or does not belong to the class). `LabelBinarizer` makes this process easy with the transform method.\n\n  At prediction time, one assigns the class for which the corresponding model gave the greatest confidence. `LabelBinarizer` makes this easy with the [`inverse\\_transform`](#sklearn.preprocessing.LabelBinarizer.inverse_transform \"sklearn.preprocessing.LabelBinarizer.inverse_transform\") method.\n\n  Read more in the [User Guide](../preprocessing_targets.html#preprocessing-targets).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html)\n */\nexport class LabelBinarizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Value with which negative labels must be encoded.\n\n      @defaultValue `0`\n     */\n    neg_label?: number\n\n    /**\n      Value with which positive labels must be encoded.\n\n      @defaultValue `1`\n     */\n    pos_label?: number\n\n    /**\n      True if the returned array from transform is desired to be in sparse CSR format.\n\n      @defaultValue `false`\n     */\n    sparse_output?: boolean\n  }) {\n    this.id = `LabelBinarizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelBinarizer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import LabelBinarizer\ntry: bridgeLabelBinarizer\nexcept NameError: bridgeLabelBinarizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelBinarizer = {'neg_label': ${\n      this.opts['neg_label'] ?? undefined\n    }, 'pos_label': ${this.opts['pos_label'] ?? undefined}, 'sparse_output': ${\n      this.opts['sparse_output'] ?? undefined\n    }}\n\nctor_LabelBinarizer = {k: v for k, v in ctor_LabelBinarizer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelBinarizer[${this.id}] = LabelBinarizer(**ctor_LabelBinarizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelBinarizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit label binarizer.\n   */\n  async fit(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification.\n     */\n    y?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_fit = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_fit = {k: v for k, v in pms_LabelBinarizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_fit = bridgeLabelBinarizer[${this.id}].fit(**pms_LabelBinarizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_fit.tolist() if hasattr(res_LabelBinarizer_fit, 'tolist') else res_LabelBinarizer_fit`\n  }\n\n  /**\n    Fit label binarizer/transform multi-class labels to binary labels.\n\n    The output of transform is sometimes referred to as the 1-of-K coding scheme.\n   */\n  async fit_transform(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.\n     */\n    y?: NDArray | SparseMatrix\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_fit_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_fit_transform = {k: v for k, v in pms_LabelBinarizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_fit_transform = bridgeLabelBinarizer[${this.id}].fit_transform(**pms_LabelBinarizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_fit_transform.tolist() if hasattr(res_LabelBinarizer_fit_transform, 'tolist') else res_LabelBinarizer_fit_transform`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LabelBinarizer_get_metadata_routing = {k: v for k, v in pms_LabelBinarizer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_get_metadata_routing = bridgeLabelBinarizer[${this.id}].get_metadata_routing(**pms_LabelBinarizer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_get_metadata_routing.tolist() if hasattr(res_LabelBinarizer_get_metadata_routing, 'tolist') else res_LabelBinarizer_get_metadata_routing`\n  }\n\n  /**\n    Transform binary labels back to multi-class labels.\n   */\n  async inverse_transform(opts: {\n    /**\n      Target values. All sparse matrices are converted to CSR before inverse transformation.\n     */\n    Y?: NDArray | SparseMatrix[]\n\n    /**\n      Threshold used in the binary and multi-label cases.\n\n      Use 0 when `Y` contains the output of [decision\\_function](../../glossary.html#term-decision_function) (classifier). Use 0.5 when `Y` contains the output of [predict\\_proba](../../glossary.html#term-predict_proba).\n\n      If `undefined`, the threshold is assumed to be half way between neg\\_label and pos\\_label.\n     */\n    threshold?: number\n  }): Promise<NDArray | SparseMatrix> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_inverse_transform = {'Y': np.array(${\n      opts['Y'] ?? undefined\n    }) if ${opts['Y'] !== undefined} else None, 'threshold': ${\n      opts['threshold'] ?? undefined\n    }}\n\npms_LabelBinarizer_inverse_transform = {k: v for k, v in pms_LabelBinarizer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_inverse_transform = bridgeLabelBinarizer[${this.id}].inverse_transform(**pms_LabelBinarizer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_inverse_transform.tolist() if hasattr(res_LabelBinarizer_inverse_transform, 'tolist') else res_LabelBinarizer_inverse_transform`\n  }\n\n  /**\n    Request metadata passed to the `inverse\\_transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_inverse_transform_request(opts: {\n    /**\n      Metadata routing for `threshold` parameter in `inverse\\_transform`.\n     */\n    threshold?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before set_inverse_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LabelBinarizer_set_inverse_transform_request = {'threshold': ${\n      opts['threshold'] ?? undefined\n    }}\n\npms_LabelBinarizer_set_inverse_transform_request = {k: v for k, v in pms_LabelBinarizer_set_inverse_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_set_inverse_transform_request = bridgeLabelBinarizer[${this.id}].set_inverse_transform_request(**pms_LabelBinarizer_set_inverse_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_set_inverse_transform_request.tolist() if hasattr(res_LabelBinarizer_set_inverse_transform_request, 'tolist') else res_LabelBinarizer_set_inverse_transform_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_LabelBinarizer_set_output = {k: v for k, v in pms_LabelBinarizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_set_output = bridgeLabelBinarizer[${this.id}].set_output(**pms_LabelBinarizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_set_output.tolist() if hasattr(res_LabelBinarizer_set_output, 'tolist') else res_LabelBinarizer_set_output`\n  }\n\n  /**\n    Transform multi-class labels to binary labels.\n\n    The output of transform is sometimes referred to by some authors as the 1-of-K coding scheme.\n   */\n  async transform(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.\n     */\n    y?: SparseMatrix\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_transform = {k: v for k, v in pms_LabelBinarizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_transform = bridgeLabelBinarizer[${this.id}].transform(**pms_LabelBinarizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_transform.tolist() if hasattr(res_LabelBinarizer_transform, 'tolist') else res_LabelBinarizer_transform`\n  }\n\n  /**\n    Holds the label for each class.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_classes_ = bridgeLabelBinarizer[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_classes_.tolist() if hasattr(attr_LabelBinarizer_classes_, 'tolist') else attr_LabelBinarizer_classes_`\n    })()\n  }\n\n  /**\n    Represents the type of the target data as evaluated by [`type\\_of\\_target`](sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target \"sklearn.utils.multiclass.type_of_target\"). Possible type are ‘continuous’, ‘continuous-multioutput’, ‘binary’, ‘multiclass’, ‘multiclass-multioutput’, ‘multilabel-indicator’, and ‘unknown’.\n   */\n  get y_type_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing y_type_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_y_type_ = bridgeLabelBinarizer[${this.id}].y_type_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_y_type_.tolist() if hasattr(attr_LabelBinarizer_y_type_, 'tolist') else attr_LabelBinarizer_y_type_`\n    })()\n  }\n\n  /**\n    `false` otherwise.\n   */\n  get sparse_input_(): Promise<boolean> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing sparse_input_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_sparse_input_ = bridgeLabelBinarizer[${this.id}].sparse_input_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_sparse_input_.tolist() if hasattr(attr_LabelBinarizer_sparse_input_, 'tolist') else attr_LabelBinarizer_sparse_input_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Encode target labels with value between 0 and n\\_classes-1.\n\n  This transformer should be used to encode target values, *i.e.* `y`, and not the input `X`.\n\n  Read more in the [User Guide](../preprocessing_targets.html#preprocessing-targets).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html)\n */\nexport class LabelEncoder {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Holds the label for each class.\n     */\n    classes_?: NDArray\n  }) {\n    this.id = `LabelEncoder${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelEncoder.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import LabelEncoder\ntry: bridgeLabelEncoder\nexcept NameError: bridgeLabelEncoder = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelEncoder = {'classes_': np.array(${\n      this.opts['classes_'] ?? undefined\n    }) if ${this.opts['classes_'] !== undefined} else None}\n\nctor_LabelEncoder = {k: v for k, v in ctor_LabelEncoder.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelEncoder[${this.id}] = LabelEncoder(**ctor_LabelEncoder)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelEncoder[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit label encoder.\n   */\n  async fit(opts: {\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelEncoder must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_fit = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelEncoder_fit = {k: v for k, v in pms_LabelEncoder_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_fit = bridgeLabelEncoder[${this.id}].fit(**pms_LabelEncoder_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_fit.tolist() if hasattr(res_LabelEncoder_fit, 'tolist') else res_LabelEncoder_fit`\n  }\n\n  /**\n    Fit label encoder and return encoded labels.\n   */\n  async fit_transform(opts: {\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelEncoder must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_fit_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelEncoder_fit_transform = {k: v for k, v in pms_LabelEncoder_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_fit_transform = bridgeLabelEncoder[${this.id}].fit_transform(**pms_LabelEncoder_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_fit_transform.tolist() if hasattr(res_LabelEncoder_fit_transform, 'tolist') else res_LabelEncoder_fit_transform`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelEncoder must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LabelEncoder_get_metadata_routing = {k: v for k, v in pms_LabelEncoder_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_get_metadata_routing = bridgeLabelEncoder[${this.id}].get_metadata_routing(**pms_LabelEncoder_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_get_metadata_routing.tolist() if hasattr(res_LabelEncoder_get_metadata_routing, 'tolist') else res_LabelEncoder_get_metadata_routing`\n  }\n\n  /**\n    Transform labels back to original encoding.\n   */\n  async inverse_transform(opts: {\n    /**\n      Target values.\n     */\n    y?: NDArray\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelEncoder must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_inverse_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelEncoder_inverse_transform = {k: v for k, v in pms_LabelEncoder_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_inverse_transform = bridgeLabelEncoder[${this.id}].inverse_transform(**pms_LabelEncoder_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_inverse_transform.tolist() if hasattr(res_LabelEncoder_inverse_transform, 'tolist') else res_LabelEncoder_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelEncoder must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_LabelEncoder_set_output = {k: v for k, v in pms_LabelEncoder_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_set_output = bridgeLabelEncoder[${this.id}].set_output(**pms_LabelEncoder_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_set_output.tolist() if hasattr(res_LabelEncoder_set_output, 'tolist') else res_LabelEncoder_set_output`\n  }\n\n  /**\n    Transform labels to normalized encoding.\n   */\n  async transform(opts: {\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LabelEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelEncoder must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelEncoder_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelEncoder_transform = {k: v for k, v in pms_LabelEncoder_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelEncoder_transform = bridgeLabelEncoder[${this.id}].transform(**pms_LabelEncoder_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelEncoder_transform.tolist() if hasattr(res_LabelEncoder_transform, 'tolist') else res_LabelEncoder_transform`\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Scale each feature by its maximum absolute value.\n\n  This estimator scales and translates each feature individually such that the maximal absolute value of each feature in the training set will be 1.0. It does not shift/center the data, and thus does not destroy any sparsity.\n\n  This scaler can also be applied to sparse CSR or CSC matrices.\n\n  `MaxAbsScaler` doesn’t reduce the effect of outliers; it only linearily scales them down. For an example visualization, refer to [Compare MaxAbsScaler with other scalers](../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-max-abs-scaler-section).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html)\n */\nexport class MaxAbsScaler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Set to `false` to perform inplace scaling and avoid a copy (if the input is already a numpy array).\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `MaxAbsScaler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MaxAbsScaler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import MaxAbsScaler\ntry: bridgeMaxAbsScaler\nexcept NameError: bridgeMaxAbsScaler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MaxAbsScaler = {'copy': ${\n      this.opts['copy'] ?? undefined\n    }}\n\nctor_MaxAbsScaler = {k: v for k, v in ctor_MaxAbsScaler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMaxAbsScaler[${this.id}] = MaxAbsScaler(**ctor_MaxAbsScaler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMaxAbsScaler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the maximum absolute value to be used for later scaling.\n   */\n  async fit(opts: {\n    /**\n      The data used to compute the per-feature minimum and maximum used for later scaling along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MaxAbsScaler_fit = {k: v for k, v in pms_MaxAbsScaler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_fit = bridgeMaxAbsScaler[${this.id}].fit(**pms_MaxAbsScaler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_fit.tolist() if hasattr(res_MaxAbsScaler_fit, 'tolist') else res_MaxAbsScaler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_MaxAbsScaler_fit_transform = {k: v for k, v in pms_MaxAbsScaler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_fit_transform = bridgeMaxAbsScaler[${this.id}].fit_transform(**pms_MaxAbsScaler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_fit_transform.tolist() if hasattr(res_MaxAbsScaler_fit_transform, 'tolist') else res_MaxAbsScaler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MaxAbsScaler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MaxAbsScaler_get_feature_names_out = {k: v for k, v in pms_MaxAbsScaler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_get_feature_names_out = bridgeMaxAbsScaler[${this.id}].get_feature_names_out(**pms_MaxAbsScaler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_get_feature_names_out.tolist() if hasattr(res_MaxAbsScaler_get_feature_names_out, 'tolist') else res_MaxAbsScaler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MaxAbsScaler_get_metadata_routing = {k: v for k, v in pms_MaxAbsScaler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_get_metadata_routing = bridgeMaxAbsScaler[${this.id}].get_metadata_routing(**pms_MaxAbsScaler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_get_metadata_routing.tolist() if hasattr(res_MaxAbsScaler_get_metadata_routing, 'tolist') else res_MaxAbsScaler_get_metadata_routing`\n  }\n\n  /**\n    Scale back the data to the original representation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The data that should be transformed back.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MaxAbsScaler_inverse_transform = {k: v for k, v in pms_MaxAbsScaler_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_inverse_transform = bridgeMaxAbsScaler[${this.id}].inverse_transform(**pms_MaxAbsScaler_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_inverse_transform.tolist() if hasattr(res_MaxAbsScaler_inverse_transform, 'tolist') else res_MaxAbsScaler_inverse_transform`\n  }\n\n  /**\n    Online computation of max absolute value of X for later scaling.\n\n    All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MaxAbsScaler.fit \"sklearn.preprocessing.MaxAbsScaler.fit\") is not feasible due to very large number of `n\\_samples` or because X is read from a continuous stream.\n   */\n  async partial_fit(opts: {\n    /**\n      The data used to compute the mean and standard deviation used for later scaling along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MaxAbsScaler_partial_fit = {k: v for k, v in pms_MaxAbsScaler_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_partial_fit = bridgeMaxAbsScaler[${this.id}].partial_fit(**pms_MaxAbsScaler_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_partial_fit.tolist() if hasattr(res_MaxAbsScaler_partial_fit, 'tolist') else res_MaxAbsScaler_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MaxAbsScaler_set_output = {k: v for k, v in pms_MaxAbsScaler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_set_output = bridgeMaxAbsScaler[${this.id}].set_output(**pms_MaxAbsScaler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_set_output.tolist() if hasattr(res_MaxAbsScaler_set_output, 'tolist') else res_MaxAbsScaler_set_output`\n  }\n\n  /**\n    Scale the data.\n   */\n  async transform(opts: {\n    /**\n      The data that should be scaled.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MaxAbsScaler_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MaxAbsScaler_transform = {k: v for k, v in pms_MaxAbsScaler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MaxAbsScaler_transform = bridgeMaxAbsScaler[${this.id}].transform(**pms_MaxAbsScaler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MaxAbsScaler_transform.tolist() if hasattr(res_MaxAbsScaler_transform, 'tolist') else res_MaxAbsScaler_transform`\n  }\n\n  /**\n    Per feature relative scaling of the data.\n   */\n  get scale_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before accessing scale_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MaxAbsScaler_scale_ = bridgeMaxAbsScaler[${this.id}].scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MaxAbsScaler_scale_.tolist() if hasattr(attr_MaxAbsScaler_scale_, 'tolist') else attr_MaxAbsScaler_scale_`\n    })()\n  }\n\n  /**\n    Per feature maximum absolute value.\n   */\n  get max_abs_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MaxAbsScaler must call init() before accessing max_abs_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MaxAbsScaler_max_abs_ = bridgeMaxAbsScaler[${this.id}].max_abs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MaxAbsScaler_max_abs_.tolist() if hasattr(attr_MaxAbsScaler_max_abs_, 'tolist') else attr_MaxAbsScaler_max_abs_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MaxAbsScaler_n_features_in_ = bridgeMaxAbsScaler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MaxAbsScaler_n_features_in_.tolist() if hasattr(attr_MaxAbsScaler_n_features_in_, 'tolist') else attr_MaxAbsScaler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MaxAbsScaler_feature_names_in_ = bridgeMaxAbsScaler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MaxAbsScaler_feature_names_in_.tolist() if hasattr(attr_MaxAbsScaler_feature_names_in_, 'tolist') else attr_MaxAbsScaler_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\\_fit` calls.\n   */\n  get n_samples_seen_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MaxAbsScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MaxAbsScaler must call init() before accessing n_samples_seen_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MaxAbsScaler_n_samples_seen_ = bridgeMaxAbsScaler[${this.id}].n_samples_seen_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MaxAbsScaler_n_samples_seen_.tolist() if hasattr(attr_MaxAbsScaler_n_samples_seen_, 'tolist') else attr_MaxAbsScaler_n_samples_seen_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transform features by scaling each feature to a given range.\n\n  This estimator scales and translates each feature individually such that it is in the given range on the training set, e.g. between zero and one.\n\n  The transformation is given by:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html)\n */\nexport class MinMaxScaler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Desired range of transformed data.\n     */\n    feature_range?: any\n\n    /**\n      Set to `false` to perform inplace row normalization and avoid a copy (if the input is already a numpy array).\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      Set to `true` to clip transformed values of held-out data to provided `feature range`.\n\n      @defaultValue `false`\n     */\n    clip?: boolean\n  }) {\n    this.id = `MinMaxScaler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MinMaxScaler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\ntry: bridgeMinMaxScaler\nexcept NameError: bridgeMinMaxScaler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MinMaxScaler = {'feature_range': ${\n      this.opts['feature_range'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}, 'clip': ${\n      this.opts['clip'] ?? undefined\n    }}\n\nctor_MinMaxScaler = {k: v for k, v in ctor_MinMaxScaler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMinMaxScaler[${this.id}] = MinMaxScaler(**ctor_MinMaxScaler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMinMaxScaler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the minimum and maximum to be used for later scaling.\n   */\n  async fit(opts: {\n    /**\n      The data used to compute the per-feature minimum and maximum used for later scaling along the features axis.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MinMaxScaler_fit = {k: v for k, v in pms_MinMaxScaler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_fit = bridgeMinMaxScaler[${this.id}].fit(**pms_MinMaxScaler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_fit.tolist() if hasattr(res_MinMaxScaler_fit, 'tolist') else res_MinMaxScaler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_MinMaxScaler_fit_transform = {k: v for k, v in pms_MinMaxScaler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_fit_transform = bridgeMinMaxScaler[${this.id}].fit_transform(**pms_MinMaxScaler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_fit_transform.tolist() if hasattr(res_MinMaxScaler_fit_transform, 'tolist') else res_MinMaxScaler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MinMaxScaler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MinMaxScaler_get_feature_names_out = {k: v for k, v in pms_MinMaxScaler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_get_feature_names_out = bridgeMinMaxScaler[${this.id}].get_feature_names_out(**pms_MinMaxScaler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_get_feature_names_out.tolist() if hasattr(res_MinMaxScaler_get_feature_names_out, 'tolist') else res_MinMaxScaler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MinMaxScaler_get_metadata_routing = {k: v for k, v in pms_MinMaxScaler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_get_metadata_routing = bridgeMinMaxScaler[${this.id}].get_metadata_routing(**pms_MinMaxScaler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_get_metadata_routing.tolist() if hasattr(res_MinMaxScaler_get_metadata_routing, 'tolist') else res_MinMaxScaler_get_metadata_routing`\n  }\n\n  /**\n    Undo the scaling of X according to feature\\_range.\n   */\n  async inverse_transform(opts: {\n    /**\n      Input data that will be transformed. It cannot be sparse.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MinMaxScaler_inverse_transform = {k: v for k, v in pms_MinMaxScaler_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_inverse_transform = bridgeMinMaxScaler[${this.id}].inverse_transform(**pms_MinMaxScaler_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_inverse_transform.tolist() if hasattr(res_MinMaxScaler_inverse_transform, 'tolist') else res_MinMaxScaler_inverse_transform`\n  }\n\n  /**\n    Online computation of min and max on X for later scaling.\n\n    All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MinMaxScaler.fit \"sklearn.preprocessing.MinMaxScaler.fit\") is not feasible due to very large number of `n\\_samples` or because X is read from a continuous stream.\n   */\n  async partial_fit(opts: {\n    /**\n      The data used to compute the mean and standard deviation used for later scaling along the features axis.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MinMaxScaler_partial_fit = {k: v for k, v in pms_MinMaxScaler_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_partial_fit = bridgeMinMaxScaler[${this.id}].partial_fit(**pms_MinMaxScaler_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_partial_fit.tolist() if hasattr(res_MinMaxScaler_partial_fit, 'tolist') else res_MinMaxScaler_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MinMaxScaler_set_output = {k: v for k, v in pms_MinMaxScaler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_set_output = bridgeMinMaxScaler[${this.id}].set_output(**pms_MinMaxScaler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_set_output.tolist() if hasattr(res_MinMaxScaler_set_output, 'tolist') else res_MinMaxScaler_set_output`\n  }\n\n  /**\n    Scale features of X according to feature\\_range.\n   */\n  async transform(opts: {\n    /**\n      Input data that will be transformed.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MinMaxScaler_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MinMaxScaler_transform = {k: v for k, v in pms_MinMaxScaler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MinMaxScaler_transform = bridgeMinMaxScaler[${this.id}].transform(**pms_MinMaxScaler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MinMaxScaler_transform.tolist() if hasattr(res_MinMaxScaler_transform, 'tolist') else res_MinMaxScaler_transform`\n  }\n\n  /**\n    Per feature adjustment for minimum. Equivalent to `min \\- X.min(axis=0) \\* self.scale\\_`\n   */\n  get min_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before accessing min_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_min_ = bridgeMinMaxScaler[${this.id}].min_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_min_.tolist() if hasattr(attr_MinMaxScaler_min_, 'tolist') else attr_MinMaxScaler_min_`\n    })()\n  }\n\n  /**\n    Per feature relative scaling of the data. Equivalent to `(max \\- min) / (X.max(axis=0) \\- X.min(axis=0))`\n   */\n  get scale_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MinMaxScaler must call init() before accessing scale_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_scale_ = bridgeMinMaxScaler[${this.id}].scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_scale_.tolist() if hasattr(attr_MinMaxScaler_scale_, 'tolist') else attr_MinMaxScaler_scale_`\n    })()\n  }\n\n  /**\n    Per feature minimum seen in the data\n   */\n  get data_min_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing data_min_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_data_min_ = bridgeMinMaxScaler[${this.id}].data_min_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_data_min_.tolist() if hasattr(attr_MinMaxScaler_data_min_, 'tolist') else attr_MinMaxScaler_data_min_`\n    })()\n  }\n\n  /**\n    Per feature maximum seen in the data\n   */\n  get data_max_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing data_max_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_data_max_ = bridgeMinMaxScaler[${this.id}].data_max_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_data_max_.tolist() if hasattr(attr_MinMaxScaler_data_max_, 'tolist') else attr_MinMaxScaler_data_max_`\n    })()\n  }\n\n  /**\n    Per feature range `(data\\_max\\_ \\- data\\_min\\_)` seen in the data\n   */\n  get data_range_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing data_range_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_data_range_ = bridgeMinMaxScaler[${this.id}].data_range_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_data_range_.tolist() if hasattr(attr_MinMaxScaler_data_range_, 'tolist') else attr_MinMaxScaler_data_range_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_n_features_in_ = bridgeMinMaxScaler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_n_features_in_.tolist() if hasattr(attr_MinMaxScaler_n_features_in_, 'tolist') else attr_MinMaxScaler_n_features_in_`\n    })()\n  }\n\n  /**\n    The number of samples processed by the estimator. It will be reset on new calls to fit, but increments across `partial\\_fit` calls.\n   */\n  get n_samples_seen_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing n_samples_seen_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_n_samples_seen_ = bridgeMinMaxScaler[${this.id}].n_samples_seen_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_n_samples_seen_.tolist() if hasattr(attr_MinMaxScaler_n_samples_seen_, 'tolist') else attr_MinMaxScaler_n_samples_seen_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MinMaxScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MinMaxScaler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MinMaxScaler_feature_names_in_ = bridgeMinMaxScaler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MinMaxScaler_feature_names_in_.tolist() if hasattr(attr_MinMaxScaler_feature_names_in_, 'tolist') else attr_MinMaxScaler_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transform between iterable of iterables and a multilabel format.\n\n  Although a list of sets or tuples is a very intuitive format for multilabel data, it is unwieldy to process. This transformer converts between this intuitive format and the supported multilabel format: a (samples x classes) binary matrix indicating the presence of a class label.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MultiLabelBinarizer.html)\n */\nexport class MultiLabelBinarizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Indicates an ordering for the class labels. All entries should be unique (cannot contain duplicate classes).\n     */\n    classes?: ArrayLike\n\n    /**\n      Set to `true` if output binary array is desired in CSR sparse format.\n\n      @defaultValue `false`\n     */\n    sparse_output?: boolean\n  }) {\n    this.id = `MultiLabelBinarizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MultiLabelBinarizer.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import MultiLabelBinarizer\ntry: bridgeMultiLabelBinarizer\nexcept NameError: bridgeMultiLabelBinarizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MultiLabelBinarizer = {'classes': np.array(${\n      this.opts['classes'] ?? undefined\n    }) if ${this.opts['classes'] !== undefined} else None, 'sparse_output': ${\n      this.opts['sparse_output'] ?? undefined\n    }}\n\nctor_MultiLabelBinarizer = {k: v for k, v in ctor_MultiLabelBinarizer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMultiLabelBinarizer[${this.id}] = MultiLabelBinarizer(**ctor_MultiLabelBinarizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMultiLabelBinarizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the label sets binarizer, storing [classes\\_](../../glossary.html#term-classes_).\n   */\n  async fit(opts: {\n    /**\n      A set of labels (any orderable and hashable object) for each sample. If the `classes` parameter is set, `y` will not be iterated.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiLabelBinarizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiLabelBinarizer_fit = {'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_MultiLabelBinarizer_fit = {k: v for k, v in pms_MultiLabelBinarizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_fit = bridgeMultiLabelBinarizer[${this.id}].fit(**pms_MultiLabelBinarizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_fit.tolist() if hasattr(res_MultiLabelBinarizer_fit, 'tolist') else res_MultiLabelBinarizer_fit`\n  }\n\n  /**\n    Fit the label sets binarizer and transform the given label sets.\n   */\n  async fit_transform(opts: {\n    /**\n      A set of labels (any orderable and hashable object) for each sample. If the `classes` parameter is set, `y` will not be iterated.\n     */\n    y?: any\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiLabelBinarizer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiLabelBinarizer_fit_transform = {'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_MultiLabelBinarizer_fit_transform = {k: v for k, v in pms_MultiLabelBinarizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_fit_transform = bridgeMultiLabelBinarizer[${this.id}].fit_transform(**pms_MultiLabelBinarizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_fit_transform.tolist() if hasattr(res_MultiLabelBinarizer_fit_transform, 'tolist') else res_MultiLabelBinarizer_fit_transform`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiLabelBinarizer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiLabelBinarizer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MultiLabelBinarizer_get_metadata_routing = {k: v for k, v in pms_MultiLabelBinarizer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_get_metadata_routing = bridgeMultiLabelBinarizer[${this.id}].get_metadata_routing(**pms_MultiLabelBinarizer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_get_metadata_routing.tolist() if hasattr(res_MultiLabelBinarizer_get_metadata_routing, 'tolist') else res_MultiLabelBinarizer_get_metadata_routing`\n  }\n\n  /**\n    Transform the given indicator matrix into label sets.\n   */\n  async inverse_transform(opts: {\n    /**\n      A matrix containing only 1s ands 0s.\n     */\n    yt?: NDArray | SparseMatrix[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiLabelBinarizer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiLabelBinarizer_inverse_transform = {'yt': np.array(${\n      opts['yt'] ?? undefined\n    }) if ${opts['yt'] !== undefined} else None}\n\npms_MultiLabelBinarizer_inverse_transform = {k: v for k, v in pms_MultiLabelBinarizer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_inverse_transform = bridgeMultiLabelBinarizer[${this.id}].inverse_transform(**pms_MultiLabelBinarizer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_inverse_transform.tolist() if hasattr(res_MultiLabelBinarizer_inverse_transform, 'tolist') else res_MultiLabelBinarizer_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiLabelBinarizer must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiLabelBinarizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MultiLabelBinarizer_set_output = {k: v for k, v in pms_MultiLabelBinarizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_set_output = bridgeMultiLabelBinarizer[${this.id}].set_output(**pms_MultiLabelBinarizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_set_output.tolist() if hasattr(res_MultiLabelBinarizer_set_output, 'tolist') else res_MultiLabelBinarizer_set_output`\n  }\n\n  /**\n    Transform the given label sets.\n   */\n  async transform(opts: {\n    /**\n      A set of labels (any orderable and hashable object) for each sample. If the `classes` parameter is set, `y` will not be iterated.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiLabelBinarizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiLabelBinarizer_transform = {'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_MultiLabelBinarizer_transform = {k: v for k, v in pms_MultiLabelBinarizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiLabelBinarizer_transform = bridgeMultiLabelBinarizer[${this.id}].transform(**pms_MultiLabelBinarizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiLabelBinarizer_transform.tolist() if hasattr(res_MultiLabelBinarizer_transform, 'tolist') else res_MultiLabelBinarizer_transform`\n  }\n\n  /**\n    A copy of the `classes` parameter when provided. Otherwise it corresponds to the sorted set of classes found when fitting.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiLabelBinarizer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiLabelBinarizer must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiLabelBinarizer_classes_ = bridgeMultiLabelBinarizer[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiLabelBinarizer_classes_.tolist() if hasattr(attr_MultiLabelBinarizer_classes_, 'tolist') else attr_MultiLabelBinarizer_classes_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Normalize samples individually to unit norm.\n\n  Each sample (i.e. each row of the data matrix) with at least one non zero component is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one.\n\n  This transformer is able to work both with dense numpy arrays and scipy.sparse matrix (use CSR format if you want to avoid the burden of a copy / conversion).\n\n  Scaling inputs to unit norms is a common operation for text classification or clustering for instance. For instance the dot product of two l2-normalized TF-IDF vectors is the cosine similarity of the vectors and is the base similarity metric for the Vector Space Model commonly used by the Information Retrieval community.\n\n  For an example visualization, refer to [Compare Normalizer with other scalers](../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-normalizer-section).\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-normalization).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html)\n */\nexport class Normalizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The norm to use to normalize each non zero sample. If norm=’max’ is used, values will be rescaled by the maximum of the absolute values.\n\n      @defaultValue `'l2'`\n     */\n    norm?: 'l1' | 'l2' | 'max'\n\n    /**\n      Set to `false` to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix).\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `Normalizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Normalizer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import Normalizer\ntry: bridgeNormalizer\nexcept NameError: bridgeNormalizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Normalizer = {'norm': ${\n      this.opts['norm'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}}\n\nctor_Normalizer = {k: v for k, v in ctor_Normalizer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeNormalizer[${this.id}] = Normalizer(**ctor_Normalizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNormalizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Only validates estimator’s parameters.\n\n    This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.\n   */\n  async fit(opts: {\n    /**\n      The data to estimate the normalization parameters.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Normalizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_Normalizer_fit = {k: v for k, v in pms_Normalizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_fit = bridgeNormalizer[${this.id}].fit(**pms_Normalizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_fit.tolist() if hasattr(res_Normalizer_fit, 'tolist') else res_Normalizer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Normalizer must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_Normalizer_fit_transform = {k: v for k, v in pms_Normalizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_fit_transform = bridgeNormalizer[${this.id}].fit_transform(**pms_Normalizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_fit_transform.tolist() if hasattr(res_Normalizer_fit_transform, 'tolist') else res_Normalizer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Normalizer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Normalizer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Normalizer_get_feature_names_out = {k: v for k, v in pms_Normalizer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_get_feature_names_out = bridgeNormalizer[${this.id}].get_feature_names_out(**pms_Normalizer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_get_feature_names_out.tolist() if hasattr(res_Normalizer_get_feature_names_out, 'tolist') else res_Normalizer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Normalizer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Normalizer_get_metadata_routing = {k: v for k, v in pms_Normalizer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_get_metadata_routing = bridgeNormalizer[${this.id}].get_metadata_routing(**pms_Normalizer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_get_metadata_routing.tolist() if hasattr(res_Normalizer_get_metadata_routing, 'tolist') else res_Normalizer_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Normalizer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Normalizer_set_output = {k: v for k, v in pms_Normalizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_set_output = bridgeNormalizer[${this.id}].set_output(**pms_Normalizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_set_output.tolist() if hasattr(res_Normalizer_set_output, 'tolist') else res_Normalizer_set_output`\n  }\n\n  /**\n    Request metadata passed to the `transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Normalizer must call init() before set_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_set_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_Normalizer_set_transform_request = {k: v for k, v in pms_Normalizer_set_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_set_transform_request = bridgeNormalizer[${this.id}].set_transform_request(**pms_Normalizer_set_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_set_transform_request.tolist() if hasattr(res_Normalizer_set_transform_request, 'tolist') else res_Normalizer_set_transform_request`\n  }\n\n  /**\n    Scale each non zero row of X to unit norm.\n   */\n  async transform(opts: {\n    /**\n      The data to normalize, row by row. scipy.sparse matrices should be in CSR format to avoid an un-necessary copy.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Copy the input X or not.\n     */\n    copy?: boolean\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Normalizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Normalizer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_Normalizer_transform = {k: v for k, v in pms_Normalizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Normalizer_transform = bridgeNormalizer[${this.id}].transform(**pms_Normalizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Normalizer_transform.tolist() if hasattr(res_Normalizer_transform, 'tolist') else res_Normalizer_transform`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Normalizer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Normalizer_n_features_in_ = bridgeNormalizer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Normalizer_n_features_in_.tolist() if hasattr(attr_Normalizer_n_features_in_, 'tolist') else attr_Normalizer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Normalizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Normalizer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Normalizer_feature_names_in_ = bridgeNormalizer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Normalizer_feature_names_in_.tolist() if hasattr(attr_Normalizer_feature_names_in_, 'tolist') else attr_Normalizer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Encode categorical features as a one-hot numeric array.\n\n  The input to this transformer should be an array-like of integers or strings, denoting the values taken on by categorical (discrete) features. The features are encoded using a one-hot (aka ‘one-of-K’ or ‘dummy’) encoding scheme. This creates a binary column for each category and returns a sparse matrix or dense array (depending on the `sparse\\_output` parameter)\n\n  By default, the encoder derives the categories based on the unique values in each feature. Alternatively, you can also specify the `categories` manually.\n\n  This encoding is needed for feeding categorical data to many scikit-learn estimators, notably linear models and SVMs with the standard kernels.\n\n  Note: a one-hot encoding of y labels should use a LabelBinarizer instead.\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-categorical-features). For a comparison of different encoders, refer to: [Comparing Target Encoder with Other Encoders](../../auto_examples/preprocessing/plot_target_encoder.html#sphx-glr-auto-examples-preprocessing-plot-target-encoder-py).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html)\n */\nexport class OneHotEncoder {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Categories (unique values) per feature:\n\n      @defaultValue `'auto'`\n     */\n    categories?: 'auto'\n\n    /**\n      Specifies a methodology to use to drop one of the categories per feature. This is useful in situations where perfectly collinear features cause problems, such as when feeding the resulting data into an unregularized linear regression model.\n\n      However, dropping one category breaks the symmetry of the original representation and can therefore induce a bias in downstream models, for instance for penalized linear classification or regression models.\n     */\n    drop?: 'first' | 'if_binary' | any[]\n\n    /**\n      Will return sparse matrix if set `true` else will return an array.\n\n      @defaultValue `true`\n     */\n    sparse?: boolean\n\n    /**\n      Will return sparse matrix if set `true` else will return an array.\n\n      @defaultValue `true`\n     */\n    sparse_output?: boolean\n\n    /**\n      Desired dtype of output.\n     */\n    dtype?: any\n\n    /**\n      Specifies the way unknown categories are handled during [`transform`](#sklearn.preprocessing.OneHotEncoder.transform \"sklearn.preprocessing.OneHotEncoder.transform\").\n\n      @defaultValue `'error'`\n     */\n    handle_unknown?: 'error' | 'ignore' | 'infrequent_if_exist'\n\n    /**\n      Specifies the minimum frequency below which a category will be considered infrequent.\n     */\n    min_frequency?: number\n\n    /**\n      Specifies an upper limit to the number of output features for each input feature when considering infrequent categories. If there are infrequent categories, `max\\_categories` includes the category representing the infrequent categories along with the frequent categories. If `undefined`, there is no limit to the number of output features.\n     */\n    max_categories?: number\n\n    /**\n      Callable with signature `def callable(input\\_feature, category)` that returns a string. This is used to create feature names to be returned by [`get\\_feature\\_names\\_out`](#sklearn.preprocessing.OneHotEncoder.get_feature_names_out \"sklearn.preprocessing.OneHotEncoder.get_feature_names_out\").\n\n      `\"concat\"` concatenates encoded feature name and category with `feature + \"\\_\" + str(category)`.E.g. feature X with values 1, 6, 7 create feature names `X\\_1, X\\_6, X\\_7`.\n\n      @defaultValue `'concat'`\n     */\n    feature_name_combiner?: 'concat'\n  }) {\n    this.id = `OneHotEncoder${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('OneHotEncoder.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import OneHotEncoder\ntry: bridgeOneHotEncoder\nexcept NameError: bridgeOneHotEncoder = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OneHotEncoder = {'categories': ${\n      this.opts['categories'] ?? undefined\n    }, 'drop': np.array(${this.opts['drop'] ?? undefined}) if ${\n      this.opts['drop'] !== undefined\n    } else None, 'sparse': ${\n      this.opts['sparse'] ?? undefined\n    }, 'sparse_output': ${this.opts['sparse_output'] ?? undefined}, 'dtype': ${\n      this.opts['dtype'] ?? undefined\n    }, 'handle_unknown': ${\n      this.opts['handle_unknown'] ?? undefined\n    }, 'min_frequency': ${\n      this.opts['min_frequency'] ?? undefined\n    }, 'max_categories': ${\n      this.opts['max_categories'] ?? undefined\n    }, 'feature_name_combiner': ${\n      this.opts['feature_name_combiner'] ?? undefined\n    }}\n\nctor_OneHotEncoder = {k: v for k, v in ctor_OneHotEncoder.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOneHotEncoder[${this.id}] = OneHotEncoder(**ctor_OneHotEncoder)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOneHotEncoder[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit OneHotEncoder to X.\n   */\n  async fit(opts: {\n    /**\n      The data to determine the categories of each feature.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\").\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneHotEncoder must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OneHotEncoder_fit = {k: v for k, v in pms_OneHotEncoder_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_fit = bridgeOneHotEncoder[${this.id}].fit(**pms_OneHotEncoder_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_fit.tolist() if hasattr(res_OneHotEncoder_fit, 'tolist') else res_OneHotEncoder_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneHotEncoder must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_OneHotEncoder_fit_transform = {k: v for k, v in pms_OneHotEncoder_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_fit_transform = bridgeOneHotEncoder[${this.id}].fit_transform(**pms_OneHotEncoder_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_fit_transform.tolist() if hasattr(res_OneHotEncoder_fit_transform, 'tolist') else res_OneHotEncoder_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneHotEncoder_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_OneHotEncoder_get_feature_names_out = {k: v for k, v in pms_OneHotEncoder_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_get_feature_names_out = bridgeOneHotEncoder[${this.id}].get_feature_names_out(**pms_OneHotEncoder_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_get_feature_names_out.tolist() if hasattr(res_OneHotEncoder_get_feature_names_out, 'tolist') else res_OneHotEncoder_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OneHotEncoder_get_metadata_routing = {k: v for k, v in pms_OneHotEncoder_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_get_metadata_routing = bridgeOneHotEncoder[${this.id}].get_metadata_routing(**pms_OneHotEncoder_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_get_metadata_routing.tolist() if hasattr(res_OneHotEncoder_get_metadata_routing, 'tolist') else res_OneHotEncoder_get_metadata_routing`\n  }\n\n  /**\n    Convert the data back to the original representation.\n\n    When unknown categories are encountered (all zeros in the one-hot encoding), `undefined` is used to represent this category. If the feature with the unknown category has a dropped category, the dropped category will be its inverse.\n\n    For a given input feature, if there is an infrequent category, ‘infrequent\\_sklearn’ will be used to represent the infrequent category.\n   */\n  async inverse_transform(opts: {\n    /**\n      The transformed data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneHotEncoder_inverse_transform = {k: v for k, v in pms_OneHotEncoder_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_inverse_transform = bridgeOneHotEncoder[${this.id}].inverse_transform(**pms_OneHotEncoder_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_inverse_transform.tolist() if hasattr(res_OneHotEncoder_inverse_transform, 'tolist') else res_OneHotEncoder_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneHotEncoder must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_OneHotEncoder_set_output = {k: v for k, v in pms_OneHotEncoder_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_set_output = bridgeOneHotEncoder[${this.id}].set_output(**pms_OneHotEncoder_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_set_output.tolist() if hasattr(res_OneHotEncoder_set_output, 'tolist') else res_OneHotEncoder_set_output`\n  }\n\n  /**\n    Transform X using one-hot encoding.\n\n    If there are infrequent categories for a feature, the infrequent categories will be grouped into a single category.\n   */\n  async transform(opts: {\n    /**\n      The data to encode.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneHotEncoder must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneHotEncoder_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneHotEncoder_transform = {k: v for k, v in pms_OneHotEncoder_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneHotEncoder_transform = bridgeOneHotEncoder[${this.id}].transform(**pms_OneHotEncoder_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneHotEncoder_transform.tolist() if hasattr(res_OneHotEncoder_transform, 'tolist') else res_OneHotEncoder_transform`\n  }\n\n  /**\n    The categories of each feature determined during fitting (in order of the features in X and corresponding with the output of `transform`). This includes the category specified in `drop` (if any).\n   */\n  get categories_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before accessing categories_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneHotEncoder_categories_ = bridgeOneHotEncoder[${this.id}].categories_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneHotEncoder_categories_.tolist() if hasattr(attr_OneHotEncoder_categories_, 'tolist') else attr_OneHotEncoder_categories_`\n    })()\n  }\n\n  /**\n    `drop\\_idx\\_\\[i\\]` is the index in `categories\\_\\[i\\]` of the category to be dropped for each feature.\n   */\n  get drop_idx_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before accessing drop_idx_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneHotEncoder_drop_idx_ = bridgeOneHotEncoder[${this.id}].drop_idx_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneHotEncoder_drop_idx_.tolist() if hasattr(attr_OneHotEncoder_drop_idx_, 'tolist') else attr_OneHotEncoder_drop_idx_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneHotEncoder_n_features_in_ = bridgeOneHotEncoder[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneHotEncoder_n_features_in_.tolist() if hasattr(attr_OneHotEncoder_n_features_in_, 'tolist') else attr_OneHotEncoder_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneHotEncoder_feature_names_in_ = bridgeOneHotEncoder[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneHotEncoder_feature_names_in_.tolist() if hasattr(attr_OneHotEncoder_feature_names_in_, 'tolist') else attr_OneHotEncoder_feature_names_in_`\n    })()\n  }\n\n  /**\n    Callable with signature `def callable(input\\_feature, category)` that returns a string. This is used to create feature names to be returned by [`get\\_feature\\_names\\_out`](#sklearn.preprocessing.OneHotEncoder.get_feature_names_out \"sklearn.preprocessing.OneHotEncoder.get_feature_names_out\").\n   */\n  get feature_name_combiner(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OneHotEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneHotEncoder must call init() before accessing feature_name_combiner'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneHotEncoder_feature_name_combiner = bridgeOneHotEncoder[${this.id}].feature_name_combiner`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneHotEncoder_feature_name_combiner.tolist() if hasattr(attr_OneHotEncoder_feature_name_combiner, 'tolist') else attr_OneHotEncoder_feature_name_combiner`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Encode categorical features as an integer array.\n\n  The input to this transformer should be an array-like of integers or strings, denoting the values taken on by categorical (discrete) features. The features are converted to ordinal integers. This results in a single column of integers (0 to n\\_categories - 1) per feature.\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-categorical-features). For a comparison of different encoders, refer to: [Comparing Target Encoder with Other Encoders](../../auto_examples/preprocessing/plot_target_encoder.html#sphx-glr-auto-examples-preprocessing-plot-target-encoder-py).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html)\n */\nexport class OrdinalEncoder {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Categories (unique values) per feature:\n\n      @defaultValue `'auto'`\n     */\n    categories?: 'auto'\n\n    /**\n      Desired dtype of output.\n     */\n    dtype?: any\n\n    /**\n      When set to ‘error’ an error will be raised in case an unknown categorical feature is present during transform. When set to ‘use\\_encoded\\_value’, the encoded value of unknown categories will be set to the value given for the parameter `unknown\\_value`. In [`inverse\\_transform`](#sklearn.preprocessing.OrdinalEncoder.inverse_transform \"sklearn.preprocessing.OrdinalEncoder.inverse_transform\"), an unknown category will be denoted as `undefined`.\n\n      @defaultValue `'error'`\n     */\n    handle_unknown?: 'error' | 'use_encoded_value'\n\n    /**\n      When the parameter handle\\_unknown is set to ‘use\\_encoded\\_value’, this parameter is required and will set the encoded value of unknown categories. It has to be distinct from the values used to encode any of the categories in `fit`. If set to np.nan, the `dtype` parameter must be a float dtype.\n     */\n    unknown_value?: number\n\n    /**\n      Encoded value of missing categories. If set to `np.nan`, then the `dtype` parameter must be a float dtype.\n     */\n    encoded_missing_value?: number\n\n    /**\n      Specifies the minimum frequency below which a category will be considered infrequent.\n     */\n    min_frequency?: number\n\n    /**\n      Specifies an upper limit to the number of output categories for each input feature when considering infrequent categories. If there are infrequent categories, `max\\_categories` includes the category representing the infrequent categories along with the frequent categories. If `undefined`, there is no limit to the number of output features.\n\n      `max\\_categories` do **not** take into account missing or unknown categories. Setting `unknown\\_value` or `encoded\\_missing\\_value` to an integer will increase the number of unique integer codes by one each. This can result in up to `max\\_categories + 2` integer codes.\n     */\n    max_categories?: number\n  }) {\n    this.id = `OrdinalEncoder${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('OrdinalEncoder.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import OrdinalEncoder\ntry: bridgeOrdinalEncoder\nexcept NameError: bridgeOrdinalEncoder = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OrdinalEncoder = {'categories': ${\n      this.opts['categories'] ?? undefined\n    }, 'dtype': ${this.opts['dtype'] ?? undefined}, 'handle_unknown': ${\n      this.opts['handle_unknown'] ?? undefined\n    }, 'unknown_value': ${\n      this.opts['unknown_value'] ?? undefined\n    }, 'encoded_missing_value': ${\n      this.opts['encoded_missing_value'] ?? undefined\n    }, 'min_frequency': ${\n      this.opts['min_frequency'] ?? undefined\n    }, 'max_categories': ${this.opts['max_categories'] ?? undefined}}\n\nctor_OrdinalEncoder = {k: v for k, v in ctor_OrdinalEncoder.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOrdinalEncoder[${this.id}] = OrdinalEncoder(**ctor_OrdinalEncoder)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOrdinalEncoder[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the OrdinalEncoder to X.\n   */\n  async fit(opts: {\n    /**\n      The data to determine the categories of each feature.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\").\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OrdinalEncoder must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OrdinalEncoder_fit = {k: v for k, v in pms_OrdinalEncoder_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_fit = bridgeOrdinalEncoder[${this.id}].fit(**pms_OrdinalEncoder_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_fit.tolist() if hasattr(res_OrdinalEncoder_fit, 'tolist') else res_OrdinalEncoder_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OrdinalEncoder must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_OrdinalEncoder_fit_transform = {k: v for k, v in pms_OrdinalEncoder_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_fit_transform = bridgeOrdinalEncoder[${this.id}].fit_transform(**pms_OrdinalEncoder_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_fit_transform.tolist() if hasattr(res_OrdinalEncoder_fit_transform, 'tolist') else res_OrdinalEncoder_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OrdinalEncoder_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_OrdinalEncoder_get_feature_names_out = {k: v for k, v in pms_OrdinalEncoder_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_get_feature_names_out = bridgeOrdinalEncoder[${this.id}].get_feature_names_out(**pms_OrdinalEncoder_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_get_feature_names_out.tolist() if hasattr(res_OrdinalEncoder_get_feature_names_out, 'tolist') else res_OrdinalEncoder_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OrdinalEncoder_get_metadata_routing = {k: v for k, v in pms_OrdinalEncoder_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_get_metadata_routing = bridgeOrdinalEncoder[${this.id}].get_metadata_routing(**pms_OrdinalEncoder_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_get_metadata_routing.tolist() if hasattr(res_OrdinalEncoder_get_metadata_routing, 'tolist') else res_OrdinalEncoder_get_metadata_routing`\n  }\n\n  /**\n    Convert the data back to the original representation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The transformed data.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OrdinalEncoder_inverse_transform = {k: v for k, v in pms_OrdinalEncoder_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_inverse_transform = bridgeOrdinalEncoder[${this.id}].inverse_transform(**pms_OrdinalEncoder_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_inverse_transform.tolist() if hasattr(res_OrdinalEncoder_inverse_transform, 'tolist') else res_OrdinalEncoder_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OrdinalEncoder must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_OrdinalEncoder_set_output = {k: v for k, v in pms_OrdinalEncoder_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_set_output = bridgeOrdinalEncoder[${this.id}].set_output(**pms_OrdinalEncoder_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_set_output.tolist() if hasattr(res_OrdinalEncoder_set_output, 'tolist') else res_OrdinalEncoder_set_output`\n  }\n\n  /**\n    Transform X to ordinal codes.\n   */\n  async transform(opts: {\n    /**\n      The data to encode.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OrdinalEncoder must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrdinalEncoder_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OrdinalEncoder_transform = {k: v for k, v in pms_OrdinalEncoder_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrdinalEncoder_transform = bridgeOrdinalEncoder[${this.id}].transform(**pms_OrdinalEncoder_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrdinalEncoder_transform.tolist() if hasattr(res_OrdinalEncoder_transform, 'tolist') else res_OrdinalEncoder_transform`\n  }\n\n  /**\n    The categories of each feature determined during `fit` (in order of the features in X and corresponding with the output of `transform`). This does not include categories that weren’t seen during `fit`.\n   */\n  get categories_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before accessing categories_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrdinalEncoder_categories_ = bridgeOrdinalEncoder[${this.id}].categories_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrdinalEncoder_categories_.tolist() if hasattr(attr_OrdinalEncoder_categories_, 'tolist') else attr_OrdinalEncoder_categories_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrdinalEncoder_n_features_in_ = bridgeOrdinalEncoder[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrdinalEncoder_n_features_in_.tolist() if hasattr(attr_OrdinalEncoder_n_features_in_, 'tolist') else attr_OrdinalEncoder_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OrdinalEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrdinalEncoder must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrdinalEncoder_feature_names_in_ = bridgeOrdinalEncoder[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrdinalEncoder_feature_names_in_.tolist() if hasattr(attr_OrdinalEncoder_feature_names_in_, 'tolist') else attr_OrdinalEncoder_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generate polynomial and interaction features.\n\n  Generate a new feature matrix consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. For example, if an input sample is two dimensional and of the form \\[a, b\\], the degree-2 polynomial features are \\[1, a, b, a^2, ab, b^2\\].\n\n  Read more in the [User Guide](../preprocessing.html#polynomial-features).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html)\n */\nexport class PolynomialFeatures {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      If a single int is given, it specifies the maximal degree of the polynomial features. If a tuple `(min\\_degree, max\\_degree)` is passed, then `min\\_degree` is the minimum and `max\\_degree` is the maximum polynomial degree of the generated features. Note that `min\\_degree=0` and `min\\_degree=1` are equivalent as outputting the degree zero term is determined by `include\\_bias`.\n\n      @defaultValue `2`\n     */\n    degree?: number\n\n    /**\n      If `true`, only interaction features are produced: features that are products of at most `degree` *distinct* input features, i.e. terms with power of 2 or higher of the same input feature are excluded:\n\n      @defaultValue `false`\n     */\n    interaction_only?: boolean\n\n    /**\n      If `true` (default), then include a bias column, the feature in which all polynomial powers are zero (i.e. a column of ones - acts as an intercept term in a linear model).\n\n      @defaultValue `true`\n     */\n    include_bias?: boolean\n\n    /**\n      Order of output array in the dense case. `'F'` order is faster to compute, but may slow down subsequent estimators.\n\n      @defaultValue `'C'`\n     */\n    order?: 'C' | 'F'\n  }) {\n    this.id = `PolynomialFeatures${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'PolynomialFeatures.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\ntry: bridgePolynomialFeatures\nexcept NameError: bridgePolynomialFeatures = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PolynomialFeatures = {'degree': ${\n      this.opts['degree'] ?? undefined\n    }, 'interaction_only': ${\n      this.opts['interaction_only'] ?? undefined\n    }, 'include_bias': ${this.opts['include_bias'] ?? undefined}, 'order': ${\n      this.opts['order'] ?? undefined\n    }}\n\nctor_PolynomialFeatures = {k: v for k, v in ctor_PolynomialFeatures.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePolynomialFeatures[${this.id}] = PolynomialFeatures(**ctor_PolynomialFeatures)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePolynomialFeatures[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute number of output features.\n   */\n  async fit(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PolynomialFeatures must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialFeatures_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PolynomialFeatures_fit = {k: v for k, v in pms_PolynomialFeatures_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_fit = bridgePolynomialFeatures[${this.id}].fit(**pms_PolynomialFeatures_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_fit.tolist() if hasattr(res_PolynomialFeatures_fit, 'tolist') else res_PolynomialFeatures_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialFeatures_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_PolynomialFeatures_fit_transform = {k: v for k, v in pms_PolynomialFeatures_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_fit_transform = bridgePolynomialFeatures[${this.id}].fit_transform(**pms_PolynomialFeatures_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_fit_transform.tolist() if hasattr(res_PolynomialFeatures_fit_transform, 'tolist') else res_PolynomialFeatures_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PolynomialFeatures_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_PolynomialFeatures_get_feature_names_out = {k: v for k, v in pms_PolynomialFeatures_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_get_feature_names_out = bridgePolynomialFeatures[${this.id}].get_feature_names_out(**pms_PolynomialFeatures_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_get_feature_names_out.tolist() if hasattr(res_PolynomialFeatures_get_feature_names_out, 'tolist') else res_PolynomialFeatures_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PolynomialFeatures_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PolynomialFeatures_get_metadata_routing = {k: v for k, v in pms_PolynomialFeatures_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_get_metadata_routing = bridgePolynomialFeatures[${this.id}].get_metadata_routing(**pms_PolynomialFeatures_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_get_metadata_routing.tolist() if hasattr(res_PolynomialFeatures_get_metadata_routing, 'tolist') else res_PolynomialFeatures_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PolynomialFeatures must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialFeatures_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_PolynomialFeatures_set_output = {k: v for k, v in pms_PolynomialFeatures_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_set_output = bridgePolynomialFeatures[${this.id}].set_output(**pms_PolynomialFeatures_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_set_output.tolist() if hasattr(res_PolynomialFeatures_set_output, 'tolist') else res_PolynomialFeatures_set_output`\n  }\n\n  /**\n    Transform data to polynomial features.\n   */\n  async transform(opts: {\n    /**\n      The data to transform, row by row.\n\n      Prefer CSR over CSC for sparse input (for speed), but CSC is required if the degree is 4 or higher. If the degree is less than 4 and the input format is CSC, it will be converted to CSR, have its polynomial features generated, then converted back to CSC.\n\n      If the degree is 2 or 3, the method described in “Leveraging Sparsity to Speed Up Polynomial Feature Expansions of CSR Matrices Using K-Simplex Numbers” by Andrew Nystrom and John Hughes is used, which is much faster than the method used on CSC input. For this reason, a CSC input will be converted to CSR, and the output will be converted back to CSC prior to being returned, hence the preference of CSR.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PolynomialFeatures must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialFeatures_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PolynomialFeatures_transform = {k: v for k, v in pms_PolynomialFeatures_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialFeatures_transform = bridgePolynomialFeatures[${this.id}].transform(**pms_PolynomialFeatures_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialFeatures_transform.tolist() if hasattr(res_PolynomialFeatures_transform, 'tolist') else res_PolynomialFeatures_transform`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialFeatures_n_features_in_ = bridgePolynomialFeatures[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialFeatures_n_features_in_.tolist() if hasattr(attr_PolynomialFeatures_n_features_in_, 'tolist') else attr_PolynomialFeatures_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialFeatures_feature_names_in_ = bridgePolynomialFeatures[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialFeatures_feature_names_in_.tolist() if hasattr(attr_PolynomialFeatures_feature_names_in_, 'tolist') else attr_PolynomialFeatures_feature_names_in_`\n    })()\n  }\n\n  /**\n    The total number of polynomial output features. The number of output features is computed by iterating over all suitably sized combinations of input features.\n   */\n  get n_output_features_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialFeatures instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialFeatures must call init() before accessing n_output_features_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialFeatures_n_output_features_ = bridgePolynomialFeatures[${this.id}].n_output_features_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialFeatures_n_output_features_.tolist() if hasattr(attr_PolynomialFeatures_n_output_features_, 'tolist') else attr_PolynomialFeatures_n_output_features_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Apply a power transform featurewise to make data more Gaussian-like.\n\n  Power transforms are a family of parametric, monotonic transformations that are applied to make data more Gaussian-like. This is useful for modeling issues related to heteroscedasticity (non-constant variance), or other situations where normality is desired.\n\n  Currently, PowerTransformer supports the Box-Cox transform and the Yeo-Johnson transform. The optimal parameter for stabilizing variance and minimizing skewness is estimated through maximum likelihood.\n\n  Box-Cox requires input data to be strictly positive, while Yeo-Johnson supports both positive or negative data.\n\n  By default, zero-mean, unit-variance normalization is applied to the transformed data.\n\n  For an example visualization, refer to [Compare PowerTransformer with other scalers](../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-power-transformer-section). To see the effect of Box-Cox and Yeo-Johnson transformations on different distributions, see: [Map data to a normal distribution](../../auto_examples/preprocessing/plot_map_data_to_normal.html#sphx-glr-auto-examples-preprocessing-plot-map-data-to-normal-py).\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html)\n */\nexport class PowerTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The power transform method. Available methods are:\n\n      @defaultValue `'yeo-johnson'`\n     */\n    method?: 'yeo-johnson' | 'box-cox'\n\n    /**\n      Set to `true` to apply zero-mean, unit-variance normalization to the transformed output.\n\n      @defaultValue `true`\n     */\n    standardize?: boolean\n\n    /**\n      Set to `false` to perform inplace computation during transformation.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `PowerTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('PowerTransformer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import PowerTransformer\ntry: bridgePowerTransformer\nexcept NameError: bridgePowerTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PowerTransformer = {'method': ${\n      this.opts['method'] ?? undefined\n    }, 'standardize': ${this.opts['standardize'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }}\n\nctor_PowerTransformer = {k: v for k, v in ctor_PowerTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePowerTransformer[${this.id}] = PowerTransformer(**ctor_PowerTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePowerTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Estimate the optimal parameter lambda for each feature.\n\n    The optimal lambda parameter for minimizing skewness is estimated on each feature independently using maximum likelihood.\n   */\n  async fit(opts: {\n    /**\n      The data used to estimate the optimal transformation parameters.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PowerTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PowerTransformer_fit = {k: v for k, v in pms_PowerTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_fit = bridgePowerTransformer[${this.id}].fit(**pms_PowerTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_fit.tolist() if hasattr(res_PowerTransformer_fit, 'tolist') else res_PowerTransformer_fit`\n  }\n\n  /**\n    Fit `PowerTransformer` to `X`, then transform `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      The data used to estimate the optimal transformation parameters and to be transformed using a power transformation.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PowerTransformer_fit_transform = {k: v for k, v in pms_PowerTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_fit_transform = bridgePowerTransformer[${this.id}].fit_transform(**pms_PowerTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_fit_transform.tolist() if hasattr(res_PowerTransformer_fit_transform, 'tolist') else res_PowerTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PowerTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_PowerTransformer_get_feature_names_out = {k: v for k, v in pms_PowerTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_get_feature_names_out = bridgePowerTransformer[${this.id}].get_feature_names_out(**pms_PowerTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_get_feature_names_out.tolist() if hasattr(res_PowerTransformer_get_feature_names_out, 'tolist') else res_PowerTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PowerTransformer_get_metadata_routing = {k: v for k, v in pms_PowerTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_get_metadata_routing = bridgePowerTransformer[${this.id}].get_metadata_routing(**pms_PowerTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_get_metadata_routing.tolist() if hasattr(res_PowerTransformer_get_metadata_routing, 'tolist') else res_PowerTransformer_get_metadata_routing`\n  }\n\n  /**\n    Apply the inverse power transformation using the fitted lambdas.\n\n    The inverse of the Box-Cox transformation is given by:\n   */\n  async inverse_transform(opts: {\n    /**\n      The transformed data.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PowerTransformer_inverse_transform = {k: v for k, v in pms_PowerTransformer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_inverse_transform = bridgePowerTransformer[${this.id}].inverse_transform(**pms_PowerTransformer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_inverse_transform.tolist() if hasattr(res_PowerTransformer_inverse_transform, 'tolist') else res_PowerTransformer_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PowerTransformer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_PowerTransformer_set_output = {k: v for k, v in pms_PowerTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_set_output = bridgePowerTransformer[${this.id}].set_output(**pms_PowerTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_set_output.tolist() if hasattr(res_PowerTransformer_set_output, 'tolist') else res_PowerTransformer_set_output`\n  }\n\n  /**\n    Apply the power transform to each feature using the fitted lambdas.\n   */\n  async transform(opts: {\n    /**\n      The data to be transformed using a power transformation.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PowerTransformer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PowerTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PowerTransformer_transform = {k: v for k, v in pms_PowerTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PowerTransformer_transform = bridgePowerTransformer[${this.id}].transform(**pms_PowerTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PowerTransformer_transform.tolist() if hasattr(res_PowerTransformer_transform, 'tolist') else res_PowerTransformer_transform`\n  }\n\n  /**\n    The parameters of the power transformation for the selected features.\n   */\n  get lambdas_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before accessing lambdas_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PowerTransformer_lambdas_ = bridgePowerTransformer[${this.id}].lambdas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PowerTransformer_lambdas_.tolist() if hasattr(attr_PowerTransformer_lambdas_, 'tolist') else attr_PowerTransformer_lambdas_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PowerTransformer_n_features_in_ = bridgePowerTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PowerTransformer_n_features_in_.tolist() if hasattr(attr_PowerTransformer_n_features_in_, 'tolist') else attr_PowerTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PowerTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PowerTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PowerTransformer_feature_names_in_ = bridgePowerTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PowerTransformer_feature_names_in_.tolist() if hasattr(attr_PowerTransformer_feature_names_in_, 'tolist') else attr_PowerTransformer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transform features using quantiles information.\n\n  This method transforms the features to follow a uniform or a normal distribution. Therefore, for a given feature, this transformation tends to spread out the most frequent values. It also reduces the impact of (marginal) outliers: this is therefore a robust preprocessing scheme.\n\n  The transformation is applied on each feature independently. First an estimate of the cumulative distribution function of a feature is used to map the original values to a uniform distribution. The obtained values are then mapped to the desired output distribution using the associated quantile function. Features values of new/unseen data that fall below or above the fitted range will be mapped to the bounds of the output distribution. Note that this transform is non-linear. It may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable.\n\n  For example visualizations, refer to [Compare QuantileTransformer with other scalers](../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-quantile-transformer-section).\n\n  Read more in the [User Guide](../preprocessing.html#preprocessing-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html)\n */\nexport class QuantileTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of quantiles to be computed. It corresponds to the number of landmarks used to discretize the cumulative distribution function. If n\\_quantiles is larger than the number of samples, n\\_quantiles is set to the number of samples as a larger number of quantiles does not give a better approximation of the cumulative distribution function estimator.\n\n      @defaultValue `1000`\n     */\n    n_quantiles?: number\n\n    /**\n      Marginal distribution for the transformed data. The choices are ‘uniform’ (default) or ‘normal’.\n\n      @defaultValue `'uniform'`\n     */\n    output_distribution?: 'uniform' | 'normal'\n\n    /**\n      Only applies to sparse matrices. If `true`, the sparse entries of the matrix are discarded to compute the quantile statistics. If `false`, these entries are treated as zeros.\n\n      @defaultValue `false`\n     */\n    ignore_implicit_zeros?: boolean\n\n    /**\n      Maximum number of samples used to estimate the quantiles for computational efficiency. Note that the subsampling procedure may differ for value-identical sparse and dense matrices.\n\n      @defaultValue `10`\n     */\n    subsample?: number\n\n    /**\n      Determines random number generation for subsampling and smoothing noise. Please see `subsample` for more details. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Set to `false` to perform inplace transformation and avoid a copy (if the input is already a numpy array).\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `QuantileTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'QuantileTransformer.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import QuantileTransformer\ntry: bridgeQuantileTransformer\nexcept NameError: bridgeQuantileTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_QuantileTransformer = {'n_quantiles': ${\n      this.opts['n_quantiles'] ?? undefined\n    }, 'output_distribution': ${\n      this.opts['output_distribution'] ?? undefined\n    }, 'ignore_implicit_zeros': ${\n      this.opts['ignore_implicit_zeros'] ?? undefined\n    }, 'subsample': ${this.opts['subsample'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}}\n\nctor_QuantileTransformer = {k: v for k, v in ctor_QuantileTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeQuantileTransformer[${this.id}] = QuantileTransformer(**ctor_QuantileTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeQuantileTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the quantiles used for transforming.\n   */\n  async fit(opts: {\n    /**\n      The data used to scale along the features axis. If a sparse matrix is provided, it will be converted into a sparse `csc\\_matrix`. Additionally, the sparse matrix needs to be nonnegative if `ignore\\_implicit\\_zeros` is `false`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('QuantileTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_QuantileTransformer_fit = {k: v for k, v in pms_QuantileTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_fit = bridgeQuantileTransformer[${this.id}].fit(**pms_QuantileTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_fit.tolist() if hasattr(res_QuantileTransformer_fit, 'tolist') else res_QuantileTransformer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_QuantileTransformer_fit_transform = {k: v for k, v in pms_QuantileTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_fit_transform = bridgeQuantileTransformer[${this.id}].fit_transform(**pms_QuantileTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_fit_transform.tolist() if hasattr(res_QuantileTransformer_fit_transform, 'tolist') else res_QuantileTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_QuantileTransformer_get_feature_names_out = {k: v for k, v in pms_QuantileTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_get_feature_names_out = bridgeQuantileTransformer[${this.id}].get_feature_names_out(**pms_QuantileTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_get_feature_names_out.tolist() if hasattr(res_QuantileTransformer_get_feature_names_out, 'tolist') else res_QuantileTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_QuantileTransformer_get_metadata_routing = {k: v for k, v in pms_QuantileTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_get_metadata_routing = bridgeQuantileTransformer[${this.id}].get_metadata_routing(**pms_QuantileTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_get_metadata_routing.tolist() if hasattr(res_QuantileTransformer_get_metadata_routing, 'tolist') else res_QuantileTransformer_get_metadata_routing`\n  }\n\n  /**\n    Back-projection to the original space.\n   */\n  async inverse_transform(opts: {\n    /**\n      The data used to scale along the features axis. If a sparse matrix is provided, it will be converted into a sparse `csc\\_matrix`. Additionally, the sparse matrix needs to be nonnegative if `ignore\\_implicit\\_zeros` is `false`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileTransformer_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuantileTransformer_inverse_transform = {k: v for k, v in pms_QuantileTransformer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_inverse_transform = bridgeQuantileTransformer[${this.id}].inverse_transform(**pms_QuantileTransformer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_inverse_transform.tolist() if hasattr(res_QuantileTransformer_inverse_transform, 'tolist') else res_QuantileTransformer_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_QuantileTransformer_set_output = {k: v for k, v in pms_QuantileTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_set_output = bridgeQuantileTransformer[${this.id}].set_output(**pms_QuantileTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_set_output.tolist() if hasattr(res_QuantileTransformer_set_output, 'tolist') else res_QuantileTransformer_set_output`\n  }\n\n  /**\n    Feature-wise transformation of the data.\n   */\n  async transform(opts: {\n    /**\n      The data used to scale along the features axis. If a sparse matrix is provided, it will be converted into a sparse `csc\\_matrix`. Additionally, the sparse matrix needs to be nonnegative if `ignore\\_implicit\\_zeros` is `false`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('QuantileTransformer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuantileTransformer_transform = {k: v for k, v in pms_QuantileTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileTransformer_transform = bridgeQuantileTransformer[${this.id}].transform(**pms_QuantileTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileTransformer_transform.tolist() if hasattr(res_QuantileTransformer_transform, 'tolist') else res_QuantileTransformer_transform`\n  }\n\n  /**\n    The actual number of quantiles used to discretize the cumulative distribution function.\n   */\n  get n_quantiles_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before accessing n_quantiles_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileTransformer_n_quantiles_ = bridgeQuantileTransformer[${this.id}].n_quantiles_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileTransformer_n_quantiles_.tolist() if hasattr(attr_QuantileTransformer_n_quantiles_, 'tolist') else attr_QuantileTransformer_n_quantiles_`\n    })()\n  }\n\n  /**\n    The values corresponding the quantiles of reference.\n   */\n  get quantiles_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before accessing quantiles_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileTransformer_quantiles_ = bridgeQuantileTransformer[${this.id}].quantiles_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileTransformer_quantiles_.tolist() if hasattr(attr_QuantileTransformer_quantiles_, 'tolist') else attr_QuantileTransformer_quantiles_`\n    })()\n  }\n\n  /**\n    Quantiles of references.\n   */\n  get references_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before accessing references_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileTransformer_references_ = bridgeQuantileTransformer[${this.id}].references_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileTransformer_references_.tolist() if hasattr(attr_QuantileTransformer_references_, 'tolist') else attr_QuantileTransformer_references_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileTransformer_n_features_in_ = bridgeQuantileTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileTransformer_n_features_in_.tolist() if hasattr(attr_QuantileTransformer_n_features_in_, 'tolist') else attr_QuantileTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileTransformer_feature_names_in_ = bridgeQuantileTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileTransformer_feature_names_in_.tolist() if hasattr(attr_QuantileTransformer_feature_names_in_, 'tolist') else attr_QuantileTransformer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Scale features using statistics that are robust to outliers.\n\n  This Scaler removes the median and scales the data according to the quantile range (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and the 3rd quartile (75th quantile).\n\n  Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Median and interquartile range are then stored to be used on later data using the [`transform`](#sklearn.preprocessing.RobustScaler.transform \"sklearn.preprocessing.RobustScaler.transform\") method.\n\n  Standardization of a dataset is a common preprocessing for many machine learning estimators. Typically this is done by removing the mean and scaling to unit variance. However, outliers can often influence the sample mean / variance in a negative way. In such cases, using the median and the interquartile range often give better results. For an example visualization and comparison to other scalers, refer to [Compare RobustScaler with other scalers](../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-robust-scaler-section).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html)\n */\nexport class RobustScaler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      If `true`, center the data before scaling. This will cause [`transform`](#sklearn.preprocessing.RobustScaler.transform \"sklearn.preprocessing.RobustScaler.transform\") to raise an exception when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory.\n\n      @defaultValue `true`\n     */\n    with_centering?: boolean\n\n    /**\n      If `true`, scale the data to interquartile range.\n\n      @defaultValue `true`\n     */\n    with_scaling?: boolean\n\n    /**\n      Quantile range used to calculate `scale\\_`. By default this is equal to the IQR, i.e., `q\\_min` is the first quantile and `q\\_max` is the third quantile.\n     */\n    quantile_range?: any\n\n    /**\n      If `false`, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      If `true`, scale data so that normally distributed features have a variance of 1. In general, if the difference between the x-values of `q\\_max` and `q\\_min` for a standard normal distribution is greater than 1, the dataset will be scaled down. If less than 1, the dataset will be scaled up.\n\n      @defaultValue `false`\n     */\n    unit_variance?: boolean\n  }) {\n    this.id = `RobustScaler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RobustScaler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import RobustScaler\ntry: bridgeRobustScaler\nexcept NameError: bridgeRobustScaler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RobustScaler = {'with_centering': ${\n      this.opts['with_centering'] ?? undefined\n    }, 'with_scaling': ${\n      this.opts['with_scaling'] ?? undefined\n    }, 'quantile_range': ${this.opts['quantile_range'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }, 'unit_variance': ${this.opts['unit_variance'] ?? undefined}}\n\nctor_RobustScaler = {k: v for k, v in ctor_RobustScaler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRobustScaler[${this.id}] = RobustScaler(**ctor_RobustScaler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRobustScaler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the median and quantiles to be used for scaling.\n   */\n  async fit(opts: {\n    /**\n      The data used to compute the median and quantiles used for later scaling along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_RobustScaler_fit = {k: v for k, v in pms_RobustScaler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_fit = bridgeRobustScaler[${this.id}].fit(**pms_RobustScaler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_fit.tolist() if hasattr(res_RobustScaler_fit, 'tolist') else res_RobustScaler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RobustScaler_fit_transform = {k: v for k, v in pms_RobustScaler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_fit_transform = bridgeRobustScaler[${this.id}].fit_transform(**pms_RobustScaler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_fit_transform.tolist() if hasattr(res_RobustScaler_fit_transform, 'tolist') else res_RobustScaler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RobustScaler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RobustScaler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_RobustScaler_get_feature_names_out = {k: v for k, v in pms_RobustScaler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_get_feature_names_out = bridgeRobustScaler[${this.id}].get_feature_names_out(**pms_RobustScaler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_get_feature_names_out.tolist() if hasattr(res_RobustScaler_get_feature_names_out, 'tolist') else res_RobustScaler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RobustScaler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RobustScaler_get_metadata_routing = {k: v for k, v in pms_RobustScaler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_get_metadata_routing = bridgeRobustScaler[${this.id}].get_metadata_routing(**pms_RobustScaler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_get_metadata_routing.tolist() if hasattr(res_RobustScaler_get_metadata_routing, 'tolist') else res_RobustScaler_get_metadata_routing`\n  }\n\n  /**\n    Scale back the data to the original representation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The rescaled data to be transformed back.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RobustScaler must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RobustScaler_inverse_transform = {k: v for k, v in pms_RobustScaler_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_inverse_transform = bridgeRobustScaler[${this.id}].inverse_transform(**pms_RobustScaler_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_inverse_transform.tolist() if hasattr(res_RobustScaler_inverse_transform, 'tolist') else res_RobustScaler_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_RobustScaler_set_output = {k: v for k, v in pms_RobustScaler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_set_output = bridgeRobustScaler[${this.id}].set_output(**pms_RobustScaler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_set_output.tolist() if hasattr(res_RobustScaler_set_output, 'tolist') else res_RobustScaler_set_output`\n  }\n\n  /**\n    Center and scale the data.\n   */\n  async transform(opts: {\n    /**\n      The data used to scale along the specified axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RobustScaler_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RobustScaler_transform = {k: v for k, v in pms_RobustScaler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RobustScaler_transform = bridgeRobustScaler[${this.id}].transform(**pms_RobustScaler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RobustScaler_transform.tolist() if hasattr(res_RobustScaler_transform, 'tolist') else res_RobustScaler_transform`\n  }\n\n  /**\n    The median value for each feature in the training set.\n   */\n  get center_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before accessing center_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RobustScaler_center_ = bridgeRobustScaler[${this.id}].center_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RobustScaler_center_.tolist() if hasattr(attr_RobustScaler_center_, 'tolist') else attr_RobustScaler_center_`\n    })()\n  }\n\n  /**\n    The (scaled) interquartile range for each feature in the training set.\n   */\n  get scale_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RobustScaler must call init() before accessing scale_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RobustScaler_scale_ = bridgeRobustScaler[${this.id}].scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RobustScaler_scale_.tolist() if hasattr(attr_RobustScaler_scale_, 'tolist') else attr_RobustScaler_scale_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RobustScaler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RobustScaler_n_features_in_ = bridgeRobustScaler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RobustScaler_n_features_in_.tolist() if hasattr(attr_RobustScaler_n_features_in_, 'tolist') else attr_RobustScaler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RobustScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RobustScaler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RobustScaler_feature_names_in_ = bridgeRobustScaler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RobustScaler_feature_names_in_.tolist() if hasattr(attr_RobustScaler_feature_names_in_, 'tolist') else attr_RobustScaler_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generate univariate B-spline bases for features.\n\n  Generate a new feature matrix consisting of `n\\_splines=n\\_knots + degree \\- 1` (`n\\_knots \\- 1` for `extrapolation=\"periodic\"`) spline basis functions (B-splines) of polynomial order=\\`degree\\` for each feature.\n\n  Read more in the [User Guide](../preprocessing.html#spline-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.SplineTransformer.html)\n */\nexport class SplineTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of knots of the splines if `knots` equals one of {‘uniform’, ‘quantile’}. Must be larger or equal 2. Ignored if `knots` is array-like.\n\n      @defaultValue `5`\n     */\n    n_knots?: number\n\n    /**\n      The polynomial degree of the spline basis. Must be a non-negative integer.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Set knot positions such that first knot <= features <= last knot.\n\n      @defaultValue `'uniform'`\n     */\n    knots?: 'uniform' | 'quantile' | ArrayLike[]\n\n    /**\n      If ‘error’, values outside the min and max values of the training features raises a `ValueError`. If ‘constant’, the value of the splines at minimum and maximum value of the features is used as constant extrapolation. If ‘linear’, a linear extrapolation is used. If ‘continue’, the splines are extrapolated as is, i.e. option `extrapolate=True` in [`scipy.interpolate.BSpline`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BSpline.html#scipy.interpolate.BSpline \"(in SciPy v1.11.3)\"). If ‘periodic’, periodic splines with a periodicity equal to the distance between the first and last knot are used. Periodic splines enforce equal function values and derivatives at the first and last knot. For example, this makes it possible to avoid introducing an arbitrary jump between Dec 31st and Jan 1st in spline features derived from a naturally periodic “day-of-year” input feature. In this case it is recommended to manually set the knot values to control the period.\n\n      @defaultValue `'constant'`\n     */\n    extrapolation?: 'error' | 'constant' | 'linear' | 'continue' | 'periodic'\n\n    /**\n      If `false`, then the last spline element inside the data range of a feature is dropped. As B-splines sum to one over the spline basis functions for each data point, they implicitly include a bias term, i.e. a column of ones. It acts as an intercept term in a linear models.\n\n      @defaultValue `true`\n     */\n    include_bias?: boolean\n\n    /**\n      Order of output array in the dense case. `'F'` order is faster to compute, but may slow down subsequent estimators.\n\n      @defaultValue `'C'`\n     */\n    order?: 'C' | 'F'\n\n    /**\n      Will return sparse CSR matrix if set `true` else will return an array. This option is only available with `scipy>=1.8`.\n\n      @defaultValue `false`\n     */\n    sparse_output?: boolean\n  }) {\n    this.id = `SplineTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SplineTransformer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import SplineTransformer\ntry: bridgeSplineTransformer\nexcept NameError: bridgeSplineTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SplineTransformer = {'n_knots': ${\n      this.opts['n_knots'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'knots': np.array(${\n      this.opts['knots'] ?? undefined\n    }) if ${this.opts['knots'] !== undefined} else None, 'extrapolation': ${\n      this.opts['extrapolation'] ?? undefined\n    }, 'include_bias': ${this.opts['include_bias'] ?? undefined}, 'order': ${\n      this.opts['order'] ?? undefined\n    }, 'sparse_output': ${this.opts['sparse_output'] ?? undefined}}\n\nctor_SplineTransformer = {k: v for k, v in ctor_SplineTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSplineTransformer[${this.id}] = SplineTransformer(**ctor_SplineTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSplineTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute knot positions of splines.\n   */\n  async fit(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n\n    /**\n      Individual weights for each sample. Used to calculate quantiles if `knots=\"quantile\"`. For `knots=\"uniform\"`, zero weighted observations are ignored for finding the min and max of `X`.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SplineTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SplineTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_SplineTransformer_fit = {k: v for k, v in pms_SplineTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_fit = bridgeSplineTransformer[${this.id}].fit(**pms_SplineTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_fit.tolist() if hasattr(res_SplineTransformer_fit, 'tolist') else res_SplineTransformer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SplineTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SplineTransformer_fit_transform = {k: v for k, v in pms_SplineTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_fit_transform = bridgeSplineTransformer[${this.id}].fit_transform(**pms_SplineTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_fit_transform.tolist() if hasattr(res_SplineTransformer_fit_transform, 'tolist') else res_SplineTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SplineTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SplineTransformer_get_feature_names_out = {k: v for k, v in pms_SplineTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_get_feature_names_out = bridgeSplineTransformer[${this.id}].get_feature_names_out(**pms_SplineTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_get_feature_names_out.tolist() if hasattr(res_SplineTransformer_get_feature_names_out, 'tolist') else res_SplineTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SplineTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SplineTransformer_get_metadata_routing = {k: v for k, v in pms_SplineTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_get_metadata_routing = bridgeSplineTransformer[${this.id}].get_metadata_routing(**pms_SplineTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_get_metadata_routing.tolist() if hasattr(res_SplineTransformer_get_metadata_routing, 'tolist') else res_SplineTransformer_get_metadata_routing`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SplineTransformer_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SplineTransformer_set_fit_request = {k: v for k, v in pms_SplineTransformer_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_set_fit_request = bridgeSplineTransformer[${this.id}].set_fit_request(**pms_SplineTransformer_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_set_fit_request.tolist() if hasattr(res_SplineTransformer_set_fit_request, 'tolist') else res_SplineTransformer_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SplineTransformer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SplineTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SplineTransformer_set_output = {k: v for k, v in pms_SplineTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_set_output = bridgeSplineTransformer[${this.id}].set_output(**pms_SplineTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_set_output.tolist() if hasattr(res_SplineTransformer_set_output, 'tolist') else res_SplineTransformer_set_output`\n  }\n\n  /**\n    Transform each feature data to B-splines.\n   */\n  async transform(opts: {\n    /**\n      The data to transform.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SplineTransformer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SplineTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SplineTransformer_transform = {k: v for k, v in pms_SplineTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SplineTransformer_transform = bridgeSplineTransformer[${this.id}].transform(**pms_SplineTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SplineTransformer_transform.tolist() if hasattr(res_SplineTransformer_transform, 'tolist') else res_SplineTransformer_transform`\n  }\n\n  /**\n    List of BSplines objects, one for each feature.\n   */\n  get bsplines_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before accessing bsplines_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SplineTransformer_bsplines_ = bridgeSplineTransformer[${this.id}].bsplines_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SplineTransformer_bsplines_.tolist() if hasattr(attr_SplineTransformer_bsplines_, 'tolist') else attr_SplineTransformer_bsplines_`\n    })()\n  }\n\n  /**\n    The total number of input features.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SplineTransformer_n_features_in_ = bridgeSplineTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SplineTransformer_n_features_in_.tolist() if hasattr(attr_SplineTransformer_n_features_in_, 'tolist') else attr_SplineTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SplineTransformer_feature_names_in_ = bridgeSplineTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SplineTransformer_feature_names_in_.tolist() if hasattr(attr_SplineTransformer_feature_names_in_, 'tolist') else attr_SplineTransformer_feature_names_in_`\n    })()\n  }\n\n  /**\n    The total number of output features, which is computed as `n\\_features \\* n\\_splines`, where `n\\_splines` is the number of bases elements of the B-splines, `n\\_knots + degree \\- 1` for non-periodic splines and `n\\_knots \\- 1` for periodic ones. If `include\\_bias=False`, then it is only `n\\_features \\* (n\\_splines \\- 1)`.\n   */\n  get n_features_out_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SplineTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SplineTransformer must call init() before accessing n_features_out_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SplineTransformer_n_features_out_ = bridgeSplineTransformer[${this.id}].n_features_out_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SplineTransformer_n_features_out_.tolist() if hasattr(attr_SplineTransformer_n_features_out_, 'tolist') else attr_SplineTransformer_n_features_out_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Standardize features by removing the mean and scaling to unit variance.\n\n  The standard score of a sample `x` is calculated as:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html)\n */\nexport class StandardScaler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      If `false`, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      If `true`, center the data before scaling. This does not work (and will raise an exception) when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory.\n\n      @defaultValue `true`\n     */\n    with_mean?: boolean\n\n    /**\n      If `true`, scale the data to unit variance (or equivalently, unit standard deviation).\n\n      @defaultValue `true`\n     */\n    with_std?: boolean\n  }) {\n    this.id = `StandardScaler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('StandardScaler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\ntry: bridgeStandardScaler\nexcept NameError: bridgeStandardScaler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_StandardScaler = {'copy': ${\n      this.opts['copy'] ?? undefined\n    }, 'with_mean': ${this.opts['with_mean'] ?? undefined}, 'with_std': ${\n      this.opts['with_std'] ?? undefined\n    }}\n\nctor_StandardScaler = {k: v for k, v in ctor_StandardScaler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeStandardScaler[${this.id}] = StandardScaler(**ctor_StandardScaler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeStandardScaler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the mean and std to be used for later scaling.\n   */\n  async fit(opts: {\n    /**\n      The data used to compute the mean and standard deviation used for later scaling along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n\n    /**\n      Individual weights for each sample.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_StandardScaler_fit = {k: v for k, v in pms_StandardScaler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_fit = bridgeStandardScaler[${this.id}].fit(**pms_StandardScaler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_fit.tolist() if hasattr(res_StandardScaler_fit, 'tolist') else res_StandardScaler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_StandardScaler_fit_transform = {k: v for k, v in pms_StandardScaler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_fit_transform = bridgeStandardScaler[${this.id}].fit_transform(**pms_StandardScaler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_fit_transform.tolist() if hasattr(res_StandardScaler_fit_transform, 'tolist') else res_StandardScaler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_StandardScaler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_StandardScaler_get_feature_names_out = {k: v for k, v in pms_StandardScaler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_get_feature_names_out = bridgeStandardScaler[${this.id}].get_feature_names_out(**pms_StandardScaler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_get_feature_names_out.tolist() if hasattr(res_StandardScaler_get_feature_names_out, 'tolist') else res_StandardScaler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_StandardScaler_get_metadata_routing = {k: v for k, v in pms_StandardScaler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_get_metadata_routing = bridgeStandardScaler[${this.id}].get_metadata_routing(**pms_StandardScaler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_get_metadata_routing.tolist() if hasattr(res_StandardScaler_get_metadata_routing, 'tolist') else res_StandardScaler_get_metadata_routing`\n  }\n\n  /**\n    Scale back the data to the original representation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The data used to scale along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Copy the input X or not.\n     */\n    copy?: boolean\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_StandardScaler_inverse_transform = {k: v for k, v in pms_StandardScaler_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_inverse_transform = bridgeStandardScaler[${this.id}].inverse_transform(**pms_StandardScaler_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_inverse_transform.tolist() if hasattr(res_StandardScaler_inverse_transform, 'tolist') else res_StandardScaler_inverse_transform`\n  }\n\n  /**\n    Online computation of mean and std on X for later scaling.\n\n    All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.StandardScaler.fit \"sklearn.preprocessing.StandardScaler.fit\") is not feasible due to very large number of `n\\_samples` or because X is read from a continuous stream.\n\n    The algorithm for incremental mean and std is given in Equation 1.5a,b in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. “Algorithms for computing the sample variance: Analysis and recommendations.” The American Statistician 37.3 (1983): 242-247:\n   */\n  async partial_fit(opts: {\n    /**\n      The data used to compute the mean and standard deviation used for later scaling along the features axis.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n\n    /**\n      Individual weights for each sample.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_StandardScaler_partial_fit = {k: v for k, v in pms_StandardScaler_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_partial_fit = bridgeStandardScaler[${this.id}].partial_fit(**pms_StandardScaler_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_partial_fit.tolist() if hasattr(res_StandardScaler_partial_fit, 'tolist') else res_StandardScaler_partial_fit`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_StandardScaler_set_fit_request = {k: v for k, v in pms_StandardScaler_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_set_fit_request = bridgeStandardScaler[${this.id}].set_fit_request(**pms_StandardScaler_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_set_fit_request.tolist() if hasattr(res_StandardScaler_set_fit_request, 'tolist') else res_StandardScaler_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `inverse\\_transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_inverse_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `inverse\\_transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before set_inverse_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_StandardScaler_set_inverse_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_StandardScaler_set_inverse_transform_request = {k: v for k, v in pms_StandardScaler_set_inverse_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_set_inverse_transform_request = bridgeStandardScaler[${this.id}].set_inverse_transform_request(**pms_StandardScaler_set_inverse_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_set_inverse_transform_request.tolist() if hasattr(res_StandardScaler_set_inverse_transform_request, 'tolist') else res_StandardScaler_set_inverse_transform_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_StandardScaler_set_output = {k: v for k, v in pms_StandardScaler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_set_output = bridgeStandardScaler[${this.id}].set_output(**pms_StandardScaler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_set_output.tolist() if hasattr(res_StandardScaler_set_output, 'tolist') else res_StandardScaler_set_output`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_StandardScaler_set_partial_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_StandardScaler_set_partial_fit_request = {k: v for k, v in pms_StandardScaler_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_set_partial_fit_request = bridgeStandardScaler[${this.id}].set_partial_fit_request(**pms_StandardScaler_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_set_partial_fit_request.tolist() if hasattr(res_StandardScaler_set_partial_fit_request, 'tolist') else res_StandardScaler_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before set_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_set_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_StandardScaler_set_transform_request = {k: v for k, v in pms_StandardScaler_set_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_set_transform_request = bridgeStandardScaler[${this.id}].set_transform_request(**pms_StandardScaler_set_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_set_transform_request.tolist() if hasattr(res_StandardScaler_set_transform_request, 'tolist') else res_StandardScaler_set_transform_request`\n  }\n\n  /**\n    Perform standardization by centering and scaling.\n   */\n  async transform(opts: {\n    /**\n      The data used to scale along the features axis.\n     */\n    X?: SparseMatrix[]\n\n    /**\n      Copy the input X or not.\n     */\n    copy?: boolean\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_StandardScaler_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_StandardScaler_transform = {k: v for k, v in pms_StandardScaler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_StandardScaler_transform = bridgeStandardScaler[${this.id}].transform(**pms_StandardScaler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_StandardScaler_transform.tolist() if hasattr(res_StandardScaler_transform, 'tolist') else res_StandardScaler_transform`\n  }\n\n  /**\n    Per feature relative scaling of the data to achieve zero mean and unit variance. Generally this is calculated using `np.sqrt(var\\_)`. If a variance is zero, we can’t achieve unit variance, and the data is left as-is, giving a scaling factor of 1. `scale\\_` is equal to `undefined` when `with\\_std=False`.\n   */\n  get scale_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before accessing scale_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_scale_ = bridgeStandardScaler[${this.id}].scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_scale_.tolist() if hasattr(attr_StandardScaler_scale_, 'tolist') else attr_StandardScaler_scale_`\n    })()\n  }\n\n  /**\n    The mean value for each feature in the training set. Equal to `undefined` when `with\\_mean=False` and `with\\_std=False`.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_mean_ = bridgeStandardScaler[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_mean_.tolist() if hasattr(attr_StandardScaler_mean_, 'tolist') else attr_StandardScaler_mean_`\n    })()\n  }\n\n  /**\n    The variance for each feature in the training set. Used to compute `scale\\_`. Equal to `undefined` when `with\\_mean=False` and `with\\_std=False`.\n   */\n  get var_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('StandardScaler must call init() before accessing var_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_var_ = bridgeStandardScaler[${this.id}].var_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_var_.tolist() if hasattr(attr_StandardScaler_var_, 'tolist') else attr_StandardScaler_var_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_n_features_in_ = bridgeStandardScaler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_n_features_in_.tolist() if hasattr(attr_StandardScaler_n_features_in_, 'tolist') else attr_StandardScaler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_feature_names_in_ = bridgeStandardScaler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_feature_names_in_.tolist() if hasattr(attr_StandardScaler_feature_names_in_, 'tolist') else attr_StandardScaler_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of samples processed by the estimator for each feature. If there are no missing samples, the `n\\_samples\\_seen` will be an integer, otherwise it will be an array of dtype int. If `sample\\_weights` are used it will be a float (if no missing data) or an array of dtype float that sums the weights seen so far. Will be reset on new calls to fit, but increments across `partial\\_fit` calls.\n   */\n  get n_samples_seen_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This StandardScaler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'StandardScaler must call init() before accessing n_samples_seen_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_StandardScaler_n_samples_seen_ = bridgeStandardScaler[${this.id}].n_samples_seen_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_StandardScaler_n_samples_seen_.tolist() if hasattr(attr_StandardScaler_n_samples_seen_, 'tolist') else attr_StandardScaler_n_samples_seen_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Target Encoder for regression and classification targets.\n\n  Each category is encoded based on a shrunk estimate of the average target values for observations belonging to the category. The encoding scheme mixes the global target mean with the target mean conditioned on the value of the category. [\\[MIC\\]](#rf862141e5a0c-mic)\n\n  [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder \"sklearn.preprocessing.TargetEncoder\") considers missing values, such as `np.nan` or `undefined`, as another category and encodes them like any other category. Categories that are not seen during [`fit`](#sklearn.preprocessing.TargetEncoder.fit \"sklearn.preprocessing.TargetEncoder.fit\") are encoded with the target mean, i.e. `target\\_mean\\_`.\n\n  For a demo on the importance of the `TargetEncoder` internal cross-fitting, see ref:`sphx\\_glr\\_auto\\_examples\\_preprocessing\\_plot\\_target\\_encoder\\_cross\\_val.py`. For a comparison of different encoders, refer to [Comparing Target Encoder with Other Encoders](../../auto_examples/preprocessing/plot_target_encoder.html#sphx-glr-auto-examples-preprocessing-plot-target-encoder-py). Read more in the [User Guide](../preprocessing.html#target-encoder).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.TargetEncoder.html)\n */\nexport class TargetEncoder {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Categories (unique values) per feature:\n\n      @defaultValue `'auto'`\n     */\n    categories?: 'auto'\n\n    /**\n      Type of target.\n\n      @defaultValue `'auto'`\n     */\n    target_type?: 'auto' | 'continuous' | 'binary'\n\n    /**\n      The amount of mixing of the target mean conditioned on the value of the category with the global target mean. A larger `smooth` value will put more weight on the global target mean. If `\"auto\"`, then `smooth` is set to an empirical Bayes estimate.\n\n      @defaultValue `'auto'`\n     */\n    smooth?: 'auto' | number\n\n    /**\n      Determines the number of folds in the [cross fitting](../../glossary.html#term-0) strategy used in [`fit\\_transform`](#sklearn.preprocessing.TargetEncoder.fit_transform \"sklearn.preprocessing.TargetEncoder.fit_transform\"). For classification targets, `StratifiedKFold` is used and for continuous targets, `KFold` is used.\n\n      @defaultValue `5`\n     */\n    cv?: number\n\n    /**\n      Whether to shuffle the data in [`fit\\_transform`](#sklearn.preprocessing.TargetEncoder.fit_transform \"sklearn.preprocessing.TargetEncoder.fit_transform\") before splitting into folds. Note that the samples within each split will not be shuffled.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      When `shuffle` is `true`, `random\\_state` affects the ordering of the indices, which controls the randomness of each fold. Otherwise, this parameter has no effect. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `TargetEncoder${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('TargetEncoder.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import TargetEncoder\ntry: bridgeTargetEncoder\nexcept NameError: bridgeTargetEncoder = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_TargetEncoder = {'categories': np.array(${\n      this.opts['categories'] ?? undefined\n    }) if ${this.opts['categories'] !== undefined} else None, 'target_type': ${\n      this.opts['target_type'] ?? undefined\n    }, 'smooth': ${this.opts['smooth'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_TargetEncoder = {k: v for k, v in ctor_TargetEncoder.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeTargetEncoder[${this.id}] = TargetEncoder(**ctor_TargetEncoder)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTargetEncoder[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder \"sklearn.preprocessing.TargetEncoder\") to X and y.\n   */\n  async fit(opts: {\n    /**\n      The data to determine the categories of each feature.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target data used to encode the categories.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TargetEncoder must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TargetEncoder_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_TargetEncoder_fit = {k: v for k, v in pms_TargetEncoder_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_fit = bridgeTargetEncoder[${this.id}].fit(**pms_TargetEncoder_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_fit.tolist() if hasattr(res_TargetEncoder_fit, 'tolist') else res_TargetEncoder_fit`\n  }\n\n  /**\n    Fit [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder \"sklearn.preprocessing.TargetEncoder\") and transform X with the target encoding.\n   */\n  async fit_transform(opts: {\n    /**\n      The data to determine the categories of each feature.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target data used to encode the categories.\n     */\n    y?: ArrayLike\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TargetEncoder must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TargetEncoder_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_TargetEncoder_fit_transform = {k: v for k, v in pms_TargetEncoder_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_fit_transform = bridgeTargetEncoder[${this.id}].fit_transform(**pms_TargetEncoder_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_fit_transform.tolist() if hasattr(res_TargetEncoder_fit_transform, 'tolist') else res_TargetEncoder_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TargetEncoder_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_TargetEncoder_get_feature_names_out = {k: v for k, v in pms_TargetEncoder_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_get_feature_names_out = bridgeTargetEncoder[${this.id}].get_feature_names_out(**pms_TargetEncoder_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_get_feature_names_out.tolist() if hasattr(res_TargetEncoder_get_feature_names_out, 'tolist') else res_TargetEncoder_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_TargetEncoder_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_TargetEncoder_get_metadata_routing = {k: v for k, v in pms_TargetEncoder_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_get_metadata_routing = bridgeTargetEncoder[${this.id}].get_metadata_routing(**pms_TargetEncoder_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_get_metadata_routing.tolist() if hasattr(res_TargetEncoder_get_metadata_routing, 'tolist') else res_TargetEncoder_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TargetEncoder must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TargetEncoder_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_TargetEncoder_set_output = {k: v for k, v in pms_TargetEncoder_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_set_output = bridgeTargetEncoder[${this.id}].set_output(**pms_TargetEncoder_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_set_output.tolist() if hasattr(res_TargetEncoder_set_output, 'tolist') else res_TargetEncoder_set_output`\n  }\n\n  /**\n    Transform X with the target encoding.\n   */\n  async transform(opts: {\n    /**\n      The data to determine the categories of each feature.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TargetEncoder must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TargetEncoder_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_TargetEncoder_transform = {k: v for k, v in pms_TargetEncoder_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TargetEncoder_transform = bridgeTargetEncoder[${this.id}].transform(**pms_TargetEncoder_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TargetEncoder_transform.tolist() if hasattr(res_TargetEncoder_transform, 'tolist') else res_TargetEncoder_transform`\n  }\n\n  /**\n    Encodings learnt on all of `X`. For feature `i`, `encodings\\_\\[i\\]` are the encodings matching the categories listed in `categories\\_\\[i\\]`.\n   */\n  get encodings_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing encodings_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_encodings_ = bridgeTargetEncoder[${this.id}].encodings_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_encodings_.tolist() if hasattr(attr_TargetEncoder_encodings_, 'tolist') else attr_TargetEncoder_encodings_`\n    })()\n  }\n\n  /**\n    The categories of each feature determined during fitting or specified in `categories` (in order of the features in `X` and corresponding with the output of [`transform`](#sklearn.preprocessing.TargetEncoder.transform \"sklearn.preprocessing.TargetEncoder.transform\")).\n   */\n  get categories_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing categories_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_categories_ = bridgeTargetEncoder[${this.id}].categories_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_categories_.tolist() if hasattr(attr_TargetEncoder_categories_, 'tolist') else attr_TargetEncoder_categories_`\n    })()\n  }\n\n  /**\n    Type of target.\n   */\n  get target_type_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing target_type_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_target_type_ = bridgeTargetEncoder[${this.id}].target_type_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_target_type_.tolist() if hasattr(attr_TargetEncoder_target_type_, 'tolist') else attr_TargetEncoder_target_type_`\n    })()\n  }\n\n  /**\n    The overall mean of the target. This value is only used in [`transform`](#sklearn.preprocessing.TargetEncoder.transform \"sklearn.preprocessing.TargetEncoder.transform\") to encode categories.\n   */\n  get target_mean_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing target_mean_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_target_mean_ = bridgeTargetEncoder[${this.id}].target_mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_target_mean_.tolist() if hasattr(attr_TargetEncoder_target_mean_, 'tolist') else attr_TargetEncoder_target_mean_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_n_features_in_ = bridgeTargetEncoder[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_n_features_in_.tolist() if hasattr(attr_TargetEncoder_n_features_in_, 'tolist') else attr_TargetEncoder_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TargetEncoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TargetEncoder must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TargetEncoder_feature_names_in_ = bridgeTargetEncoder[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TargetEncoder_feature_names_in_.tolist() if hasattr(attr_TargetEncoder_feature_names_in_, 'tolist') else attr_TargetEncoder_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}