// src/generated/preprocessing/Binarizer.ts
import crypto from "node:crypto";
var Binarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Binarizer${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Binarizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import Binarizer
try: bridgeBinarizer
except NameError: bridgeBinarizer = {}
`;
    await this._py.ex`ctor_Binarizer = {'threshold': ${this.opts["threshold"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Binarizer = {k: v for k, v in ctor_Binarizer.items() if v is not None}`;
    await this._py.ex`bridgeBinarizer[${this.id}] = Binarizer(**ctor_Binarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimator’s parameters.
  
      This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before fit()");
    }
    await this._py.ex`pms_Binarizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Binarizer_fit = {k: v for k, v in pms_Binarizer_fit.items() if v is not None}`;
    await this._py.ex`res_Binarizer_fit = bridgeBinarizer[${this.id}].fit(**pms_Binarizer_fit)`;
    return this._py`res_Binarizer_fit.tolist() if hasattr(res_Binarizer_fit, 'tolist') else res_Binarizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_Binarizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Binarizer_fit_transform = {k: v for k, v in pms_Binarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Binarizer_fit_transform = bridgeBinarizer[${this.id}].fit_transform(**pms_Binarizer_fit_transform)`;
    return this._py`res_Binarizer_fit_transform.tolist() if hasattr(res_Binarizer_fit_transform, 'tolist') else res_Binarizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Binarizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Binarizer_get_feature_names_out = {k: v for k, v in pms_Binarizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Binarizer_get_feature_names_out = bridgeBinarizer[${this.id}].get_feature_names_out(**pms_Binarizer_get_feature_names_out)`;
    return this._py`res_Binarizer_get_feature_names_out.tolist() if hasattr(res_Binarizer_get_feature_names_out, 'tolist') else res_Binarizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Binarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Binarizer_get_metadata_routing = {k: v for k, v in pms_Binarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Binarizer_get_metadata_routing = bridgeBinarizer[${this.id}].get_metadata_routing(**pms_Binarizer_get_metadata_routing)`;
    return this._py`res_Binarizer_get_metadata_routing.tolist() if hasattr(res_Binarizer_get_metadata_routing, 'tolist') else res_Binarizer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before set_output()");
    }
    await this._py.ex`pms_Binarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Binarizer_set_output = {k: v for k, v in pms_Binarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_Binarizer_set_output = bridgeBinarizer[${this.id}].set_output(**pms_Binarizer_set_output)`;
    return this._py`res_Binarizer_set_output.tolist() if hasattr(res_Binarizer_set_output, 'tolist') else res_Binarizer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_Binarizer_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_Binarizer_set_transform_request = {k: v for k, v in pms_Binarizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_Binarizer_set_transform_request = bridgeBinarizer[${this.id}].set_transform_request(**pms_Binarizer_set_transform_request)`;
    return this._py`res_Binarizer_set_transform_request.tolist() if hasattr(res_Binarizer_set_transform_request, 'tolist') else res_Binarizer_set_transform_request`;
  }
  /**
    Binarize each element of X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before transform()");
    }
    await this._py.ex`pms_Binarizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_Binarizer_transform = {k: v for k, v in pms_Binarizer_transform.items() if v is not None}`;
    await this._py.ex`res_Binarizer_transform = bridgeBinarizer[${this.id}].transform(**pms_Binarizer_transform)`;
    return this._py`res_Binarizer_transform.tolist() if hasattr(res_Binarizer_transform, 'tolist') else res_Binarizer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Binarizer_n_features_in_ = bridgeBinarizer[${this.id}].n_features_in_`;
      return this._py`attr_Binarizer_n_features_in_.tolist() if hasattr(attr_Binarizer_n_features_in_, 'tolist') else attr_Binarizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Binarizer_feature_names_in_ = bridgeBinarizer[${this.id}].feature_names_in_`;
      return this._py`attr_Binarizer_feature_names_in_.tolist() if hasattr(attr_Binarizer_feature_names_in_, 'tolist') else attr_Binarizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/FunctionTransformer.ts
import crypto2 from "node:crypto";
var FunctionTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FunctionTransformer${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "FunctionTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import FunctionTransformer
try: bridgeFunctionTransformer
except NameError: bridgeFunctionTransformer = {}
`;
    await this._py.ex`ctor_FunctionTransformer = {'func': ${this.opts["func"] ?? void 0}, 'inverse_func': ${this.opts["inverse_func"] ?? void 0}, 'validate': ${this.opts["validate"] ?? void 0}, 'accept_sparse': ${this.opts["accept_sparse"] ?? void 0}, 'check_inverse': ${this.opts["check_inverse"] ?? void 0}, 'feature_names_out': ${this.opts["feature_names_out"] ?? void 0}, 'kw_args': ${this.opts["kw_args"] ?? void 0}, 'inv_kw_args': ${this.opts["inv_kw_args"] ?? void 0}}

ctor_FunctionTransformer = {k: v for k, v in ctor_FunctionTransformer.items() if v is not None}`;
    await this._py.ex`bridgeFunctionTransformer[${this.id}] = FunctionTransformer(**ctor_FunctionTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFunctionTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit transformer by checking X.
  
      If `validate` is `true`, `X` will be checked.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FunctionTransformer must call init() before fit()");
    }
    await this._py.ex`pms_FunctionTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FunctionTransformer_fit = {k: v for k, v in pms_FunctionTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_fit = bridgeFunctionTransformer[${this.id}].fit(**pms_FunctionTransformer_fit)`;
    return this._py`res_FunctionTransformer_fit.tolist() if hasattr(res_FunctionTransformer_fit, 'tolist') else res_FunctionTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FunctionTransformer_fit_transform = {k: v for k, v in pms_FunctionTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_fit_transform = bridgeFunctionTransformer[${this.id}].fit_transform(**pms_FunctionTransformer_fit_transform)`;
    return this._py`res_FunctionTransformer_fit_transform.tolist() if hasattr(res_FunctionTransformer_fit_transform, 'tolist') else res_FunctionTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      This method is only defined if `feature\_names\_out` is not `undefined`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FunctionTransformer_get_feature_names_out = {k: v for k, v in pms_FunctionTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_get_feature_names_out = bridgeFunctionTransformer[${this.id}].get_feature_names_out(**pms_FunctionTransformer_get_feature_names_out)`;
    return this._py`res_FunctionTransformer_get_feature_names_out.tolist() if hasattr(res_FunctionTransformer_get_feature_names_out, 'tolist') else res_FunctionTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FunctionTransformer_get_metadata_routing = {k: v for k, v in pms_FunctionTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_get_metadata_routing = bridgeFunctionTransformer[${this.id}].get_metadata_routing(**pms_FunctionTransformer_get_metadata_routing)`;
    return this._py`res_FunctionTransformer_get_metadata_routing.tolist() if hasattr(res_FunctionTransformer_get_metadata_routing, 'tolist') else res_FunctionTransformer_get_metadata_routing`;
  }
  /**
    Transform X using the inverse function.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FunctionTransformer_inverse_transform = {k: v for k, v in pms_FunctionTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_inverse_transform = bridgeFunctionTransformer[${this.id}].inverse_transform(**pms_FunctionTransformer_inverse_transform)`;
    return this._py`res_FunctionTransformer_inverse_transform.tolist() if hasattr(res_FunctionTransformer_inverse_transform, 'tolist') else res_FunctionTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FunctionTransformer_set_output = {k: v for k, v in pms_FunctionTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_set_output = bridgeFunctionTransformer[${this.id}].set_output(**pms_FunctionTransformer_set_output)`;
    return this._py`res_FunctionTransformer_set_output.tolist() if hasattr(res_FunctionTransformer_set_output, 'tolist') else res_FunctionTransformer_set_output`;
  }
  /**
    Transform X using the forward function.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FunctionTransformer must call init() before transform()");
    }
    await this._py.ex`pms_FunctionTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FunctionTransformer_transform = {k: v for k, v in pms_FunctionTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_transform = bridgeFunctionTransformer[${this.id}].transform(**pms_FunctionTransformer_transform)`;
    return this._py`res_FunctionTransformer_transform.tolist() if hasattr(res_FunctionTransformer_transform, 'tolist') else res_FunctionTransformer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FunctionTransformer_n_features_in_ = bridgeFunctionTransformer[${this.id}].n_features_in_`;
      return this._py`attr_FunctionTransformer_n_features_in_.tolist() if hasattr(attr_FunctionTransformer_n_features_in_, 'tolist') else attr_FunctionTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FunctionTransformer_feature_names_in_ = bridgeFunctionTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_FunctionTransformer_feature_names_in_.tolist() if hasattr(attr_FunctionTransformer_feature_names_in_, 'tolist') else attr_FunctionTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/KBinsDiscretizer.ts
import crypto3 from "node:crypto";
var KBinsDiscretizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KBinsDiscretizer${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KBinsDiscretizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import KBinsDiscretizer
try: bridgeKBinsDiscretizer
except NameError: bridgeKBinsDiscretizer = {}
`;
    await this._py.ex`ctor_KBinsDiscretizer = {'n_bins': np.array(${this.opts["n_bins"] ?? void 0}) if ${this.opts["n_bins"] !== void 0} else None, 'encode': ${this.opts["encode"] ?? void 0}, 'strategy': ${this.opts["strategy"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_KBinsDiscretizer = {k: v for k, v in ctor_KBinsDiscretizer.items() if v is not None}`;
    await this._py.ex`bridgeKBinsDiscretizer[${this.id}] = KBinsDiscretizer(**ctor_KBinsDiscretizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKBinsDiscretizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the estimator.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before fit()");
    }
    await this._py.ex`pms_KBinsDiscretizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KBinsDiscretizer_fit = {k: v for k, v in pms_KBinsDiscretizer_fit.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_fit = bridgeKBinsDiscretizer[${this.id}].fit(**pms_KBinsDiscretizer_fit)`;
    return this._py`res_KBinsDiscretizer_fit.tolist() if hasattr(res_KBinsDiscretizer_fit, 'tolist') else res_KBinsDiscretizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_KBinsDiscretizer_fit_transform = {k: v for k, v in pms_KBinsDiscretizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_fit_transform = bridgeKBinsDiscretizer[${this.id}].fit_transform(**pms_KBinsDiscretizer_fit_transform)`;
    return this._py`res_KBinsDiscretizer_fit_transform.tolist() if hasattr(res_KBinsDiscretizer_fit_transform, 'tolist') else res_KBinsDiscretizer_fit_transform`;
  }
  /**
    Get output feature names.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KBinsDiscretizer_get_feature_names_out = {k: v for k, v in pms_KBinsDiscretizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_get_feature_names_out = bridgeKBinsDiscretizer[${this.id}].get_feature_names_out(**pms_KBinsDiscretizer_get_feature_names_out)`;
    return this._py`res_KBinsDiscretizer_get_feature_names_out.tolist() if hasattr(res_KBinsDiscretizer_get_feature_names_out, 'tolist') else res_KBinsDiscretizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KBinsDiscretizer_get_metadata_routing = {k: v for k, v in pms_KBinsDiscretizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_get_metadata_routing = bridgeKBinsDiscretizer[${this.id}].get_metadata_routing(**pms_KBinsDiscretizer_get_metadata_routing)`;
    return this._py`res_KBinsDiscretizer_get_metadata_routing.tolist() if hasattr(res_KBinsDiscretizer_get_metadata_routing, 'tolist') else res_KBinsDiscretizer_get_metadata_routing`;
  }
  /**
      Transform discretized data back to original feature space.
  
      Note that this function does not regenerate the original data due to discretization rounding.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_KBinsDiscretizer_inverse_transform = {k: v for k, v in pms_KBinsDiscretizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_inverse_transform = bridgeKBinsDiscretizer[${this.id}].inverse_transform(**pms_KBinsDiscretizer_inverse_transform)`;
    return this._py`res_KBinsDiscretizer_inverse_transform.tolist() if hasattr(res_KBinsDiscretizer_inverse_transform, 'tolist') else res_KBinsDiscretizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KBinsDiscretizer_set_fit_request = {k: v for k, v in pms_KBinsDiscretizer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_set_fit_request = bridgeKBinsDiscretizer[${this.id}].set_fit_request(**pms_KBinsDiscretizer_set_fit_request)`;
    return this._py`res_KBinsDiscretizer_set_fit_request.tolist() if hasattr(res_KBinsDiscretizer_set_fit_request, 'tolist') else res_KBinsDiscretizer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before set_output()");
    }
    await this._py.ex`pms_KBinsDiscretizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KBinsDiscretizer_set_output = {k: v for k, v in pms_KBinsDiscretizer_set_output.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_set_output = bridgeKBinsDiscretizer[${this.id}].set_output(**pms_KBinsDiscretizer_set_output)`;
    return this._py`res_KBinsDiscretizer_set_output.tolist() if hasattr(res_KBinsDiscretizer_set_output, 'tolist') else res_KBinsDiscretizer_set_output`;
  }
  /**
    Discretize the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before transform()");
    }
    await this._py.ex`pms_KBinsDiscretizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KBinsDiscretizer_transform = {k: v for k, v in pms_KBinsDiscretizer_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_transform = bridgeKBinsDiscretizer[${this.id}].transform(**pms_KBinsDiscretizer_transform)`;
    return this._py`res_KBinsDiscretizer_transform.tolist() if hasattr(res_KBinsDiscretizer_transform, 'tolist') else res_KBinsDiscretizer_transform`;
  }
  /**
    The edges of each bin. Contain arrays of varying shapes `(n\_bins\_, )` Ignored features will have empty arrays.
   */
  get bin_edges_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing bin_edges_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_bin_edges_ = bridgeKBinsDiscretizer[${this.id}].bin_edges_`;
      return this._py`attr_KBinsDiscretizer_bin_edges_.tolist() if hasattr(attr_KBinsDiscretizer_bin_edges_, 'tolist') else attr_KBinsDiscretizer_bin_edges_`;
    })();
  }
  /**
    Number of bins per feature. Bins whose width are too small (i.e., <= 1e-8) are removed with a warning.
   */
  get n_bins_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing n_bins_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_n_bins_ = bridgeKBinsDiscretizer[${this.id}].n_bins_`;
      return this._py`attr_KBinsDiscretizer_n_bins_.tolist() if hasattr(attr_KBinsDiscretizer_n_bins_, 'tolist') else attr_KBinsDiscretizer_n_bins_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_n_features_in_ = bridgeKBinsDiscretizer[${this.id}].n_features_in_`;
      return this._py`attr_KBinsDiscretizer_n_features_in_.tolist() if hasattr(attr_KBinsDiscretizer_n_features_in_, 'tolist') else attr_KBinsDiscretizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_feature_names_in_ = bridgeKBinsDiscretizer[${this.id}].feature_names_in_`;
      return this._py`attr_KBinsDiscretizer_feature_names_in_.tolist() if hasattr(attr_KBinsDiscretizer_feature_names_in_, 'tolist') else attr_KBinsDiscretizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/KernelCenterer.ts
import crypto4 from "node:crypto";
var KernelCenterer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelCenterer${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelCenterer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import KernelCenterer
try: bridgeKernelCenterer
except NameError: bridgeKernelCenterer = {}
`;
    await this._py.ex`ctor_KernelCenterer = {'K_fit_rows_': np.array(${this.opts["K_fit_rows_"] ?? void 0}) if ${this.opts["K_fit_rows_"] !== void 0} else None, 'K_fit_all_': ${this.opts["K_fit_all_"] ?? void 0}, 'n_features_in_': ${this.opts["n_features_in_"] ?? void 0}, 'feature_names_in_': np.array(${this.opts["feature_names_in_"] ?? void 0}) if ${this.opts["feature_names_in_"] !== void 0} else None}

ctor_KernelCenterer = {k: v for k, v in ctor_KernelCenterer.items() if v is not None}`;
    await this._py.ex`bridgeKernelCenterer[${this.id}] = KernelCenterer(**ctor_KernelCenterer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelCenterer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit KernelCenterer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before fit()");
    }
    await this._py.ex`pms_KernelCenterer_fit = {'K': np.array(${opts["K"] ?? void 0}) if ${opts["K"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelCenterer_fit = {k: v for k, v in pms_KernelCenterer_fit.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_fit = bridgeKernelCenterer[${this.id}].fit(**pms_KernelCenterer_fit)`;
    return this._py`res_KernelCenterer_fit.tolist() if hasattr(res_KernelCenterer_fit, 'tolist') else res_KernelCenterer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before fit_transform()");
    }
    await this._py.ex`pms_KernelCenterer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_KernelCenterer_fit_transform = {k: v for k, v in pms_KernelCenterer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_fit_transform = bridgeKernelCenterer[${this.id}].fit_transform(**pms_KernelCenterer_fit_transform)`;
    return this._py`res_KernelCenterer_fit_transform.tolist() if hasattr(res_KernelCenterer_fit_transform, 'tolist') else res_KernelCenterer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KernelCenterer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KernelCenterer_get_feature_names_out = {k: v for k, v in pms_KernelCenterer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_get_feature_names_out = bridgeKernelCenterer[${this.id}].get_feature_names_out(**pms_KernelCenterer_get_feature_names_out)`;
    return this._py`res_KernelCenterer_get_feature_names_out.tolist() if hasattr(res_KernelCenterer_get_feature_names_out, 'tolist') else res_KernelCenterer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelCenterer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelCenterer_get_metadata_routing = {k: v for k, v in pms_KernelCenterer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_get_metadata_routing = bridgeKernelCenterer[${this.id}].get_metadata_routing(**pms_KernelCenterer_get_metadata_routing)`;
    return this._py`res_KernelCenterer_get_metadata_routing.tolist() if hasattr(res_KernelCenterer_get_metadata_routing, 'tolist') else res_KernelCenterer_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_KernelCenterer_set_fit_request = {'K': ${opts["K"] ?? void 0}}

pms_KernelCenterer_set_fit_request = {k: v for k, v in pms_KernelCenterer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_fit_request = bridgeKernelCenterer[${this.id}].set_fit_request(**pms_KernelCenterer_set_fit_request)`;
    return this._py`res_KernelCenterer_set_fit_request.tolist() if hasattr(res_KernelCenterer_set_fit_request, 'tolist') else res_KernelCenterer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before set_output()");
    }
    await this._py.ex`pms_KernelCenterer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KernelCenterer_set_output = {k: v for k, v in pms_KernelCenterer_set_output.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_output = bridgeKernelCenterer[${this.id}].set_output(**pms_KernelCenterer_set_output)`;
    return this._py`res_KernelCenterer_set_output.tolist() if hasattr(res_KernelCenterer_set_output, 'tolist') else res_KernelCenterer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_KernelCenterer_set_transform_request = {'K': ${opts["K"] ?? void 0}, 'copy': ${opts["copy"] ?? void 0}}

pms_KernelCenterer_set_transform_request = {k: v for k, v in pms_KernelCenterer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_transform_request = bridgeKernelCenterer[${this.id}].set_transform_request(**pms_KernelCenterer_set_transform_request)`;
    return this._py`res_KernelCenterer_set_transform_request.tolist() if hasattr(res_KernelCenterer_set_transform_request, 'tolist') else res_KernelCenterer_set_transform_request`;
  }
  /**
    Center kernel matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before transform()");
    }
    await this._py.ex`pms_KernelCenterer_transform = {'K': np.array(${opts["K"] ?? void 0}) if ${opts["K"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_KernelCenterer_transform = {k: v for k, v in pms_KernelCenterer_transform.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_transform = bridgeKernelCenterer[${this.id}].transform(**pms_KernelCenterer_transform)`;
    return this._py`res_KernelCenterer_transform.tolist() if hasattr(res_KernelCenterer_transform, 'tolist') else res_KernelCenterer_transform`;
  }
};

// src/generated/preprocessing/LabelBinarizer.ts
import crypto5 from "node:crypto";
var LabelBinarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelBinarizer${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelBinarizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import LabelBinarizer
try: bridgeLabelBinarizer
except NameError: bridgeLabelBinarizer = {}
`;
    await this._py.ex`ctor_LabelBinarizer = {'neg_label': ${this.opts["neg_label"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_LabelBinarizer = {k: v for k, v in ctor_LabelBinarizer.items() if v is not None}`;
    await this._py.ex`bridgeLabelBinarizer[${this.id}] = LabelBinarizer(**ctor_LabelBinarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit label binarizer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before fit()");
    }
    await this._py.ex`pms_LabelBinarizer_fit = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_fit = {k: v for k, v in pms_LabelBinarizer_fit.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_fit = bridgeLabelBinarizer[${this.id}].fit(**pms_LabelBinarizer_fit)`;
    return this._py`res_LabelBinarizer_fit.tolist() if hasattr(res_LabelBinarizer_fit, 'tolist') else res_LabelBinarizer_fit`;
  }
  /**
      Fit label binarizer/transform multi-class labels to binary labels.
  
      The output of transform is sometimes referred to as the 1-of-K coding scheme.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_LabelBinarizer_fit_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_fit_transform = {k: v for k, v in pms_LabelBinarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_fit_transform = bridgeLabelBinarizer[${this.id}].fit_transform(**pms_LabelBinarizer_fit_transform)`;
    return this._py`res_LabelBinarizer_fit_transform.tolist() if hasattr(res_LabelBinarizer_fit_transform, 'tolist') else res_LabelBinarizer_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelBinarizer_get_metadata_routing = {k: v for k, v in pms_LabelBinarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_get_metadata_routing = bridgeLabelBinarizer[${this.id}].get_metadata_routing(**pms_LabelBinarizer_get_metadata_routing)`;
    return this._py`res_LabelBinarizer_get_metadata_routing.tolist() if hasattr(res_LabelBinarizer_get_metadata_routing, 'tolist') else res_LabelBinarizer_get_metadata_routing`;
  }
  /**
    Transform binary labels back to multi-class labels.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_inverse_transform = {'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'threshold': ${opts["threshold"] ?? void 0}}

pms_LabelBinarizer_inverse_transform = {k: v for k, v in pms_LabelBinarizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_inverse_transform = bridgeLabelBinarizer[${this.id}].inverse_transform(**pms_LabelBinarizer_inverse_transform)`;
    return this._py`res_LabelBinarizer_inverse_transform.tolist() if hasattr(res_LabelBinarizer_inverse_transform, 'tolist') else res_LabelBinarizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_set_inverse_transform_request = {'threshold': ${opts["threshold"] ?? void 0}}

pms_LabelBinarizer_set_inverse_transform_request = {k: v for k, v in pms_LabelBinarizer_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_set_inverse_transform_request = bridgeLabelBinarizer[${this.id}].set_inverse_transform_request(**pms_LabelBinarizer_set_inverse_transform_request)`;
    return this._py`res_LabelBinarizer_set_inverse_transform_request.tolist() if hasattr(res_LabelBinarizer_set_inverse_transform_request, 'tolist') else res_LabelBinarizer_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before set_output()");
    }
    await this._py.ex`pms_LabelBinarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LabelBinarizer_set_output = {k: v for k, v in pms_LabelBinarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_set_output = bridgeLabelBinarizer[${this.id}].set_output(**pms_LabelBinarizer_set_output)`;
    return this._py`res_LabelBinarizer_set_output.tolist() if hasattr(res_LabelBinarizer_set_output, 'tolist') else res_LabelBinarizer_set_output`;
  }
  /**
      Transform multi-class labels to binary labels.
  
      The output of transform is sometimes referred to by some authors as the 1-of-K coding scheme.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before transform()");
    }
    await this._py.ex`pms_LabelBinarizer_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_transform = {k: v for k, v in pms_LabelBinarizer_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_transform = bridgeLabelBinarizer[${this.id}].transform(**pms_LabelBinarizer_transform)`;
    return this._py`res_LabelBinarizer_transform.tolist() if hasattr(res_LabelBinarizer_transform, 'tolist') else res_LabelBinarizer_transform`;
  }
  /**
    Holds the label for each class.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_classes_ = bridgeLabelBinarizer[${this.id}].classes_`;
      return this._py`attr_LabelBinarizer_classes_.tolist() if hasattr(attr_LabelBinarizer_classes_, 'tolist') else attr_LabelBinarizer_classes_`;
    })();
  }
  /**
    Represents the type of the target data as evaluated by [`type\_of\_target`](sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target "sklearn.utils.multiclass.type_of_target"). Possible type are ‘continuous’, ‘continuous-multioutput’, ‘binary’, ‘multiclass’, ‘multiclass-multioutput’, ‘multilabel-indicator’, and ‘unknown’.
   */
  get y_type_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing y_type_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_y_type_ = bridgeLabelBinarizer[${this.id}].y_type_`;
      return this._py`attr_LabelBinarizer_y_type_.tolist() if hasattr(attr_LabelBinarizer_y_type_, 'tolist') else attr_LabelBinarizer_y_type_`;
    })();
  }
  /**
    `false` otherwise.
   */
  get sparse_input_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing sparse_input_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_sparse_input_ = bridgeLabelBinarizer[${this.id}].sparse_input_`;
      return this._py`attr_LabelBinarizer_sparse_input_.tolist() if hasattr(attr_LabelBinarizer_sparse_input_, 'tolist') else attr_LabelBinarizer_sparse_input_`;
    })();
  }
};

// src/generated/preprocessing/LabelEncoder.ts
import crypto6 from "node:crypto";
var LabelEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelEncoder${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import LabelEncoder
try: bridgeLabelEncoder
except NameError: bridgeLabelEncoder = {}
`;
    await this._py.ex`ctor_LabelEncoder = {'classes_': np.array(${this.opts["classes_"] ?? void 0}) if ${this.opts["classes_"] !== void 0} else None}

ctor_LabelEncoder = {k: v for k, v in ctor_LabelEncoder.items() if v is not None}`;
    await this._py.ex`bridgeLabelEncoder[${this.id}] = LabelEncoder(**ctor_LabelEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit label encoder.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before fit()");
    }
    await this._py.ex`pms_LabelEncoder_fit = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_fit = {k: v for k, v in pms_LabelEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_fit = bridgeLabelEncoder[${this.id}].fit(**pms_LabelEncoder_fit)`;
    return this._py`res_LabelEncoder_fit.tolist() if hasattr(res_LabelEncoder_fit, 'tolist') else res_LabelEncoder_fit`;
  }
  /**
    Fit label encoder and return encoded labels.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_LabelEncoder_fit_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_fit_transform = {k: v for k, v in pms_LabelEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_fit_transform = bridgeLabelEncoder[${this.id}].fit_transform(**pms_LabelEncoder_fit_transform)`;
    return this._py`res_LabelEncoder_fit_transform.tolist() if hasattr(res_LabelEncoder_fit_transform, 'tolist') else res_LabelEncoder_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelEncoder_get_metadata_routing = {k: v for k, v in pms_LabelEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_get_metadata_routing = bridgeLabelEncoder[${this.id}].get_metadata_routing(**pms_LabelEncoder_get_metadata_routing)`;
    return this._py`res_LabelEncoder_get_metadata_routing.tolist() if hasattr(res_LabelEncoder_get_metadata_routing, 'tolist') else res_LabelEncoder_get_metadata_routing`;
  }
  /**
    Transform labels back to original encoding.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_LabelEncoder_inverse_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_inverse_transform = {k: v for k, v in pms_LabelEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_inverse_transform = bridgeLabelEncoder[${this.id}].inverse_transform(**pms_LabelEncoder_inverse_transform)`;
    return this._py`res_LabelEncoder_inverse_transform.tolist() if hasattr(res_LabelEncoder_inverse_transform, 'tolist') else res_LabelEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_LabelEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LabelEncoder_set_output = {k: v for k, v in pms_LabelEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_set_output = bridgeLabelEncoder[${this.id}].set_output(**pms_LabelEncoder_set_output)`;
    return this._py`res_LabelEncoder_set_output.tolist() if hasattr(res_LabelEncoder_set_output, 'tolist') else res_LabelEncoder_set_output`;
  }
  /**
    Transform labels to normalized encoding.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before transform()");
    }
    await this._py.ex`pms_LabelEncoder_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_transform = {k: v for k, v in pms_LabelEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_transform = bridgeLabelEncoder[${this.id}].transform(**pms_LabelEncoder_transform)`;
    return this._py`res_LabelEncoder_transform.tolist() if hasattr(res_LabelEncoder_transform, 'tolist') else res_LabelEncoder_transform`;
  }
};

// src/generated/preprocessing/MaxAbsScaler.ts
import crypto7 from "node:crypto";
var MaxAbsScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MaxAbsScaler${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MaxAbsScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MaxAbsScaler
try: bridgeMaxAbsScaler
except NameError: bridgeMaxAbsScaler = {}
`;
    await this._py.ex`ctor_MaxAbsScaler = {'copy': ${this.opts["copy"] ?? void 0}}

ctor_MaxAbsScaler = {k: v for k, v in ctor_MaxAbsScaler.items() if v is not None}`;
    await this._py.ex`bridgeMaxAbsScaler[${this.id}] = MaxAbsScaler(**ctor_MaxAbsScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMaxAbsScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the maximum absolute value to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before fit()");
    }
    await this._py.ex`pms_MaxAbsScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MaxAbsScaler_fit = {k: v for k, v in pms_MaxAbsScaler_fit.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_fit = bridgeMaxAbsScaler[${this.id}].fit(**pms_MaxAbsScaler_fit)`;
    return this._py`res_MaxAbsScaler_fit.tolist() if hasattr(res_MaxAbsScaler_fit, 'tolist') else res_MaxAbsScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_MaxAbsScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MaxAbsScaler_fit_transform = {k: v for k, v in pms_MaxAbsScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_fit_transform = bridgeMaxAbsScaler[${this.id}].fit_transform(**pms_MaxAbsScaler_fit_transform)`;
    return this._py`res_MaxAbsScaler_fit_transform.tolist() if hasattr(res_MaxAbsScaler_fit_transform, 'tolist') else res_MaxAbsScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MaxAbsScaler_get_feature_names_out = {k: v for k, v in pms_MaxAbsScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_get_feature_names_out = bridgeMaxAbsScaler[${this.id}].get_feature_names_out(**pms_MaxAbsScaler_get_feature_names_out)`;
    return this._py`res_MaxAbsScaler_get_feature_names_out.tolist() if hasattr(res_MaxAbsScaler_get_feature_names_out, 'tolist') else res_MaxAbsScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MaxAbsScaler_get_metadata_routing = {k: v for k, v in pms_MaxAbsScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_get_metadata_routing = bridgeMaxAbsScaler[${this.id}].get_metadata_routing(**pms_MaxAbsScaler_get_metadata_routing)`;
    return this._py`res_MaxAbsScaler_get_metadata_routing.tolist() if hasattr(res_MaxAbsScaler_get_metadata_routing, 'tolist') else res_MaxAbsScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MaxAbsScaler_inverse_transform = {k: v for k, v in pms_MaxAbsScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_inverse_transform = bridgeMaxAbsScaler[${this.id}].inverse_transform(**pms_MaxAbsScaler_inverse_transform)`;
    return this._py`res_MaxAbsScaler_inverse_transform.tolist() if hasattr(res_MaxAbsScaler_inverse_transform, 'tolist') else res_MaxAbsScaler_inverse_transform`;
  }
  /**
      Online computation of max absolute value of X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MaxAbsScaler.fit "sklearn.preprocessing.MaxAbsScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_MaxAbsScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MaxAbsScaler_partial_fit = {k: v for k, v in pms_MaxAbsScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_partial_fit = bridgeMaxAbsScaler[${this.id}].partial_fit(**pms_MaxAbsScaler_partial_fit)`;
    return this._py`res_MaxAbsScaler_partial_fit.tolist() if hasattr(res_MaxAbsScaler_partial_fit, 'tolist') else res_MaxAbsScaler_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before set_output()");
    }
    await this._py.ex`pms_MaxAbsScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MaxAbsScaler_set_output = {k: v for k, v in pms_MaxAbsScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_set_output = bridgeMaxAbsScaler[${this.id}].set_output(**pms_MaxAbsScaler_set_output)`;
    return this._py`res_MaxAbsScaler_set_output.tolist() if hasattr(res_MaxAbsScaler_set_output, 'tolist') else res_MaxAbsScaler_set_output`;
  }
  /**
    Scale the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before transform()");
    }
    await this._py.ex`pms_MaxAbsScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MaxAbsScaler_transform = {k: v for k, v in pms_MaxAbsScaler_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_transform = bridgeMaxAbsScaler[${this.id}].transform(**pms_MaxAbsScaler_transform)`;
    return this._py`res_MaxAbsScaler_transform.tolist() if hasattr(res_MaxAbsScaler_transform, 'tolist') else res_MaxAbsScaler_transform`;
  }
  /**
    Per feature relative scaling of the data.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_scale_ = bridgeMaxAbsScaler[${this.id}].scale_`;
      return this._py`attr_MaxAbsScaler_scale_.tolist() if hasattr(attr_MaxAbsScaler_scale_, 'tolist') else attr_MaxAbsScaler_scale_`;
    })();
  }
  /**
    Per feature maximum absolute value.
   */
  get max_abs_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before accessing max_abs_");
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_max_abs_ = bridgeMaxAbsScaler[${this.id}].max_abs_`;
      return this._py`attr_MaxAbsScaler_max_abs_.tolist() if hasattr(attr_MaxAbsScaler_max_abs_, 'tolist') else attr_MaxAbsScaler_max_abs_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_n_features_in_ = bridgeMaxAbsScaler[${this.id}].n_features_in_`;
      return this._py`attr_MaxAbsScaler_n_features_in_.tolist() if hasattr(attr_MaxAbsScaler_n_features_in_, 'tolist') else attr_MaxAbsScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_feature_names_in_ = bridgeMaxAbsScaler[${this.id}].feature_names_in_`;
      return this._py`attr_MaxAbsScaler_feature_names_in_.tolist() if hasattr(attr_MaxAbsScaler_feature_names_in_, 'tolist') else attr_MaxAbsScaler_feature_names_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_n_samples_seen_ = bridgeMaxAbsScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_MaxAbsScaler_n_samples_seen_.tolist() if hasattr(attr_MaxAbsScaler_n_samples_seen_, 'tolist') else attr_MaxAbsScaler_n_samples_seen_`;
    })();
  }
};

// src/generated/preprocessing/MinMaxScaler.ts
import crypto8 from "node:crypto";
var MinMaxScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MinMaxScaler${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MinMaxScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MinMaxScaler
try: bridgeMinMaxScaler
except NameError: bridgeMinMaxScaler = {}
`;
    await this._py.ex`ctor_MinMaxScaler = {'feature_range': ${this.opts["feature_range"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'clip': ${this.opts["clip"] ?? void 0}}

ctor_MinMaxScaler = {k: v for k, v in ctor_MinMaxScaler.items() if v is not None}`;
    await this._py.ex`bridgeMinMaxScaler[${this.id}] = MinMaxScaler(**ctor_MinMaxScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMinMaxScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the minimum and maximum to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before fit()");
    }
    await this._py.ex`pms_MinMaxScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinMaxScaler_fit = {k: v for k, v in pms_MinMaxScaler_fit.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_fit = bridgeMinMaxScaler[${this.id}].fit(**pms_MinMaxScaler_fit)`;
    return this._py`res_MinMaxScaler_fit.tolist() if hasattr(res_MinMaxScaler_fit, 'tolist') else res_MinMaxScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_MinMaxScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MinMaxScaler_fit_transform = {k: v for k, v in pms_MinMaxScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_fit_transform = bridgeMinMaxScaler[${this.id}].fit_transform(**pms_MinMaxScaler_fit_transform)`;
    return this._py`res_MinMaxScaler_fit_transform.tolist() if hasattr(res_MinMaxScaler_fit_transform, 'tolist') else res_MinMaxScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MinMaxScaler_get_feature_names_out = {k: v for k, v in pms_MinMaxScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_get_feature_names_out = bridgeMinMaxScaler[${this.id}].get_feature_names_out(**pms_MinMaxScaler_get_feature_names_out)`;
    return this._py`res_MinMaxScaler_get_feature_names_out.tolist() if hasattr(res_MinMaxScaler_get_feature_names_out, 'tolist') else res_MinMaxScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MinMaxScaler_get_metadata_routing = {k: v for k, v in pms_MinMaxScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_get_metadata_routing = bridgeMinMaxScaler[${this.id}].get_metadata_routing(**pms_MinMaxScaler_get_metadata_routing)`;
    return this._py`res_MinMaxScaler_get_metadata_routing.tolist() if hasattr(res_MinMaxScaler_get_metadata_routing, 'tolist') else res_MinMaxScaler_get_metadata_routing`;
  }
  /**
    Undo the scaling of X according to feature\_range.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinMaxScaler_inverse_transform = {k: v for k, v in pms_MinMaxScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_inverse_transform = bridgeMinMaxScaler[${this.id}].inverse_transform(**pms_MinMaxScaler_inverse_transform)`;
    return this._py`res_MinMaxScaler_inverse_transform.tolist() if hasattr(res_MinMaxScaler_inverse_transform, 'tolist') else res_MinMaxScaler_inverse_transform`;
  }
  /**
      Online computation of min and max on X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MinMaxScaler.fit "sklearn.preprocessing.MinMaxScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_MinMaxScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinMaxScaler_partial_fit = {k: v for k, v in pms_MinMaxScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_partial_fit = bridgeMinMaxScaler[${this.id}].partial_fit(**pms_MinMaxScaler_partial_fit)`;
    return this._py`res_MinMaxScaler_partial_fit.tolist() if hasattr(res_MinMaxScaler_partial_fit, 'tolist') else res_MinMaxScaler_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before set_output()");
    }
    await this._py.ex`pms_MinMaxScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MinMaxScaler_set_output = {k: v for k, v in pms_MinMaxScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_set_output = bridgeMinMaxScaler[${this.id}].set_output(**pms_MinMaxScaler_set_output)`;
    return this._py`res_MinMaxScaler_set_output.tolist() if hasattr(res_MinMaxScaler_set_output, 'tolist') else res_MinMaxScaler_set_output`;
  }
  /**
    Scale features of X according to feature\_range.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before transform()");
    }
    await this._py.ex`pms_MinMaxScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinMaxScaler_transform = {k: v for k, v in pms_MinMaxScaler_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_transform = bridgeMinMaxScaler[${this.id}].transform(**pms_MinMaxScaler_transform)`;
    return this._py`res_MinMaxScaler_transform.tolist() if hasattr(res_MinMaxScaler_transform, 'tolist') else res_MinMaxScaler_transform`;
  }
  /**
    Per feature adjustment for minimum. Equivalent to `min \- X.min(axis=0) \* self.scale\_`
   */
  get min_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before accessing min_");
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_min_ = bridgeMinMaxScaler[${this.id}].min_`;
      return this._py`attr_MinMaxScaler_min_.tolist() if hasattr(attr_MinMaxScaler_min_, 'tolist') else attr_MinMaxScaler_min_`;
    })();
  }
  /**
    Per feature relative scaling of the data. Equivalent to `(max \- min) / (X.max(axis=0) \- X.min(axis=0))`
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_scale_ = bridgeMinMaxScaler[${this.id}].scale_`;
      return this._py`attr_MinMaxScaler_scale_.tolist() if hasattr(attr_MinMaxScaler_scale_, 'tolist') else attr_MinMaxScaler_scale_`;
    })();
  }
  /**
    Per feature minimum seen in the data
   */
  get data_min_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_min_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_min_ = bridgeMinMaxScaler[${this.id}].data_min_`;
      return this._py`attr_MinMaxScaler_data_min_.tolist() if hasattr(attr_MinMaxScaler_data_min_, 'tolist') else attr_MinMaxScaler_data_min_`;
    })();
  }
  /**
    Per feature maximum seen in the data
   */
  get data_max_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_max_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_max_ = bridgeMinMaxScaler[${this.id}].data_max_`;
      return this._py`attr_MinMaxScaler_data_max_.tolist() if hasattr(attr_MinMaxScaler_data_max_, 'tolist') else attr_MinMaxScaler_data_max_`;
    })();
  }
  /**
    Per feature range `(data\_max\_ \- data\_min\_)` seen in the data
   */
  get data_range_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_range_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_range_ = bridgeMinMaxScaler[${this.id}].data_range_`;
      return this._py`attr_MinMaxScaler_data_range_.tolist() if hasattr(attr_MinMaxScaler_data_range_, 'tolist') else attr_MinMaxScaler_data_range_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_n_features_in_ = bridgeMinMaxScaler[${this.id}].n_features_in_`;
      return this._py`attr_MinMaxScaler_n_features_in_.tolist() if hasattr(attr_MinMaxScaler_n_features_in_, 'tolist') else attr_MinMaxScaler_n_features_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator. It will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_n_samples_seen_ = bridgeMinMaxScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_MinMaxScaler_n_samples_seen_.tolist() if hasattr(attr_MinMaxScaler_n_samples_seen_, 'tolist') else attr_MinMaxScaler_n_samples_seen_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_feature_names_in_ = bridgeMinMaxScaler[${this.id}].feature_names_in_`;
      return this._py`attr_MinMaxScaler_feature_names_in_.tolist() if hasattr(attr_MinMaxScaler_feature_names_in_, 'tolist') else attr_MinMaxScaler_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/MultiLabelBinarizer.ts
import crypto9 from "node:crypto";
var MultiLabelBinarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiLabelBinarizer${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiLabelBinarizer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MultiLabelBinarizer
try: bridgeMultiLabelBinarizer
except NameError: bridgeMultiLabelBinarizer = {}
`;
    await this._py.ex`ctor_MultiLabelBinarizer = {'classes': np.array(${this.opts["classes"] ?? void 0}) if ${this.opts["classes"] !== void 0} else None, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_MultiLabelBinarizer = {k: v for k, v in ctor_MultiLabelBinarizer.items() if v is not None}`;
    await this._py.ex`bridgeMultiLabelBinarizer[${this.id}] = MultiLabelBinarizer(**ctor_MultiLabelBinarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiLabelBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the label sets binarizer, storing [classes\_](../../glossary.html#term-classes_).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiLabelBinarizer must call init() before fit()");
    }
    await this._py.ex`pms_MultiLabelBinarizer_fit = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_fit = {k: v for k, v in pms_MultiLabelBinarizer_fit.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_fit = bridgeMultiLabelBinarizer[${this.id}].fit(**pms_MultiLabelBinarizer_fit)`;
    return this._py`res_MultiLabelBinarizer_fit.tolist() if hasattr(res_MultiLabelBinarizer_fit, 'tolist') else res_MultiLabelBinarizer_fit`;
  }
  /**
    Fit the label sets binarizer and transform the given label sets.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_fit_transform = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_fit_transform = {k: v for k, v in pms_MultiLabelBinarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_fit_transform = bridgeMultiLabelBinarizer[${this.id}].fit_transform(**pms_MultiLabelBinarizer_fit_transform)`;
    return this._py`res_MultiLabelBinarizer_fit_transform.tolist() if hasattr(res_MultiLabelBinarizer_fit_transform, 'tolist') else res_MultiLabelBinarizer_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiLabelBinarizer_get_metadata_routing = {k: v for k, v in pms_MultiLabelBinarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_get_metadata_routing = bridgeMultiLabelBinarizer[${this.id}].get_metadata_routing(**pms_MultiLabelBinarizer_get_metadata_routing)`;
    return this._py`res_MultiLabelBinarizer_get_metadata_routing.tolist() if hasattr(res_MultiLabelBinarizer_get_metadata_routing, 'tolist') else res_MultiLabelBinarizer_get_metadata_routing`;
  }
  /**
    Transform the given indicator matrix into label sets.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_inverse_transform = {'yt': np.array(${opts["yt"] ?? void 0}) if ${opts["yt"] !== void 0} else None}

pms_MultiLabelBinarizer_inverse_transform = {k: v for k, v in pms_MultiLabelBinarizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_inverse_transform = bridgeMultiLabelBinarizer[${this.id}].inverse_transform(**pms_MultiLabelBinarizer_inverse_transform)`;
    return this._py`res_MultiLabelBinarizer_inverse_transform.tolist() if hasattr(res_MultiLabelBinarizer_inverse_transform, 'tolist') else res_MultiLabelBinarizer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MultiLabelBinarizer_set_output = {k: v for k, v in pms_MultiLabelBinarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_set_output = bridgeMultiLabelBinarizer[${this.id}].set_output(**pms_MultiLabelBinarizer_set_output)`;
    return this._py`res_MultiLabelBinarizer_set_output.tolist() if hasattr(res_MultiLabelBinarizer_set_output, 'tolist') else res_MultiLabelBinarizer_set_output`;
  }
  /**
    Transform the given label sets.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiLabelBinarizer must call init() before transform()");
    }
    await this._py.ex`pms_MultiLabelBinarizer_transform = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_transform = {k: v for k, v in pms_MultiLabelBinarizer_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_transform = bridgeMultiLabelBinarizer[${this.id}].transform(**pms_MultiLabelBinarizer_transform)`;
    return this._py`res_MultiLabelBinarizer_transform.tolist() if hasattr(res_MultiLabelBinarizer_transform, 'tolist') else res_MultiLabelBinarizer_transform`;
  }
  /**
    A copy of the `classes` parameter when provided. Otherwise it corresponds to the sorted set of classes found when fitting.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiLabelBinarizer_classes_ = bridgeMultiLabelBinarizer[${this.id}].classes_`;
      return this._py`attr_MultiLabelBinarizer_classes_.tolist() if hasattr(attr_MultiLabelBinarizer_classes_, 'tolist') else attr_MultiLabelBinarizer_classes_`;
    })();
  }
};

// src/generated/preprocessing/Normalizer.ts
import crypto10 from "node:crypto";
var Normalizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Normalizer${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Normalizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import Normalizer
try: bridgeNormalizer
except NameError: bridgeNormalizer = {}
`;
    await this._py.ex`ctor_Normalizer = {'norm': ${this.opts["norm"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Normalizer = {k: v for k, v in ctor_Normalizer.items() if v is not None}`;
    await this._py.ex`bridgeNormalizer[${this.id}] = Normalizer(**ctor_Normalizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNormalizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimator’s parameters.
  
      This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before fit()");
    }
    await this._py.ex`pms_Normalizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Normalizer_fit = {k: v for k, v in pms_Normalizer_fit.items() if v is not None}`;
    await this._py.ex`res_Normalizer_fit = bridgeNormalizer[${this.id}].fit(**pms_Normalizer_fit)`;
    return this._py`res_Normalizer_fit.tolist() if hasattr(res_Normalizer_fit, 'tolist') else res_Normalizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_Normalizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Normalizer_fit_transform = {k: v for k, v in pms_Normalizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Normalizer_fit_transform = bridgeNormalizer[${this.id}].fit_transform(**pms_Normalizer_fit_transform)`;
    return this._py`res_Normalizer_fit_transform.tolist() if hasattr(res_Normalizer_fit_transform, 'tolist') else res_Normalizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Normalizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Normalizer_get_feature_names_out = {k: v for k, v in pms_Normalizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Normalizer_get_feature_names_out = bridgeNormalizer[${this.id}].get_feature_names_out(**pms_Normalizer_get_feature_names_out)`;
    return this._py`res_Normalizer_get_feature_names_out.tolist() if hasattr(res_Normalizer_get_feature_names_out, 'tolist') else res_Normalizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Normalizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Normalizer_get_metadata_routing = {k: v for k, v in pms_Normalizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Normalizer_get_metadata_routing = bridgeNormalizer[${this.id}].get_metadata_routing(**pms_Normalizer_get_metadata_routing)`;
    return this._py`res_Normalizer_get_metadata_routing.tolist() if hasattr(res_Normalizer_get_metadata_routing, 'tolist') else res_Normalizer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before set_output()");
    }
    await this._py.ex`pms_Normalizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Normalizer_set_output = {k: v for k, v in pms_Normalizer_set_output.items() if v is not None}`;
    await this._py.ex`res_Normalizer_set_output = bridgeNormalizer[${this.id}].set_output(**pms_Normalizer_set_output)`;
    return this._py`res_Normalizer_set_output.tolist() if hasattr(res_Normalizer_set_output, 'tolist') else res_Normalizer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_Normalizer_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_Normalizer_set_transform_request = {k: v for k, v in pms_Normalizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_Normalizer_set_transform_request = bridgeNormalizer[${this.id}].set_transform_request(**pms_Normalizer_set_transform_request)`;
    return this._py`res_Normalizer_set_transform_request.tolist() if hasattr(res_Normalizer_set_transform_request, 'tolist') else res_Normalizer_set_transform_request`;
  }
  /**
    Scale each non zero row of X to unit norm.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before transform()");
    }
    await this._py.ex`pms_Normalizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_Normalizer_transform = {k: v for k, v in pms_Normalizer_transform.items() if v is not None}`;
    await this._py.ex`res_Normalizer_transform = bridgeNormalizer[${this.id}].transform(**pms_Normalizer_transform)`;
    return this._py`res_Normalizer_transform.tolist() if hasattr(res_Normalizer_transform, 'tolist') else res_Normalizer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Normalizer_n_features_in_ = bridgeNormalizer[${this.id}].n_features_in_`;
      return this._py`attr_Normalizer_n_features_in_.tolist() if hasattr(attr_Normalizer_n_features_in_, 'tolist') else attr_Normalizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Normalizer_feature_names_in_ = bridgeNormalizer[${this.id}].feature_names_in_`;
      return this._py`attr_Normalizer_feature_names_in_.tolist() if hasattr(attr_Normalizer_feature_names_in_, 'tolist') else attr_Normalizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/OneHotEncoder.ts
import crypto11 from "node:crypto";
var OneHotEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneHotEncoder${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OneHotEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import OneHotEncoder
try: bridgeOneHotEncoder
except NameError: bridgeOneHotEncoder = {}
`;
    await this._py.ex`ctor_OneHotEncoder = {'categories': ${this.opts["categories"] ?? void 0}, 'drop': np.array(${this.opts["drop"] ?? void 0}) if ${this.opts["drop"] !== void 0} else None, 'sparse': ${this.opts["sparse"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'handle_unknown': ${this.opts["handle_unknown"] ?? void 0}, 'min_frequency': ${this.opts["min_frequency"] ?? void 0}, 'max_categories': ${this.opts["max_categories"] ?? void 0}, 'feature_name_combiner': ${this.opts["feature_name_combiner"] ?? void 0}}

ctor_OneHotEncoder = {k: v for k, v in ctor_OneHotEncoder.items() if v is not None}`;
    await this._py.ex`bridgeOneHotEncoder[${this.id}] = OneHotEncoder(**ctor_OneHotEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneHotEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit OneHotEncoder to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before fit()");
    }
    await this._py.ex`pms_OneHotEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OneHotEncoder_fit = {k: v for k, v in pms_OneHotEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_fit = bridgeOneHotEncoder[${this.id}].fit(**pms_OneHotEncoder_fit)`;
    return this._py`res_OneHotEncoder_fit.tolist() if hasattr(res_OneHotEncoder_fit, 'tolist') else res_OneHotEncoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_OneHotEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_OneHotEncoder_fit_transform = {k: v for k, v in pms_OneHotEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_fit_transform = bridgeOneHotEncoder[${this.id}].fit_transform(**pms_OneHotEncoder_fit_transform)`;
    return this._py`res_OneHotEncoder_fit_transform.tolist() if hasattr(res_OneHotEncoder_fit_transform, 'tolist') else res_OneHotEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_OneHotEncoder_get_feature_names_out = {k: v for k, v in pms_OneHotEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_get_feature_names_out = bridgeOneHotEncoder[${this.id}].get_feature_names_out(**pms_OneHotEncoder_get_feature_names_out)`;
    return this._py`res_OneHotEncoder_get_feature_names_out.tolist() if hasattr(res_OneHotEncoder_get_feature_names_out, 'tolist') else res_OneHotEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OneHotEncoder_get_metadata_routing = {k: v for k, v in pms_OneHotEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_get_metadata_routing = bridgeOneHotEncoder[${this.id}].get_metadata_routing(**pms_OneHotEncoder_get_metadata_routing)`;
    return this._py`res_OneHotEncoder_get_metadata_routing.tolist() if hasattr(res_OneHotEncoder_get_metadata_routing, 'tolist') else res_OneHotEncoder_get_metadata_routing`;
  }
  /**
      Convert the data back to the original representation.
  
      When unknown categories are encountered (all zeros in the one-hot encoding), `undefined` is used to represent this category. If the feature with the unknown category has a dropped category, the dropped category will be its inverse.
  
      For a given input feature, if there is an infrequent category, ‘infrequent\_sklearn’ will be used to represent the infrequent category.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneHotEncoder_inverse_transform = {k: v for k, v in pms_OneHotEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_inverse_transform = bridgeOneHotEncoder[${this.id}].inverse_transform(**pms_OneHotEncoder_inverse_transform)`;
    return this._py`res_OneHotEncoder_inverse_transform.tolist() if hasattr(res_OneHotEncoder_inverse_transform, 'tolist') else res_OneHotEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_OneHotEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_OneHotEncoder_set_output = {k: v for k, v in pms_OneHotEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_set_output = bridgeOneHotEncoder[${this.id}].set_output(**pms_OneHotEncoder_set_output)`;
    return this._py`res_OneHotEncoder_set_output.tolist() if hasattr(res_OneHotEncoder_set_output, 'tolist') else res_OneHotEncoder_set_output`;
  }
  /**
      Transform X using one-hot encoding.
  
      If there are infrequent categories for a feature, the infrequent categories will be grouped into a single category.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before transform()");
    }
    await this._py.ex`pms_OneHotEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneHotEncoder_transform = {k: v for k, v in pms_OneHotEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_transform = bridgeOneHotEncoder[${this.id}].transform(**pms_OneHotEncoder_transform)`;
    return this._py`res_OneHotEncoder_transform.tolist() if hasattr(res_OneHotEncoder_transform, 'tolist') else res_OneHotEncoder_transform`;
  }
  /**
    The categories of each feature determined during fitting (in order of the features in X and corresponding with the output of `transform`). This includes the category specified in `drop` (if any).
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_categories_ = bridgeOneHotEncoder[${this.id}].categories_`;
      return this._py`attr_OneHotEncoder_categories_.tolist() if hasattr(attr_OneHotEncoder_categories_, 'tolist') else attr_OneHotEncoder_categories_`;
    })();
  }
  /**
    `drop\_idx\_\[i\]` is the index in `categories\_\[i\]` of the category to be dropped for each feature.
   */
  get drop_idx_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing drop_idx_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_drop_idx_ = bridgeOneHotEncoder[${this.id}].drop_idx_`;
      return this._py`attr_OneHotEncoder_drop_idx_.tolist() if hasattr(attr_OneHotEncoder_drop_idx_, 'tolist') else attr_OneHotEncoder_drop_idx_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_n_features_in_ = bridgeOneHotEncoder[${this.id}].n_features_in_`;
      return this._py`attr_OneHotEncoder_n_features_in_.tolist() if hasattr(attr_OneHotEncoder_n_features_in_, 'tolist') else attr_OneHotEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_feature_names_in_ = bridgeOneHotEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_OneHotEncoder_feature_names_in_.tolist() if hasattr(attr_OneHotEncoder_feature_names_in_, 'tolist') else attr_OneHotEncoder_feature_names_in_`;
    })();
  }
  /**
    Callable with signature `def callable(input\_feature, category)` that returns a string. This is used to create feature names to be returned by [`get\_feature\_names\_out`](#sklearn.preprocessing.OneHotEncoder.get_feature_names_out "sklearn.preprocessing.OneHotEncoder.get_feature_names_out").
   */
  get feature_name_combiner() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing feature_name_combiner"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_feature_name_combiner = bridgeOneHotEncoder[${this.id}].feature_name_combiner`;
      return this._py`attr_OneHotEncoder_feature_name_combiner.tolist() if hasattr(attr_OneHotEncoder_feature_name_combiner, 'tolist') else attr_OneHotEncoder_feature_name_combiner`;
    })();
  }
};

// src/generated/preprocessing/OrdinalEncoder.ts
import crypto12 from "node:crypto";
var OrdinalEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrdinalEncoder${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OrdinalEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import OrdinalEncoder
try: bridgeOrdinalEncoder
except NameError: bridgeOrdinalEncoder = {}
`;
    await this._py.ex`ctor_OrdinalEncoder = {'categories': ${this.opts["categories"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'handle_unknown': ${this.opts["handle_unknown"] ?? void 0}, 'unknown_value': ${this.opts["unknown_value"] ?? void 0}, 'encoded_missing_value': ${this.opts["encoded_missing_value"] ?? void 0}, 'min_frequency': ${this.opts["min_frequency"] ?? void 0}, 'max_categories': ${this.opts["max_categories"] ?? void 0}}

ctor_OrdinalEncoder = {k: v for k, v in ctor_OrdinalEncoder.items() if v is not None}`;
    await this._py.ex`bridgeOrdinalEncoder[${this.id}] = OrdinalEncoder(**ctor_OrdinalEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrdinalEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the OrdinalEncoder to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before fit()");
    }
    await this._py.ex`pms_OrdinalEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OrdinalEncoder_fit = {k: v for k, v in pms_OrdinalEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_fit = bridgeOrdinalEncoder[${this.id}].fit(**pms_OrdinalEncoder_fit)`;
    return this._py`res_OrdinalEncoder_fit.tolist() if hasattr(res_OrdinalEncoder_fit, 'tolist') else res_OrdinalEncoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_OrdinalEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_OrdinalEncoder_fit_transform = {k: v for k, v in pms_OrdinalEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_fit_transform = bridgeOrdinalEncoder[${this.id}].fit_transform(**pms_OrdinalEncoder_fit_transform)`;
    return this._py`res_OrdinalEncoder_fit_transform.tolist() if hasattr(res_OrdinalEncoder_fit_transform, 'tolist') else res_OrdinalEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_OrdinalEncoder_get_feature_names_out = {k: v for k, v in pms_OrdinalEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_get_feature_names_out = bridgeOrdinalEncoder[${this.id}].get_feature_names_out(**pms_OrdinalEncoder_get_feature_names_out)`;
    return this._py`res_OrdinalEncoder_get_feature_names_out.tolist() if hasattr(res_OrdinalEncoder_get_feature_names_out, 'tolist') else res_OrdinalEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrdinalEncoder_get_metadata_routing = {k: v for k, v in pms_OrdinalEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_get_metadata_routing = bridgeOrdinalEncoder[${this.id}].get_metadata_routing(**pms_OrdinalEncoder_get_metadata_routing)`;
    return this._py`res_OrdinalEncoder_get_metadata_routing.tolist() if hasattr(res_OrdinalEncoder_get_metadata_routing, 'tolist') else res_OrdinalEncoder_get_metadata_routing`;
  }
  /**
    Convert the data back to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OrdinalEncoder_inverse_transform = {k: v for k, v in pms_OrdinalEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_inverse_transform = bridgeOrdinalEncoder[${this.id}].inverse_transform(**pms_OrdinalEncoder_inverse_transform)`;
    return this._py`res_OrdinalEncoder_inverse_transform.tolist() if hasattr(res_OrdinalEncoder_inverse_transform, 'tolist') else res_OrdinalEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_OrdinalEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_OrdinalEncoder_set_output = {k: v for k, v in pms_OrdinalEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_set_output = bridgeOrdinalEncoder[${this.id}].set_output(**pms_OrdinalEncoder_set_output)`;
    return this._py`res_OrdinalEncoder_set_output.tolist() if hasattr(res_OrdinalEncoder_set_output, 'tolist') else res_OrdinalEncoder_set_output`;
  }
  /**
    Transform X to ordinal codes.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before transform()");
    }
    await this._py.ex`pms_OrdinalEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OrdinalEncoder_transform = {k: v for k, v in pms_OrdinalEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_transform = bridgeOrdinalEncoder[${this.id}].transform(**pms_OrdinalEncoder_transform)`;
    return this._py`res_OrdinalEncoder_transform.tolist() if hasattr(res_OrdinalEncoder_transform, 'tolist') else res_OrdinalEncoder_transform`;
  }
  /**
    The categories of each feature determined during `fit` (in order of the features in X and corresponding with the output of `transform`). This does not include categories that weren’t seen during `fit`.
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_categories_ = bridgeOrdinalEncoder[${this.id}].categories_`;
      return this._py`attr_OrdinalEncoder_categories_.tolist() if hasattr(attr_OrdinalEncoder_categories_, 'tolist') else attr_OrdinalEncoder_categories_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_n_features_in_ = bridgeOrdinalEncoder[${this.id}].n_features_in_`;
      return this._py`attr_OrdinalEncoder_n_features_in_.tolist() if hasattr(attr_OrdinalEncoder_n_features_in_, 'tolist') else attr_OrdinalEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_feature_names_in_ = bridgeOrdinalEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_OrdinalEncoder_feature_names_in_.tolist() if hasattr(attr_OrdinalEncoder_feature_names_in_, 'tolist') else attr_OrdinalEncoder_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/PolynomialFeatures.ts
import crypto13 from "node:crypto";
var PolynomialFeatures = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PolynomialFeatures${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PolynomialFeatures.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import PolynomialFeatures
try: bridgePolynomialFeatures
except NameError: bridgePolynomialFeatures = {}
`;
    await this._py.ex`ctor_PolynomialFeatures = {'degree': ${this.opts["degree"] ?? void 0}, 'interaction_only': ${this.opts["interaction_only"] ?? void 0}, 'include_bias': ${this.opts["include_bias"] ?? void 0}, 'order': ${this.opts["order"] ?? void 0}}

ctor_PolynomialFeatures = {k: v for k, v in ctor_PolynomialFeatures.items() if v is not None}`;
    await this._py.ex`bridgePolynomialFeatures[${this.id}] = PolynomialFeatures(**ctor_PolynomialFeatures)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePolynomialFeatures[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute number of output features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before fit()");
    }
    await this._py.ex`pms_PolynomialFeatures_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PolynomialFeatures_fit = {k: v for k, v in pms_PolynomialFeatures_fit.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_fit = bridgePolynomialFeatures[${this.id}].fit(**pms_PolynomialFeatures_fit)`;
    return this._py`res_PolynomialFeatures_fit.tolist() if hasattr(res_PolynomialFeatures_fit, 'tolist') else res_PolynomialFeatures_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_PolynomialFeatures_fit_transform = {k: v for k, v in pms_PolynomialFeatures_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_fit_transform = bridgePolynomialFeatures[${this.id}].fit_transform(**pms_PolynomialFeatures_fit_transform)`;
    return this._py`res_PolynomialFeatures_fit_transform.tolist() if hasattr(res_PolynomialFeatures_fit_transform, 'tolist') else res_PolynomialFeatures_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PolynomialFeatures_get_feature_names_out = {k: v for k, v in pms_PolynomialFeatures_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_get_feature_names_out = bridgePolynomialFeatures[${this.id}].get_feature_names_out(**pms_PolynomialFeatures_get_feature_names_out)`;
    return this._py`res_PolynomialFeatures_get_feature_names_out.tolist() if hasattr(res_PolynomialFeatures_get_feature_names_out, 'tolist') else res_PolynomialFeatures_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PolynomialFeatures_get_metadata_routing = {k: v for k, v in pms_PolynomialFeatures_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_get_metadata_routing = bridgePolynomialFeatures[${this.id}].get_metadata_routing(**pms_PolynomialFeatures_get_metadata_routing)`;
    return this._py`res_PolynomialFeatures_get_metadata_routing.tolist() if hasattr(res_PolynomialFeatures_get_metadata_routing, 'tolist') else res_PolynomialFeatures_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before set_output()");
    }
    await this._py.ex`pms_PolynomialFeatures_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PolynomialFeatures_set_output = {k: v for k, v in pms_PolynomialFeatures_set_output.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_set_output = bridgePolynomialFeatures[${this.id}].set_output(**pms_PolynomialFeatures_set_output)`;
    return this._py`res_PolynomialFeatures_set_output.tolist() if hasattr(res_PolynomialFeatures_set_output, 'tolist') else res_PolynomialFeatures_set_output`;
  }
  /**
    Transform data to polynomial features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before transform()");
    }
    await this._py.ex`pms_PolynomialFeatures_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PolynomialFeatures_transform = {k: v for k, v in pms_PolynomialFeatures_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_transform = bridgePolynomialFeatures[${this.id}].transform(**pms_PolynomialFeatures_transform)`;
    return this._py`res_PolynomialFeatures_transform.tolist() if hasattr(res_PolynomialFeatures_transform, 'tolist') else res_PolynomialFeatures_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_n_features_in_ = bridgePolynomialFeatures[${this.id}].n_features_in_`;
      return this._py`attr_PolynomialFeatures_n_features_in_.tolist() if hasattr(attr_PolynomialFeatures_n_features_in_, 'tolist') else attr_PolynomialFeatures_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_feature_names_in_ = bridgePolynomialFeatures[${this.id}].feature_names_in_`;
      return this._py`attr_PolynomialFeatures_feature_names_in_.tolist() if hasattr(attr_PolynomialFeatures_feature_names_in_, 'tolist') else attr_PolynomialFeatures_feature_names_in_`;
    })();
  }
  /**
    The total number of polynomial output features. The number of output features is computed by iterating over all suitably sized combinations of input features.
   */
  get n_output_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing n_output_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_n_output_features_ = bridgePolynomialFeatures[${this.id}].n_output_features_`;
      return this._py`attr_PolynomialFeatures_n_output_features_.tolist() if hasattr(attr_PolynomialFeatures_n_output_features_, 'tolist') else attr_PolynomialFeatures_n_output_features_`;
    })();
  }
};

// src/generated/preprocessing/PowerTransformer.ts
import crypto14 from "node:crypto";
var PowerTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PowerTransformer${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PowerTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import PowerTransformer
try: bridgePowerTransformer
except NameError: bridgePowerTransformer = {}
`;
    await this._py.ex`ctor_PowerTransformer = {'method': ${this.opts["method"] ?? void 0}, 'standardize': ${this.opts["standardize"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PowerTransformer = {k: v for k, v in ctor_PowerTransformer.items() if v is not None}`;
    await this._py.ex`bridgePowerTransformer[${this.id}] = PowerTransformer(**ctor_PowerTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePowerTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Estimate the optimal parameter lambda for each feature.
  
      The optimal lambda parameter for minimizing skewness is estimated on each feature independently using maximum likelihood.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before fit()");
    }
    await this._py.ex`pms_PowerTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PowerTransformer_fit = {k: v for k, v in pms_PowerTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_fit = bridgePowerTransformer[${this.id}].fit(**pms_PowerTransformer_fit)`;
    return this._py`res_PowerTransformer_fit.tolist() if hasattr(res_PowerTransformer_fit, 'tolist') else res_PowerTransformer_fit`;
  }
  /**
    Fit `PowerTransformer` to `X`, then transform `X`.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_PowerTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PowerTransformer_fit_transform = {k: v for k, v in pms_PowerTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_fit_transform = bridgePowerTransformer[${this.id}].fit_transform(**pms_PowerTransformer_fit_transform)`;
    return this._py`res_PowerTransformer_fit_transform.tolist() if hasattr(res_PowerTransformer_fit_transform, 'tolist') else res_PowerTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PowerTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PowerTransformer_get_feature_names_out = {k: v for k, v in pms_PowerTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_get_feature_names_out = bridgePowerTransformer[${this.id}].get_feature_names_out(**pms_PowerTransformer_get_feature_names_out)`;
    return this._py`res_PowerTransformer_get_feature_names_out.tolist() if hasattr(res_PowerTransformer_get_feature_names_out, 'tolist') else res_PowerTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PowerTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PowerTransformer_get_metadata_routing = {k: v for k, v in pms_PowerTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_get_metadata_routing = bridgePowerTransformer[${this.id}].get_metadata_routing(**pms_PowerTransformer_get_metadata_routing)`;
    return this._py`res_PowerTransformer_get_metadata_routing.tolist() if hasattr(res_PowerTransformer_get_metadata_routing, 'tolist') else res_PowerTransformer_get_metadata_routing`;
  }
  /**
      Apply the inverse power transformation using the fitted lambdas.
  
      The inverse of the Box-Cox transformation is given by:
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PowerTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PowerTransformer_inverse_transform = {k: v for k, v in pms_PowerTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_inverse_transform = bridgePowerTransformer[${this.id}].inverse_transform(**pms_PowerTransformer_inverse_transform)`;
    return this._py`res_PowerTransformer_inverse_transform.tolist() if hasattr(res_PowerTransformer_inverse_transform, 'tolist') else res_PowerTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_PowerTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PowerTransformer_set_output = {k: v for k, v in pms_PowerTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_set_output = bridgePowerTransformer[${this.id}].set_output(**pms_PowerTransformer_set_output)`;
    return this._py`res_PowerTransformer_set_output.tolist() if hasattr(res_PowerTransformer_set_output, 'tolist') else res_PowerTransformer_set_output`;
  }
  /**
    Apply the power transform to each feature using the fitted lambdas.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before transform()");
    }
    await this._py.ex`pms_PowerTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PowerTransformer_transform = {k: v for k, v in pms_PowerTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_transform = bridgePowerTransformer[${this.id}].transform(**pms_PowerTransformer_transform)`;
    return this._py`res_PowerTransformer_transform.tolist() if hasattr(res_PowerTransformer_transform, 'tolist') else res_PowerTransformer_transform`;
  }
  /**
    The parameters of the power transformation for the selected features.
   */
  get lambdas_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing lambdas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_lambdas_ = bridgePowerTransformer[${this.id}].lambdas_`;
      return this._py`attr_PowerTransformer_lambdas_.tolist() if hasattr(attr_PowerTransformer_lambdas_, 'tolist') else attr_PowerTransformer_lambdas_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_n_features_in_ = bridgePowerTransformer[${this.id}].n_features_in_`;
      return this._py`attr_PowerTransformer_n_features_in_.tolist() if hasattr(attr_PowerTransformer_n_features_in_, 'tolist') else attr_PowerTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_feature_names_in_ = bridgePowerTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_PowerTransformer_feature_names_in_.tolist() if hasattr(attr_PowerTransformer_feature_names_in_, 'tolist') else attr_PowerTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/QuantileTransformer.ts
import crypto15 from "node:crypto";
var QuantileTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `QuantileTransformer${crypto15.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "QuantileTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import QuantileTransformer
try: bridgeQuantileTransformer
except NameError: bridgeQuantileTransformer = {}
`;
    await this._py.ex`ctor_QuantileTransformer = {'n_quantiles': ${this.opts["n_quantiles"] ?? void 0}, 'output_distribution': ${this.opts["output_distribution"] ?? void 0}, 'ignore_implicit_zeros': ${this.opts["ignore_implicit_zeros"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_QuantileTransformer = {k: v for k, v in ctor_QuantileTransformer.items() if v is not None}`;
    await this._py.ex`bridgeQuantileTransformer[${this.id}] = QuantileTransformer(**ctor_QuantileTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuantileTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the quantiles used for transforming.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileTransformer must call init() before fit()");
    }
    await this._py.ex`pms_QuantileTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_QuantileTransformer_fit = {k: v for k, v in pms_QuantileTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_fit = bridgeQuantileTransformer[${this.id}].fit(**pms_QuantileTransformer_fit)`;
    return this._py`res_QuantileTransformer_fit.tolist() if hasattr(res_QuantileTransformer_fit, 'tolist') else res_QuantileTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_QuantileTransformer_fit_transform = {k: v for k, v in pms_QuantileTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_fit_transform = bridgeQuantileTransformer[${this.id}].fit_transform(**pms_QuantileTransformer_fit_transform)`;
    return this._py`res_QuantileTransformer_fit_transform.tolist() if hasattr(res_QuantileTransformer_fit_transform, 'tolist') else res_QuantileTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_QuantileTransformer_get_feature_names_out = {k: v for k, v in pms_QuantileTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_get_feature_names_out = bridgeQuantileTransformer[${this.id}].get_feature_names_out(**pms_QuantileTransformer_get_feature_names_out)`;
    return this._py`res_QuantileTransformer_get_feature_names_out.tolist() if hasattr(res_QuantileTransformer_get_feature_names_out, 'tolist') else res_QuantileTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuantileTransformer_get_metadata_routing = {k: v for k, v in pms_QuantileTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_get_metadata_routing = bridgeQuantileTransformer[${this.id}].get_metadata_routing(**pms_QuantileTransformer_get_metadata_routing)`;
    return this._py`res_QuantileTransformer_get_metadata_routing.tolist() if hasattr(res_QuantileTransformer_get_metadata_routing, 'tolist') else res_QuantileTransformer_get_metadata_routing`;
  }
  /**
    Back-projection to the original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuantileTransformer_inverse_transform = {k: v for k, v in pms_QuantileTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_inverse_transform = bridgeQuantileTransformer[${this.id}].inverse_transform(**pms_QuantileTransformer_inverse_transform)`;
    return this._py`res_QuantileTransformer_inverse_transform.tolist() if hasattr(res_QuantileTransformer_inverse_transform, 'tolist') else res_QuantileTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_QuantileTransformer_set_output = {k: v for k, v in pms_QuantileTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_set_output = bridgeQuantileTransformer[${this.id}].set_output(**pms_QuantileTransformer_set_output)`;
    return this._py`res_QuantileTransformer_set_output.tolist() if hasattr(res_QuantileTransformer_set_output, 'tolist') else res_QuantileTransformer_set_output`;
  }
  /**
    Feature-wise transformation of the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileTransformer must call init() before transform()");
    }
    await this._py.ex`pms_QuantileTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuantileTransformer_transform = {k: v for k, v in pms_QuantileTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_transform = bridgeQuantileTransformer[${this.id}].transform(**pms_QuantileTransformer_transform)`;
    return this._py`res_QuantileTransformer_transform.tolist() if hasattr(res_QuantileTransformer_transform, 'tolist') else res_QuantileTransformer_transform`;
  }
  /**
    The actual number of quantiles used to discretize the cumulative distribution function.
   */
  get n_quantiles_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing n_quantiles_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_n_quantiles_ = bridgeQuantileTransformer[${this.id}].n_quantiles_`;
      return this._py`attr_QuantileTransformer_n_quantiles_.tolist() if hasattr(attr_QuantileTransformer_n_quantiles_, 'tolist') else attr_QuantileTransformer_n_quantiles_`;
    })();
  }
  /**
    The values corresponding the quantiles of reference.
   */
  get quantiles_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing quantiles_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_quantiles_ = bridgeQuantileTransformer[${this.id}].quantiles_`;
      return this._py`attr_QuantileTransformer_quantiles_.tolist() if hasattr(attr_QuantileTransformer_quantiles_, 'tolist') else attr_QuantileTransformer_quantiles_`;
    })();
  }
  /**
    Quantiles of references.
   */
  get references_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing references_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_references_ = bridgeQuantileTransformer[${this.id}].references_`;
      return this._py`attr_QuantileTransformer_references_.tolist() if hasattr(attr_QuantileTransformer_references_, 'tolist') else attr_QuantileTransformer_references_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_n_features_in_ = bridgeQuantileTransformer[${this.id}].n_features_in_`;
      return this._py`attr_QuantileTransformer_n_features_in_.tolist() if hasattr(attr_QuantileTransformer_n_features_in_, 'tolist') else attr_QuantileTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_feature_names_in_ = bridgeQuantileTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_QuantileTransformer_feature_names_in_.tolist() if hasattr(attr_QuantileTransformer_feature_names_in_, 'tolist') else attr_QuantileTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/RobustScaler.ts
import crypto16 from "node:crypto";
var RobustScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RobustScaler${crypto16.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RobustScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import RobustScaler
try: bridgeRobustScaler
except NameError: bridgeRobustScaler = {}
`;
    await this._py.ex`ctor_RobustScaler = {'with_centering': ${this.opts["with_centering"] ?? void 0}, 'with_scaling': ${this.opts["with_scaling"] ?? void 0}, 'quantile_range': ${this.opts["quantile_range"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'unit_variance': ${this.opts["unit_variance"] ?? void 0}}

ctor_RobustScaler = {k: v for k, v in ctor_RobustScaler.items() if v is not None}`;
    await this._py.ex`bridgeRobustScaler[${this.id}] = RobustScaler(**ctor_RobustScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRobustScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the median and quantiles to be used for scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before fit()");
    }
    await this._py.ex`pms_RobustScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RobustScaler_fit = {k: v for k, v in pms_RobustScaler_fit.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_fit = bridgeRobustScaler[${this.id}].fit(**pms_RobustScaler_fit)`;
    return this._py`res_RobustScaler_fit.tolist() if hasattr(res_RobustScaler_fit, 'tolist') else res_RobustScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_RobustScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RobustScaler_fit_transform = {k: v for k, v in pms_RobustScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_fit_transform = bridgeRobustScaler[${this.id}].fit_transform(**pms_RobustScaler_fit_transform)`;
    return this._py`res_RobustScaler_fit_transform.tolist() if hasattr(res_RobustScaler_fit_transform, 'tolist') else res_RobustScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RobustScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RobustScaler_get_feature_names_out = {k: v for k, v in pms_RobustScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_get_feature_names_out = bridgeRobustScaler[${this.id}].get_feature_names_out(**pms_RobustScaler_get_feature_names_out)`;
    return this._py`res_RobustScaler_get_feature_names_out.tolist() if hasattr(res_RobustScaler_get_feature_names_out, 'tolist') else res_RobustScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RobustScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RobustScaler_get_metadata_routing = {k: v for k, v in pms_RobustScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_get_metadata_routing = bridgeRobustScaler[${this.id}].get_metadata_routing(**pms_RobustScaler_get_metadata_routing)`;
    return this._py`res_RobustScaler_get_metadata_routing.tolist() if hasattr(res_RobustScaler_get_metadata_routing, 'tolist') else res_RobustScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_RobustScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RobustScaler_inverse_transform = {k: v for k, v in pms_RobustScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_inverse_transform = bridgeRobustScaler[${this.id}].inverse_transform(**pms_RobustScaler_inverse_transform)`;
    return this._py`res_RobustScaler_inverse_transform.tolist() if hasattr(res_RobustScaler_inverse_transform, 'tolist') else res_RobustScaler_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before set_output()");
    }
    await this._py.ex`pms_RobustScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RobustScaler_set_output = {k: v for k, v in pms_RobustScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_set_output = bridgeRobustScaler[${this.id}].set_output(**pms_RobustScaler_set_output)`;
    return this._py`res_RobustScaler_set_output.tolist() if hasattr(res_RobustScaler_set_output, 'tolist') else res_RobustScaler_set_output`;
  }
  /**
    Center and scale the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before transform()");
    }
    await this._py.ex`pms_RobustScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RobustScaler_transform = {k: v for k, v in pms_RobustScaler_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_transform = bridgeRobustScaler[${this.id}].transform(**pms_RobustScaler_transform)`;
    return this._py`res_RobustScaler_transform.tolist() if hasattr(res_RobustScaler_transform, 'tolist') else res_RobustScaler_transform`;
  }
  /**
    The median value for each feature in the training set.
   */
  get center_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before accessing center_");
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_center_ = bridgeRobustScaler[${this.id}].center_`;
      return this._py`attr_RobustScaler_center_.tolist() if hasattr(attr_RobustScaler_center_, 'tolist') else attr_RobustScaler_center_`;
    })();
  }
  /**
    The (scaled) interquartile range for each feature in the training set.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_scale_ = bridgeRobustScaler[${this.id}].scale_`;
      return this._py`attr_RobustScaler_scale_.tolist() if hasattr(attr_RobustScaler_scale_, 'tolist') else attr_RobustScaler_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_n_features_in_ = bridgeRobustScaler[${this.id}].n_features_in_`;
      return this._py`attr_RobustScaler_n_features_in_.tolist() if hasattr(attr_RobustScaler_n_features_in_, 'tolist') else attr_RobustScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_feature_names_in_ = bridgeRobustScaler[${this.id}].feature_names_in_`;
      return this._py`attr_RobustScaler_feature_names_in_.tolist() if hasattr(attr_RobustScaler_feature_names_in_, 'tolist') else attr_RobustScaler_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/SplineTransformer.ts
import crypto17 from "node:crypto";
var SplineTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SplineTransformer${crypto17.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SplineTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import SplineTransformer
try: bridgeSplineTransformer
except NameError: bridgeSplineTransformer = {}
`;
    await this._py.ex`ctor_SplineTransformer = {'n_knots': ${this.opts["n_knots"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'knots': np.array(${this.opts["knots"] ?? void 0}) if ${this.opts["knots"] !== void 0} else None, 'extrapolation': ${this.opts["extrapolation"] ?? void 0}, 'include_bias': ${this.opts["include_bias"] ?? void 0}, 'order': ${this.opts["order"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_SplineTransformer = {k: v for k, v in ctor_SplineTransformer.items() if v is not None}`;
    await this._py.ex`bridgeSplineTransformer[${this.id}] = SplineTransformer(**ctor_SplineTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSplineTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute knot positions of splines.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before fit()");
    }
    await this._py.ex`pms_SplineTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SplineTransformer_fit = {k: v for k, v in pms_SplineTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_fit = bridgeSplineTransformer[${this.id}].fit(**pms_SplineTransformer_fit)`;
    return this._py`res_SplineTransformer_fit.tolist() if hasattr(res_SplineTransformer_fit, 'tolist') else res_SplineTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SplineTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SplineTransformer_fit_transform = {k: v for k, v in pms_SplineTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_fit_transform = bridgeSplineTransformer[${this.id}].fit_transform(**pms_SplineTransformer_fit_transform)`;
    return this._py`res_SplineTransformer_fit_transform.tolist() if hasattr(res_SplineTransformer_fit_transform, 'tolist') else res_SplineTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SplineTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SplineTransformer_get_feature_names_out = {k: v for k, v in pms_SplineTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_get_feature_names_out = bridgeSplineTransformer[${this.id}].get_feature_names_out(**pms_SplineTransformer_get_feature_names_out)`;
    return this._py`res_SplineTransformer_get_feature_names_out.tolist() if hasattr(res_SplineTransformer_get_feature_names_out, 'tolist') else res_SplineTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SplineTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SplineTransformer_get_metadata_routing = {k: v for k, v in pms_SplineTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_get_metadata_routing = bridgeSplineTransformer[${this.id}].get_metadata_routing(**pms_SplineTransformer_get_metadata_routing)`;
    return this._py`res_SplineTransformer_get_metadata_routing.tolist() if hasattr(res_SplineTransformer_get_metadata_routing, 'tolist') else res_SplineTransformer_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_SplineTransformer_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SplineTransformer_set_fit_request = {k: v for k, v in pms_SplineTransformer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_set_fit_request = bridgeSplineTransformer[${this.id}].set_fit_request(**pms_SplineTransformer_set_fit_request)`;
    return this._py`res_SplineTransformer_set_fit_request.tolist() if hasattr(res_SplineTransformer_set_fit_request, 'tolist') else res_SplineTransformer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_SplineTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SplineTransformer_set_output = {k: v for k, v in pms_SplineTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_set_output = bridgeSplineTransformer[${this.id}].set_output(**pms_SplineTransformer_set_output)`;
    return this._py`res_SplineTransformer_set_output.tolist() if hasattr(res_SplineTransformer_set_output, 'tolist') else res_SplineTransformer_set_output`;
  }
  /**
    Transform each feature data to B-splines.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before transform()");
    }
    await this._py.ex`pms_SplineTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SplineTransformer_transform = {k: v for k, v in pms_SplineTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_transform = bridgeSplineTransformer[${this.id}].transform(**pms_SplineTransformer_transform)`;
    return this._py`res_SplineTransformer_transform.tolist() if hasattr(res_SplineTransformer_transform, 'tolist') else res_SplineTransformer_transform`;
  }
  /**
    List of BSplines objects, one for each feature.
   */
  get bsplines_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing bsplines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_bsplines_ = bridgeSplineTransformer[${this.id}].bsplines_`;
      return this._py`attr_SplineTransformer_bsplines_.tolist() if hasattr(attr_SplineTransformer_bsplines_, 'tolist') else attr_SplineTransformer_bsplines_`;
    })();
  }
  /**
    The total number of input features.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_n_features_in_ = bridgeSplineTransformer[${this.id}].n_features_in_`;
      return this._py`attr_SplineTransformer_n_features_in_.tolist() if hasattr(attr_SplineTransformer_n_features_in_, 'tolist') else attr_SplineTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_feature_names_in_ = bridgeSplineTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_SplineTransformer_feature_names_in_.tolist() if hasattr(attr_SplineTransformer_feature_names_in_, 'tolist') else attr_SplineTransformer_feature_names_in_`;
    })();
  }
  /**
    The total number of output features, which is computed as `n\_features \* n\_splines`, where `n\_splines` is the number of bases elements of the B-splines, `n\_knots + degree \- 1` for non-periodic splines and `n\_knots \- 1` for periodic ones. If `include\_bias=False`, then it is only `n\_features \* (n\_splines \- 1)`.
   */
  get n_features_out_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing n_features_out_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_n_features_out_ = bridgeSplineTransformer[${this.id}].n_features_out_`;
      return this._py`attr_SplineTransformer_n_features_out_.tolist() if hasattr(attr_SplineTransformer_n_features_out_, 'tolist') else attr_SplineTransformer_n_features_out_`;
    })();
  }
};

// src/generated/preprocessing/StandardScaler.ts
import crypto18 from "node:crypto";
var StandardScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StandardScaler${crypto18.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("StandardScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import StandardScaler
try: bridgeStandardScaler
except NameError: bridgeStandardScaler = {}
`;
    await this._py.ex`ctor_StandardScaler = {'copy': ${this.opts["copy"] ?? void 0}, 'with_mean': ${this.opts["with_mean"] ?? void 0}, 'with_std': ${this.opts["with_std"] ?? void 0}}

ctor_StandardScaler = {k: v for k, v in ctor_StandardScaler.items() if v is not None}`;
    await this._py.ex`bridgeStandardScaler[${this.id}] = StandardScaler(**ctor_StandardScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStandardScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the mean and std to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before fit()");
    }
    await this._py.ex`pms_StandardScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StandardScaler_fit = {k: v for k, v in pms_StandardScaler_fit.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_fit = bridgeStandardScaler[${this.id}].fit(**pms_StandardScaler_fit)`;
    return this._py`res_StandardScaler_fit.tolist() if hasattr(res_StandardScaler_fit, 'tolist') else res_StandardScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_StandardScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_StandardScaler_fit_transform = {k: v for k, v in pms_StandardScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_fit_transform = bridgeStandardScaler[${this.id}].fit_transform(**pms_StandardScaler_fit_transform)`;
    return this._py`res_StandardScaler_fit_transform.tolist() if hasattr(res_StandardScaler_fit_transform, 'tolist') else res_StandardScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_StandardScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_StandardScaler_get_feature_names_out = {k: v for k, v in pms_StandardScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_get_feature_names_out = bridgeStandardScaler[${this.id}].get_feature_names_out(**pms_StandardScaler_get_feature_names_out)`;
    return this._py`res_StandardScaler_get_feature_names_out.tolist() if hasattr(res_StandardScaler_get_feature_names_out, 'tolist') else res_StandardScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StandardScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StandardScaler_get_metadata_routing = {k: v for k, v in pms_StandardScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_get_metadata_routing = bridgeStandardScaler[${this.id}].get_metadata_routing(**pms_StandardScaler_get_metadata_routing)`;
    return this._py`res_StandardScaler_get_metadata_routing.tolist() if hasattr(res_StandardScaler_get_metadata_routing, 'tolist') else res_StandardScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_StandardScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_inverse_transform = {k: v for k, v in pms_StandardScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_inverse_transform = bridgeStandardScaler[${this.id}].inverse_transform(**pms_StandardScaler_inverse_transform)`;
    return this._py`res_StandardScaler_inverse_transform.tolist() if hasattr(res_StandardScaler_inverse_transform, 'tolist') else res_StandardScaler_inverse_transform`;
  }
  /**
      Online computation of mean and std on X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.StandardScaler.fit "sklearn.preprocessing.StandardScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
  
      The algorithm for incremental mean and std is given in Equation 1.5a,b in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. “Algorithms for computing the sample variance: Analysis and recommendations.” The American Statistician 37.3 (1983): 242-247:
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_StandardScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StandardScaler_partial_fit = {k: v for k, v in pms_StandardScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_partial_fit = bridgeStandardScaler[${this.id}].partial_fit(**pms_StandardScaler_partial_fit)`;
    return this._py`res_StandardScaler_partial_fit.tolist() if hasattr(res_StandardScaler_partial_fit, 'tolist') else res_StandardScaler_partial_fit`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StandardScaler_set_fit_request = {k: v for k, v in pms_StandardScaler_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_fit_request = bridgeStandardScaler[${this.id}].set_fit_request(**pms_StandardScaler_set_fit_request)`;
    return this._py`res_StandardScaler_set_fit_request.tolist() if hasattr(res_StandardScaler_set_fit_request, 'tolist') else res_StandardScaler_set_fit_request`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_inverse_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_set_inverse_transform_request = {k: v for k, v in pms_StandardScaler_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_inverse_transform_request = bridgeStandardScaler[${this.id}].set_inverse_transform_request(**pms_StandardScaler_set_inverse_transform_request)`;
    return this._py`res_StandardScaler_set_inverse_transform_request.tolist() if hasattr(res_StandardScaler_set_inverse_transform_request, 'tolist') else res_StandardScaler_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before set_output()");
    }
    await this._py.ex`pms_StandardScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_StandardScaler_set_output = {k: v for k, v in pms_StandardScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_output = bridgeStandardScaler[${this.id}].set_output(**pms_StandardScaler_set_output)`;
    return this._py`res_StandardScaler_set_output.tolist() if hasattr(res_StandardScaler_set_output, 'tolist') else res_StandardScaler_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StandardScaler_set_partial_fit_request = {k: v for k, v in pms_StandardScaler_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_partial_fit_request = bridgeStandardScaler[${this.id}].set_partial_fit_request(**pms_StandardScaler_set_partial_fit_request)`;
    return this._py`res_StandardScaler_set_partial_fit_request.tolist() if hasattr(res_StandardScaler_set_partial_fit_request, 'tolist') else res_StandardScaler_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_set_transform_request = {k: v for k, v in pms_StandardScaler_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_transform_request = bridgeStandardScaler[${this.id}].set_transform_request(**pms_StandardScaler_set_transform_request)`;
    return this._py`res_StandardScaler_set_transform_request.tolist() if hasattr(res_StandardScaler_set_transform_request, 'tolist') else res_StandardScaler_set_transform_request`;
  }
  /**
    Perform standardization by centering and scaling.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before transform()");
    }
    await this._py.ex`pms_StandardScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_transform = {k: v for k, v in pms_StandardScaler_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_transform = bridgeStandardScaler[${this.id}].transform(**pms_StandardScaler_transform)`;
    return this._py`res_StandardScaler_transform.tolist() if hasattr(res_StandardScaler_transform, 'tolist') else res_StandardScaler_transform`;
  }
  /**
    Per feature relative scaling of the data to achieve zero mean and unit variance. Generally this is calculated using `np.sqrt(var\_)`. If a variance is zero, we can’t achieve unit variance, and the data is left as-is, giving a scaling factor of 1. `scale\_` is equal to `undefined` when `with\_std=False`.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_scale_ = bridgeStandardScaler[${this.id}].scale_`;
      return this._py`attr_StandardScaler_scale_.tolist() if hasattr(attr_StandardScaler_scale_, 'tolist') else attr_StandardScaler_scale_`;
    })();
  }
  /**
    The mean value for each feature in the training set. Equal to `undefined` when `with\_mean=False` and `with\_std=False`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_mean_ = bridgeStandardScaler[${this.id}].mean_`;
      return this._py`attr_StandardScaler_mean_.tolist() if hasattr(attr_StandardScaler_mean_, 'tolist') else attr_StandardScaler_mean_`;
    })();
  }
  /**
    The variance for each feature in the training set. Used to compute `scale\_`. Equal to `undefined` when `with\_mean=False` and `with\_std=False`.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_var_ = bridgeStandardScaler[${this.id}].var_`;
      return this._py`attr_StandardScaler_var_.tolist() if hasattr(attr_StandardScaler_var_, 'tolist') else attr_StandardScaler_var_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_n_features_in_ = bridgeStandardScaler[${this.id}].n_features_in_`;
      return this._py`attr_StandardScaler_n_features_in_.tolist() if hasattr(attr_StandardScaler_n_features_in_, 'tolist') else attr_StandardScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_feature_names_in_ = bridgeStandardScaler[${this.id}].feature_names_in_`;
      return this._py`attr_StandardScaler_feature_names_in_.tolist() if hasattr(attr_StandardScaler_feature_names_in_, 'tolist') else attr_StandardScaler_feature_names_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator for each feature. If there are no missing samples, the `n\_samples\_seen` will be an integer, otherwise it will be an array of dtype int. If `sample\_weights` are used it will be a float (if no missing data) or an array of dtype float that sums the weights seen so far. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_n_samples_seen_ = bridgeStandardScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_StandardScaler_n_samples_seen_.tolist() if hasattr(attr_StandardScaler_n_samples_seen_, 'tolist') else attr_StandardScaler_n_samples_seen_`;
    })();
  }
};

// src/generated/preprocessing/TargetEncoder.ts
import crypto19 from "node:crypto";
var TargetEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TargetEncoder${crypto19.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TargetEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import TargetEncoder
try: bridgeTargetEncoder
except NameError: bridgeTargetEncoder = {}
`;
    await this._py.ex`ctor_TargetEncoder = {'categories': np.array(${this.opts["categories"] ?? void 0}) if ${this.opts["categories"] !== void 0} else None, 'target_type': ${this.opts["target_type"] ?? void 0}, 'smooth': ${this.opts["smooth"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_TargetEncoder = {k: v for k, v in ctor_TargetEncoder.items() if v is not None}`;
    await this._py.ex`bridgeTargetEncoder[${this.id}] = TargetEncoder(**ctor_TargetEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTargetEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") to X and y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before fit()");
    }
    await this._py.ex`pms_TargetEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TargetEncoder_fit = {k: v for k, v in pms_TargetEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_fit = bridgeTargetEncoder[${this.id}].fit(**pms_TargetEncoder_fit)`;
    return this._py`res_TargetEncoder_fit.tolist() if hasattr(res_TargetEncoder_fit, 'tolist') else res_TargetEncoder_fit`;
  }
  /**
    Fit [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") and transform X with the target encoding.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_TargetEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TargetEncoder_fit_transform = {k: v for k, v in pms_TargetEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_fit_transform = bridgeTargetEncoder[${this.id}].fit_transform(**pms_TargetEncoder_fit_transform)`;
    return this._py`res_TargetEncoder_fit_transform.tolist() if hasattr(res_TargetEncoder_fit_transform, 'tolist') else res_TargetEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TargetEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TargetEncoder_get_feature_names_out = {k: v for k, v in pms_TargetEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_get_feature_names_out = bridgeTargetEncoder[${this.id}].get_feature_names_out(**pms_TargetEncoder_get_feature_names_out)`;
    return this._py`res_TargetEncoder_get_feature_names_out.tolist() if hasattr(res_TargetEncoder_get_feature_names_out, 'tolist') else res_TargetEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TargetEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TargetEncoder_get_metadata_routing = {k: v for k, v in pms_TargetEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_get_metadata_routing = bridgeTargetEncoder[${this.id}].get_metadata_routing(**pms_TargetEncoder_get_metadata_routing)`;
    return this._py`res_TargetEncoder_get_metadata_routing.tolist() if hasattr(res_TargetEncoder_get_metadata_routing, 'tolist') else res_TargetEncoder_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_TargetEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TargetEncoder_set_output = {k: v for k, v in pms_TargetEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_set_output = bridgeTargetEncoder[${this.id}].set_output(**pms_TargetEncoder_set_output)`;
    return this._py`res_TargetEncoder_set_output.tolist() if hasattr(res_TargetEncoder_set_output, 'tolist') else res_TargetEncoder_set_output`;
  }
  /**
    Transform X with the target encoding.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before transform()");
    }
    await this._py.ex`pms_TargetEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TargetEncoder_transform = {k: v for k, v in pms_TargetEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_transform = bridgeTargetEncoder[${this.id}].transform(**pms_TargetEncoder_transform)`;
    return this._py`res_TargetEncoder_transform.tolist() if hasattr(res_TargetEncoder_transform, 'tolist') else res_TargetEncoder_transform`;
  }
  /**
    Encodings learnt on all of `X`. For feature `i`, `encodings\_\[i\]` are the encodings matching the categories listed in `categories\_\[i\]`.
   */
  get encodings_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing encodings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_encodings_ = bridgeTargetEncoder[${this.id}].encodings_`;
      return this._py`attr_TargetEncoder_encodings_.tolist() if hasattr(attr_TargetEncoder_encodings_, 'tolist') else attr_TargetEncoder_encodings_`;
    })();
  }
  /**
    The categories of each feature determined during fitting or specified in `categories` (in order of the features in `X` and corresponding with the output of [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform")).
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_categories_ = bridgeTargetEncoder[${this.id}].categories_`;
      return this._py`attr_TargetEncoder_categories_.tolist() if hasattr(attr_TargetEncoder_categories_, 'tolist') else attr_TargetEncoder_categories_`;
    })();
  }
  /**
    Type of target.
   */
  get target_type_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing target_type_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_target_type_ = bridgeTargetEncoder[${this.id}].target_type_`;
      return this._py`attr_TargetEncoder_target_type_.tolist() if hasattr(attr_TargetEncoder_target_type_, 'tolist') else attr_TargetEncoder_target_type_`;
    })();
  }
  /**
    The overall mean of the target. This value is only used in [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform") to encode categories.
   */
  get target_mean_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing target_mean_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_target_mean_ = bridgeTargetEncoder[${this.id}].target_mean_`;
      return this._py`attr_TargetEncoder_target_mean_.tolist() if hasattr(attr_TargetEncoder_target_mean_, 'tolist') else attr_TargetEncoder_target_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_n_features_in_ = bridgeTargetEncoder[${this.id}].n_features_in_`;
      return this._py`attr_TargetEncoder_n_features_in_.tolist() if hasattr(attr_TargetEncoder_n_features_in_, 'tolist') else attr_TargetEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_feature_names_in_ = bridgeTargetEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_TargetEncoder_feature_names_in_.tolist() if hasattr(attr_TargetEncoder_feature_names_in_, 'tolist') else attr_TargetEncoder_feature_names_in_`;
    })();
  }
};
export {
  Binarizer,
  FunctionTransformer,
  KBinsDiscretizer,
  KernelCenterer,
  LabelBinarizer,
  LabelEncoder,
  MaxAbsScaler,
  MinMaxScaler,
  MultiLabelBinarizer,
  Normalizer,
  OneHotEncoder,
  OrdinalEncoder,
  PolynomialFeatures,
  PowerTransformer,
  QuantileTransformer,
  RobustScaler,
  SplineTransformer,
  StandardScaler,
  TargetEncoder
};
//# sourceMappingURL=index.js.map