// src/generated/feature_selection/GenericUnivariateSelect.ts
import crypto from "node:crypto";
var GenericUnivariateSelect = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GenericUnivariateSelect${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GenericUnivariateSelect.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import GenericUnivariateSelect
try: bridgeGenericUnivariateSelect
except NameError: bridgeGenericUnivariateSelect = {}
`;
    await this._py.ex`ctor_GenericUnivariateSelect = {'score_func': ${this.opts["score_func"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'param': ${this.opts["param"] ?? void 0}}

ctor_GenericUnivariateSelect = {k: v for k, v in ctor_GenericUnivariateSelect.items() if v is not None}`;
    await this._py.ex`bridgeGenericUnivariateSelect[${this.id}] = GenericUnivariateSelect(**ctor_GenericUnivariateSelect)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGenericUnivariateSelect[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GenericUnivariateSelect must call init() before fit()");
    }
    await this._py.ex`pms_GenericUnivariateSelect_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GenericUnivariateSelect_fit = {k: v for k, v in pms_GenericUnivariateSelect_fit.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_fit = bridgeGenericUnivariateSelect[${this.id}].fit(**pms_GenericUnivariateSelect_fit)`;
    return this._py`res_GenericUnivariateSelect_fit.tolist() if hasattr(res_GenericUnivariateSelect_fit, 'tolist') else res_GenericUnivariateSelect_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_GenericUnivariateSelect_fit_transform = {k: v for k, v in pms_GenericUnivariateSelect_fit_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_fit_transform = bridgeGenericUnivariateSelect[${this.id}].fit_transform(**pms_GenericUnivariateSelect_fit_transform)`;
    return this._py`res_GenericUnivariateSelect_fit_transform.tolist() if hasattr(res_GenericUnivariateSelect_fit_transform, 'tolist') else res_GenericUnivariateSelect_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_GenericUnivariateSelect_get_feature_names_out = {k: v for k, v in pms_GenericUnivariateSelect_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_feature_names_out = bridgeGenericUnivariateSelect[${this.id}].get_feature_names_out(**pms_GenericUnivariateSelect_get_feature_names_out)`;
    return this._py`res_GenericUnivariateSelect_get_feature_names_out.tolist() if hasattr(res_GenericUnivariateSelect_get_feature_names_out, 'tolist') else res_GenericUnivariateSelect_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GenericUnivariateSelect_get_metadata_routing = {k: v for k, v in pms_GenericUnivariateSelect_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_metadata_routing = bridgeGenericUnivariateSelect[${this.id}].get_metadata_routing(**pms_GenericUnivariateSelect_get_metadata_routing)`;
    return this._py`res_GenericUnivariateSelect_get_metadata_routing.tolist() if hasattr(res_GenericUnivariateSelect_get_metadata_routing, 'tolist') else res_GenericUnivariateSelect_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_support()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_GenericUnivariateSelect_get_support = {k: v for k, v in pms_GenericUnivariateSelect_get_support.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_support = bridgeGenericUnivariateSelect[${this.id}].get_support(**pms_GenericUnivariateSelect_get_support)`;
    return this._py`res_GenericUnivariateSelect_get_support.tolist() if hasattr(res_GenericUnivariateSelect_get_support, 'tolist') else res_GenericUnivariateSelect_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GenericUnivariateSelect_inverse_transform = {k: v for k, v in pms_GenericUnivariateSelect_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_inverse_transform = bridgeGenericUnivariateSelect[${this.id}].inverse_transform(**pms_GenericUnivariateSelect_inverse_transform)`;
    return this._py`res_GenericUnivariateSelect_inverse_transform.tolist() if hasattr(res_GenericUnivariateSelect_inverse_transform, 'tolist') else res_GenericUnivariateSelect_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before set_output()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_GenericUnivariateSelect_set_output = {k: v for k, v in pms_GenericUnivariateSelect_set_output.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_set_output = bridgeGenericUnivariateSelect[${this.id}].set_output(**pms_GenericUnivariateSelect_set_output)`;
    return this._py`res_GenericUnivariateSelect_set_output.tolist() if hasattr(res_GenericUnivariateSelect_set_output, 'tolist') else res_GenericUnivariateSelect_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GenericUnivariateSelect_transform = {k: v for k, v in pms_GenericUnivariateSelect_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_transform = bridgeGenericUnivariateSelect[${this.id}].transform(**pms_GenericUnivariateSelect_transform)`;
    return this._py`res_GenericUnivariateSelect_transform.tolist() if hasattr(res_GenericUnivariateSelect_transform, 'tolist') else res_GenericUnivariateSelect_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_scores_ = bridgeGenericUnivariateSelect[${this.id}].scores_`;
      return this._py`attr_GenericUnivariateSelect_scores_.tolist() if hasattr(attr_GenericUnivariateSelect_scores_, 'tolist') else attr_GenericUnivariateSelect_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned scores only.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing pvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_pvalues_ = bridgeGenericUnivariateSelect[${this.id}].pvalues_`;
      return this._py`attr_GenericUnivariateSelect_pvalues_.tolist() if hasattr(attr_GenericUnivariateSelect_pvalues_, 'tolist') else attr_GenericUnivariateSelect_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_n_features_in_ = bridgeGenericUnivariateSelect[${this.id}].n_features_in_`;
      return this._py`attr_GenericUnivariateSelect_n_features_in_.tolist() if hasattr(attr_GenericUnivariateSelect_n_features_in_, 'tolist') else attr_GenericUnivariateSelect_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_feature_names_in_ = bridgeGenericUnivariateSelect[${this.id}].feature_names_in_`;
      return this._py`attr_GenericUnivariateSelect_feature_names_in_.tolist() if hasattr(attr_GenericUnivariateSelect_feature_names_in_, 'tolist') else attr_GenericUnivariateSelect_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/RFE.ts
import crypto2 from "node:crypto";
var RFE = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RFE${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RFE.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import RFE
try: bridgeRFE
except NameError: bridgeRFE = {}
`;
    await this._py.ex`ctor_RFE = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_features_to_select': ${this.opts["n_features_to_select"] ?? void 0}, 'step': ${this.opts["step"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_RFE = {k: v for k, v in ctor_RFE.items() if v is not None}`;
    await this._py.ex`bridgeRFE[${this.id}] = RFE(**ctor_RFE)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRFE[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before decision_function()");
    }
    await this._py.ex`pms_RFE_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_decision_function = {k: v for k, v in pms_RFE_decision_function.items() if v is not None}`;
    await this._py.ex`res_RFE_decision_function = bridgeRFE[${this.id}].decision_function(**pms_RFE_decision_function)`;
    return this._py`res_RFE_decision_function.tolist() if hasattr(res_RFE_decision_function, 'tolist') else res_RFE_decision_function`;
  }
  /**
    Fit the RFE model and then the underlying estimator on the selected features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before fit()");
    }
    await this._py.ex`pms_RFE_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_fit = {k: v for k, v in pms_RFE_fit.items() if v is not None}`;
    await this._py.ex`res_RFE_fit = bridgeRFE[${this.id}].fit(**pms_RFE_fit)`;
    return this._py`res_RFE_fit.tolist() if hasattr(res_RFE_fit, 'tolist') else res_RFE_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before fit_transform()");
    }
    await this._py.ex`pms_RFE_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_fit_transform = {k: v for k, v in pms_RFE_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_fit_transform = bridgeRFE[${this.id}].fit_transform(**pms_RFE_fit_transform)`;
    return this._py`res_RFE_fit_transform.tolist() if hasattr(res_RFE_fit_transform, 'tolist') else res_RFE_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_RFE_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RFE_get_feature_names_out = {k: v for k, v in pms_RFE_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RFE_get_feature_names_out = bridgeRFE[${this.id}].get_feature_names_out(**pms_RFE_get_feature_names_out)`;
    return this._py`res_RFE_get_feature_names_out.tolist() if hasattr(res_RFE_get_feature_names_out, 'tolist') else res_RFE_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RFE_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RFE_get_metadata_routing = {k: v for k, v in pms_RFE_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RFE_get_metadata_routing = bridgeRFE[${this.id}].get_metadata_routing(**pms_RFE_get_metadata_routing)`;
    return this._py`res_RFE_get_metadata_routing.tolist() if hasattr(res_RFE_get_metadata_routing, 'tolist') else res_RFE_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_support()");
    }
    await this._py.ex`pms_RFE_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_RFE_get_support = {k: v for k, v in pms_RFE_get_support.items() if v is not None}`;
    await this._py.ex`res_RFE_get_support = bridgeRFE[${this.id}].get_support(**pms_RFE_get_support)`;
    return this._py`res_RFE_get_support.tolist() if hasattr(res_RFE_get_support, 'tolist') else res_RFE_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before inverse_transform()");
    }
    await this._py.ex`pms_RFE_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_inverse_transform = {k: v for k, v in pms_RFE_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_inverse_transform = bridgeRFE[${this.id}].inverse_transform(**pms_RFE_inverse_transform)`;
    return this._py`res_RFE_inverse_transform.tolist() if hasattr(res_RFE_inverse_transform, 'tolist') else res_RFE_inverse_transform`;
  }
  /**
    Reduce X to the selected features and predict using the estimator.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict()");
    }
    await this._py.ex`pms_RFE_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict = {k: v for k, v in pms_RFE_predict.items() if v is not None}`;
    await this._py.ex`res_RFE_predict = bridgeRFE[${this.id}].predict(**pms_RFE_predict)`;
    return this._py`res_RFE_predict.tolist() if hasattr(res_RFE_predict, 'tolist') else res_RFE_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_RFE_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict_log_proba = {k: v for k, v in pms_RFE_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RFE_predict_log_proba = bridgeRFE[${this.id}].predict_log_proba(**pms_RFE_predict_log_proba)`;
    return this._py`res_RFE_predict_log_proba.tolist() if hasattr(res_RFE_predict_log_proba, 'tolist') else res_RFE_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict_proba()");
    }
    await this._py.ex`pms_RFE_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict_proba = {k: v for k, v in pms_RFE_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RFE_predict_proba = bridgeRFE[${this.id}].predict_proba(**pms_RFE_predict_proba)`;
    return this._py`res_RFE_predict_proba.tolist() if hasattr(res_RFE_predict_proba, 'tolist') else res_RFE_predict_proba`;
  }
  /**
    Reduce X to the selected features and return the score of the estimator.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before score()");
    }
    await this._py.ex`pms_RFE_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_score = {k: v for k, v in pms_RFE_score.items() if v is not None}`;
    await this._py.ex`res_RFE_score = bridgeRFE[${this.id}].score(**pms_RFE_score)`;
    return this._py`res_RFE_score.tolist() if hasattr(res_RFE_score, 'tolist') else res_RFE_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before set_output()");
    }
    await this._py.ex`pms_RFE_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RFE_set_output = {k: v for k, v in pms_RFE_set_output.items() if v is not None}`;
    await this._py.ex`res_RFE_set_output = bridgeRFE[${this.id}].set_output(**pms_RFE_set_output)`;
    return this._py`res_RFE_set_output.tolist() if hasattr(res_RFE_set_output, 'tolist') else res_RFE_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before transform()");
    }
    await this._py.ex`pms_RFE_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_transform = {k: v for k, v in pms_RFE_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_transform = bridgeRFE[${this.id}].transform(**pms_RFE_transform)`;
    return this._py`res_RFE_transform.tolist() if hasattr(res_RFE_transform, 'tolist') else res_RFE_transform`;
  }
  /**
    The fitted estimator used to select features.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing estimator_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_estimator_ = bridgeRFE[${this.id}].estimator_`;
      return this._py`attr_RFE_estimator_.tolist() if hasattr(attr_RFE_estimator_, 'tolist') else attr_RFE_estimator_`;
    })();
  }
  /**
    The number of selected features.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_n_features_ = bridgeRFE[${this.id}].n_features_`;
      return this._py`attr_RFE_n_features_.tolist() if hasattr(attr_RFE_n_features_, 'tolist') else attr_RFE_n_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_n_features_in_ = bridgeRFE[${this.id}].n_features_in_`;
      return this._py`attr_RFE_n_features_in_.tolist() if hasattr(attr_RFE_n_features_in_, 'tolist') else attr_RFE_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_feature_names_in_ = bridgeRFE[${this.id}].feature_names_in_`;
      return this._py`attr_RFE_feature_names_in_.tolist() if hasattr(attr_RFE_feature_names_in_, 'tolist') else attr_RFE_feature_names_in_`;
    })();
  }
  /**
    The feature ranking, such that `ranking\_\[i\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.
   */
  get ranking_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing ranking_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_ranking_ = bridgeRFE[${this.id}].ranking_`;
      return this._py`attr_RFE_ranking_.tolist() if hasattr(attr_RFE_ranking_, 'tolist') else attr_RFE_ranking_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_support_ = bridgeRFE[${this.id}].support_`;
      return this._py`attr_RFE_support_.tolist() if hasattr(attr_RFE_support_, 'tolist') else attr_RFE_support_`;
    })();
  }
};

// src/generated/feature_selection/RFECV.ts
import crypto3 from "node:crypto";
var RFECV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RFECV${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RFECV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import RFECV
try: bridgeRFECV
except NameError: bridgeRFECV = {}
`;
    await this._py.ex`ctor_RFECV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'step': ${this.opts["step"] ?? void 0}, 'min_features_to_select': ${this.opts["min_features_to_select"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_RFECV = {k: v for k, v in ctor_RFECV.items() if v is not None}`;
    await this._py.ex`bridgeRFECV[${this.id}] = RFECV(**ctor_RFECV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRFECV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before decision_function()");
    }
    await this._py.ex`pms_RFECV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_decision_function = {k: v for k, v in pms_RFECV_decision_function.items() if v is not None}`;
    await this._py.ex`res_RFECV_decision_function = bridgeRFECV[${this.id}].decision_function(**pms_RFECV_decision_function)`;
    return this._py`res_RFECV_decision_function.tolist() if hasattr(res_RFECV_decision_function, 'tolist') else res_RFECV_decision_function`;
  }
  /**
    Fit the RFE model and automatically tune the number of selected features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before fit()");
    }
    await this._py.ex`pms_RFECV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RFECV_fit = {k: v for k, v in pms_RFECV_fit.items() if v is not None}`;
    await this._py.ex`res_RFECV_fit = bridgeRFECV[${this.id}].fit(**pms_RFECV_fit)`;
    return this._py`res_RFECV_fit.tolist() if hasattr(res_RFECV_fit, 'tolist') else res_RFECV_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before fit_transform()");
    }
    await this._py.ex`pms_RFECV_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFECV_fit_transform = {k: v for k, v in pms_RFECV_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_fit_transform = bridgeRFECV[${this.id}].fit_transform(**pms_RFECV_fit_transform)`;
    return this._py`res_RFECV_fit_transform.tolist() if hasattr(res_RFECV_fit_transform, 'tolist') else res_RFECV_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_RFECV_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RFECV_get_feature_names_out = {k: v for k, v in pms_RFECV_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_feature_names_out = bridgeRFECV[${this.id}].get_feature_names_out(**pms_RFECV_get_feature_names_out)`;
    return this._py`res_RFECV_get_feature_names_out.tolist() if hasattr(res_RFECV_get_feature_names_out, 'tolist') else res_RFECV_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RFECV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RFECV_get_metadata_routing = {k: v for k, v in pms_RFECV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_metadata_routing = bridgeRFECV[${this.id}].get_metadata_routing(**pms_RFECV_get_metadata_routing)`;
    return this._py`res_RFECV_get_metadata_routing.tolist() if hasattr(res_RFECV_get_metadata_routing, 'tolist') else res_RFECV_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_support()");
    }
    await this._py.ex`pms_RFECV_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_RFECV_get_support = {k: v for k, v in pms_RFECV_get_support.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_support = bridgeRFECV[${this.id}].get_support(**pms_RFECV_get_support)`;
    return this._py`res_RFECV_get_support.tolist() if hasattr(res_RFECV_get_support, 'tolist') else res_RFECV_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before inverse_transform()");
    }
    await this._py.ex`pms_RFECV_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_inverse_transform = {k: v for k, v in pms_RFECV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_inverse_transform = bridgeRFECV[${this.id}].inverse_transform(**pms_RFECV_inverse_transform)`;
    return this._py`res_RFECV_inverse_transform.tolist() if hasattr(res_RFECV_inverse_transform, 'tolist') else res_RFECV_inverse_transform`;
  }
  /**
    Reduce X to the selected features and predict using the estimator.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict()");
    }
    await this._py.ex`pms_RFECV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict = {k: v for k, v in pms_RFECV_predict.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict = bridgeRFECV[${this.id}].predict(**pms_RFECV_predict)`;
    return this._py`res_RFECV_predict.tolist() if hasattr(res_RFECV_predict, 'tolist') else res_RFECV_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_RFECV_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict_log_proba = {k: v for k, v in pms_RFECV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict_log_proba = bridgeRFECV[${this.id}].predict_log_proba(**pms_RFECV_predict_log_proba)`;
    return this._py`res_RFECV_predict_log_proba.tolist() if hasattr(res_RFECV_predict_log_proba, 'tolist') else res_RFECV_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict_proba()");
    }
    await this._py.ex`pms_RFECV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict_proba = {k: v for k, v in pms_RFECV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict_proba = bridgeRFECV[${this.id}].predict_proba(**pms_RFECV_predict_proba)`;
    return this._py`res_RFECV_predict_proba.tolist() if hasattr(res_RFECV_predict_proba, 'tolist') else res_RFECV_predict_proba`;
  }
  /**
    Reduce X to the selected features and return the score of the estimator.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before score()");
    }
    await this._py.ex`pms_RFECV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFECV_score = {k: v for k, v in pms_RFECV_score.items() if v is not None}`;
    await this._py.ex`res_RFECV_score = bridgeRFECV[${this.id}].score(**pms_RFECV_score)`;
    return this._py`res_RFECV_score.tolist() if hasattr(res_RFECV_score, 'tolist') else res_RFECV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_RFECV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_RFECV_set_fit_request = {k: v for k, v in pms_RFECV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RFECV_set_fit_request = bridgeRFECV[${this.id}].set_fit_request(**pms_RFECV_set_fit_request)`;
    return this._py`res_RFECV_set_fit_request.tolist() if hasattr(res_RFECV_set_fit_request, 'tolist') else res_RFECV_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before set_output()");
    }
    await this._py.ex`pms_RFECV_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RFECV_set_output = {k: v for k, v in pms_RFECV_set_output.items() if v is not None}`;
    await this._py.ex`res_RFECV_set_output = bridgeRFECV[${this.id}].set_output(**pms_RFECV_set_output)`;
    return this._py`res_RFECV_set_output.tolist() if hasattr(res_RFECV_set_output, 'tolist') else res_RFECV_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before transform()");
    }
    await this._py.ex`pms_RFECV_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_transform = {k: v for k, v in pms_RFECV_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_transform = bridgeRFECV[${this.id}].transform(**pms_RFECV_transform)`;
    return this._py`res_RFECV_transform.tolist() if hasattr(res_RFECV_transform, 'tolist') else res_RFECV_transform`;
  }
  /**
    The fitted estimator used to select features.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing estimator_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_estimator_ = bridgeRFECV[${this.id}].estimator_`;
      return this._py`attr_RFECV_estimator_.tolist() if hasattr(attr_RFECV_estimator_, 'tolist') else attr_RFECV_estimator_`;
    })();
  }
  /**
    A dict with keys:
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing cv_results_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_cv_results_ = bridgeRFECV[${this.id}].cv_results_`;
      return this._py`attr_RFECV_cv_results_.tolist() if hasattr(attr_RFECV_cv_results_, 'tolist') else attr_RFECV_cv_results_`;
    })();
  }
  /**
    The number of selected features with cross-validation.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_n_features_ = bridgeRFECV[${this.id}].n_features_`;
      return this._py`attr_RFECV_n_features_.tolist() if hasattr(attr_RFECV_n_features_, 'tolist') else attr_RFECV_n_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_n_features_in_ = bridgeRFECV[${this.id}].n_features_in_`;
      return this._py`attr_RFECV_n_features_in_.tolist() if hasattr(attr_RFECV_n_features_in_, 'tolist') else attr_RFECV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RFECV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RFECV_feature_names_in_ = bridgeRFECV[${this.id}].feature_names_in_`;
      return this._py`attr_RFECV_feature_names_in_.tolist() if hasattr(attr_RFECV_feature_names_in_, 'tolist') else attr_RFECV_feature_names_in_`;
    })();
  }
  /**
    The feature ranking, such that `ranking\_\[i\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.
   */
  get ranking_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing ranking_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_ranking_ = bridgeRFECV[${this.id}].ranking_`;
      return this._py`attr_RFECV_ranking_.tolist() if hasattr(attr_RFECV_ranking_, 'tolist') else attr_RFECV_ranking_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_support_ = bridgeRFECV[${this.id}].support_`;
      return this._py`attr_RFECV_support_.tolist() if hasattr(attr_RFECV_support_, 'tolist') else attr_RFECV_support_`;
    })();
  }
};

// src/generated/feature_selection/SelectFdr.ts
import crypto4 from "node:crypto";
var SelectFdr = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFdr${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFdr.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFdr
try: bridgeSelectFdr
except NameError: bridgeSelectFdr = {}
`;
    await this._py.ex`ctor_SelectFdr = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFdr = {k: v for k, v in ctor_SelectFdr.items() if v is not None}`;
    await this._py.ex`bridgeSelectFdr[${this.id}] = SelectFdr(**ctor_SelectFdr)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFdr[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before fit()");
    }
    await this._py.ex`pms_SelectFdr_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFdr_fit = {k: v for k, v in pms_SelectFdr_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_fit = bridgeSelectFdr[${this.id}].fit(**pms_SelectFdr_fit)`;
    return this._py`res_SelectFdr_fit.tolist() if hasattr(res_SelectFdr_fit, 'tolist') else res_SelectFdr_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFdr_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFdr_fit_transform = {k: v for k, v in pms_SelectFdr_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_fit_transform = bridgeSelectFdr[${this.id}].fit_transform(**pms_SelectFdr_fit_transform)`;
    return this._py`res_SelectFdr_fit_transform.tolist() if hasattr(res_SelectFdr_fit_transform, 'tolist') else res_SelectFdr_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFdr_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFdr_get_feature_names_out = {k: v for k, v in pms_SelectFdr_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_feature_names_out = bridgeSelectFdr[${this.id}].get_feature_names_out(**pms_SelectFdr_get_feature_names_out)`;
    return this._py`res_SelectFdr_get_feature_names_out.tolist() if hasattr(res_SelectFdr_get_feature_names_out, 'tolist') else res_SelectFdr_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFdr_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFdr_get_metadata_routing = {k: v for k, v in pms_SelectFdr_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_metadata_routing = bridgeSelectFdr[${this.id}].get_metadata_routing(**pms_SelectFdr_get_metadata_routing)`;
    return this._py`res_SelectFdr_get_metadata_routing.tolist() if hasattr(res_SelectFdr_get_metadata_routing, 'tolist') else res_SelectFdr_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFdr_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFdr_get_support = {k: v for k, v in pms_SelectFdr_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_support = bridgeSelectFdr[${this.id}].get_support(**pms_SelectFdr_get_support)`;
    return this._py`res_SelectFdr_get_support.tolist() if hasattr(res_SelectFdr_get_support, 'tolist') else res_SelectFdr_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFdr_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFdr_inverse_transform = {k: v for k, v in pms_SelectFdr_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_inverse_transform = bridgeSelectFdr[${this.id}].inverse_transform(**pms_SelectFdr_inverse_transform)`;
    return this._py`res_SelectFdr_inverse_transform.tolist() if hasattr(res_SelectFdr_inverse_transform, 'tolist') else res_SelectFdr_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFdr_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFdr_set_output = {k: v for k, v in pms_SelectFdr_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_set_output = bridgeSelectFdr[${this.id}].set_output(**pms_SelectFdr_set_output)`;
    return this._py`res_SelectFdr_set_output.tolist() if hasattr(res_SelectFdr_set_output, 'tolist') else res_SelectFdr_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before transform()");
    }
    await this._py.ex`pms_SelectFdr_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFdr_transform = {k: v for k, v in pms_SelectFdr_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_transform = bridgeSelectFdr[${this.id}].transform(**pms_SelectFdr_transform)`;
    return this._py`res_SelectFdr_transform.tolist() if hasattr(res_SelectFdr_transform, 'tolist') else res_SelectFdr_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_scores_ = bridgeSelectFdr[${this.id}].scores_`;
      return this._py`attr_SelectFdr_scores_.tolist() if hasattr(attr_SelectFdr_scores_, 'tolist') else attr_SelectFdr_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_pvalues_ = bridgeSelectFdr[${this.id}].pvalues_`;
      return this._py`attr_SelectFdr_pvalues_.tolist() if hasattr(attr_SelectFdr_pvalues_, 'tolist') else attr_SelectFdr_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_n_features_in_ = bridgeSelectFdr[${this.id}].n_features_in_`;
      return this._py`attr_SelectFdr_n_features_in_.tolist() if hasattr(attr_SelectFdr_n_features_in_, 'tolist') else attr_SelectFdr_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_feature_names_in_ = bridgeSelectFdr[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFdr_feature_names_in_.tolist() if hasattr(attr_SelectFdr_feature_names_in_, 'tolist') else attr_SelectFdr_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFpr.ts
import crypto5 from "node:crypto";
var SelectFpr = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFpr${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFpr.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFpr
try: bridgeSelectFpr
except NameError: bridgeSelectFpr = {}
`;
    await this._py.ex`ctor_SelectFpr = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFpr = {k: v for k, v in ctor_SelectFpr.items() if v is not None}`;
    await this._py.ex`bridgeSelectFpr[${this.id}] = SelectFpr(**ctor_SelectFpr)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFpr[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before fit()");
    }
    await this._py.ex`pms_SelectFpr_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFpr_fit = {k: v for k, v in pms_SelectFpr_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_fit = bridgeSelectFpr[${this.id}].fit(**pms_SelectFpr_fit)`;
    return this._py`res_SelectFpr_fit.tolist() if hasattr(res_SelectFpr_fit, 'tolist') else res_SelectFpr_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFpr_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFpr_fit_transform = {k: v for k, v in pms_SelectFpr_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_fit_transform = bridgeSelectFpr[${this.id}].fit_transform(**pms_SelectFpr_fit_transform)`;
    return this._py`res_SelectFpr_fit_transform.tolist() if hasattr(res_SelectFpr_fit_transform, 'tolist') else res_SelectFpr_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFpr_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFpr_get_feature_names_out = {k: v for k, v in pms_SelectFpr_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_feature_names_out = bridgeSelectFpr[${this.id}].get_feature_names_out(**pms_SelectFpr_get_feature_names_out)`;
    return this._py`res_SelectFpr_get_feature_names_out.tolist() if hasattr(res_SelectFpr_get_feature_names_out, 'tolist') else res_SelectFpr_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFpr_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFpr_get_metadata_routing = {k: v for k, v in pms_SelectFpr_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_metadata_routing = bridgeSelectFpr[${this.id}].get_metadata_routing(**pms_SelectFpr_get_metadata_routing)`;
    return this._py`res_SelectFpr_get_metadata_routing.tolist() if hasattr(res_SelectFpr_get_metadata_routing, 'tolist') else res_SelectFpr_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFpr_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFpr_get_support = {k: v for k, v in pms_SelectFpr_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_support = bridgeSelectFpr[${this.id}].get_support(**pms_SelectFpr_get_support)`;
    return this._py`res_SelectFpr_get_support.tolist() if hasattr(res_SelectFpr_get_support, 'tolist') else res_SelectFpr_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFpr_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFpr_inverse_transform = {k: v for k, v in pms_SelectFpr_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_inverse_transform = bridgeSelectFpr[${this.id}].inverse_transform(**pms_SelectFpr_inverse_transform)`;
    return this._py`res_SelectFpr_inverse_transform.tolist() if hasattr(res_SelectFpr_inverse_transform, 'tolist') else res_SelectFpr_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFpr_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFpr_set_output = {k: v for k, v in pms_SelectFpr_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_set_output = bridgeSelectFpr[${this.id}].set_output(**pms_SelectFpr_set_output)`;
    return this._py`res_SelectFpr_set_output.tolist() if hasattr(res_SelectFpr_set_output, 'tolist') else res_SelectFpr_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before transform()");
    }
    await this._py.ex`pms_SelectFpr_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFpr_transform = {k: v for k, v in pms_SelectFpr_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_transform = bridgeSelectFpr[${this.id}].transform(**pms_SelectFpr_transform)`;
    return this._py`res_SelectFpr_transform.tolist() if hasattr(res_SelectFpr_transform, 'tolist') else res_SelectFpr_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_scores_ = bridgeSelectFpr[${this.id}].scores_`;
      return this._py`attr_SelectFpr_scores_.tolist() if hasattr(attr_SelectFpr_scores_, 'tolist') else attr_SelectFpr_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_pvalues_ = bridgeSelectFpr[${this.id}].pvalues_`;
      return this._py`attr_SelectFpr_pvalues_.tolist() if hasattr(attr_SelectFpr_pvalues_, 'tolist') else attr_SelectFpr_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_n_features_in_ = bridgeSelectFpr[${this.id}].n_features_in_`;
      return this._py`attr_SelectFpr_n_features_in_.tolist() if hasattr(attr_SelectFpr_n_features_in_, 'tolist') else attr_SelectFpr_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_feature_names_in_ = bridgeSelectFpr[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFpr_feature_names_in_.tolist() if hasattr(attr_SelectFpr_feature_names_in_, 'tolist') else attr_SelectFpr_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFromModel.ts
import crypto6 from "node:crypto";
var SelectFromModel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFromModel${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFromModel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFromModel
try: bridgeSelectFromModel
except NameError: bridgeSelectFromModel = {}
`;
    await this._py.ex`ctor_SelectFromModel = {'estimator': ${this.opts["estimator"] ?? void 0}, 'threshold': ${this.opts["threshold"] ?? void 0}, 'prefit': ${this.opts["prefit"] ?? void 0}, 'norm_order': ${this.opts["norm_order"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_SelectFromModel = {k: v for k, v in ctor_SelectFromModel.items() if v is not None}`;
    await this._py.ex`bridgeSelectFromModel[${this.id}] = SelectFromModel(**ctor_SelectFromModel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFromModel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SelectFromModel meta-transformer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before fit()");
    }
    await this._py.ex`pms_SelectFromModel_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_fit = {k: v for k, v in pms_SelectFromModel_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_fit = bridgeSelectFromModel[${this.id}].fit(**pms_SelectFromModel_fit)`;
    return this._py`res_SelectFromModel_fit.tolist() if hasattr(res_SelectFromModel_fit, 'tolist') else res_SelectFromModel_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFromModel_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_fit_transform = {k: v for k, v in pms_SelectFromModel_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_fit_transform = bridgeSelectFromModel[${this.id}].fit_transform(**pms_SelectFromModel_fit_transform)`;
    return this._py`res_SelectFromModel_fit_transform.tolist() if hasattr(res_SelectFromModel_fit_transform, 'tolist') else res_SelectFromModel_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFromModel_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFromModel_get_feature_names_out = {k: v for k, v in pms_SelectFromModel_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_feature_names_out = bridgeSelectFromModel[${this.id}].get_feature_names_out(**pms_SelectFromModel_get_feature_names_out)`;
    return this._py`res_SelectFromModel_get_feature_names_out.tolist() if hasattr(res_SelectFromModel_get_feature_names_out, 'tolist') else res_SelectFromModel_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFromModel_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFromModel_get_metadata_routing = {k: v for k, v in pms_SelectFromModel_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_metadata_routing = bridgeSelectFromModel[${this.id}].get_metadata_routing(**pms_SelectFromModel_get_metadata_routing)`;
    return this._py`res_SelectFromModel_get_metadata_routing.tolist() if hasattr(res_SelectFromModel_get_metadata_routing, 'tolist') else res_SelectFromModel_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFromModel_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFromModel_get_support = {k: v for k, v in pms_SelectFromModel_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_support = bridgeSelectFromModel[${this.id}].get_support(**pms_SelectFromModel_get_support)`;
    return this._py`res_SelectFromModel_get_support.tolist() if hasattr(res_SelectFromModel_get_support, 'tolist') else res_SelectFromModel_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectFromModel_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFromModel_inverse_transform = {k: v for k, v in pms_SelectFromModel_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_inverse_transform = bridgeSelectFromModel[${this.id}].inverse_transform(**pms_SelectFromModel_inverse_transform)`;
    return this._py`res_SelectFromModel_inverse_transform.tolist() if hasattr(res_SelectFromModel_inverse_transform, 'tolist') else res_SelectFromModel_inverse_transform`;
  }
  /**
    Fit the SelectFromModel meta-transformer only once.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before partial_fit()");
    }
    await this._py.ex`pms_SelectFromModel_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_partial_fit = {k: v for k, v in pms_SelectFromModel_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_partial_fit = bridgeSelectFromModel[${this.id}].partial_fit(**pms_SelectFromModel_partial_fit)`;
    return this._py`res_SelectFromModel_partial_fit.tolist() if hasattr(res_SelectFromModel_partial_fit, 'tolist') else res_SelectFromModel_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFromModel_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFromModel_set_output = {k: v for k, v in pms_SelectFromModel_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_set_output = bridgeSelectFromModel[${this.id}].set_output(**pms_SelectFromModel_set_output)`;
    return this._py`res_SelectFromModel_set_output.tolist() if hasattr(res_SelectFromModel_set_output, 'tolist') else res_SelectFromModel_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before transform()");
    }
    await this._py.ex`pms_SelectFromModel_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFromModel_transform = {k: v for k, v in pms_SelectFromModel_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_transform = bridgeSelectFromModel[${this.id}].transform(**pms_SelectFromModel_transform)`;
    return this._py`res_SelectFromModel_transform.tolist() if hasattr(res_SelectFromModel_transform, 'tolist') else res_SelectFromModel_transform`;
  }
  /**
    The base estimator from which the transformer is built. This attribute exist only when `fit` has been called.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_estimator_ = bridgeSelectFromModel[${this.id}].estimator_`;
      return this._py`attr_SelectFromModel_estimator_.tolist() if hasattr(attr_SelectFromModel_estimator_, 'tolist') else attr_SelectFromModel_estimator_`;
    })();
  }
  /**
    Maximum number of features calculated during [fit](../../glossary.html#term-fit). Only defined if the `max\_features` is not `undefined`.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_max_features_ = bridgeSelectFromModel[${this.id}].max_features_`;
      return this._py`attr_SelectFromModel_max_features_.tolist() if hasattr(attr_SelectFromModel_max_features_, 'tolist') else attr_SelectFromModel_max_features_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_feature_names_in_ = bridgeSelectFromModel[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFromModel_feature_names_in_.tolist() if hasattr(attr_SelectFromModel_feature_names_in_, 'tolist') else attr_SelectFromModel_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFwe.ts
import crypto7 from "node:crypto";
var SelectFwe = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFwe${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFwe.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFwe
try: bridgeSelectFwe
except NameError: bridgeSelectFwe = {}
`;
    await this._py.ex`ctor_SelectFwe = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFwe = {k: v for k, v in ctor_SelectFwe.items() if v is not None}`;
    await this._py.ex`bridgeSelectFwe[${this.id}] = SelectFwe(**ctor_SelectFwe)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFwe[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before fit()");
    }
    await this._py.ex`pms_SelectFwe_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFwe_fit = {k: v for k, v in pms_SelectFwe_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_fit = bridgeSelectFwe[${this.id}].fit(**pms_SelectFwe_fit)`;
    return this._py`res_SelectFwe_fit.tolist() if hasattr(res_SelectFwe_fit, 'tolist') else res_SelectFwe_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFwe_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFwe_fit_transform = {k: v for k, v in pms_SelectFwe_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_fit_transform = bridgeSelectFwe[${this.id}].fit_transform(**pms_SelectFwe_fit_transform)`;
    return this._py`res_SelectFwe_fit_transform.tolist() if hasattr(res_SelectFwe_fit_transform, 'tolist') else res_SelectFwe_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFwe_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFwe_get_feature_names_out = {k: v for k, v in pms_SelectFwe_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_feature_names_out = bridgeSelectFwe[${this.id}].get_feature_names_out(**pms_SelectFwe_get_feature_names_out)`;
    return this._py`res_SelectFwe_get_feature_names_out.tolist() if hasattr(res_SelectFwe_get_feature_names_out, 'tolist') else res_SelectFwe_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFwe_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFwe_get_metadata_routing = {k: v for k, v in pms_SelectFwe_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_metadata_routing = bridgeSelectFwe[${this.id}].get_metadata_routing(**pms_SelectFwe_get_metadata_routing)`;
    return this._py`res_SelectFwe_get_metadata_routing.tolist() if hasattr(res_SelectFwe_get_metadata_routing, 'tolist') else res_SelectFwe_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFwe_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFwe_get_support = {k: v for k, v in pms_SelectFwe_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_support = bridgeSelectFwe[${this.id}].get_support(**pms_SelectFwe_get_support)`;
    return this._py`res_SelectFwe_get_support.tolist() if hasattr(res_SelectFwe_get_support, 'tolist') else res_SelectFwe_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFwe_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFwe_inverse_transform = {k: v for k, v in pms_SelectFwe_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_inverse_transform = bridgeSelectFwe[${this.id}].inverse_transform(**pms_SelectFwe_inverse_transform)`;
    return this._py`res_SelectFwe_inverse_transform.tolist() if hasattr(res_SelectFwe_inverse_transform, 'tolist') else res_SelectFwe_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFwe_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFwe_set_output = {k: v for k, v in pms_SelectFwe_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_set_output = bridgeSelectFwe[${this.id}].set_output(**pms_SelectFwe_set_output)`;
    return this._py`res_SelectFwe_set_output.tolist() if hasattr(res_SelectFwe_set_output, 'tolist') else res_SelectFwe_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before transform()");
    }
    await this._py.ex`pms_SelectFwe_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFwe_transform = {k: v for k, v in pms_SelectFwe_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_transform = bridgeSelectFwe[${this.id}].transform(**pms_SelectFwe_transform)`;
    return this._py`res_SelectFwe_transform.tolist() if hasattr(res_SelectFwe_transform, 'tolist') else res_SelectFwe_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_scores_ = bridgeSelectFwe[${this.id}].scores_`;
      return this._py`attr_SelectFwe_scores_.tolist() if hasattr(attr_SelectFwe_scores_, 'tolist') else attr_SelectFwe_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_pvalues_ = bridgeSelectFwe[${this.id}].pvalues_`;
      return this._py`attr_SelectFwe_pvalues_.tolist() if hasattr(attr_SelectFwe_pvalues_, 'tolist') else attr_SelectFwe_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_n_features_in_ = bridgeSelectFwe[${this.id}].n_features_in_`;
      return this._py`attr_SelectFwe_n_features_in_.tolist() if hasattr(attr_SelectFwe_n_features_in_, 'tolist') else attr_SelectFwe_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_feature_names_in_ = bridgeSelectFwe[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFwe_feature_names_in_.tolist() if hasattr(attr_SelectFwe_feature_names_in_, 'tolist') else attr_SelectFwe_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectKBest.ts
import crypto8 from "node:crypto";
var SelectKBest = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectKBest${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectKBest.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectKBest
try: bridgeSelectKBest
except NameError: bridgeSelectKBest = {}
`;
    await this._py.ex`ctor_SelectKBest = {'score_func': ${this.opts["score_func"] ?? void 0}, 'k': ${this.opts["k"] ?? void 0}}

ctor_SelectKBest = {k: v for k, v in ctor_SelectKBest.items() if v is not None}`;
    await this._py.ex`bridgeSelectKBest[${this.id}] = SelectKBest(**ctor_SelectKBest)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectKBest[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before fit()");
    }
    await this._py.ex`pms_SelectKBest_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectKBest_fit = {k: v for k, v in pms_SelectKBest_fit.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_fit = bridgeSelectKBest[${this.id}].fit(**pms_SelectKBest_fit)`;
    return this._py`res_SelectKBest_fit.tolist() if hasattr(res_SelectKBest_fit, 'tolist') else res_SelectKBest_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectKBest_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectKBest_fit_transform = {k: v for k, v in pms_SelectKBest_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_fit_transform = bridgeSelectKBest[${this.id}].fit_transform(**pms_SelectKBest_fit_transform)`;
    return this._py`res_SelectKBest_fit_transform.tolist() if hasattr(res_SelectKBest_fit_transform, 'tolist') else res_SelectKBest_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectKBest_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectKBest_get_feature_names_out = {k: v for k, v in pms_SelectKBest_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_feature_names_out = bridgeSelectKBest[${this.id}].get_feature_names_out(**pms_SelectKBest_get_feature_names_out)`;
    return this._py`res_SelectKBest_get_feature_names_out.tolist() if hasattr(res_SelectKBest_get_feature_names_out, 'tolist') else res_SelectKBest_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectKBest_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectKBest_get_metadata_routing = {k: v for k, v in pms_SelectKBest_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_metadata_routing = bridgeSelectKBest[${this.id}].get_metadata_routing(**pms_SelectKBest_get_metadata_routing)`;
    return this._py`res_SelectKBest_get_metadata_routing.tolist() if hasattr(res_SelectKBest_get_metadata_routing, 'tolist') else res_SelectKBest_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before get_support()");
    }
    await this._py.ex`pms_SelectKBest_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectKBest_get_support = {k: v for k, v in pms_SelectKBest_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_support = bridgeSelectKBest[${this.id}].get_support(**pms_SelectKBest_get_support)`;
    return this._py`res_SelectKBest_get_support.tolist() if hasattr(res_SelectKBest_get_support, 'tolist') else res_SelectKBest_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectKBest_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectKBest_inverse_transform = {k: v for k, v in pms_SelectKBest_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_inverse_transform = bridgeSelectKBest[${this.id}].inverse_transform(**pms_SelectKBest_inverse_transform)`;
    return this._py`res_SelectKBest_inverse_transform.tolist() if hasattr(res_SelectKBest_inverse_transform, 'tolist') else res_SelectKBest_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before set_output()");
    }
    await this._py.ex`pms_SelectKBest_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectKBest_set_output = {k: v for k, v in pms_SelectKBest_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_set_output = bridgeSelectKBest[${this.id}].set_output(**pms_SelectKBest_set_output)`;
    return this._py`res_SelectKBest_set_output.tolist() if hasattr(res_SelectKBest_set_output, 'tolist') else res_SelectKBest_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before transform()");
    }
    await this._py.ex`pms_SelectKBest_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectKBest_transform = {k: v for k, v in pms_SelectKBest_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_transform = bridgeSelectKBest[${this.id}].transform(**pms_SelectKBest_transform)`;
    return this._py`res_SelectKBest_transform.tolist() if hasattr(res_SelectKBest_transform, 'tolist') else res_SelectKBest_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_scores_ = bridgeSelectKBest[${this.id}].scores_`;
      return this._py`attr_SelectKBest_scores_.tolist() if hasattr(attr_SelectKBest_scores_, 'tolist') else attr_SelectKBest_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned only scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_pvalues_ = bridgeSelectKBest[${this.id}].pvalues_`;
      return this._py`attr_SelectKBest_pvalues_.tolist() if hasattr(attr_SelectKBest_pvalues_, 'tolist') else attr_SelectKBest_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_n_features_in_ = bridgeSelectKBest[${this.id}].n_features_in_`;
      return this._py`attr_SelectKBest_n_features_in_.tolist() if hasattr(attr_SelectKBest_n_features_in_, 'tolist') else attr_SelectKBest_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_feature_names_in_ = bridgeSelectKBest[${this.id}].feature_names_in_`;
      return this._py`attr_SelectKBest_feature_names_in_.tolist() if hasattr(attr_SelectKBest_feature_names_in_, 'tolist') else attr_SelectKBest_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectorMixin.ts
import crypto9 from "node:crypto";
var SelectorMixin = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectorMixin${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectorMixin.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectorMixin
try: bridgeSelectorMixin
except NameError: bridgeSelectorMixin = {}
`;
    await this._py.ex`ctor_SelectorMixin = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'y': np.array(${this.opts["y"] ?? void 0}) if ${this.opts["y"] !== void 0} else None, 'fit_params': ${this.opts["fit_params"] ?? void 0}}

ctor_SelectorMixin = {k: v for k, v in ctor_SelectorMixin.items() if v is not None}`;
    await this._py.ex`bridgeSelectorMixin[${this.id}] = SelectorMixin(**ctor_SelectorMixin)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectorMixin[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectorMixin_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectorMixin_fit_transform = {k: v for k, v in pms_SelectorMixin_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_fit_transform = bridgeSelectorMixin[${this.id}].fit_transform(**pms_SelectorMixin_fit_transform)`;
    return this._py`res_SelectorMixin_fit_transform.tolist() if hasattr(res_SelectorMixin_fit_transform, 'tolist') else res_SelectorMixin_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectorMixin must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectorMixin_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectorMixin_get_feature_names_out = {k: v for k, v in pms_SelectorMixin_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_get_feature_names_out = bridgeSelectorMixin[${this.id}].get_feature_names_out(**pms_SelectorMixin_get_feature_names_out)`;
    return this._py`res_SelectorMixin_get_feature_names_out.tolist() if hasattr(res_SelectorMixin_get_feature_names_out, 'tolist') else res_SelectorMixin_get_feature_names_out`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before get_support()");
    }
    await this._py.ex`pms_SelectorMixin_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectorMixin_get_support = {k: v for k, v in pms_SelectorMixin_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_get_support = bridgeSelectorMixin[${this.id}].get_support(**pms_SelectorMixin_get_support)`;
    return this._py`res_SelectorMixin_get_support.tolist() if hasattr(res_SelectorMixin_get_support, 'tolist') else res_SelectorMixin_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectorMixin must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectorMixin_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectorMixin_inverse_transform = {k: v for k, v in pms_SelectorMixin_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_inverse_transform = bridgeSelectorMixin[${this.id}].inverse_transform(**pms_SelectorMixin_inverse_transform)`;
    return this._py`res_SelectorMixin_inverse_transform.tolist() if hasattr(res_SelectorMixin_inverse_transform, 'tolist') else res_SelectorMixin_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before set_output()");
    }
    await this._py.ex`pms_SelectorMixin_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectorMixin_set_output = {k: v for k, v in pms_SelectorMixin_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_set_output = bridgeSelectorMixin[${this.id}].set_output(**pms_SelectorMixin_set_output)`;
    return this._py`res_SelectorMixin_set_output.tolist() if hasattr(res_SelectorMixin_set_output, 'tolist') else res_SelectorMixin_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before transform()");
    }
    await this._py.ex`pms_SelectorMixin_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectorMixin_transform = {k: v for k, v in pms_SelectorMixin_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_transform = bridgeSelectorMixin[${this.id}].transform(**pms_SelectorMixin_transform)`;
    return this._py`res_SelectorMixin_transform.tolist() if hasattr(res_SelectorMixin_transform, 'tolist') else res_SelectorMixin_transform`;
  }
  /**
    Transformed array.
   */
  get X_new() {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before accessing X_new");
    }
    return (async () => {
      await this._py.ex`attr_SelectorMixin_X_new = bridgeSelectorMixin[${this.id}].X_new`;
      return this._py`attr_SelectorMixin_X_new.tolist() if hasattr(attr_SelectorMixin_X_new, 'tolist') else attr_SelectorMixin_X_new`;
    })();
  }
};

// src/generated/feature_selection/SelectPercentile.ts
import crypto10 from "node:crypto";
var SelectPercentile = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectPercentile${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectPercentile.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectPercentile
try: bridgeSelectPercentile
except NameError: bridgeSelectPercentile = {}
`;
    await this._py.ex`ctor_SelectPercentile = {'score_func': ${this.opts["score_func"] ?? void 0}, 'percentile': ${this.opts["percentile"] ?? void 0}}

ctor_SelectPercentile = {k: v for k, v in ctor_SelectPercentile.items() if v is not None}`;
    await this._py.ex`bridgeSelectPercentile[${this.id}] = SelectPercentile(**ctor_SelectPercentile)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectPercentile[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before fit()");
    }
    await this._py.ex`pms_SelectPercentile_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectPercentile_fit = {k: v for k, v in pms_SelectPercentile_fit.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_fit = bridgeSelectPercentile[${this.id}].fit(**pms_SelectPercentile_fit)`;
    return this._py`res_SelectPercentile_fit.tolist() if hasattr(res_SelectPercentile_fit, 'tolist') else res_SelectPercentile_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SelectPercentile_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectPercentile_fit_transform = {k: v for k, v in pms_SelectPercentile_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_fit_transform = bridgeSelectPercentile[${this.id}].fit_transform(**pms_SelectPercentile_fit_transform)`;
    return this._py`res_SelectPercentile_fit_transform.tolist() if hasattr(res_SelectPercentile_fit_transform, 'tolist') else res_SelectPercentile_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectPercentile_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectPercentile_get_feature_names_out = {k: v for k, v in pms_SelectPercentile_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_feature_names_out = bridgeSelectPercentile[${this.id}].get_feature_names_out(**pms_SelectPercentile_get_feature_names_out)`;
    return this._py`res_SelectPercentile_get_feature_names_out.tolist() if hasattr(res_SelectPercentile_get_feature_names_out, 'tolist') else res_SelectPercentile_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectPercentile_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectPercentile_get_metadata_routing = {k: v for k, v in pms_SelectPercentile_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_metadata_routing = bridgeSelectPercentile[${this.id}].get_metadata_routing(**pms_SelectPercentile_get_metadata_routing)`;
    return this._py`res_SelectPercentile_get_metadata_routing.tolist() if hasattr(res_SelectPercentile_get_metadata_routing, 'tolist') else res_SelectPercentile_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before get_support()");
    }
    await this._py.ex`pms_SelectPercentile_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectPercentile_get_support = {k: v for k, v in pms_SelectPercentile_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_support = bridgeSelectPercentile[${this.id}].get_support(**pms_SelectPercentile_get_support)`;
    return this._py`res_SelectPercentile_get_support.tolist() if hasattr(res_SelectPercentile_get_support, 'tolist') else res_SelectPercentile_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectPercentile_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectPercentile_inverse_transform = {k: v for k, v in pms_SelectPercentile_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_inverse_transform = bridgeSelectPercentile[${this.id}].inverse_transform(**pms_SelectPercentile_inverse_transform)`;
    return this._py`res_SelectPercentile_inverse_transform.tolist() if hasattr(res_SelectPercentile_inverse_transform, 'tolist') else res_SelectPercentile_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before set_output()");
    }
    await this._py.ex`pms_SelectPercentile_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectPercentile_set_output = {k: v for k, v in pms_SelectPercentile_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_set_output = bridgeSelectPercentile[${this.id}].set_output(**pms_SelectPercentile_set_output)`;
    return this._py`res_SelectPercentile_set_output.tolist() if hasattr(res_SelectPercentile_set_output, 'tolist') else res_SelectPercentile_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before transform()");
    }
    await this._py.ex`pms_SelectPercentile_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectPercentile_transform = {k: v for k, v in pms_SelectPercentile_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_transform = bridgeSelectPercentile[${this.id}].transform(**pms_SelectPercentile_transform)`;
    return this._py`res_SelectPercentile_transform.tolist() if hasattr(res_SelectPercentile_transform, 'tolist') else res_SelectPercentile_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_scores_ = bridgeSelectPercentile[${this.id}].scores_`;
      return this._py`attr_SelectPercentile_scores_.tolist() if hasattr(attr_SelectPercentile_scores_, 'tolist') else attr_SelectPercentile_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned only scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing pvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_pvalues_ = bridgeSelectPercentile[${this.id}].pvalues_`;
      return this._py`attr_SelectPercentile_pvalues_.tolist() if hasattr(attr_SelectPercentile_pvalues_, 'tolist') else attr_SelectPercentile_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_n_features_in_ = bridgeSelectPercentile[${this.id}].n_features_in_`;
      return this._py`attr_SelectPercentile_n_features_in_.tolist() if hasattr(attr_SelectPercentile_n_features_in_, 'tolist') else attr_SelectPercentile_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_feature_names_in_ = bridgeSelectPercentile[${this.id}].feature_names_in_`;
      return this._py`attr_SelectPercentile_feature_names_in_.tolist() if hasattr(attr_SelectPercentile_feature_names_in_, 'tolist') else attr_SelectPercentile_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SequentialFeatureSelector.ts
import crypto11 from "node:crypto";
var SequentialFeatureSelector = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SequentialFeatureSelector${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SequentialFeatureSelector.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SequentialFeatureSelector
try: bridgeSequentialFeatureSelector
except NameError: bridgeSequentialFeatureSelector = {}
`;
    await this._py.ex`ctor_SequentialFeatureSelector = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_features_to_select': ${this.opts["n_features_to_select"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'direction': ${this.opts["direction"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_SequentialFeatureSelector = {k: v for k, v in ctor_SequentialFeatureSelector.items() if v is not None}`;
    await this._py.ex`bridgeSequentialFeatureSelector[${this.id}] = SequentialFeatureSelector(**ctor_SequentialFeatureSelector)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSequentialFeatureSelector[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn the features to select from X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SequentialFeatureSelector must call init() before fit()");
    }
    await this._py.ex`pms_SequentialFeatureSelector_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SequentialFeatureSelector_fit = {k: v for k, v in pms_SequentialFeatureSelector_fit.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_fit = bridgeSequentialFeatureSelector[${this.id}].fit(**pms_SequentialFeatureSelector_fit)`;
    return this._py`res_SequentialFeatureSelector_fit.tolist() if hasattr(res_SequentialFeatureSelector_fit, 'tolist') else res_SequentialFeatureSelector_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SequentialFeatureSelector_fit_transform = {k: v for k, v in pms_SequentialFeatureSelector_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_fit_transform = bridgeSequentialFeatureSelector[${this.id}].fit_transform(**pms_SequentialFeatureSelector_fit_transform)`;
    return this._py`res_SequentialFeatureSelector_fit_transform.tolist() if hasattr(res_SequentialFeatureSelector_fit_transform, 'tolist') else res_SequentialFeatureSelector_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SequentialFeatureSelector_get_feature_names_out = {k: v for k, v in pms_SequentialFeatureSelector_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_feature_names_out = bridgeSequentialFeatureSelector[${this.id}].get_feature_names_out(**pms_SequentialFeatureSelector_get_feature_names_out)`;
    return this._py`res_SequentialFeatureSelector_get_feature_names_out.tolist() if hasattr(res_SequentialFeatureSelector_get_feature_names_out, 'tolist') else res_SequentialFeatureSelector_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SequentialFeatureSelector_get_metadata_routing = {k: v for k, v in pms_SequentialFeatureSelector_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_metadata_routing = bridgeSequentialFeatureSelector[${this.id}].get_metadata_routing(**pms_SequentialFeatureSelector_get_metadata_routing)`;
    return this._py`res_SequentialFeatureSelector_get_metadata_routing.tolist() if hasattr(res_SequentialFeatureSelector_get_metadata_routing, 'tolist') else res_SequentialFeatureSelector_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_support()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SequentialFeatureSelector_get_support = {k: v for k, v in pms_SequentialFeatureSelector_get_support.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_support = bridgeSequentialFeatureSelector[${this.id}].get_support(**pms_SequentialFeatureSelector_get_support)`;
    return this._py`res_SequentialFeatureSelector_get_support.tolist() if hasattr(res_SequentialFeatureSelector_get_support, 'tolist') else res_SequentialFeatureSelector_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SequentialFeatureSelector_inverse_transform = {k: v for k, v in pms_SequentialFeatureSelector_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_inverse_transform = bridgeSequentialFeatureSelector[${this.id}].inverse_transform(**pms_SequentialFeatureSelector_inverse_transform)`;
    return this._py`res_SequentialFeatureSelector_inverse_transform.tolist() if hasattr(res_SequentialFeatureSelector_inverse_transform, 'tolist') else res_SequentialFeatureSelector_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before set_output()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SequentialFeatureSelector_set_output = {k: v for k, v in pms_SequentialFeatureSelector_set_output.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_set_output = bridgeSequentialFeatureSelector[${this.id}].set_output(**pms_SequentialFeatureSelector_set_output)`;
    return this._py`res_SequentialFeatureSelector_set_output.tolist() if hasattr(res_SequentialFeatureSelector_set_output, 'tolist') else res_SequentialFeatureSelector_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SequentialFeatureSelector_transform = {k: v for k, v in pms_SequentialFeatureSelector_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_transform = bridgeSequentialFeatureSelector[${this.id}].transform(**pms_SequentialFeatureSelector_transform)`;
    return this._py`res_SequentialFeatureSelector_transform.tolist() if hasattr(res_SequentialFeatureSelector_transform, 'tolist') else res_SequentialFeatureSelector_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_n_features_in_ = bridgeSequentialFeatureSelector[${this.id}].n_features_in_`;
      return this._py`attr_SequentialFeatureSelector_n_features_in_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_in_, 'tolist') else attr_SequentialFeatureSelector_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_feature_names_in_ = bridgeSequentialFeatureSelector[${this.id}].feature_names_in_`;
      return this._py`attr_SequentialFeatureSelector_feature_names_in_.tolist() if hasattr(attr_SequentialFeatureSelector_feature_names_in_, 'tolist') else attr_SequentialFeatureSelector_feature_names_in_`;
    })();
  }
  /**
    The number of features that were selected.
   */
  get n_features_to_select_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing n_features_to_select_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_n_features_to_select_ = bridgeSequentialFeatureSelector[${this.id}].n_features_to_select_`;
      return this._py`attr_SequentialFeatureSelector_n_features_to_select_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_to_select_, 'tolist') else attr_SequentialFeatureSelector_n_features_to_select_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_support_ = bridgeSequentialFeatureSelector[${this.id}].support_`;
      return this._py`attr_SequentialFeatureSelector_support_.tolist() if hasattr(attr_SequentialFeatureSelector_support_, 'tolist') else attr_SequentialFeatureSelector_support_`;
    })();
  }
};

// src/generated/feature_selection/VarianceThreshold.ts
import crypto12 from "node:crypto";
var VarianceThreshold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `VarianceThreshold${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("VarianceThreshold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import VarianceThreshold
try: bridgeVarianceThreshold
except NameError: bridgeVarianceThreshold = {}
`;
    await this._py.ex`ctor_VarianceThreshold = {'threshold': ${this.opts["threshold"] ?? void 0}}

ctor_VarianceThreshold = {k: v for k, v in ctor_VarianceThreshold.items() if v is not None}`;
    await this._py.ex`bridgeVarianceThreshold[${this.id}] = VarianceThreshold(**ctor_VarianceThreshold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeVarianceThreshold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn empirical variances from X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before fit()");
    }
    await this._py.ex`pms_VarianceThreshold_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_VarianceThreshold_fit = {k: v for k, v in pms_VarianceThreshold_fit.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_fit = bridgeVarianceThreshold[${this.id}].fit(**pms_VarianceThreshold_fit)`;
    return this._py`res_VarianceThreshold_fit.tolist() if hasattr(res_VarianceThreshold_fit, 'tolist') else res_VarianceThreshold_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_VarianceThreshold_fit_transform = {k: v for k, v in pms_VarianceThreshold_fit_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_fit_transform = bridgeVarianceThreshold[${this.id}].fit_transform(**pms_VarianceThreshold_fit_transform)`;
    return this._py`res_VarianceThreshold_fit_transform.tolist() if hasattr(res_VarianceThreshold_fit_transform, 'tolist') else res_VarianceThreshold_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_VarianceThreshold_get_feature_names_out = {k: v for k, v in pms_VarianceThreshold_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_feature_names_out = bridgeVarianceThreshold[${this.id}].get_feature_names_out(**pms_VarianceThreshold_get_feature_names_out)`;
    return this._py`res_VarianceThreshold_get_feature_names_out.tolist() if hasattr(res_VarianceThreshold_get_feature_names_out, 'tolist') else res_VarianceThreshold_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_VarianceThreshold_get_metadata_routing = {k: v for k, v in pms_VarianceThreshold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_metadata_routing = bridgeVarianceThreshold[${this.id}].get_metadata_routing(**pms_VarianceThreshold_get_metadata_routing)`;
    return this._py`res_VarianceThreshold_get_metadata_routing.tolist() if hasattr(res_VarianceThreshold_get_metadata_routing, 'tolist') else res_VarianceThreshold_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before get_support()");
    }
    await this._py.ex`pms_VarianceThreshold_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_VarianceThreshold_get_support = {k: v for k, v in pms_VarianceThreshold_get_support.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_support = bridgeVarianceThreshold[${this.id}].get_support(**pms_VarianceThreshold_get_support)`;
    return this._py`res_VarianceThreshold_get_support.tolist() if hasattr(res_VarianceThreshold_get_support, 'tolist') else res_VarianceThreshold_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VarianceThreshold_inverse_transform = {k: v for k, v in pms_VarianceThreshold_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_inverse_transform = bridgeVarianceThreshold[${this.id}].inverse_transform(**pms_VarianceThreshold_inverse_transform)`;
    return this._py`res_VarianceThreshold_inverse_transform.tolist() if hasattr(res_VarianceThreshold_inverse_transform, 'tolist') else res_VarianceThreshold_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before set_output()");
    }
    await this._py.ex`pms_VarianceThreshold_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_VarianceThreshold_set_output = {k: v for k, v in pms_VarianceThreshold_set_output.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_set_output = bridgeVarianceThreshold[${this.id}].set_output(**pms_VarianceThreshold_set_output)`;
    return this._py`res_VarianceThreshold_set_output.tolist() if hasattr(res_VarianceThreshold_set_output, 'tolist') else res_VarianceThreshold_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before transform()");
    }
    await this._py.ex`pms_VarianceThreshold_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VarianceThreshold_transform = {k: v for k, v in pms_VarianceThreshold_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_transform = bridgeVarianceThreshold[${this.id}].transform(**pms_VarianceThreshold_transform)`;
    return this._py`res_VarianceThreshold_transform.tolist() if hasattr(res_VarianceThreshold_transform, 'tolist') else res_VarianceThreshold_transform`;
  }
  /**
    Variances of individual features.
   */
  get variances_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing variances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_variances_ = bridgeVarianceThreshold[${this.id}].variances_`;
      return this._py`attr_VarianceThreshold_variances_.tolist() if hasattr(attr_VarianceThreshold_variances_, 'tolist') else attr_VarianceThreshold_variances_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_n_features_in_ = bridgeVarianceThreshold[${this.id}].n_features_in_`;
      return this._py`attr_VarianceThreshold_n_features_in_.tolist() if hasattr(attr_VarianceThreshold_n_features_in_, 'tolist') else attr_VarianceThreshold_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_feature_names_in_ = bridgeVarianceThreshold[${this.id}].feature_names_in_`;
      return this._py`attr_VarianceThreshold_feature_names_in_.tolist() if hasattr(attr_VarianceThreshold_feature_names_in_, 'tolist') else attr_VarianceThreshold_feature_names_in_`;
    })();
  }
};
export {
  GenericUnivariateSelect,
  RFE,
  RFECV,
  SelectFdr,
  SelectFpr,
  SelectFromModel,
  SelectFwe,
  SelectKBest,
  SelectPercentile,
  SelectorMixin,
  SequentialFeatureSelector,
  VarianceThreshold
};
//# sourceMappingURL=index.js.map