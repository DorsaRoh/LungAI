{"version":3,"sources":["../../../src/generated/feature_selection/GenericUnivariateSelect.ts","../../../src/generated/feature_selection/RFE.ts","../../../src/generated/feature_selection/RFECV.ts","../../../src/generated/feature_selection/SelectFdr.ts","../../../src/generated/feature_selection/SelectFpr.ts","../../../src/generated/feature_selection/SelectFromModel.ts","../../../src/generated/feature_selection/SelectFwe.ts","../../../src/generated/feature_selection/SelectKBest.ts","../../../src/generated/feature_selection/SelectorMixin.ts","../../../src/generated/feature_selection/SelectPercentile.ts","../../../src/generated/feature_selection/SequentialFeatureSelector.ts","../../../src/generated/feature_selection/VarianceThreshold.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Univariate feature selector with configurable strategy.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.GenericUnivariateSelect.html)\n */\nexport class GenericUnivariateSelect {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). For modes ‘percentile’ or ‘kbest’ it can return a single array scores.\n     */\n    score_func?: any\n\n    /**\n      Feature selection mode.\n\n      @defaultValue `'percentile'`\n     */\n    mode?: 'percentile' | 'k_best' | 'fpr' | 'fdr' | 'fwe'\n\n    /**\n      Parameter of the corresponding mode.\n\n      @defaultValue `0.00001`\n     */\n    param?: 'all' | number | number\n  }) {\n    this.id = `GenericUnivariateSelect${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'GenericUnivariateSelect.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import GenericUnivariateSelect\ntry: bridgeGenericUnivariateSelect\nexcept NameError: bridgeGenericUnivariateSelect = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_GenericUnivariateSelect = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'mode': ${this.opts['mode'] ?? undefined}, 'param': ${\n      this.opts['param'] ?? undefined\n    }}\n\nctor_GenericUnivariateSelect = {k: v for k, v in ctor_GenericUnivariateSelect.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeGenericUnivariateSelect[${this.id}] = GenericUnivariateSelect(**ctor_GenericUnivariateSelect)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeGenericUnivariateSelect[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GenericUnivariateSelect must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GenericUnivariateSelect_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_GenericUnivariateSelect_fit = {k: v for k, v in pms_GenericUnivariateSelect_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_fit = bridgeGenericUnivariateSelect[${this.id}].fit(**pms_GenericUnivariateSelect_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_fit.tolist() if hasattr(res_GenericUnivariateSelect_fit, 'tolist') else res_GenericUnivariateSelect_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GenericUnivariateSelect_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_GenericUnivariateSelect_fit_transform = {k: v for k, v in pms_GenericUnivariateSelect_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_fit_transform = bridgeGenericUnivariateSelect[${this.id}].fit_transform(**pms_GenericUnivariateSelect_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_fit_transform.tolist() if hasattr(res_GenericUnivariateSelect_fit_transform, 'tolist') else res_GenericUnivariateSelect_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GenericUnivariateSelect_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_GenericUnivariateSelect_get_feature_names_out = {k: v for k, v in pms_GenericUnivariateSelect_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_get_feature_names_out = bridgeGenericUnivariateSelect[${this.id}].get_feature_names_out(**pms_GenericUnivariateSelect_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_get_feature_names_out.tolist() if hasattr(res_GenericUnivariateSelect_get_feature_names_out, 'tolist') else res_GenericUnivariateSelect_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GenericUnivariateSelect_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_GenericUnivariateSelect_get_metadata_routing = {k: v for k, v in pms_GenericUnivariateSelect_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_get_metadata_routing = bridgeGenericUnivariateSelect[${this.id}].get_metadata_routing(**pms_GenericUnivariateSelect_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_get_metadata_routing.tolist() if hasattr(res_GenericUnivariateSelect_get_metadata_routing, 'tolist') else res_GenericUnivariateSelect_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before get_support()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_GenericUnivariateSelect_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_GenericUnivariateSelect_get_support = {k: v for k, v in pms_GenericUnivariateSelect_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_get_support = bridgeGenericUnivariateSelect[${this.id}].get_support(**pms_GenericUnivariateSelect_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_get_support.tolist() if hasattr(res_GenericUnivariateSelect_get_support, 'tolist') else res_GenericUnivariateSelect_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GenericUnivariateSelect_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_GenericUnivariateSelect_inverse_transform = {k: v for k, v in pms_GenericUnivariateSelect_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_inverse_transform = bridgeGenericUnivariateSelect[${this.id}].inverse_transform(**pms_GenericUnivariateSelect_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_inverse_transform.tolist() if hasattr(res_GenericUnivariateSelect_inverse_transform, 'tolist') else res_GenericUnivariateSelect_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_GenericUnivariateSelect_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_GenericUnivariateSelect_set_output = {k: v for k, v in pms_GenericUnivariateSelect_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_set_output = bridgeGenericUnivariateSelect[${this.id}].set_output(**pms_GenericUnivariateSelect_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_set_output.tolist() if hasattr(res_GenericUnivariateSelect_set_output, 'tolist') else res_GenericUnivariateSelect_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_GenericUnivariateSelect_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_GenericUnivariateSelect_transform = {k: v for k, v in pms_GenericUnivariateSelect_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GenericUnivariateSelect_transform = bridgeGenericUnivariateSelect[${this.id}].transform(**pms_GenericUnivariateSelect_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GenericUnivariateSelect_transform.tolist() if hasattr(res_GenericUnivariateSelect_transform, 'tolist') else res_GenericUnivariateSelect_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before accessing scores_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GenericUnivariateSelect_scores_ = bridgeGenericUnivariateSelect[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GenericUnivariateSelect_scores_.tolist() if hasattr(attr_GenericUnivariateSelect_scores_, 'tolist') else attr_GenericUnivariateSelect_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores, `undefined` if `score\\_func` returned scores only.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before accessing pvalues_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GenericUnivariateSelect_pvalues_ = bridgeGenericUnivariateSelect[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GenericUnivariateSelect_pvalues_.tolist() if hasattr(attr_GenericUnivariateSelect_pvalues_, 'tolist') else attr_GenericUnivariateSelect_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GenericUnivariateSelect_n_features_in_ = bridgeGenericUnivariateSelect[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GenericUnivariateSelect_n_features_in_.tolist() if hasattr(attr_GenericUnivariateSelect_n_features_in_, 'tolist') else attr_GenericUnivariateSelect_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This GenericUnivariateSelect instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GenericUnivariateSelect must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GenericUnivariateSelect_feature_names_in_ = bridgeGenericUnivariateSelect[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GenericUnivariateSelect_feature_names_in_.tolist() if hasattr(attr_GenericUnivariateSelect_feature_names_in_, 'tolist') else attr_GenericUnivariateSelect_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Feature ranking with recursive feature elimination.\n\n  Given an external estimator that assigns weights to features (e.g., the coefficients of a linear model), the goal of recursive feature elimination (RFE) is to select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features and the importance of each feature is obtained either through any specific attribute or callable. Then, the least important features are pruned from current set of features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached.\n\n  Read more in the [User Guide](../feature_selection.html#rfe).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html)\n */\nexport class RFE {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      A supervised learning estimator with a `fit` method that provides information about feature importance (e.g. `coef\\_`, `feature\\_importances\\_`).\n     */\n    estimator?: any\n\n    /**\n      The number of features to select. If `undefined`, half of the features are selected. If integer, the parameter is the absolute number of features to select. If float between 0 and 1, it is the fraction of features to select.\n     */\n    n_features_to_select?: number\n\n    /**\n      If greater than or equal to 1, then `step` corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then `step` corresponds to the percentage (rounded down) of features to remove at each iteration.\n\n      @defaultValue `1`\n     */\n    step?: number\n\n    /**\n      Controls verbosity of output.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      If ‘auto’, uses the feature importance either through a `coef\\_` or `feature\\_importances\\_` attributes of estimator.\n\n      Also accepts a string that specifies an attribute name/path for extracting feature importance (implemented with `attrgetter`). For example, give `regressor\\_.coef\\_` in case of [`TransformedTargetRegressor`](sklearn.compose.TransformedTargetRegressor.html#sklearn.compose.TransformedTargetRegressor \"sklearn.compose.TransformedTargetRegressor\") or `named\\_steps.clf.feature\\_importances\\_` in case of class:`~sklearn.pipeline.Pipeline` with its last step named `clf`.\n\n      If `callable`, overrides the default feature importance getter. The callable is passed with the fitted estimator and it should return importance for each feature.\n\n      @defaultValue `'auto'`\n     */\n    importance_getter?: string\n  }) {\n    this.id = `RFE${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RFE.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import RFE\ntry: bridgeRFE\nexcept NameError: bridgeRFE = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RFE = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'n_features_to_select': ${\n      this.opts['n_features_to_select'] ?? undefined\n    }, 'step': ${this.opts['step'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'importance_getter': ${this.opts['importance_getter'] ?? undefined}}\n\nctor_RFE = {k: v for k, v in ctor_RFE.items() if v is not None}`\n\n    await this._py.ex`bridgeRFE[${this.id}] = RFE(**ctor_RFE)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRFE[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the decision function of `X`.\n   */\n  async decision_function(opts: {\n    /**\n      The input samples. Internally, it will be converted to `dtype=np.float32` and if a sparse matrix is provided to a sparse `csr\\_matrix`.\n     */\n    X?: any[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_decision_function = {k: v for k, v in pms_RFE_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_decision_function = bridgeRFE[${this.id}].decision_function(**pms_RFE_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_decision_function.tolist() if hasattr(res_RFE_decision_function, 'tolist') else res_RFE_decision_function`\n  }\n\n  /**\n    Fit the RFE model and then the underlying estimator on the selected features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      The target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Additional parameters passed to the `fit` method of the underlying estimator.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RFE_fit = {k: v for k, v in pms_RFE_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_RFE_fit = bridgeRFE[${this.id}].fit(**pms_RFE_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_fit.tolist() if hasattr(res_RFE_fit, 'tolist') else res_RFE_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RFE_fit_transform = {k: v for k, v in pms_RFE_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_fit_transform = bridgeRFE[${this.id}].fit_transform(**pms_RFE_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_fit_transform.tolist() if hasattr(res_RFE_fit_transform, 'tolist') else res_RFE_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_RFE_get_feature_names_out = {k: v for k, v in pms_RFE_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_get_feature_names_out = bridgeRFE[${this.id}].get_feature_names_out(**pms_RFE_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_get_feature_names_out.tolist() if hasattr(res_RFE_get_feature_names_out, 'tolist') else res_RFE_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RFE_get_metadata_routing = {k: v for k, v in pms_RFE_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_get_metadata_routing = bridgeRFE[${this.id}].get_metadata_routing(**pms_RFE_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_get_metadata_routing.tolist() if hasattr(res_RFE_get_metadata_routing, 'tolist') else res_RFE_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_RFE_get_support = {k: v for k, v in pms_RFE_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_get_support = bridgeRFE[${this.id}].get_support(**pms_RFE_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_get_support.tolist() if hasattr(res_RFE_get_support, 'tolist') else res_RFE_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_inverse_transform = {k: v for k, v in pms_RFE_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_inverse_transform = bridgeRFE[${this.id}].inverse_transform(**pms_RFE_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_inverse_transform.tolist() if hasattr(res_RFE_inverse_transform, 'tolist') else res_RFE_inverse_transform`\n  }\n\n  /**\n    Reduce X to the selected features and predict using the estimator.\n   */\n  async predict(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_predict = {k: v for k, v in pms_RFE_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_predict = bridgeRFE[${this.id}].predict(**pms_RFE_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_predict.tolist() if hasattr(res_RFE_predict, 'tolist') else res_RFE_predict`\n  }\n\n  /**\n    Predict class log-probabilities for X.\n   */\n  async predict_log_proba(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_predict_log_proba = {k: v for k, v in pms_RFE_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_predict_log_proba = bridgeRFE[${this.id}].predict_log_proba(**pms_RFE_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_predict_log_proba.tolist() if hasattr(res_RFE_predict_log_proba, 'tolist') else res_RFE_predict_log_proba`\n  }\n\n  /**\n    Predict class probabilities for X.\n   */\n  async predict_proba(opts: {\n    /**\n      The input samples. Internally, it will be converted to `dtype=np.float32` and if a sparse matrix is provided to a sparse `csr\\_matrix`.\n     */\n    X?: any[]\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_predict_proba = {k: v for k, v in pms_RFE_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_predict_proba = bridgeRFE[${this.id}].predict_proba(**pms_RFE_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_predict_proba.tolist() if hasattr(res_RFE_predict_proba, 'tolist') else res_RFE_predict_proba`\n  }\n\n  /**\n    Reduce X to the selected features and return the score of the estimator.\n   */\n  async score(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n\n    /**\n      The target values.\n     */\n    y?: any\n\n    /**\n      Parameters to pass to the `score` method of the underlying estimator.\n     */\n    fit_params?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RFE_score = {k: v for k, v in pms_RFE_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_score = bridgeRFE[${this.id}].score(**pms_RFE_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_score.tolist() if hasattr(res_RFE_score, 'tolist') else res_RFE_score`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_RFE_set_output = {k: v for k, v in pms_RFE_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_set_output = bridgeRFE[${this.id}].set_output(**pms_RFE_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_set_output.tolist() if hasattr(res_RFE_set_output, 'tolist') else res_RFE_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFE_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFE_transform = {k: v for k, v in pms_RFE_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFE_transform = bridgeRFE[${this.id}].transform(**pms_RFE_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFE_transform.tolist() if hasattr(res_RFE_transform, 'tolist') else res_RFE_transform`\n  }\n\n  /**\n    The fitted estimator used to select features.\n   */\n  get estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing estimator_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RFE_estimator_ = bridgeRFE[${this.id}].estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_estimator_.tolist() if hasattr(attr_RFE_estimator_, 'tolist') else attr_RFE_estimator_`\n    })()\n  }\n\n  /**\n    The number of selected features.\n   */\n  get n_features_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing n_features_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFE_n_features_ = bridgeRFE[${this.id}].n_features_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_n_features_.tolist() if hasattr(attr_RFE_n_features_, 'tolist') else attr_RFE_n_features_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFE_n_features_in_ = bridgeRFE[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_n_features_in_.tolist() if hasattr(attr_RFE_n_features_in_, 'tolist') else attr_RFE_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFE_feature_names_in_ = bridgeRFE[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_feature_names_in_.tolist() if hasattr(attr_RFE_feature_names_in_, 'tolist') else attr_RFE_feature_names_in_`\n    })()\n  }\n\n  /**\n    The feature ranking, such that `ranking\\_\\[i\\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.\n   */\n  get ranking_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing ranking_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RFE_ranking_ = bridgeRFE[${this.id}].ranking_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_ranking_.tolist() if hasattr(attr_RFE_ranking_, 'tolist') else attr_RFE_ranking_`\n    })()\n  }\n\n  /**\n    The mask of selected features.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RFE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFE must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RFE_support_ = bridgeRFE[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFE_support_.tolist() if hasattr(attr_RFE_support_, 'tolist') else attr_RFE_support_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Recursive feature elimination with cross-validation to select features.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  Read more in the [User Guide](../feature_selection.html#rfe).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFECV.html)\n */\nexport class RFECV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      A supervised learning estimator with a `fit` method that provides information about feature importance either through a `coef\\_` attribute or through a `feature\\_importances\\_` attribute.\n     */\n    estimator?: any\n\n    /**\n      If greater than or equal to 1, then `step` corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then `step` corresponds to the percentage (rounded down) of features to remove at each iteration. Note that the last iteration may remove fewer than `step` features in order to reach `min\\_features\\_to\\_select`.\n\n      @defaultValue `1`\n     */\n    step?: number\n\n    /**\n      The minimum number of features to be selected. This number of features will always be scored, even if the difference between the original feature count and `min\\_features\\_to\\_select` isn’t divisible by `step`.\n\n      @defaultValue `1`\n     */\n    min_features_to_select?: number\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      A string (see model evaluation documentation) or a scorer callable object / function with signature `scorer(estimator, X, y)`.\n     */\n    scoring?: string\n\n    /**\n      Controls verbosity of output.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Number of cores to run in parallel while fitting across folds. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      If ‘auto’, uses the feature importance either through a `coef\\_` or `feature\\_importances\\_` attributes of estimator.\n\n      Also accepts a string that specifies an attribute name/path for extracting feature importance. For example, give `regressor\\_.coef\\_` in case of [`TransformedTargetRegressor`](sklearn.compose.TransformedTargetRegressor.html#sklearn.compose.TransformedTargetRegressor \"sklearn.compose.TransformedTargetRegressor\") or `named\\_steps.clf.feature\\_importances\\_` in case of [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\") with its last step named `clf`.\n\n      If `callable`, overrides the default feature importance getter. The callable is passed with the fitted estimator and it should return importance for each feature.\n\n      @defaultValue `'auto'`\n     */\n    importance_getter?: string\n  }) {\n    this.id = `RFECV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RFECV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import RFECV\ntry: bridgeRFECV\nexcept NameError: bridgeRFECV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RFECV = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'step': ${this.opts['step'] ?? undefined}, 'min_features_to_select': ${\n      this.opts['min_features_to_select'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'scoring': ${\n      this.opts['scoring'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'importance_getter': ${this.opts['importance_getter'] ?? undefined}}\n\nctor_RFECV = {k: v for k, v in ctor_RFECV.items() if v is not None}`\n\n    await this._py.ex`bridgeRFECV[${this.id}] = RFECV(**ctor_RFECV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRFECV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the decision function of `X`.\n   */\n  async decision_function(opts: {\n    /**\n      The input samples. Internally, it will be converted to `dtype=np.float32` and if a sparse matrix is provided to a sparse `csr\\_matrix`.\n     */\n    X?: any[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_decision_function = {k: v for k, v in pms_RFECV_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_decision_function = bridgeRFECV[${this.id}].decision_function(**pms_RFECV_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_decision_function.tolist() if hasattr(res_RFECV_decision_function, 'tolist') else res_RFECV_decision_function`\n  }\n\n  /**\n    Fit the RFE model and automatically tune the number of selected features.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the total number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (integers for classification, real numbers for regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Group labels for the samples used while splitting the dataset into train/test set. Only used in conjunction with a “Group” [cv](../../glossary.html#term-cv) instance (e.g., [`GroupKFold`](sklearn.model_selection.GroupKFold.html#sklearn.model_selection.GroupKFold \"sklearn.model_selection.GroupKFold\")).\n     */\n    groups?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'groups': np.array(${\n      opts['groups'] ?? undefined\n    }) if ${opts['groups'] !== undefined} else None}\n\npms_RFECV_fit = {k: v for k, v in pms_RFECV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_fit = bridgeRFECV[${this.id}].fit(**pms_RFECV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_fit.tolist() if hasattr(res_RFECV_fit, 'tolist') else res_RFECV_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RFECV_fit_transform = {k: v for k, v in pms_RFECV_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_fit_transform = bridgeRFECV[${this.id}].fit_transform(**pms_RFECV_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_fit_transform.tolist() if hasattr(res_RFECV_fit_transform, 'tolist') else res_RFECV_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_RFECV_get_feature_names_out = {k: v for k, v in pms_RFECV_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_get_feature_names_out = bridgeRFECV[${this.id}].get_feature_names_out(**pms_RFECV_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_get_feature_names_out.tolist() if hasattr(res_RFECV_get_feature_names_out, 'tolist') else res_RFECV_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RFECV_get_metadata_routing = {k: v for k, v in pms_RFECV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_get_metadata_routing = bridgeRFECV[${this.id}].get_metadata_routing(**pms_RFECV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_get_metadata_routing.tolist() if hasattr(res_RFECV_get_metadata_routing, 'tolist') else res_RFECV_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_RFECV_get_support = {k: v for k, v in pms_RFECV_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_get_support = bridgeRFECV[${this.id}].get_support(**pms_RFECV_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_get_support.tolist() if hasattr(res_RFECV_get_support, 'tolist') else res_RFECV_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_inverse_transform = {k: v for k, v in pms_RFECV_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_inverse_transform = bridgeRFECV[${this.id}].inverse_transform(**pms_RFECV_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_inverse_transform.tolist() if hasattr(res_RFECV_inverse_transform, 'tolist') else res_RFECV_inverse_transform`\n  }\n\n  /**\n    Reduce X to the selected features and predict using the estimator.\n   */\n  async predict(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_predict = {k: v for k, v in pms_RFECV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_predict = bridgeRFECV[${this.id}].predict(**pms_RFECV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_predict.tolist() if hasattr(res_RFECV_predict, 'tolist') else res_RFECV_predict`\n  }\n\n  /**\n    Predict class log-probabilities for X.\n   */\n  async predict_log_proba(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_predict_log_proba = {k: v for k, v in pms_RFECV_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_predict_log_proba = bridgeRFECV[${this.id}].predict_log_proba(**pms_RFECV_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_predict_log_proba.tolist() if hasattr(res_RFECV_predict_log_proba, 'tolist') else res_RFECV_predict_log_proba`\n  }\n\n  /**\n    Predict class probabilities for X.\n   */\n  async predict_proba(opts: {\n    /**\n      The input samples. Internally, it will be converted to `dtype=np.float32` and if a sparse matrix is provided to a sparse `csr\\_matrix`.\n     */\n    X?: any[]\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_predict_proba = {k: v for k, v in pms_RFECV_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_predict_proba = bridgeRFECV[${this.id}].predict_proba(**pms_RFECV_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_predict_proba.tolist() if hasattr(res_RFECV_predict_proba, 'tolist') else res_RFECV_predict_proba`\n  }\n\n  /**\n    Reduce X to the selected features and return the score of the estimator.\n   */\n  async score(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n\n    /**\n      The target values.\n     */\n    y?: any\n\n    /**\n      Parameters to pass to the `score` method of the underlying estimator.\n     */\n    fit_params?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RFECV_score = {k: v for k, v in pms_RFECV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_score = bridgeRFECV[${this.id}].score(**pms_RFECV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_score.tolist() if hasattr(res_RFECV_score, 'tolist') else res_RFECV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `groups` parameter in `fit`.\n     */\n    groups?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_set_fit_request = {'groups': ${\n      opts['groups'] ?? undefined\n    }}\n\npms_RFECV_set_fit_request = {k: v for k, v in pms_RFECV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_set_fit_request = bridgeRFECV[${this.id}].set_fit_request(**pms_RFECV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_set_fit_request.tolist() if hasattr(res_RFECV_set_fit_request, 'tolist') else res_RFECV_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_RFECV_set_output = {k: v for k, v in pms_RFECV_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_set_output = bridgeRFECV[${this.id}].set_output(**pms_RFECV_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_set_output.tolist() if hasattr(res_RFECV_set_output, 'tolist') else res_RFECV_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RFECV_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RFECV_transform = {k: v for k, v in pms_RFECV_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RFECV_transform = bridgeRFECV[${this.id}].transform(**pms_RFECV_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RFECV_transform.tolist() if hasattr(res_RFECV_transform, 'tolist') else res_RFECV_transform`\n  }\n\n  /**\n    The fitted estimator used to select features.\n   */\n  get estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing estimator_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFECV_estimator_ = bridgeRFECV[${this.id}].estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_estimator_.tolist() if hasattr(attr_RFECV_estimator_, 'tolist') else attr_RFECV_estimator_`\n    })()\n  }\n\n  /**\n    A dict with keys:\n   */\n  get cv_results_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing cv_results_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFECV_cv_results_ = bridgeRFECV[${this.id}].cv_results_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_cv_results_.tolist() if hasattr(attr_RFECV_cv_results_, 'tolist') else attr_RFECV_cv_results_`\n    })()\n  }\n\n  /**\n    The number of selected features with cross-validation.\n   */\n  get n_features_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing n_features_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFECV_n_features_ = bridgeRFECV[${this.id}].n_features_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_n_features_.tolist() if hasattr(attr_RFECV_n_features_, 'tolist') else attr_RFECV_n_features_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFECV_n_features_in_ = bridgeRFECV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_n_features_in_.tolist() if hasattr(attr_RFECV_n_features_in_, 'tolist') else attr_RFECV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RFECV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RFECV_feature_names_in_ = bridgeRFECV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_feature_names_in_.tolist() if hasattr(attr_RFECV_feature_names_in_, 'tolist') else attr_RFECV_feature_names_in_`\n    })()\n  }\n\n  /**\n    The feature ranking, such that `ranking\\_\\[i\\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.\n   */\n  get ranking_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing ranking_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RFECV_ranking_ = bridgeRFECV[${this.id}].ranking_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_ranking_.tolist() if hasattr(attr_RFECV_ranking_, 'tolist') else attr_RFECV_ranking_`\n    })()\n  }\n\n  /**\n    The mask of selected features.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RFECV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RFECV must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RFECV_support_ = bridgeRFECV[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RFECV_support_.tolist() if hasattr(attr_RFECV_support_, 'tolist') else attr_RFECV_support_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Filter: Select the p-values for an estimated false discovery rate.\n\n  This uses the Benjamini-Hochberg procedure. `alpha` is an upper bound on the expected false discovery rate.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectFdr.html)\n */\nexport class SelectFdr {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). Default is f\\_classif (see below “See Also”). The default function only works with classification tasks.\n     */\n    score_func?: any\n\n    /**\n      The highest uncorrected p-value for features to keep.\n\n      @defaultValue `0.05`\n     */\n    alpha?: number\n  }) {\n    this.id = `SelectFdr${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectFdr.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectFdr\ntry: bridgeSelectFdr\nexcept NameError: bridgeSelectFdr = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectFdr = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}}\n\nctor_SelectFdr = {k: v for k, v in ctor_SelectFdr.items() if v is not None}`\n\n    await this._py.ex`bridgeSelectFdr[${this.id}] = SelectFdr(**ctor_SelectFdr)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectFdr[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelectFdr_fit = {k: v for k, v in pms_SelectFdr_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_fit = bridgeSelectFdr[${this.id}].fit(**pms_SelectFdr_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_fit.tolist() if hasattr(res_SelectFdr_fit, 'tolist') else res_SelectFdr_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFdr_fit_transform = {k: v for k, v in pms_SelectFdr_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_fit_transform = bridgeSelectFdr[${this.id}].fit_transform(**pms_SelectFdr_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_fit_transform.tolist() if hasattr(res_SelectFdr_fit_transform, 'tolist') else res_SelectFdr_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFdr must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectFdr_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectFdr_get_feature_names_out = {k: v for k, v in pms_SelectFdr_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_get_feature_names_out = bridgeSelectFdr[${this.id}].get_feature_names_out(**pms_SelectFdr_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_get_feature_names_out.tolist() if hasattr(res_SelectFdr_get_feature_names_out, 'tolist') else res_SelectFdr_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFdr must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectFdr_get_metadata_routing = {k: v for k, v in pms_SelectFdr_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_get_metadata_routing = bridgeSelectFdr[${this.id}].get_metadata_routing(**pms_SelectFdr_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_get_metadata_routing.tolist() if hasattr(res_SelectFdr_get_metadata_routing, 'tolist') else res_SelectFdr_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectFdr_get_support = {k: v for k, v in pms_SelectFdr_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_get_support = bridgeSelectFdr[${this.id}].get_support(**pms_SelectFdr_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_get_support.tolist() if hasattr(res_SelectFdr_get_support, 'tolist') else res_SelectFdr_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFdr_inverse_transform = {k: v for k, v in pms_SelectFdr_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_inverse_transform = bridgeSelectFdr[${this.id}].inverse_transform(**pms_SelectFdr_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_inverse_transform.tolist() if hasattr(res_SelectFdr_inverse_transform, 'tolist') else res_SelectFdr_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectFdr_set_output = {k: v for k, v in pms_SelectFdr_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_set_output = bridgeSelectFdr[${this.id}].set_output(**pms_SelectFdr_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_set_output.tolist() if hasattr(res_SelectFdr_set_output, 'tolist') else res_SelectFdr_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFdr_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFdr_transform = {k: v for k, v in pms_SelectFdr_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFdr_transform = bridgeSelectFdr[${this.id}].transform(**pms_SelectFdr_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFdr_transform.tolist() if hasattr(res_SelectFdr_transform, 'tolist') else res_SelectFdr_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFdr_scores_ = bridgeSelectFdr[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFdr_scores_.tolist() if hasattr(attr_SelectFdr_scores_, 'tolist') else attr_SelectFdr_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFdr must call init() before accessing pvalues_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFdr_pvalues_ = bridgeSelectFdr[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFdr_pvalues_.tolist() if hasattr(attr_SelectFdr_pvalues_, 'tolist') else attr_SelectFdr_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFdr must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFdr_n_features_in_ = bridgeSelectFdr[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFdr_n_features_in_.tolist() if hasattr(attr_SelectFdr_n_features_in_, 'tolist') else attr_SelectFdr_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFdr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFdr must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFdr_feature_names_in_ = bridgeSelectFdr[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFdr_feature_names_in_.tolist() if hasattr(attr_SelectFdr_feature_names_in_, 'tolist') else attr_SelectFdr_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Filter: Select the pvalues below alpha based on a FPR test.\n\n  FPR test stands for `false` Positive Rate test. It controls the total amount of false detections.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectFpr.html)\n */\nexport class SelectFpr {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). Default is f\\_classif (see below “See Also”). The default function only works with classification tasks.\n     */\n    score_func?: any\n\n    /**\n      Features with p-values less than `alpha` are selected.\n\n      @defaultValue `0.05`\n     */\n    alpha?: number\n  }) {\n    this.id = `SelectFpr${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectFpr.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectFpr\ntry: bridgeSelectFpr\nexcept NameError: bridgeSelectFpr = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectFpr = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}}\n\nctor_SelectFpr = {k: v for k, v in ctor_SelectFpr.items() if v is not None}`\n\n    await this._py.ex`bridgeSelectFpr[${this.id}] = SelectFpr(**ctor_SelectFpr)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectFpr[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelectFpr_fit = {k: v for k, v in pms_SelectFpr_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_fit = bridgeSelectFpr[${this.id}].fit(**pms_SelectFpr_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_fit.tolist() if hasattr(res_SelectFpr_fit, 'tolist') else res_SelectFpr_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFpr_fit_transform = {k: v for k, v in pms_SelectFpr_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_fit_transform = bridgeSelectFpr[${this.id}].fit_transform(**pms_SelectFpr_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_fit_transform.tolist() if hasattr(res_SelectFpr_fit_transform, 'tolist') else res_SelectFpr_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFpr must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectFpr_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectFpr_get_feature_names_out = {k: v for k, v in pms_SelectFpr_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_get_feature_names_out = bridgeSelectFpr[${this.id}].get_feature_names_out(**pms_SelectFpr_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_get_feature_names_out.tolist() if hasattr(res_SelectFpr_get_feature_names_out, 'tolist') else res_SelectFpr_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFpr must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectFpr_get_metadata_routing = {k: v for k, v in pms_SelectFpr_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_get_metadata_routing = bridgeSelectFpr[${this.id}].get_metadata_routing(**pms_SelectFpr_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_get_metadata_routing.tolist() if hasattr(res_SelectFpr_get_metadata_routing, 'tolist') else res_SelectFpr_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectFpr_get_support = {k: v for k, v in pms_SelectFpr_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_get_support = bridgeSelectFpr[${this.id}].get_support(**pms_SelectFpr_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_get_support.tolist() if hasattr(res_SelectFpr_get_support, 'tolist') else res_SelectFpr_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFpr_inverse_transform = {k: v for k, v in pms_SelectFpr_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_inverse_transform = bridgeSelectFpr[${this.id}].inverse_transform(**pms_SelectFpr_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_inverse_transform.tolist() if hasattr(res_SelectFpr_inverse_transform, 'tolist') else res_SelectFpr_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectFpr_set_output = {k: v for k, v in pms_SelectFpr_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_set_output = bridgeSelectFpr[${this.id}].set_output(**pms_SelectFpr_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_set_output.tolist() if hasattr(res_SelectFpr_set_output, 'tolist') else res_SelectFpr_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFpr_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFpr_transform = {k: v for k, v in pms_SelectFpr_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFpr_transform = bridgeSelectFpr[${this.id}].transform(**pms_SelectFpr_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFpr_transform.tolist() if hasattr(res_SelectFpr_transform, 'tolist') else res_SelectFpr_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFpr_scores_ = bridgeSelectFpr[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFpr_scores_.tolist() if hasattr(attr_SelectFpr_scores_, 'tolist') else attr_SelectFpr_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFpr must call init() before accessing pvalues_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFpr_pvalues_ = bridgeSelectFpr[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFpr_pvalues_.tolist() if hasattr(attr_SelectFpr_pvalues_, 'tolist') else attr_SelectFpr_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFpr must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFpr_n_features_in_ = bridgeSelectFpr[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFpr_n_features_in_.tolist() if hasattr(attr_SelectFpr_n_features_in_, 'tolist') else attr_SelectFpr_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFpr instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFpr must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFpr_feature_names_in_ = bridgeSelectFpr[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFpr_feature_names_in_.tolist() if hasattr(attr_SelectFpr_feature_names_in_, 'tolist') else attr_SelectFpr_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Meta-transformer for selecting features based on importance weights.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectFromModel.html)\n */\nexport class SelectFromModel {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The base estimator from which the transformer is built. This can be both a fitted (if `prefit` is set to `true`) or a non-fitted estimator. The estimator should have a `feature\\_importances\\_` or `coef\\_` attribute after fitting. Otherwise, the `importance\\_getter` parameter should be used.\n     */\n    estimator?: any\n\n    /**\n      The threshold value to use for feature selection. Features whose absolute importance value is greater or equal are kept while the others are discarded. If “median” (resp. “mean”), then the `threshold` value is the median (resp. the mean) of the feature importances. A scaling factor (e.g., “1.25\\*mean”) may also be used. If `undefined` and if the estimator has a parameter penalty set to l1, either explicitly or implicitly (e.g, Lasso), the threshold used is 1e-5. Otherwise, “mean” is used by default.\n     */\n    threshold?: string | number\n\n    /**\n      Whether a prefit model is expected to be passed into the constructor directly or not. If `true`, `estimator` must be a fitted estimator. If `false`, `estimator` is fitted and updated by calling `fit` and `partial\\_fit`, respectively.\n\n      @defaultValue `false`\n     */\n    prefit?: boolean\n\n    /**\n      Order of the norm used to filter the vectors of coefficients below `threshold` in the case where the `coef\\_` attribute of the estimator is of dimension 2.\n\n      @defaultValue `1`\n     */\n    norm_order?: any\n\n    /**\n      The maximum number of features to select.\n     */\n    max_features?: number\n\n    /**\n      If ‘auto’, uses the feature importance either through a `coef\\_` attribute or `feature\\_importances\\_` attribute of estimator.\n\n      Also accepts a string that specifies an attribute name/path for extracting feature importance (implemented with `attrgetter`). For example, give `regressor\\_.coef\\_` in case of [`TransformedTargetRegressor`](sklearn.compose.TransformedTargetRegressor.html#sklearn.compose.TransformedTargetRegressor \"sklearn.compose.TransformedTargetRegressor\") or `named\\_steps.clf.feature\\_importances\\_` in case of [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\") with its last step named `clf`.\n\n      If `callable`, overrides the default feature importance getter. The callable is passed with the fitted estimator and it should return importance for each feature.\n\n      @defaultValue `'auto'`\n     */\n    importance_getter?: string\n  }) {\n    this.id = `SelectFromModel${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectFromModel.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectFromModel\ntry: bridgeSelectFromModel\nexcept NameError: bridgeSelectFromModel = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectFromModel = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'threshold': ${this.opts['threshold'] ?? undefined}, 'prefit': ${\n      this.opts['prefit'] ?? undefined\n    }, 'norm_order': ${this.opts['norm_order'] ?? undefined}, 'max_features': ${\n      this.opts['max_features'] ?? undefined\n    }, 'importance_getter': ${this.opts['importance_getter'] ?? undefined}}\n\nctor_SelectFromModel = {k: v for k, v in ctor_SelectFromModel.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelectFromModel[${this.id}] = SelectFromModel(**ctor_SelectFromModel)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectFromModel[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the SelectFromModel meta-transformer.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (integers that correspond to classes in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Other estimator specific parameters.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFromModel_fit = {k: v for k, v in pms_SelectFromModel_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_fit = bridgeSelectFromModel[${this.id}].fit(**pms_SelectFromModel_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_fit.tolist() if hasattr(res_SelectFromModel_fit, 'tolist') else res_SelectFromModel_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFromModel_fit_transform = {k: v for k, v in pms_SelectFromModel_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_fit_transform = bridgeSelectFromModel[${this.id}].fit_transform(**pms_SelectFromModel_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_fit_transform.tolist() if hasattr(res_SelectFromModel_fit_transform, 'tolist') else res_SelectFromModel_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectFromModel_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectFromModel_get_feature_names_out = {k: v for k, v in pms_SelectFromModel_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_get_feature_names_out = bridgeSelectFromModel[${this.id}].get_feature_names_out(**pms_SelectFromModel_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_get_feature_names_out.tolist() if hasattr(res_SelectFromModel_get_feature_names_out, 'tolist') else res_SelectFromModel_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectFromModel_get_metadata_routing = {k: v for k, v in pms_SelectFromModel_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_get_metadata_routing = bridgeSelectFromModel[${this.id}].get_metadata_routing(**pms_SelectFromModel_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_get_metadata_routing.tolist() if hasattr(res_SelectFromModel_get_metadata_routing, 'tolist') else res_SelectFromModel_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectFromModel_get_support = {k: v for k, v in pms_SelectFromModel_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_get_support = bridgeSelectFromModel[${this.id}].get_support(**pms_SelectFromModel_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_get_support.tolist() if hasattr(res_SelectFromModel_get_support, 'tolist') else res_SelectFromModel_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFromModel_inverse_transform = {k: v for k, v in pms_SelectFromModel_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_inverse_transform = bridgeSelectFromModel[${this.id}].inverse_transform(**pms_SelectFromModel_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_inverse_transform.tolist() if hasattr(res_SelectFromModel_inverse_transform, 'tolist') else res_SelectFromModel_inverse_transform`\n  }\n\n  /**\n    Fit the SelectFromModel meta-transformer only once.\n   */\n  async partial_fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (integers that correspond to classes in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Other estimator specific parameters.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFromModel_partial_fit = {k: v for k, v in pms_SelectFromModel_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_partial_fit = bridgeSelectFromModel[${this.id}].partial_fit(**pms_SelectFromModel_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_partial_fit.tolist() if hasattr(res_SelectFromModel_partial_fit, 'tolist') else res_SelectFromModel_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectFromModel_set_output = {k: v for k, v in pms_SelectFromModel_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_set_output = bridgeSelectFromModel[${this.id}].set_output(**pms_SelectFromModel_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_set_output.tolist() if hasattr(res_SelectFromModel_set_output, 'tolist') else res_SelectFromModel_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFromModel must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFromModel_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFromModel_transform = {k: v for k, v in pms_SelectFromModel_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFromModel_transform = bridgeSelectFromModel[${this.id}].transform(**pms_SelectFromModel_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFromModel_transform.tolist() if hasattr(res_SelectFromModel_transform, 'tolist') else res_SelectFromModel_transform`\n  }\n\n  /**\n    The base estimator from which the transformer is built. This attribute exist only when `fit` has been called.\n   */\n  get estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before accessing estimator_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFromModel_estimator_ = bridgeSelectFromModel[${this.id}].estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFromModel_estimator_.tolist() if hasattr(attr_SelectFromModel_estimator_, 'tolist') else attr_SelectFromModel_estimator_`\n    })()\n  }\n\n  /**\n    Maximum number of features calculated during [fit](../../glossary.html#term-fit). Only defined if the `max\\_features` is not `undefined`.\n   */\n  get max_features_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before accessing max_features_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFromModel_max_features_ = bridgeSelectFromModel[${this.id}].max_features_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFromModel_max_features_.tolist() if hasattr(attr_SelectFromModel_max_features_, 'tolist') else attr_SelectFromModel_max_features_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFromModel instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFromModel must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFromModel_feature_names_in_ = bridgeSelectFromModel[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFromModel_feature_names_in_.tolist() if hasattr(attr_SelectFromModel_feature_names_in_, 'tolist') else attr_SelectFromModel_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Filter: Select the p-values corresponding to Family-wise error rate.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectFwe.html)\n */\nexport class SelectFwe {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). Default is f\\_classif (see below “See Also”). The default function only works with classification tasks.\n     */\n    score_func?: any\n\n    /**\n      The highest uncorrected p-value for features to keep.\n\n      @defaultValue `0.05`\n     */\n    alpha?: number\n  }) {\n    this.id = `SelectFwe${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectFwe.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectFwe\ntry: bridgeSelectFwe\nexcept NameError: bridgeSelectFwe = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectFwe = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}}\n\nctor_SelectFwe = {k: v for k, v in ctor_SelectFwe.items() if v is not None}`\n\n    await this._py.ex`bridgeSelectFwe[${this.id}] = SelectFwe(**ctor_SelectFwe)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectFwe[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelectFwe_fit = {k: v for k, v in pms_SelectFwe_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_fit = bridgeSelectFwe[${this.id}].fit(**pms_SelectFwe_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_fit.tolist() if hasattr(res_SelectFwe_fit, 'tolist') else res_SelectFwe_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectFwe_fit_transform = {k: v for k, v in pms_SelectFwe_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_fit_transform = bridgeSelectFwe[${this.id}].fit_transform(**pms_SelectFwe_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_fit_transform.tolist() if hasattr(res_SelectFwe_fit_transform, 'tolist') else res_SelectFwe_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFwe must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectFwe_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectFwe_get_feature_names_out = {k: v for k, v in pms_SelectFwe_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_get_feature_names_out = bridgeSelectFwe[${this.id}].get_feature_names_out(**pms_SelectFwe_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_get_feature_names_out.tolist() if hasattr(res_SelectFwe_get_feature_names_out, 'tolist') else res_SelectFwe_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFwe must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectFwe_get_metadata_routing = {k: v for k, v in pms_SelectFwe_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_get_metadata_routing = bridgeSelectFwe[${this.id}].get_metadata_routing(**pms_SelectFwe_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_get_metadata_routing.tolist() if hasattr(res_SelectFwe_get_metadata_routing, 'tolist') else res_SelectFwe_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectFwe_get_support = {k: v for k, v in pms_SelectFwe_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_get_support = bridgeSelectFwe[${this.id}].get_support(**pms_SelectFwe_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_get_support.tolist() if hasattr(res_SelectFwe_get_support, 'tolist') else res_SelectFwe_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFwe_inverse_transform = {k: v for k, v in pms_SelectFwe_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_inverse_transform = bridgeSelectFwe[${this.id}].inverse_transform(**pms_SelectFwe_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_inverse_transform.tolist() if hasattr(res_SelectFwe_inverse_transform, 'tolist') else res_SelectFwe_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectFwe_set_output = {k: v for k, v in pms_SelectFwe_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_set_output = bridgeSelectFwe[${this.id}].set_output(**pms_SelectFwe_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_set_output.tolist() if hasattr(res_SelectFwe_set_output, 'tolist') else res_SelectFwe_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectFwe_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectFwe_transform = {k: v for k, v in pms_SelectFwe_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectFwe_transform = bridgeSelectFwe[${this.id}].transform(**pms_SelectFwe_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectFwe_transform.tolist() if hasattr(res_SelectFwe_transform, 'tolist') else res_SelectFwe_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFwe_scores_ = bridgeSelectFwe[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFwe_scores_.tolist() if hasattr(attr_SelectFwe_scores_, 'tolist') else attr_SelectFwe_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectFwe must call init() before accessing pvalues_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFwe_pvalues_ = bridgeSelectFwe[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFwe_pvalues_.tolist() if hasattr(attr_SelectFwe_pvalues_, 'tolist') else attr_SelectFwe_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFwe must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFwe_n_features_in_ = bridgeSelectFwe[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFwe_n_features_in_.tolist() if hasattr(attr_SelectFwe_n_features_in_, 'tolist') else attr_SelectFwe_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SelectFwe instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectFwe must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectFwe_feature_names_in_ = bridgeSelectFwe[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectFwe_feature_names_in_.tolist() if hasattr(attr_SelectFwe_feature_names_in_, 'tolist') else attr_SelectFwe_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Select features according to the k highest scores.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html)\n */\nexport class SelectKBest {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues) or a single array with scores. Default is f\\_classif (see below “See Also”). The default function only works with classification tasks.\n     */\n    score_func?: any\n\n    /**\n      Number of top features to select. The “all” option bypasses selection, for use in a parameter search.\n\n      @defaultValue `10`\n     */\n    k?: number | 'all'\n  }) {\n    this.id = `SelectKBest${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectKBest.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectKBest\ntry: bridgeSelectKBest\nexcept NameError: bridgeSelectKBest = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectKBest = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'k': ${this.opts['k'] ?? undefined}}\n\nctor_SelectKBest = {k: v for k, v in ctor_SelectKBest.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelectKBest[${this.id}] = SelectKBest(**ctor_SelectKBest)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectKBest[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelectKBest_fit = {k: v for k, v in pms_SelectKBest_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_fit = bridgeSelectKBest[${this.id}].fit(**pms_SelectKBest_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_fit.tolist() if hasattr(res_SelectKBest_fit, 'tolist') else res_SelectKBest_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectKBest_fit_transform = {k: v for k, v in pms_SelectKBest_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_fit_transform = bridgeSelectKBest[${this.id}].fit_transform(**pms_SelectKBest_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_fit_transform.tolist() if hasattr(res_SelectKBest_fit_transform, 'tolist') else res_SelectKBest_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectKBest must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectKBest_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectKBest_get_feature_names_out = {k: v for k, v in pms_SelectKBest_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_get_feature_names_out = bridgeSelectKBest[${this.id}].get_feature_names_out(**pms_SelectKBest_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_get_feature_names_out.tolist() if hasattr(res_SelectKBest_get_feature_names_out, 'tolist') else res_SelectKBest_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectKBest must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectKBest_get_metadata_routing = {k: v for k, v in pms_SelectKBest_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_get_metadata_routing = bridgeSelectKBest[${this.id}].get_metadata_routing(**pms_SelectKBest_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_get_metadata_routing.tolist() if hasattr(res_SelectKBest_get_metadata_routing, 'tolist') else res_SelectKBest_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectKBest_get_support = {k: v for k, v in pms_SelectKBest_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_get_support = bridgeSelectKBest[${this.id}].get_support(**pms_SelectKBest_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_get_support.tolist() if hasattr(res_SelectKBest_get_support, 'tolist') else res_SelectKBest_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectKBest_inverse_transform = {k: v for k, v in pms_SelectKBest_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_inverse_transform = bridgeSelectKBest[${this.id}].inverse_transform(**pms_SelectKBest_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_inverse_transform.tolist() if hasattr(res_SelectKBest_inverse_transform, 'tolist') else res_SelectKBest_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectKBest_set_output = {k: v for k, v in pms_SelectKBest_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_set_output = bridgeSelectKBest[${this.id}].set_output(**pms_SelectKBest_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_set_output.tolist() if hasattr(res_SelectKBest_set_output, 'tolist') else res_SelectKBest_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectKBest_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectKBest_transform = {k: v for k, v in pms_SelectKBest_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectKBest_transform = bridgeSelectKBest[${this.id}].transform(**pms_SelectKBest_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectKBest_transform.tolist() if hasattr(res_SelectKBest_transform, 'tolist') else res_SelectKBest_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectKBest_scores_ = bridgeSelectKBest[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectKBest_scores_.tolist() if hasattr(attr_SelectKBest_scores_, 'tolist') else attr_SelectKBest_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores, `undefined` if `score\\_func` returned only scores.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectKBest must call init() before accessing pvalues_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectKBest_pvalues_ = bridgeSelectKBest[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectKBest_pvalues_.tolist() if hasattr(attr_SelectKBest_pvalues_, 'tolist') else attr_SelectKBest_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectKBest must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectKBest_n_features_in_ = bridgeSelectKBest[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectKBest_n_features_in_.tolist() if hasattr(attr_SelectKBest_n_features_in_, 'tolist') else attr_SelectKBest_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SelectKBest instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectKBest must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectKBest_feature_names_in_ = bridgeSelectKBest[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectKBest_feature_names_in_.tolist() if hasattr(attr_SelectKBest_feature_names_in_, 'tolist') else attr_SelectKBest_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transformer mixin that performs feature selection given a support mask\n\n  This mixin provides a feature selector implementation with `transform` and `inverse\\_transform` functionality given an implementation of `\\_get\\_support\\_mask`.\n\n  Methods\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectorMixin.html)\n */\nexport class SelectorMixin {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }) {\n    this.id = `SelectorMixin${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectorMixin.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectorMixin\ntry: bridgeSelectorMixin\nexcept NameError: bridgeSelectorMixin = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectorMixin = {'X': np.array(${\n      this.opts['X'] ?? undefined\n    }) if ${this.opts['X'] !== undefined} else None, 'y': np.array(${\n      this.opts['y'] ?? undefined\n    }) if ${this.opts['y'] !== undefined} else None, 'fit_params': ${\n      this.opts['fit_params'] ?? undefined\n    }}\n\nctor_SelectorMixin = {k: v for k, v in ctor_SelectorMixin.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelectorMixin[${this.id}] = SelectorMixin(**ctor_SelectorMixin)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectorMixin[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectorMixin must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectorMixin_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectorMixin_fit_transform = {k: v for k, v in pms_SelectorMixin_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_fit_transform = bridgeSelectorMixin[${this.id}].fit_transform(**pms_SelectorMixin_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_fit_transform.tolist() if hasattr(res_SelectorMixin_fit_transform, 'tolist') else res_SelectorMixin_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectorMixin must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectorMixin_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectorMixin_get_feature_names_out = {k: v for k, v in pms_SelectorMixin_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_get_feature_names_out = bridgeSelectorMixin[${this.id}].get_feature_names_out(**pms_SelectorMixin_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_get_feature_names_out.tolist() if hasattr(res_SelectorMixin_get_feature_names_out, 'tolist') else res_SelectorMixin_get_feature_names_out`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectorMixin must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectorMixin_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectorMixin_get_support = {k: v for k, v in pms_SelectorMixin_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_get_support = bridgeSelectorMixin[${this.id}].get_support(**pms_SelectorMixin_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_get_support.tolist() if hasattr(res_SelectorMixin_get_support, 'tolist') else res_SelectorMixin_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectorMixin must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectorMixin_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectorMixin_inverse_transform = {k: v for k, v in pms_SelectorMixin_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_inverse_transform = bridgeSelectorMixin[${this.id}].inverse_transform(**pms_SelectorMixin_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_inverse_transform.tolist() if hasattr(res_SelectorMixin_inverse_transform, 'tolist') else res_SelectorMixin_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectorMixin must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectorMixin_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectorMixin_set_output = {k: v for k, v in pms_SelectorMixin_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_set_output = bridgeSelectorMixin[${this.id}].set_output(**pms_SelectorMixin_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_set_output.tolist() if hasattr(res_SelectorMixin_set_output, 'tolist') else res_SelectorMixin_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectorMixin must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectorMixin_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectorMixin_transform = {k: v for k, v in pms_SelectorMixin_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectorMixin_transform = bridgeSelectorMixin[${this.id}].transform(**pms_SelectorMixin_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectorMixin_transform.tolist() if hasattr(res_SelectorMixin_transform, 'tolist') else res_SelectorMixin_transform`\n  }\n\n  /**\n    Transformed array.\n   */\n  get X_new(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SelectorMixin instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectorMixin must call init() before accessing X_new')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectorMixin_X_new = bridgeSelectorMixin[${this.id}].X_new`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectorMixin_X_new.tolist() if hasattr(attr_SelectorMixin_X_new, 'tolist') else attr_SelectorMixin_X_new`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Select features according to a percentile of the highest scores.\n\n  Read more in the [User Guide](../feature_selection.html#univariate-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectPercentile.html)\n */\nexport class SelectPercentile {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues) or a single array with scores. Default is f\\_classif (see below “See Also”). The default function only works with classification tasks.\n     */\n    score_func?: any\n\n    /**\n      Percent of features to keep.\n\n      @defaultValue `10`\n     */\n    percentile?: number\n  }) {\n    this.id = `SelectPercentile${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SelectPercentile.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SelectPercentile\ntry: bridgeSelectPercentile\nexcept NameError: bridgeSelectPercentile = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelectPercentile = {'score_func': ${\n      this.opts['score_func'] ?? undefined\n    }, 'percentile': ${this.opts['percentile'] ?? undefined}}\n\nctor_SelectPercentile = {k: v for k, v in ctor_SelectPercentile.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelectPercentile[${this.id}] = SelectPercentile(**ctor_SelectPercentile)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelectPercentile[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Run score function on (X, y) and get the appropriate features.\n   */\n  async fit(opts: {\n    /**\n      The training input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectPercentile must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelectPercentile_fit = {k: v for k, v in pms_SelectPercentile_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_fit = bridgeSelectPercentile[${this.id}].fit(**pms_SelectPercentile_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_fit.tolist() if hasattr(res_SelectPercentile_fit, 'tolist') else res_SelectPercentile_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SelectPercentile_fit_transform = {k: v for k, v in pms_SelectPercentile_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_fit_transform = bridgeSelectPercentile[${this.id}].fit_transform(**pms_SelectPercentile_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_fit_transform.tolist() if hasattr(res_SelectPercentile_fit_transform, 'tolist') else res_SelectPercentile_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelectPercentile_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SelectPercentile_get_feature_names_out = {k: v for k, v in pms_SelectPercentile_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_get_feature_names_out = bridgeSelectPercentile[${this.id}].get_feature_names_out(**pms_SelectPercentile_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_get_feature_names_out.tolist() if hasattr(res_SelectPercentile_get_feature_names_out, 'tolist') else res_SelectPercentile_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelectPercentile_get_metadata_routing = {k: v for k, v in pms_SelectPercentile_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_get_metadata_routing = bridgeSelectPercentile[${this.id}].get_metadata_routing(**pms_SelectPercentile_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_get_metadata_routing.tolist() if hasattr(res_SelectPercentile_get_metadata_routing, 'tolist') else res_SelectPercentile_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectPercentile must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SelectPercentile_get_support = {k: v for k, v in pms_SelectPercentile_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_get_support = bridgeSelectPercentile[${this.id}].get_support(**pms_SelectPercentile_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_get_support.tolist() if hasattr(res_SelectPercentile_get_support, 'tolist') else res_SelectPercentile_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectPercentile_inverse_transform = {k: v for k, v in pms_SelectPercentile_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_inverse_transform = bridgeSelectPercentile[${this.id}].inverse_transform(**pms_SelectPercentile_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_inverse_transform.tolist() if hasattr(res_SelectPercentile_inverse_transform, 'tolist') else res_SelectPercentile_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectPercentile must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SelectPercentile_set_output = {k: v for k, v in pms_SelectPercentile_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_set_output = bridgeSelectPercentile[${this.id}].set_output(**pms_SelectPercentile_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_set_output.tolist() if hasattr(res_SelectPercentile_set_output, 'tolist') else res_SelectPercentile_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelectPercentile must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelectPercentile_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelectPercentile_transform = {k: v for k, v in pms_SelectPercentile_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelectPercentile_transform = bridgeSelectPercentile[${this.id}].transform(**pms_SelectPercentile_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelectPercentile_transform.tolist() if hasattr(res_SelectPercentile_transform, 'tolist') else res_SelectPercentile_transform`\n  }\n\n  /**\n    Scores of features.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before accessing scores_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectPercentile_scores_ = bridgeSelectPercentile[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectPercentile_scores_.tolist() if hasattr(attr_SelectPercentile_scores_, 'tolist') else attr_SelectPercentile_scores_`\n    })()\n  }\n\n  /**\n    p-values of feature scores, `undefined` if `score\\_func` returned only scores.\n   */\n  get pvalues_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before accessing pvalues_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectPercentile_pvalues_ = bridgeSelectPercentile[${this.id}].pvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectPercentile_pvalues_.tolist() if hasattr(attr_SelectPercentile_pvalues_, 'tolist') else attr_SelectPercentile_pvalues_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectPercentile_n_features_in_ = bridgeSelectPercentile[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectPercentile_n_features_in_.tolist() if hasattr(attr_SelectPercentile_n_features_in_, 'tolist') else attr_SelectPercentile_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelectPercentile instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelectPercentile must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelectPercentile_feature_names_in_ = bridgeSelectPercentile[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelectPercentile_feature_names_in_.tolist() if hasattr(attr_SelectPercentile_feature_names_in_, 'tolist') else attr_SelectPercentile_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transformer that performs Sequential Feature Selection.\n\n  This Sequential Feature Selector adds (forward selection) or removes (backward selection) features to form a feature subset in a greedy fashion. At each stage, this estimator chooses the best feature to add or remove based on the cross-validation score of an estimator. In the case of unsupervised learning, this Sequential Feature Selector looks only at the features (X), not the desired outputs (y).\n\n  Read more in the [User Guide](../feature_selection.html#sequential-feature-selection).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SequentialFeatureSelector.html)\n */\nexport class SequentialFeatureSelector {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An unfitted estimator.\n     */\n    estimator?: any\n\n    /**\n      If `\"auto\"`, the behaviour depends on the `tol` parameter:\n\n      @defaultValue `'auto'`\n     */\n    n_features_to_select?: 'auto' | number | number\n\n    /**\n      If the score is not incremented by at least `tol` between two consecutive feature additions or removals, stop adding or removing.\n\n      `tol` can be negative when removing features using `direction=\"backward\"`. It can be useful to reduce the number of features at the cost of a small decrease in the score.\n\n      `tol` is enabled only when `n\\_features\\_to\\_select` is `\"auto\"`.\n     */\n    tol?: number\n\n    /**\n      Whether to perform forward selection or backward selection.\n\n      @defaultValue `'forward'`\n     */\n    direction?: 'forward' | 'backward'\n\n    /**\n      A single str (see [The scoring parameter: defining model evaluation rules](../model_evaluation.html#scoring-parameter)) or a callable (see [Defining your scoring strategy from metric functions](../model_evaluation.html#scoring)) to evaluate the predictions on the test set.\n\n      NOTE that when using a custom scorer, it should return a single value.\n\n      If `undefined`, the estimator’s score method is used.\n     */\n    scoring?: string\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Number of jobs to run in parallel. When evaluating a new feature to add or remove, the cross-validation procedure is parallel over the folds. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `SequentialFeatureSelector${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SequentialFeatureSelector.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import SequentialFeatureSelector\ntry: bridgeSequentialFeatureSelector\nexcept NameError: bridgeSequentialFeatureSelector = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SequentialFeatureSelector = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'n_features_to_select': ${\n      this.opts['n_features_to_select'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'direction': ${\n      this.opts['direction'] ?? undefined\n    }, 'scoring': ${this.opts['scoring'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_SequentialFeatureSelector = {k: v for k, v in ctor_SequentialFeatureSelector.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSequentialFeatureSelector[${this.id}] = SequentialFeatureSelector(**ctor_SequentialFeatureSelector)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSequentialFeatureSelector[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Learn the features to select from X.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of predictors.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values. This parameter may be ignored for unsupervised learning.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SequentialFeatureSelector must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SequentialFeatureSelector_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SequentialFeatureSelector_fit = {k: v for k, v in pms_SequentialFeatureSelector_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_fit = bridgeSequentialFeatureSelector[${this.id}].fit(**pms_SequentialFeatureSelector_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_fit.tolist() if hasattr(res_SequentialFeatureSelector_fit, 'tolist') else res_SequentialFeatureSelector_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SequentialFeatureSelector_fit_transform = {k: v for k, v in pms_SequentialFeatureSelector_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_fit_transform = bridgeSequentialFeatureSelector[${this.id}].fit_transform(**pms_SequentialFeatureSelector_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_fit_transform.tolist() if hasattr(res_SequentialFeatureSelector_fit_transform, 'tolist') else res_SequentialFeatureSelector_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SequentialFeatureSelector_get_feature_names_out = {k: v for k, v in pms_SequentialFeatureSelector_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_get_feature_names_out = bridgeSequentialFeatureSelector[${this.id}].get_feature_names_out(**pms_SequentialFeatureSelector_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_get_feature_names_out.tolist() if hasattr(res_SequentialFeatureSelector_get_feature_names_out, 'tolist') else res_SequentialFeatureSelector_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SequentialFeatureSelector_get_metadata_routing = {k: v for k, v in pms_SequentialFeatureSelector_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_get_metadata_routing = bridgeSequentialFeatureSelector[${this.id}].get_metadata_routing(**pms_SequentialFeatureSelector_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_get_metadata_routing.tolist() if hasattr(res_SequentialFeatureSelector_get_metadata_routing, 'tolist') else res_SequentialFeatureSelector_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before get_support()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SequentialFeatureSelector_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_SequentialFeatureSelector_get_support = {k: v for k, v in pms_SequentialFeatureSelector_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_get_support = bridgeSequentialFeatureSelector[${this.id}].get_support(**pms_SequentialFeatureSelector_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_get_support.tolist() if hasattr(res_SequentialFeatureSelector_get_support, 'tolist') else res_SequentialFeatureSelector_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SequentialFeatureSelector_inverse_transform = {k: v for k, v in pms_SequentialFeatureSelector_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_inverse_transform = bridgeSequentialFeatureSelector[${this.id}].inverse_transform(**pms_SequentialFeatureSelector_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_inverse_transform.tolist() if hasattr(res_SequentialFeatureSelector_inverse_transform, 'tolist') else res_SequentialFeatureSelector_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SequentialFeatureSelector_set_output = {k: v for k, v in pms_SequentialFeatureSelector_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_set_output = bridgeSequentialFeatureSelector[${this.id}].set_output(**pms_SequentialFeatureSelector_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_set_output.tolist() if hasattr(res_SequentialFeatureSelector_set_output, 'tolist') else res_SequentialFeatureSelector_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SequentialFeatureSelector_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SequentialFeatureSelector_transform = {k: v for k, v in pms_SequentialFeatureSelector_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SequentialFeatureSelector_transform = bridgeSequentialFeatureSelector[${this.id}].transform(**pms_SequentialFeatureSelector_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SequentialFeatureSelector_transform.tolist() if hasattr(res_SequentialFeatureSelector_transform, 'tolist') else res_SequentialFeatureSelector_transform`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SequentialFeatureSelector_n_features_in_ = bridgeSequentialFeatureSelector[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SequentialFeatureSelector_n_features_in_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_in_, 'tolist') else attr_SequentialFeatureSelector_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SequentialFeatureSelector_feature_names_in_ = bridgeSequentialFeatureSelector[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SequentialFeatureSelector_feature_names_in_.tolist() if hasattr(attr_SequentialFeatureSelector_feature_names_in_, 'tolist') else attr_SequentialFeatureSelector_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of features that were selected.\n   */\n  get n_features_to_select_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before accessing n_features_to_select_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SequentialFeatureSelector_n_features_to_select_ = bridgeSequentialFeatureSelector[${this.id}].n_features_to_select_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SequentialFeatureSelector_n_features_to_select_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_to_select_, 'tolist') else attr_SequentialFeatureSelector_n_features_to_select_`\n    })()\n  }\n\n  /**\n    The mask of selected features.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SequentialFeatureSelector instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SequentialFeatureSelector must call init() before accessing support_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SequentialFeatureSelector_support_ = bridgeSequentialFeatureSelector[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SequentialFeatureSelector_support_.tolist() if hasattr(attr_SequentialFeatureSelector_support_, 'tolist') else attr_SequentialFeatureSelector_support_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Feature selector that removes all low-variance features.\n\n  This feature selection algorithm looks only at the features (X), not the desired outputs (y), and can thus be used for unsupervised learning.\n\n  Read more in the [User Guide](../feature_selection.html#variance-threshold).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.VarianceThreshold.html)\n */\nexport class VarianceThreshold {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Features with a training-set variance lower than this threshold will be removed. The default is to keep all features with non-zero variance, i.e. remove the features that have the same value in all samples.\n\n      @defaultValue `0`\n     */\n    threshold?: number\n  }) {\n    this.id = `VarianceThreshold${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('VarianceThreshold.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.feature_selection import VarianceThreshold\ntry: bridgeVarianceThreshold\nexcept NameError: bridgeVarianceThreshold = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_VarianceThreshold = {'threshold': ${\n      this.opts['threshold'] ?? undefined\n    }}\n\nctor_VarianceThreshold = {k: v for k, v in ctor_VarianceThreshold.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeVarianceThreshold[${this.id}] = VarianceThreshold(**ctor_VarianceThreshold)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeVarianceThreshold[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Learn empirical variances from X.\n   */\n  async fit(opts: {\n    /**\n      Data from which to compute variances, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Ignored. This parameter exists only for compatibility with sklearn.pipeline.Pipeline.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('VarianceThreshold must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_VarianceThreshold_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_VarianceThreshold_fit = {k: v for k, v in pms_VarianceThreshold_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_fit = bridgeVarianceThreshold[${this.id}].fit(**pms_VarianceThreshold_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_fit.tolist() if hasattr(res_VarianceThreshold_fit, 'tolist') else res_VarianceThreshold_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_VarianceThreshold_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_VarianceThreshold_fit_transform = {k: v for k, v in pms_VarianceThreshold_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_fit_transform = bridgeVarianceThreshold[${this.id}].fit_transform(**pms_VarianceThreshold_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_fit_transform.tolist() if hasattr(res_VarianceThreshold_fit_transform, 'tolist') else res_VarianceThreshold_fit_transform`\n  }\n\n  /**\n    Mask feature names according to selected features.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_VarianceThreshold_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_VarianceThreshold_get_feature_names_out = {k: v for k, v in pms_VarianceThreshold_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_get_feature_names_out = bridgeVarianceThreshold[${this.id}].get_feature_names_out(**pms_VarianceThreshold_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_get_feature_names_out.tolist() if hasattr(res_VarianceThreshold_get_feature_names_out, 'tolist') else res_VarianceThreshold_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_VarianceThreshold_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_VarianceThreshold_get_metadata_routing = {k: v for k, v in pms_VarianceThreshold_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_get_metadata_routing = bridgeVarianceThreshold[${this.id}].get_metadata_routing(**pms_VarianceThreshold_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_get_metadata_routing.tolist() if hasattr(res_VarianceThreshold_get_metadata_routing, 'tolist') else res_VarianceThreshold_get_metadata_routing`\n  }\n\n  /**\n    Get a mask, or integer index, of the features selected.\n   */\n  async get_support(opts: {\n    /**\n      If `true`, the return value will be an array of integers, rather than a boolean mask.\n\n      @defaultValue `false`\n     */\n    indices?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('VarianceThreshold must call init() before get_support()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_VarianceThreshold_get_support = {'indices': ${\n      opts['indices'] ?? undefined\n    }}\n\npms_VarianceThreshold_get_support = {k: v for k, v in pms_VarianceThreshold_get_support.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_get_support = bridgeVarianceThreshold[${this.id}].get_support(**pms_VarianceThreshold_get_support)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_get_support.tolist() if hasattr(res_VarianceThreshold_get_support, 'tolist') else res_VarianceThreshold_get_support`\n  }\n\n  /**\n    Reverse the transformation operation.\n   */\n  async inverse_transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_VarianceThreshold_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_VarianceThreshold_inverse_transform = {k: v for k, v in pms_VarianceThreshold_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_inverse_transform = bridgeVarianceThreshold[${this.id}].inverse_transform(**pms_VarianceThreshold_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_inverse_transform.tolist() if hasattr(res_VarianceThreshold_inverse_transform, 'tolist') else res_VarianceThreshold_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('VarianceThreshold must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_VarianceThreshold_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_VarianceThreshold_set_output = {k: v for k, v in pms_VarianceThreshold_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_set_output = bridgeVarianceThreshold[${this.id}].set_output(**pms_VarianceThreshold_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_set_output.tolist() if hasattr(res_VarianceThreshold_set_output, 'tolist') else res_VarianceThreshold_set_output`\n  }\n\n  /**\n    Reduce X to the selected features.\n   */\n  async transform(opts: {\n    /**\n      The input samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('VarianceThreshold must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_VarianceThreshold_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_VarianceThreshold_transform = {k: v for k, v in pms_VarianceThreshold_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_VarianceThreshold_transform = bridgeVarianceThreshold[${this.id}].transform(**pms_VarianceThreshold_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_VarianceThreshold_transform.tolist() if hasattr(res_VarianceThreshold_transform, 'tolist') else res_VarianceThreshold_transform`\n  }\n\n  /**\n    Variances of individual features.\n   */\n  get variances_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before accessing variances_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_VarianceThreshold_variances_ = bridgeVarianceThreshold[${this.id}].variances_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_VarianceThreshold_variances_.tolist() if hasattr(attr_VarianceThreshold_variances_, 'tolist') else attr_VarianceThreshold_variances_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_VarianceThreshold_n_features_in_ = bridgeVarianceThreshold[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_VarianceThreshold_n_features_in_.tolist() if hasattr(attr_VarianceThreshold_n_features_in_, 'tolist') else attr_VarianceThreshold_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This VarianceThreshold instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'VarianceThreshold must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_VarianceThreshold_feature_names_in_ = bridgeVarianceThreshold[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_VarianceThreshold_feature_names_in_.tolist() if hasattr(attr_VarianceThreshold_feature_names_in_, 'tolist') else attr_VarianceThreshold_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}