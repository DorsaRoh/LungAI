{"version":3,"sources":["../../../src/generated/multiclass/OneVsOneClassifier.ts","../../../src/generated/multiclass/OneVsRestClassifier.ts","../../../src/generated/multiclass/OutputCodeClassifier.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  One-vs-one multiclass strategy.\n\n  This strategy consists in fitting one classifier per class pair. At prediction time, the class which received the most votes is selected. Since it requires to fit `n\\_classes \\* (n\\_classes \\- 1) / 2` classifiers, this method is usually slower than one-vs-the-rest, due to its O(n\\_classes^2) complexity. However, this method may be advantageous for algorithms such as kernel algorithms which don’t scale well with `n\\_samples`. This is because each individual learning problem only involves a small subset of the data whereas, with one-vs-the-rest, the complete dataset is used `n\\_classes` times.\n\n  Read more in the [User Guide](../multiclass.html#ovo-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.multiclass.OneVsOneClassifier.html)\n */\nexport class OneVsOneClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      A regressor or a classifier that implements [fit](../../glossary.html#term-fit). When a classifier is passed, [decision\\_function](../../glossary.html#term-decision_function) will be used in priority and it will fallback to [predict\\_proba](../../glossary.html#term-predict_proba) if it is not available. When a regressor is passed, [predict](../../glossary.html#term-predict) is used.\n     */\n    estimator?: any\n\n    /**\n      The number of jobs to use for the computation: the `n\\_classes \\* ( n\\_classes \\- 1) / 2` OVO problems are computed in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `OneVsOneClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'OneVsOneClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.multiclass import OneVsOneClassifier\ntry: bridgeOneVsOneClassifier\nexcept NameError: bridgeOneVsOneClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OneVsOneClassifier = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_OneVsOneClassifier = {k: v for k, v in ctor_OneVsOneClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOneVsOneClassifier[${this.id}] = OneVsOneClassifier(**ctor_OneVsOneClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOneVsOneClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Decision function for the OneVsOneClassifier.\n\n    The decision values for the samples are computed by adding the normalized sum of pair-wise classification confidence levels to the votes in order to disambiguate between the decision values when the votes for all the classes are equal leading to a tie.\n   */\n  async decision_function(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsOneClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneVsOneClassifier_decision_function = {k: v for k, v in pms_OneVsOneClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_decision_function = bridgeOneVsOneClassifier[${this.id}].decision_function(**pms_OneVsOneClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_decision_function.tolist() if hasattr(res_OneVsOneClassifier_decision_function, 'tolist') else res_OneVsOneClassifier_decision_function`\n  }\n\n  /**\n    Fit underlying estimators.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Multi-class targets.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsOneClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsOneClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_OneVsOneClassifier_fit = {k: v for k, v in pms_OneVsOneClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_fit = bridgeOneVsOneClassifier[${this.id}].fit(**pms_OneVsOneClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_fit.tolist() if hasattr(res_OneVsOneClassifier_fit, 'tolist') else res_OneVsOneClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsOneClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OneVsOneClassifier_get_metadata_routing = {k: v for k, v in pms_OneVsOneClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_get_metadata_routing = bridgeOneVsOneClassifier[${this.id}].get_metadata_routing(**pms_OneVsOneClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_get_metadata_routing.tolist() if hasattr(res_OneVsOneClassifier_get_metadata_routing, 'tolist') else res_OneVsOneClassifier_get_metadata_routing`\n  }\n\n  /**\n    Partially fit underlying estimators.\n\n    Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration, where the first call should have an array of all target variables.\n   */\n  async partial_fit(opts: {\n    /**\n      Data.\n     */\n    X?: any[]\n\n    /**\n      Multi-class targets.\n     */\n    y?: ArrayLike\n\n    /**\n      Classes across all calls to partial\\_fit. Can be obtained via `np.unique(y\\_all)`, where y\\_all is the target vector of the entire dataset. This argument is only required in the first call of partial\\_fit and can be omitted in the subsequent calls.\n     */\n    classes?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsOneClassifier_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'classes': ${\n      opts['classes'] ?? undefined\n    }}\n\npms_OneVsOneClassifier_partial_fit = {k: v for k, v in pms_OneVsOneClassifier_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_partial_fit = bridgeOneVsOneClassifier[${this.id}].partial_fit(**pms_OneVsOneClassifier_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_partial_fit.tolist() if hasattr(res_OneVsOneClassifier_partial_fit, 'tolist') else res_OneVsOneClassifier_partial_fit`\n  }\n\n  /**\n    Estimate the best class label for each sample in X.\n\n    This is implemented as `argmax(decision\\_function(X), axis=1)` which will return the label of the class with most votes by estimators predicting the outcome of a decision for each possible class pair.\n   */\n  async predict(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsOneClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsOneClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneVsOneClassifier_predict = {k: v for k, v in pms_OneVsOneClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_predict = bridgeOneVsOneClassifier[${this.id}].predict(**pms_OneVsOneClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_predict.tolist() if hasattr(res_OneVsOneClassifier_predict, 'tolist') else res_OneVsOneClassifier_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsOneClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsOneClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_OneVsOneClassifier_score = {k: v for k, v in pms_OneVsOneClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_score = bridgeOneVsOneClassifier[${this.id}].score(**pms_OneVsOneClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_score.tolist() if hasattr(res_OneVsOneClassifier_score, 'tolist') else res_OneVsOneClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `classes` parameter in `partial\\_fit`.\n     */\n    classes?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsOneClassifier_set_partial_fit_request = {'classes': ${\n      opts['classes'] ?? undefined\n    }}\n\npms_OneVsOneClassifier_set_partial_fit_request = {k: v for k, v in pms_OneVsOneClassifier_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_set_partial_fit_request = bridgeOneVsOneClassifier[${this.id}].set_partial_fit_request(**pms_OneVsOneClassifier_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_set_partial_fit_request.tolist() if hasattr(res_OneVsOneClassifier_set_partial_fit_request, 'tolist') else res_OneVsOneClassifier_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsOneClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OneVsOneClassifier_set_score_request = {k: v for k, v in pms_OneVsOneClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsOneClassifier_set_score_request = bridgeOneVsOneClassifier[${this.id}].set_score_request(**pms_OneVsOneClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsOneClassifier_set_score_request.tolist() if hasattr(res_OneVsOneClassifier_set_score_request, 'tolist') else res_OneVsOneClassifier_set_score_request`\n  }\n\n  /**\n    Estimators used for predictions.\n   */\n  get estimators_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before accessing estimators_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsOneClassifier_estimators_ = bridgeOneVsOneClassifier[${this.id}].estimators_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsOneClassifier_estimators_.tolist() if hasattr(attr_OneVsOneClassifier_estimators_, 'tolist') else attr_OneVsOneClassifier_estimators_`\n    })()\n  }\n\n  /**\n    Array containing labels.\n   */\n  get classes_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsOneClassifier_classes_ = bridgeOneVsOneClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsOneClassifier_classes_.tolist() if hasattr(attr_OneVsOneClassifier_classes_, 'tolist') else attr_OneVsOneClassifier_classes_`\n    })()\n  }\n\n  /**\n    Indices of samples used when training the estimators. `undefined` when `estimator`’s `pairwise` tag is `false`.\n   */\n  get pairwise_indices_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before accessing pairwise_indices_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsOneClassifier_pairwise_indices_ = bridgeOneVsOneClassifier[${this.id}].pairwise_indices_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsOneClassifier_pairwise_indices_.tolist() if hasattr(attr_OneVsOneClassifier_pairwise_indices_, 'tolist') else attr_OneVsOneClassifier_pairwise_indices_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsOneClassifier_n_features_in_ = bridgeOneVsOneClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsOneClassifier_n_features_in_.tolist() if hasattr(attr_OneVsOneClassifier_n_features_in_, 'tolist') else attr_OneVsOneClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsOneClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsOneClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsOneClassifier_feature_names_in_ = bridgeOneVsOneClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsOneClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsOneClassifier_feature_names_in_, 'tolist') else attr_OneVsOneClassifier_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  One-vs-the-rest (OvR) multiclass strategy.\n\n  Also known as one-vs-all, this strategy consists in fitting one classifier per class. For each classifier, the class is fitted against all the other classes. In addition to its computational efficiency (only `n\\_classes` classifiers are needed), one advantage of this approach is its interpretability. Since each class is represented by one and one classifier only, it is possible to gain knowledge about the class by inspecting its corresponding classifier. This is the most commonly used strategy for multiclass classification and is a fair default choice.\n\n  OneVsRestClassifier can also be used for multilabel classification. To use this feature, provide an indicator matrix for the target `y` when calling `.fit`. In other words, the target labels should be formatted as a 2D binary (0/1) matrix, where \\[i, j\\] == 1 indicates the presence of label j in sample i. This estimator uses the binary relevance method to perform multilabel classification, which involves training one binary classifier independently for each label.\n\n  Read more in the [User Guide](../multiclass.html#ovr-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.multiclass.OneVsRestClassifier.html)\n */\nexport class OneVsRestClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      A regressor or a classifier that implements [fit](../../glossary.html#term-fit). When a classifier is passed, [decision\\_function](../../glossary.html#term-decision_function) will be used in priority and it will fallback to [predict\\_proba](../../glossary.html#term-predict_proba) if it is not available. When a regressor is passed, [predict](../../glossary.html#term-predict) is used.\n     */\n    estimator?: any\n\n    /**\n      The number of jobs to use for the computation: the `n\\_classes` one-vs-rest problems are computed in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The verbosity level, if non zero, progress messages are printed. Below 50, the output is sent to stderr. Otherwise, the output is sent to stdout. The frequency of the messages increases with the verbosity level, reporting all iterations at 10. See [`joblib.Parallel`](https://joblib.readthedocs.io/en/latest/generated/joblib.Parallel.html#joblib.Parallel \"(in joblib v1.4.dev0)\") for more details.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n  }) {\n    this.id = `OneVsRestClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'OneVsRestClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.multiclass import OneVsRestClassifier\ntry: bridgeOneVsRestClassifier\nexcept NameError: bridgeOneVsRestClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OneVsRestClassifier = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_OneVsRestClassifier = {k: v for k, v in ctor_OneVsRestClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOneVsRestClassifier[${this.id}] = OneVsRestClassifier(**ctor_OneVsRestClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOneVsRestClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Decision function for the OneVsRestClassifier.\n\n    Return the distance of each sample from the decision boundary for each class. This can only be used with estimators which implement the `decision\\_function` method.\n   */\n  async decision_function(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsRestClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneVsRestClassifier_decision_function = {k: v for k, v in pms_OneVsRestClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_decision_function = bridgeOneVsRestClassifier[${this.id}].decision_function(**pms_OneVsRestClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_decision_function.tolist() if hasattr(res_OneVsRestClassifier_decision_function, 'tolist') else res_OneVsRestClassifier_decision_function`\n  }\n\n  /**\n    Fit underlying estimators.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Multi-class targets. An indicator matrix turns on multilabel classification.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsRestClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsRestClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_OneVsRestClassifier_fit = {k: v for k, v in pms_OneVsRestClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_fit = bridgeOneVsRestClassifier[${this.id}].fit(**pms_OneVsRestClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_fit.tolist() if hasattr(res_OneVsRestClassifier_fit, 'tolist') else res_OneVsRestClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsRestClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OneVsRestClassifier_get_metadata_routing = {k: v for k, v in pms_OneVsRestClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_get_metadata_routing = bridgeOneVsRestClassifier[${this.id}].get_metadata_routing(**pms_OneVsRestClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_get_metadata_routing.tolist() if hasattr(res_OneVsRestClassifier_get_metadata_routing, 'tolist') else res_OneVsRestClassifier_get_metadata_routing`\n  }\n\n  /**\n    Partially fit underlying estimators.\n\n    Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration.\n   */\n  async partial_fit(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Multi-class targets. An indicator matrix turns on multilabel classification.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Classes across all calls to partial\\_fit. Can be obtained via `np.unique(y\\_all)`, where y\\_all is the target vector of the entire dataset. This argument is only required in the first call of partial\\_fit and can be omitted in the subsequent calls.\n     */\n    classes?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsRestClassifier_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'classes': ${\n      opts['classes'] ?? undefined\n    }}\n\npms_OneVsRestClassifier_partial_fit = {k: v for k, v in pms_OneVsRestClassifier_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_partial_fit = bridgeOneVsRestClassifier[${this.id}].partial_fit(**pms_OneVsRestClassifier_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_partial_fit.tolist() if hasattr(res_OneVsRestClassifier_partial_fit, 'tolist') else res_OneVsRestClassifier_partial_fit`\n  }\n\n  /**\n    Predict multi-class targets using underlying estimators.\n   */\n  async predict(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<ArrayLike | SparseMatrix> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsRestClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsRestClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneVsRestClassifier_predict = {k: v for k, v in pms_OneVsRestClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_predict = bridgeOneVsRestClassifier[${this.id}].predict(**pms_OneVsRestClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_predict.tolist() if hasattr(res_OneVsRestClassifier_predict, 'tolist') else res_OneVsRestClassifier_predict`\n  }\n\n  /**\n    Probability estimates.\n\n    The returned estimates for all classes are ordered by label of classes.\n\n    Note that in the multilabel case, each sample can have any number of labels. This returns the marginal probability that the given sample has the label in question. For example, it is entirely consistent that two labels both have a 90% probability of applying to a given sample.\n\n    In the single label multiclass case, the rows of the returned matrix sum to 1.\n   */\n  async predict_proba(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsRestClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OneVsRestClassifier_predict_proba = {k: v for k, v in pms_OneVsRestClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_predict_proba = bridgeOneVsRestClassifier[${this.id}].predict_proba(**pms_OneVsRestClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_predict_proba.tolist() if hasattr(res_OneVsRestClassifier_predict_proba, 'tolist') else res_OneVsRestClassifier_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OneVsRestClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OneVsRestClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_OneVsRestClassifier_score = {k: v for k, v in pms_OneVsRestClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_score = bridgeOneVsRestClassifier[${this.id}].score(**pms_OneVsRestClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_score.tolist() if hasattr(res_OneVsRestClassifier_score, 'tolist') else res_OneVsRestClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `classes` parameter in `partial\\_fit`.\n     */\n    classes?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsRestClassifier_set_partial_fit_request = {'classes': ${\n      opts['classes'] ?? undefined\n    }}\n\npms_OneVsRestClassifier_set_partial_fit_request = {k: v for k, v in pms_OneVsRestClassifier_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_set_partial_fit_request = bridgeOneVsRestClassifier[${this.id}].set_partial_fit_request(**pms_OneVsRestClassifier_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_set_partial_fit_request.tolist() if hasattr(res_OneVsRestClassifier_set_partial_fit_request, 'tolist') else res_OneVsRestClassifier_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OneVsRestClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OneVsRestClassifier_set_score_request = {k: v for k, v in pms_OneVsRestClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OneVsRestClassifier_set_score_request = bridgeOneVsRestClassifier[${this.id}].set_score_request(**pms_OneVsRestClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OneVsRestClassifier_set_score_request.tolist() if hasattr(res_OneVsRestClassifier_set_score_request, 'tolist') else res_OneVsRestClassifier_set_score_request`\n  }\n\n  /**\n    Estimators used for predictions.\n   */\n  get estimators_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before accessing estimators_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsRestClassifier_estimators_ = bridgeOneVsRestClassifier[${this.id}].estimators_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsRestClassifier_estimators_.tolist() if hasattr(attr_OneVsRestClassifier_estimators_, 'tolist') else attr_OneVsRestClassifier_estimators_`\n    })()\n  }\n\n  /**\n    Class labels.\n   */\n  get classes_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsRestClassifier_classes_ = bridgeOneVsRestClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsRestClassifier_classes_.tolist() if hasattr(attr_OneVsRestClassifier_classes_, 'tolist') else attr_OneVsRestClassifier_classes_`\n    })()\n  }\n\n  /**\n    Object used to transform multiclass labels to binary labels and vice-versa.\n   */\n  get label_binarizer_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before accessing label_binarizer_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsRestClassifier_label_binarizer_ = bridgeOneVsRestClassifier[${this.id}].label_binarizer_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsRestClassifier_label_binarizer_.tolist() if hasattr(attr_OneVsRestClassifier_label_binarizer_, 'tolist') else attr_OneVsRestClassifier_label_binarizer_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsRestClassifier_n_features_in_ = bridgeOneVsRestClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsRestClassifier_n_features_in_.tolist() if hasattr(attr_OneVsRestClassifier_n_features_in_, 'tolist') else attr_OneVsRestClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OneVsRestClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OneVsRestClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OneVsRestClassifier_feature_names_in_ = bridgeOneVsRestClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OneVsRestClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsRestClassifier_feature_names_in_, 'tolist') else attr_OneVsRestClassifier_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  (Error-Correcting) Output-Code multiclass strategy.\n\n  Output-code based strategies consist in representing each class with a binary code (an array of 0s and 1s). At fitting time, one binary classifier per bit in the code book is fitted. At prediction time, the classifiers are used to project new points in the class space and the class closest to the points is chosen. The main advantage of these strategies is that the number of classifiers used can be controlled by the user, either for compressing the model (0 < `code\\_size` < 1) or for making the model more robust to errors (`code\\_size` > 1). See the documentation for more details.\n\n  Read more in the [User Guide](../multiclass.html#ecoc).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.multiclass.OutputCodeClassifier.html)\n */\nexport class OutputCodeClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An estimator object implementing [fit](../../glossary.html#term-fit) and one of [decision\\_function](../../glossary.html#term-decision_function) or [predict\\_proba](../../glossary.html#term-predict_proba).\n     */\n    estimator?: any\n\n    /**\n      Percentage of the number of classes to be used to create the code book. A number between 0 and 1 will require fewer classifiers than one-vs-the-rest. A number greater than 1 will require more classifiers than one-vs-the-rest.\n\n      @defaultValue `1.5`\n     */\n    code_size?: number\n\n    /**\n      The generator used to initialize the codebook. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The number of jobs to use for the computation: the multiclass problems are computed in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `OutputCodeClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'OutputCodeClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.multiclass import OutputCodeClassifier\ntry: bridgeOutputCodeClassifier\nexcept NameError: bridgeOutputCodeClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OutputCodeClassifier = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'code_size': ${this.opts['code_size'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_OutputCodeClassifier = {k: v for k, v in ctor_OutputCodeClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOutputCodeClassifier[${this.id}] = OutputCodeClassifier(**ctor_OutputCodeClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOutputCodeClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit underlying estimators.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Multi-class targets.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OutputCodeClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OutputCodeClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_OutputCodeClassifier_fit = {k: v for k, v in pms_OutputCodeClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OutputCodeClassifier_fit = bridgeOutputCodeClassifier[${this.id}].fit(**pms_OutputCodeClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OutputCodeClassifier_fit.tolist() if hasattr(res_OutputCodeClassifier_fit, 'tolist') else res_OutputCodeClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OutputCodeClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OutputCodeClassifier_get_metadata_routing = {k: v for k, v in pms_OutputCodeClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OutputCodeClassifier_get_metadata_routing = bridgeOutputCodeClassifier[${this.id}].get_metadata_routing(**pms_OutputCodeClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OutputCodeClassifier_get_metadata_routing.tolist() if hasattr(res_OutputCodeClassifier_get_metadata_routing, 'tolist') else res_OutputCodeClassifier_get_metadata_routing`\n  }\n\n  /**\n    Predict multi-class targets using underlying estimators.\n   */\n  async predict(opts: {\n    /**\n      Data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OutputCodeClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OutputCodeClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_OutputCodeClassifier_predict = {k: v for k, v in pms_OutputCodeClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OutputCodeClassifier_predict = bridgeOutputCodeClassifier[${this.id}].predict(**pms_OutputCodeClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OutputCodeClassifier_predict.tolist() if hasattr(res_OutputCodeClassifier_predict, 'tolist') else res_OutputCodeClassifier_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OutputCodeClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OutputCodeClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_OutputCodeClassifier_score = {k: v for k, v in pms_OutputCodeClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OutputCodeClassifier_score = bridgeOutputCodeClassifier[${this.id}].score(**pms_OutputCodeClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OutputCodeClassifier_score.tolist() if hasattr(res_OutputCodeClassifier_score, 'tolist') else res_OutputCodeClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OutputCodeClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OutputCodeClassifier_set_score_request = {k: v for k, v in pms_OutputCodeClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OutputCodeClassifier_set_score_request = bridgeOutputCodeClassifier[${this.id}].set_score_request(**pms_OutputCodeClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OutputCodeClassifier_set_score_request.tolist() if hasattr(res_OutputCodeClassifier_set_score_request, 'tolist') else res_OutputCodeClassifier_set_score_request`\n  }\n\n  /**\n    Estimators used for predictions.\n   */\n  get estimators_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before accessing estimators_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OutputCodeClassifier_estimators_ = bridgeOutputCodeClassifier[${this.id}].estimators_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OutputCodeClassifier_estimators_.tolist() if hasattr(attr_OutputCodeClassifier_estimators_, 'tolist') else attr_OutputCodeClassifier_estimators_`\n    })()\n  }\n\n  /**\n    Array containing labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OutputCodeClassifier_classes_ = bridgeOutputCodeClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OutputCodeClassifier_classes_.tolist() if hasattr(attr_OutputCodeClassifier_classes_, 'tolist') else attr_OutputCodeClassifier_classes_`\n    })()\n  }\n\n  /**\n    Binary array containing the code of each class.\n   */\n  get code_book_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before accessing code_book_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OutputCodeClassifier_code_book_ = bridgeOutputCodeClassifier[${this.id}].code_book_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OutputCodeClassifier_code_book_.tolist() if hasattr(attr_OutputCodeClassifier_code_book_, 'tolist') else attr_OutputCodeClassifier_code_book_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OutputCodeClassifier_n_features_in_ = bridgeOutputCodeClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OutputCodeClassifier_n_features_in_.tolist() if hasattr(attr_OutputCodeClassifier_n_features_in_, 'tolist') else attr_OutputCodeClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OutputCodeClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OutputCodeClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OutputCodeClassifier_feature_names_in_ = bridgeOutputCodeClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OutputCodeClassifier_feature_names_in_.tolist() if hasattr(attr_OutputCodeClassifier_feature_names_in_, 'tolist') else attr_OutputCodeClassifier_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto"]}