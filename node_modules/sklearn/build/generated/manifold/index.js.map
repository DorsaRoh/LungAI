{"version":3,"sources":["../../../src/generated/manifold/Isomap.ts","../../../src/generated/manifold/LocallyLinearEmbedding.ts","../../../src/generated/manifold/MDS.ts","../../../src/generated/manifold/SpectralEmbedding.ts","../../../src/generated/manifold/TSNE.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Isomap Embedding.\n\n  Non-linear dimensionality reduction through Isometric Mapping\n\n  Read more in the [User Guide](../manifold.html#isomap).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.Isomap.html)\n */\nexport class Isomap {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to consider for each point. If `n\\_neighbors` is an int, then `radius` must be `undefined`.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Limiting distance of neighbors to return. If `radius` is a float, then `n\\_neighbors` must be set to `undefined`.\n     */\n    radius?: number\n\n    /**\n      Number of coordinates for the manifold.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      ‘auto’ : Attempt to choose the most efficient solver for the given problem.\n\n      ‘arpack’ : Use Arnoldi decomposition to find the eigenvalues and eigenvectors.\n\n      ‘dense’ : Use a direct solver (i.e. LAPACK) for the eigenvalue decomposition.\n\n      @defaultValue `'auto'`\n     */\n    eigen_solver?: 'auto' | 'arpack' | 'dense'\n\n    /**\n      Convergence tolerance passed to arpack or lobpcg. not used if eigen\\_solver == ‘dense’.\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations for the arpack solver. not used if eigen\\_solver == ‘dense’.\n     */\n    max_iter?: number\n\n    /**\n      Method to use in finding shortest path.\n\n      ‘auto’ : attempt to choose the best algorithm automatically.\n\n      ‘FW’ : Floyd-Warshall algorithm.\n\n      ‘D’ : Dijkstra’s algorithm.\n\n      @defaultValue `'auto'`\n     */\n    path_method?: 'auto' | 'FW' | 'D'\n\n    /**\n      Algorithm to use for nearest neighbors search, passed to neighbors.NearestNeighbors instance.\n\n      @defaultValue `'auto'`\n     */\n    neighbors_algorithm?: 'auto' | 'brute' | 'kd_tree' | 'ball_tree'\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\") for its metric parameter. If metric is “precomputed”, X is assumed to be a distance matrix and must be square. X may be a [Glossary](../../glossary.html#term-sparse-graph).\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: any\n\n    /**\n      Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise\\_distances. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n  }) {\n    this.id = `Isomap${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Isomap.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import Isomap\ntry: bridgeIsomap\nexcept NameError: bridgeIsomap = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Isomap = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'radius': ${this.opts['radius'] ?? undefined}, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'eigen_solver': ${this.opts['eigen_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'path_method': ${\n      this.opts['path_method'] ?? undefined\n    }, 'neighbors_algorithm': ${\n      this.opts['neighbors_algorithm'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }}\n\nctor_Isomap = {k: v for k, v in ctor_Isomap.items() if v is not None}`\n\n    await this._py.ex`bridgeIsomap[${this.id}] = Isomap(**ctor_Isomap)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeIsomap[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the embedding vectors for data X.\n   */\n  async fit(opts: {\n    /**\n      Sample data, shape = (n\\_samples, n\\_features), in the form of a numpy array, sparse matrix, precomputed tree, or NearestNeighbors object.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_fit = {'X': ${opts['X'] ?? undefined}, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_Isomap_fit = {k: v for k, v in pms_Isomap_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_fit = bridgeIsomap[${this.id}].fit(**pms_Isomap_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_fit.tolist() if hasattr(res_Isomap_fit, 'tolist') else res_Isomap_fit`\n  }\n\n  /**\n    Fit the model from data in X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_fit_transform = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_Isomap_fit_transform = {k: v for k, v in pms_Isomap_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_fit_transform = bridgeIsomap[${this.id}].fit_transform(**pms_Isomap_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_fit_transform.tolist() if hasattr(res_Isomap_fit_transform, 'tolist') else res_Isomap_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Isomap_get_feature_names_out = {k: v for k, v in pms_Isomap_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_get_feature_names_out = bridgeIsomap[${this.id}].get_feature_names_out(**pms_Isomap_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_get_feature_names_out.tolist() if hasattr(res_Isomap_get_feature_names_out, 'tolist') else res_Isomap_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Isomap_get_metadata_routing = {k: v for k, v in pms_Isomap_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_get_metadata_routing = bridgeIsomap[${this.id}].get_metadata_routing(**pms_Isomap_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_get_metadata_routing.tolist() if hasattr(res_Isomap_get_metadata_routing, 'tolist') else res_Isomap_get_metadata_routing`\n  }\n\n  /**\n    Compute the reconstruction error for the embedding.\n   */\n  async reconstruction_error(opts: {\n    /**\n      Reconstruction error.\n     */\n    reconstruction_error?: number\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before reconstruction_error()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Isomap_reconstruction_error = {'reconstruction_error': ${\n      opts['reconstruction_error'] ?? undefined\n    }}\n\npms_Isomap_reconstruction_error = {k: v for k, v in pms_Isomap_reconstruction_error.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_reconstruction_error = bridgeIsomap[${this.id}].reconstruction_error(**pms_Isomap_reconstruction_error)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_reconstruction_error.tolist() if hasattr(res_Isomap_reconstruction_error, 'tolist') else res_Isomap_reconstruction_error`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Isomap_set_output = {k: v for k, v in pms_Isomap_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_set_output = bridgeIsomap[${this.id}].set_output(**pms_Isomap_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_set_output.tolist() if hasattr(res_Isomap_set_output, 'tolist') else res_Isomap_set_output`\n  }\n\n  /**\n    Transform X.\n\n    This is implemented by linking the points X into the graph of geodesic distances of the training data. First the `n\\_neighbors` nearest neighbors of X are found in the training data, and from these the shortest geodesic distances from each point in X to each point in the training data are computed in order to construct the kernel. The embedding of X is the projection of this kernel onto the embedding vectors of the training set.\n   */\n  async transform(opts: {\n    /**\n      If neighbors\\_algorithm=’precomputed’, X is assumed to be a distance matrix or a sparse graph of shape (n\\_queries, n\\_samples\\_fit).\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_transform = {'X': ${opts['X'] ?? undefined}}\n\npms_Isomap_transform = {k: v for k, v in pms_Isomap_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_transform = bridgeIsomap[${this.id}].transform(**pms_Isomap_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_transform.tolist() if hasattr(res_Isomap_transform, 'tolist') else res_Isomap_transform`\n  }\n\n  /**\n    Stores the embedding vectors.\n   */\n  get embedding_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing embedding_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_embedding_ = bridgeIsomap[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_embedding_.tolist() if hasattr(attr_Isomap_embedding_, 'tolist') else attr_Isomap_embedding_`\n    })()\n  }\n\n  /**\n    [`KernelPCA`](sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA \"sklearn.decomposition.KernelPCA\") object used to implement the embedding.\n   */\n  get kernel_pca_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing kernel_pca_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_kernel_pca_ = bridgeIsomap[${this.id}].kernel_pca_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_kernel_pca_.tolist() if hasattr(attr_Isomap_kernel_pca_, 'tolist') else attr_Isomap_kernel_pca_`\n    })()\n  }\n\n  /**\n    Stores nearest neighbors instance, including BallTree or KDtree if applicable.\n   */\n  get nbrs_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing nbrs_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Isomap_nbrs_ = bridgeIsomap[${this.id}].nbrs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_nbrs_.tolist() if hasattr(attr_Isomap_nbrs_, 'tolist') else attr_Isomap_nbrs_`\n    })()\n  }\n\n  /**\n    Stores the geodesic distance matrix of training data.\n   */\n  get dist_matrix_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing dist_matrix_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_dist_matrix_ = bridgeIsomap[${this.id}].dist_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_dist_matrix_.tolist() if hasattr(attr_Isomap_dist_matrix_, 'tolist') else attr_Isomap_dist_matrix_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_n_features_in_ = bridgeIsomap[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_n_features_in_.tolist() if hasattr(attr_Isomap_n_features_in_, 'tolist') else attr_Isomap_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Isomap must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_feature_names_in_ = bridgeIsomap[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_feature_names_in_.tolist() if hasattr(attr_Isomap_feature_names_in_, 'tolist') else attr_Isomap_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Locally Linear Embedding.\n\n  Read more in the [User Guide](../manifold.html#locally-linear-embedding).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.LocallyLinearEmbedding.html)\n */\nexport class LocallyLinearEmbedding {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to consider for each point.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Number of coordinates for the manifold.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      Regularization constant, multiplies the trace of the local covariance matrix of the distances.\n\n      @defaultValue `0.001`\n     */\n    reg?: number\n\n    /**\n      The solver used to compute the eigenvectors. The available options are:\n\n      @defaultValue `'auto'`\n     */\n    eigen_solver?: 'auto' | 'arpack' | 'dense'\n\n    /**\n      Tolerance for ‘arpack’ method Not used if eigen\\_solver==’dense’.\n\n      @defaultValue `0.000001`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations for the arpack solver. Not used if eigen\\_solver==’dense’.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      `standard`: use the standard locally linear embedding algorithm. see reference [\\[1\\]](#r62e36dd1b056-1)\n\n      @defaultValue `'standard'`\n     */\n    method?: 'standard' | 'hessian' | 'modified' | 'ltsa'\n\n    /**\n      Tolerance for Hessian eigenmapping method. Only used if `method \\== 'hessian'`.\n\n      @defaultValue `0.0001`\n     */\n    hessian_tol?: number\n\n    /**\n      Tolerance for modified LLE method. Only used if `method \\== 'modified'`.\n\n      @defaultValue `1e-12`\n     */\n    modified_tol?: number\n\n    /**\n      Algorithm to use for nearest neighbors search, passed to [`NearestNeighbors`](sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors \"sklearn.neighbors.NearestNeighbors\") instance.\n\n      @defaultValue `'auto'`\n     */\n    neighbors_algorithm?: 'auto' | 'brute' | 'kd_tree' | 'ball_tree'\n\n    /**\n      Determines the random number generator when `eigen\\_solver` == ‘arpack’. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `LocallyLinearEmbedding${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'LocallyLinearEmbedding.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import LocallyLinearEmbedding\ntry: bridgeLocallyLinearEmbedding\nexcept NameError: bridgeLocallyLinearEmbedding = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LocallyLinearEmbedding = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'n_components': ${this.opts['n_components'] ?? undefined}, 'reg': ${\n      this.opts['reg'] ?? undefined\n    }, 'eigen_solver': ${this.opts['eigen_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'method': ${\n      this.opts['method'] ?? undefined\n    }, 'hessian_tol': ${\n      this.opts['hessian_tol'] ?? undefined\n    }, 'modified_tol': ${\n      this.opts['modified_tol'] ?? undefined\n    }, 'neighbors_algorithm': ${\n      this.opts['neighbors_algorithm'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_LocallyLinearEmbedding = {k: v for k, v in ctor_LocallyLinearEmbedding.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLocallyLinearEmbedding[${this.id}] = LocallyLinearEmbedding(**ctor_LocallyLinearEmbedding)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLocallyLinearEmbedding[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the embedding vectors for data X.\n   */\n  async fit(opts: {\n    /**\n      Training set.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LocallyLinearEmbedding must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocallyLinearEmbedding_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LocallyLinearEmbedding_fit = {k: v for k, v in pms_LocallyLinearEmbedding_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_fit = bridgeLocallyLinearEmbedding[${this.id}].fit(**pms_LocallyLinearEmbedding_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_fit.tolist() if hasattr(res_LocallyLinearEmbedding_fit, 'tolist') else res_LocallyLinearEmbedding_fit`\n  }\n\n  /**\n    Compute the embedding vectors for data X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training set.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocallyLinearEmbedding_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LocallyLinearEmbedding_fit_transform = {k: v for k, v in pms_LocallyLinearEmbedding_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_fit_transform = bridgeLocallyLinearEmbedding[${this.id}].fit_transform(**pms_LocallyLinearEmbedding_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_fit_transform.tolist() if hasattr(res_LocallyLinearEmbedding_fit_transform, 'tolist') else res_LocallyLinearEmbedding_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocallyLinearEmbedding_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_LocallyLinearEmbedding_get_feature_names_out = {k: v for k, v in pms_LocallyLinearEmbedding_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_get_feature_names_out = bridgeLocallyLinearEmbedding[${this.id}].get_feature_names_out(**pms_LocallyLinearEmbedding_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_get_feature_names_out.tolist() if hasattr(res_LocallyLinearEmbedding_get_feature_names_out, 'tolist') else res_LocallyLinearEmbedding_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocallyLinearEmbedding_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LocallyLinearEmbedding_get_metadata_routing = {k: v for k, v in pms_LocallyLinearEmbedding_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_get_metadata_routing = bridgeLocallyLinearEmbedding[${this.id}].get_metadata_routing(**pms_LocallyLinearEmbedding_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_get_metadata_routing.tolist() if hasattr(res_LocallyLinearEmbedding_get_metadata_routing, 'tolist') else res_LocallyLinearEmbedding_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocallyLinearEmbedding_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_LocallyLinearEmbedding_set_output = {k: v for k, v in pms_LocallyLinearEmbedding_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_set_output = bridgeLocallyLinearEmbedding[${this.id}].set_output(**pms_LocallyLinearEmbedding_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_set_output.tolist() if hasattr(res_LocallyLinearEmbedding_set_output, 'tolist') else res_LocallyLinearEmbedding_set_output`\n  }\n\n  /**\n    Transform new points into embedding space.\n   */\n  async transform(opts: {\n    /**\n      Training set.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocallyLinearEmbedding_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LocallyLinearEmbedding_transform = {k: v for k, v in pms_LocallyLinearEmbedding_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocallyLinearEmbedding_transform = bridgeLocallyLinearEmbedding[${this.id}].transform(**pms_LocallyLinearEmbedding_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocallyLinearEmbedding_transform.tolist() if hasattr(res_LocallyLinearEmbedding_transform, 'tolist') else res_LocallyLinearEmbedding_transform`\n  }\n\n  /**\n    Stores the embedding vectors\n   */\n  get embedding_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before accessing embedding_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocallyLinearEmbedding_embedding_ = bridgeLocallyLinearEmbedding[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocallyLinearEmbedding_embedding_.tolist() if hasattr(attr_LocallyLinearEmbedding_embedding_, 'tolist') else attr_LocallyLinearEmbedding_embedding_`\n    })()\n  }\n\n  /**\n    Reconstruction error associated with `embedding\\_`\n   */\n  get reconstruction_error_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before accessing reconstruction_error_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocallyLinearEmbedding_reconstruction_error_ = bridgeLocallyLinearEmbedding[${this.id}].reconstruction_error_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocallyLinearEmbedding_reconstruction_error_.tolist() if hasattr(attr_LocallyLinearEmbedding_reconstruction_error_, 'tolist') else attr_LocallyLinearEmbedding_reconstruction_error_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocallyLinearEmbedding_n_features_in_ = bridgeLocallyLinearEmbedding[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocallyLinearEmbedding_n_features_in_.tolist() if hasattr(attr_LocallyLinearEmbedding_n_features_in_, 'tolist') else attr_LocallyLinearEmbedding_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocallyLinearEmbedding_feature_names_in_ = bridgeLocallyLinearEmbedding[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocallyLinearEmbedding_feature_names_in_.tolist() if hasattr(attr_LocallyLinearEmbedding_feature_names_in_, 'tolist') else attr_LocallyLinearEmbedding_feature_names_in_`\n    })()\n  }\n\n  /**\n    Stores nearest neighbors instance, including BallTree or KDtree if applicable.\n   */\n  get nbrs_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocallyLinearEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocallyLinearEmbedding must call init() before accessing nbrs_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocallyLinearEmbedding_nbrs_ = bridgeLocallyLinearEmbedding[${this.id}].nbrs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocallyLinearEmbedding_nbrs_.tolist() if hasattr(attr_LocallyLinearEmbedding_nbrs_, 'tolist') else attr_LocallyLinearEmbedding_nbrs_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multidimensional scaling.\n\n  Read more in the [User Guide](../manifold.html#multidimensional-scaling).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.MDS.html)\n */\nexport class MDS {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of dimensions in which to immerse the dissimilarities.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      If `true`, perform metric MDS; otherwise, perform nonmetric MDS. When `false` (i.e. non-metric MDS), dissimilarities with 0 are considered as missing values.\n\n      @defaultValue `true`\n     */\n    metric?: boolean\n\n    /**\n      Number of times the SMACOF algorithm will be run with different initializations. The final results will be the best output of the runs, determined by the run with the smallest final stress.\n\n      @defaultValue `4`\n     */\n    n_init?: number\n\n    /**\n      Maximum number of iterations of the SMACOF algorithm for a single run.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n\n    /**\n      Level of verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Relative tolerance with respect to stress at which to declare convergence. The value of `eps` should be tuned separately depending on whether or not `normalized\\_stress` is being used.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      The number of jobs to use for the computation. If multiple initializations are used (`n\\_init`), each run of the algorithm is computed in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Determines the random number generator used to initialize the centers. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Dissimilarity measure to use:\n\n      @defaultValue `'euclidean'`\n     */\n    dissimilarity?: 'euclidean' | 'precomputed'\n\n    /**\n      Whether use and return normed stress value (Stress-1) instead of raw stress calculated by default. Only supported in non-metric MDS.\n     */\n    normalized_stress?: boolean\n  }) {\n    this.id = `MDS${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MDS.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import MDS\ntry: bridgeMDS\nexcept NameError: bridgeMDS = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MDS = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'dissimilarity': ${\n      this.opts['dissimilarity'] ?? undefined\n    }, 'normalized_stress': ${this.opts['normalized_stress'] ?? undefined}}\n\nctor_MDS = {k: v for k, v in ctor_MDS.items() if v is not None}`\n\n    await this._py.ex`bridgeMDS[${this.id}] = MDS(**ctor_MDS)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMDS[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the position of the points in the embedding space.\n   */\n  async fit(opts: {\n    /**\n      Input data. If `dissimilarity=='precomputed'`, the input should be the dissimilarity matrix.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Starting configuration of the embedding to initialize the SMACOF algorithm. By default, the algorithm is initialized with a randomly chosen array.\n     */\n    init?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'init': np.array(${opts['init'] ?? undefined}) if ${\n      opts['init'] !== undefined\n    } else None}\n\npms_MDS_fit = {k: v for k, v in pms_MDS_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_MDS_fit = bridgeMDS[${this.id}].fit(**pms_MDS_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_fit.tolist() if hasattr(res_MDS_fit, 'tolist') else res_MDS_fit`\n  }\n\n  /**\n    Fit the data from `X`, and returns the embedded coordinates.\n   */\n  async fit_transform(opts: {\n    /**\n      Input data. If `dissimilarity=='precomputed'`, the input should be the dissimilarity matrix.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Starting configuration of the embedding to initialize the SMACOF algorithm. By default, the algorithm is initialized with a randomly chosen array.\n     */\n    init?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'init': np.array(${opts['init'] ?? undefined}) if ${\n      opts['init'] !== undefined\n    } else None}\n\npms_MDS_fit_transform = {k: v for k, v in pms_MDS_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MDS_fit_transform = bridgeMDS[${this.id}].fit_transform(**pms_MDS_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_fit_transform.tolist() if hasattr(res_MDS_fit_transform, 'tolist') else res_MDS_fit_transform`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MDS_get_metadata_routing = {k: v for k, v in pms_MDS_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MDS_get_metadata_routing = bridgeMDS[${this.id}].get_metadata_routing(**pms_MDS_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_get_metadata_routing.tolist() if hasattr(res_MDS_get_metadata_routing, 'tolist') else res_MDS_get_metadata_routing`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `init` parameter in `fit`.\n     */\n    init?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_set_fit_request = {'init': ${\n      opts['init'] ?? undefined\n    }}\n\npms_MDS_set_fit_request = {k: v for k, v in pms_MDS_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MDS_set_fit_request = bridgeMDS[${this.id}].set_fit_request(**pms_MDS_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_set_fit_request.tolist() if hasattr(res_MDS_set_fit_request, 'tolist') else res_MDS_set_fit_request`\n  }\n\n  /**\n    Stores the position of the dataset in the embedding space.\n   */\n  get embedding_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing embedding_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_embedding_ = bridgeMDS[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_embedding_.tolist() if hasattr(attr_MDS_embedding_, 'tolist') else attr_MDS_embedding_`\n    })()\n  }\n\n  /**\n    The final value of the stress (sum of squared distance of the disparities and the distances for all constrained points). If `normalized\\_stress=True`, and `metric=False` returns Stress-1. A value of 0 indicates “perfect” fit, 0.025 excellent, 0.05 good, 0.1 fair, and 0.2 poor [\\[1\\]](#r77760563872b-1).\n   */\n  get stress_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing stress_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_stress_ = bridgeMDS[${this.id}].stress_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_stress_.tolist() if hasattr(attr_MDS_stress_, 'tolist') else attr_MDS_stress_`\n    })()\n  }\n\n  /**\n    Pairwise dissimilarities between the points. Symmetric matrix that:\n   */\n  get dissimilarity_matrix_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MDS must call init() before accessing dissimilarity_matrix_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_dissimilarity_matrix_ = bridgeMDS[${this.id}].dissimilarity_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_dissimilarity_matrix_.tolist() if hasattr(attr_MDS_dissimilarity_matrix_, 'tolist') else attr_MDS_dissimilarity_matrix_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_n_features_in_ = bridgeMDS[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_n_features_in_.tolist() if hasattr(attr_MDS_n_features_in_, 'tolist') else attr_MDS_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_feature_names_in_ = bridgeMDS[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_feature_names_in_.tolist() if hasattr(attr_MDS_feature_names_in_, 'tolist') else attr_MDS_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of iterations corresponding to the best stress.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_n_iter_ = bridgeMDS[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_n_iter_.tolist() if hasattr(attr_MDS_n_iter_, 'tolist') else attr_MDS_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Spectral embedding for non-linear dimensionality reduction.\n\n  Forms an affinity matrix given by the specified function and applies spectral decomposition to the corresponding graph laplacian. The resulting transformation is given by the value of the eigenvectors for each data point.\n\n  Note : Laplacian Eigenmaps is the actual algorithm implemented here.\n\n  Read more in the [User Guide](../manifold.html#spectral-embedding).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.SpectralEmbedding.html)\n */\nexport class SpectralEmbedding {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The dimension of the projected subspace.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      ‘nearest\\_neighbors’ : construct the affinity matrix by computing a graph of nearest neighbors.\n\n      @defaultValue `'nearest_neighbors'`\n     */\n    affinity?:\n      | 'nearest_neighbors'\n      | 'rbf'\n      | 'precomputed'\n      | 'precomputed_nearest_neighbors'\n\n    /**\n      Kernel coefficient for rbf kernel. If `undefined`, gamma will be set to 1/n\\_features.\n     */\n    gamma?: number\n\n    /**\n      A pseudo random number generator used for the initialization of the lobpcg eigen vectors decomposition when `eigen\\_solver \\== 'amg'`, and for the K-Means initialization. Use an int to make the results deterministic across calls (See [Glossary](../../glossary.html#term-random_state)).\n     */\n    random_state?: number\n\n    /**\n      The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems. If `undefined`, then `'arpack'` is used.\n     */\n    eigen_solver?: 'arpack' | 'lobpcg' | 'amg'\n\n    /**\n      Stopping criterion for eigendecomposition of the Laplacian matrix. If `eigen\\_tol=\"auto\"` then the passed tolerance will depend on the `eigen\\_solver`:\n\n      @defaultValue `'auto'`\n     */\n    eigen_tol?: number\n\n    /**\n      Number of nearest neighbors for nearest\\_neighbors graph building. If `undefined`, n\\_neighbors will be set to max(n\\_samples/10, 1).\n     */\n    n_neighbors?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `SpectralEmbedding${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SpectralEmbedding.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import SpectralEmbedding\ntry: bridgeSpectralEmbedding\nexcept NameError: bridgeSpectralEmbedding = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SpectralEmbedding = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'affinity': ${this.opts['affinity'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'eigen_solver': ${\n      this.opts['eigen_solver'] ?? undefined\n    }, 'eigen_tol': ${this.opts['eigen_tol'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_SpectralEmbedding = {k: v for k, v in ctor_SpectralEmbedding.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSpectralEmbedding[${this.id}] = SpectralEmbedding(**ctor_SpectralEmbedding)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSpectralEmbedding[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n\n      If affinity is “precomputed” X : {array-like, sparse matrix}, shape (n\\_samples, n\\_samples), Interpret X as precomputed adjacency graph computed from samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SpectralEmbedding must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralEmbedding_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralEmbedding_fit = {k: v for k, v in pms_SpectralEmbedding_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralEmbedding_fit = bridgeSpectralEmbedding[${this.id}].fit(**pms_SpectralEmbedding_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralEmbedding_fit.tolist() if hasattr(res_SpectralEmbedding_fit, 'tolist') else res_SpectralEmbedding_fit`\n  }\n\n  /**\n    Fit the model from data in X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n\n      If affinity is “precomputed” X : {array-like, sparse matrix} of shape (n\\_samples, n\\_samples), Interpret X as precomputed adjacency graph computed from samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralEmbedding_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralEmbedding_fit_transform = {k: v for k, v in pms_SpectralEmbedding_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralEmbedding_fit_transform = bridgeSpectralEmbedding[${this.id}].fit_transform(**pms_SpectralEmbedding_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralEmbedding_fit_transform.tolist() if hasattr(res_SpectralEmbedding_fit_transform, 'tolist') else res_SpectralEmbedding_fit_transform`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SpectralEmbedding_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SpectralEmbedding_get_metadata_routing = {k: v for k, v in pms_SpectralEmbedding_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralEmbedding_get_metadata_routing = bridgeSpectralEmbedding[${this.id}].get_metadata_routing(**pms_SpectralEmbedding_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralEmbedding_get_metadata_routing.tolist() if hasattr(res_SpectralEmbedding_get_metadata_routing, 'tolist') else res_SpectralEmbedding_get_metadata_routing`\n  }\n\n  /**\n    Spectral embedding of the training matrix.\n   */\n  get embedding_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before accessing embedding_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralEmbedding_embedding_ = bridgeSpectralEmbedding[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralEmbedding_embedding_.tolist() if hasattr(attr_SpectralEmbedding_embedding_, 'tolist') else attr_SpectralEmbedding_embedding_`\n    })()\n  }\n\n  /**\n    Affinity\\_matrix constructed from samples or precomputed.\n   */\n  get affinity_matrix_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before accessing affinity_matrix_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralEmbedding_affinity_matrix_ = bridgeSpectralEmbedding[${this.id}].affinity_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralEmbedding_affinity_matrix_.tolist() if hasattr(attr_SpectralEmbedding_affinity_matrix_, 'tolist') else attr_SpectralEmbedding_affinity_matrix_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralEmbedding_n_features_in_ = bridgeSpectralEmbedding[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralEmbedding_n_features_in_.tolist() if hasattr(attr_SpectralEmbedding_n_features_in_, 'tolist') else attr_SpectralEmbedding_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralEmbedding_feature_names_in_ = bridgeSpectralEmbedding[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralEmbedding_feature_names_in_.tolist() if hasattr(attr_SpectralEmbedding_feature_names_in_, 'tolist') else attr_SpectralEmbedding_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of nearest neighbors effectively used.\n   */\n  get n_neighbors_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralEmbedding instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralEmbedding must call init() before accessing n_neighbors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralEmbedding_n_neighbors_ = bridgeSpectralEmbedding[${this.id}].n_neighbors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralEmbedding_n_neighbors_.tolist() if hasattr(attr_SpectralEmbedding_n_neighbors_, 'tolist') else attr_SpectralEmbedding_n_neighbors_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  T-distributed Stochastic Neighbor Embedding.\n\n  t-SNE \\[1\\] is a tool to visualize high-dimensional data. It converts similarities between data points to joint probabilities and tries to minimize the Kullback-Leibler divergence between the joint probabilities of the low-dimensional embedding and the high-dimensional data. t-SNE has a cost function that is not convex, i.e. with different initializations we can get different results.\n\n  It is highly recommended to use another dimensionality reduction method (e.g. PCA for dense data or TruncatedSVD for sparse data) to reduce the number of dimensions to a reasonable amount (e.g. 50) if the number of features is very high. This will suppress some noise and speed up the computation of pairwise distances between samples. For more tips see Laurens van der Maaten’s FAQ \\[2\\].\n\n  Read more in the [User Guide](../manifold.html#t-sne).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html)\n */\nexport class TSNE {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Dimension of the embedded space.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. Different values can result in significantly different results. The perplexity must be less than the number of samples.\n\n      @defaultValue `30`\n     */\n    perplexity?: number\n\n    /**\n      Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.\n\n      @defaultValue `12`\n     */\n    early_exaggeration?: number\n\n    /**\n      The learning rate for t-SNE is usually in the range \\[10.0, 1000.0\\]. If the learning rate is too high, the data may look like a ‘ball’ with any point approximately equidistant from its nearest neighbours. If the learning rate is too low, most points may look compressed in a dense cloud with few outliers. If the cost function gets stuck in a bad local minimum increasing the learning rate may help. Note that many other t-SNE implementations (bhtsne, FIt-SNE, openTSNE, etc.) use a definition of learning\\_rate that is 4 times smaller than ours. So our learning\\_rate=200 corresponds to learning\\_rate=800 in those other implementations. The ‘auto’ option sets the learning\\_rate to `max(N / early\\_exaggeration / 4, 50)` where N is the sample size, following \\[4\\] and \\[5\\].\n\n      @defaultValue `'auto'`\n     */\n    learning_rate?: number | 'auto'\n\n    /**\n      Maximum number of iterations for the optimization. Should be at least 250.\n\n      @defaultValue `1000`\n     */\n    n_iter?: number\n\n    /**\n      Maximum number of iterations without progress before we abort the optimization, used after 250 initial iterations with early exaggeration. Note that progress is only checked every 50 iterations so this value is rounded to the next multiple of 50.\n\n      @defaultValue `300`\n     */\n    n_iter_without_progress?: number\n\n    /**\n      If the gradient norm is below this threshold, the optimization will be stopped.\n\n      @defaultValue `1e-7`\n     */\n    min_grad_norm?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string, it must be one of the options allowed by scipy.spatial.distance.pdist for its metric parameter, or a metric listed in pairwise.PAIRWISE\\_DISTANCE\\_FUNCTIONS. If metric is “precomputed”, X is assumed to be a distance matrix. Alternatively, if metric is a callable function, it is called on each pair of instances (rows) and the resulting value recorded. The callable should take two arrays from X as input and return a value indicating the distance between them. The default is “euclidean” which is interpreted as squared euclidean distance.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: string\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      Initialization of embedding. PCA initialization cannot be used with precomputed distances and is usually more globally stable than random initialization.\n\n      @defaultValue `'pca'`\n     */\n    init?: 'random' | 'pca' | NDArray[]\n\n    /**\n      Verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Determines the random number generator. Pass an int for reproducible results across multiple function calls. Note that different initializations might result in different local minima of the cost function. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      By default the gradient calculation algorithm uses Barnes-Hut approximation running in O(NlogN) time. method=’exact’ will run on the slower, but exact, algorithm in O(N^2) time. The exact algorithm should be used when nearest-neighbor errors need to be better than 3%. However, the exact method cannot scale to millions of examples.\n\n      @defaultValue `'barnes_hut'`\n     */\n    method?: 'barnes_hut' | 'exact'\n\n    /**\n      Only used if method=’barnes\\_hut’ This is the trade-off between speed and accuracy for Barnes-Hut T-SNE. ‘angle’ is the angular size (referred to as theta in \\[3\\]) of a distant node as measured from a point. If this size is below ‘angle’ then it is used as a summary node of all points contained within it. This method is not very sensitive to changes in this parameter in the range of 0.2 - 0.8. Angle less than 0.2 has quickly increasing computation time and angle greater 0.8 has quickly increasing error.\n\n      @defaultValue `0.5`\n     */\n    angle?: number\n\n    /**\n      The number of parallel jobs to run for neighbors search. This parameter has no impact when `metric=\"precomputed\"` or (`metric=\"euclidean\"` and `method=\"exact\"`). `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `TSNE${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('TSNE.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import TSNE\ntry: bridgeTSNE\nexcept NameError: bridgeTSNE = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_TSNE = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'perplexity': ${\n      this.opts['perplexity'] ?? undefined\n    }, 'early_exaggeration': ${\n      this.opts['early_exaggeration'] ?? undefined\n    }, 'learning_rate': ${this.opts['learning_rate'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }, 'n_iter_without_progress': ${\n      this.opts['n_iter_without_progress'] ?? undefined\n    }, 'min_grad_norm': ${this.opts['min_grad_norm'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'method': ${\n      this.opts['method'] ?? undefined\n    }, 'angle': ${this.opts['angle'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_TSNE = {k: v for k, v in ctor_TSNE.items() if v is not None}`\n\n    await this._py.ex`bridgeTSNE[${this.id}] = TSNE(**ctor_TSNE)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTSNE[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit X into an embedded space.\n   */\n  async fit(opts: {\n    /**\n      If the metric is ‘precomputed’ X must be a square distance matrix. Otherwise it contains a sample per row. If the method is ‘exact’, X may be a sparse matrix of type ‘csr’, ‘csc’ or ‘coo’. If the method is ‘barnes\\_hut’ and the metric is ‘precomputed’, X may be a precomputed sparse graph.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TSNE_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_TSNE_fit = {k: v for k, v in pms_TSNE_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_TSNE_fit = bridgeTSNE[${this.id}].fit(**pms_TSNE_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TSNE_fit.tolist() if hasattr(res_TSNE_fit, 'tolist') else res_TSNE_fit`\n  }\n\n  /**\n    Fit X into an embedded space and return that transformed output.\n   */\n  async fit_transform(opts: {\n    /**\n      If the metric is ‘precomputed’ X must be a square distance matrix. Otherwise it contains a sample per row. If the method is ‘exact’, X may be a sparse matrix of type ‘csr’, ‘csc’ or ‘coo’. If the method is ‘barnes\\_hut’ and the metric is ‘precomputed’, X may be a precomputed sparse graph.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TSNE_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_TSNE_fit_transform = {k: v for k, v in pms_TSNE_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TSNE_fit_transform = bridgeTSNE[${this.id}].fit_transform(**pms_TSNE_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TSNE_fit_transform.tolist() if hasattr(res_TSNE_fit_transform, 'tolist') else res_TSNE_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TSNE_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_TSNE_get_feature_names_out = {k: v for k, v in pms_TSNE_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TSNE_get_feature_names_out = bridgeTSNE[${this.id}].get_feature_names_out(**pms_TSNE_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TSNE_get_feature_names_out.tolist() if hasattr(res_TSNE_get_feature_names_out, 'tolist') else res_TSNE_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TSNE_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_TSNE_get_metadata_routing = {k: v for k, v in pms_TSNE_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TSNE_get_metadata_routing = bridgeTSNE[${this.id}].get_metadata_routing(**pms_TSNE_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TSNE_get_metadata_routing.tolist() if hasattr(res_TSNE_get_metadata_routing, 'tolist') else res_TSNE_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TSNE_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_TSNE_set_output = {k: v for k, v in pms_TSNE_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TSNE_set_output = bridgeTSNE[${this.id}].set_output(**pms_TSNE_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TSNE_set_output.tolist() if hasattr(res_TSNE_set_output, 'tolist') else res_TSNE_set_output`\n  }\n\n  /**\n    Stores the embedding vectors.\n   */\n  get embedding_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before accessing embedding_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TSNE_embedding_ = bridgeTSNE[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_embedding_.tolist() if hasattr(attr_TSNE_embedding_, 'tolist') else attr_TSNE_embedding_`\n    })()\n  }\n\n  /**\n    Kullback-Leibler divergence after optimization.\n   */\n  get kl_divergence_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before accessing kl_divergence_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TSNE_kl_divergence_ = bridgeTSNE[${this.id}].kl_divergence_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_kl_divergence_.tolist() if hasattr(attr_TSNE_kl_divergence_, 'tolist') else attr_TSNE_kl_divergence_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TSNE_n_features_in_ = bridgeTSNE[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_n_features_in_.tolist() if hasattr(attr_TSNE_n_features_in_, 'tolist') else attr_TSNE_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TSNE must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TSNE_feature_names_in_ = bridgeTSNE[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_feature_names_in_.tolist() if hasattr(attr_TSNE_feature_names_in_, 'tolist') else attr_TSNE_feature_names_in_`\n    })()\n  }\n\n  /**\n    Effective learning rate.\n   */\n  get learning_rate_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before accessing learning_rate_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TSNE_learning_rate_ = bridgeTSNE[${this.id}].learning_rate_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_learning_rate_.tolist() if hasattr(attr_TSNE_learning_rate_, 'tolist') else attr_TSNE_learning_rate_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TSNE instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TSNE must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_TSNE_n_iter_ = bridgeTSNE[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TSNE_n_iter_.tolist() if hasattr(attr_TSNE_n_iter_, 'tolist') else attr_TSNE_n_iter_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto"]}