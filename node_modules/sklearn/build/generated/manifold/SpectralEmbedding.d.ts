import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Spectral embedding for non-linear dimensionality reduction.

  Forms an affinity matrix given by the specified function and applies spectral decomposition to the corresponding graph laplacian. The resulting transformation is given by the value of the eigenvectors for each data point.

  Note : Laplacian Eigenmaps is the actual algorithm implemented here.

  Read more in the [User Guide](../manifold.html#spectral-embedding).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.SpectralEmbedding.html)
 */
export declare class SpectralEmbedding {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          The dimension of the projected subspace.
    
          @defaultValue `2`
         */
        n_components?: number;
        /**
          ‘nearest\_neighbors’ : construct the affinity matrix by computing a graph of nearest neighbors.
    
          @defaultValue `'nearest_neighbors'`
         */
        affinity?: 'nearest_neighbors' | 'rbf' | 'precomputed' | 'precomputed_nearest_neighbors';
        /**
          Kernel coefficient for rbf kernel. If `undefined`, gamma will be set to 1/n\_features.
         */
        gamma?: number;
        /**
          A pseudo random number generator used for the initialization of the lobpcg eigen vectors decomposition when `eigen\_solver \== 'amg'`, and for the K-Means initialization. Use an int to make the results deterministic across calls (See [Glossary](../../glossary.html#term-random_state)).
         */
        random_state?: number;
        /**
          The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems. If `undefined`, then `'arpack'` is used.
         */
        eigen_solver?: 'arpack' | 'lobpcg' | 'amg';
        /**
          Stopping criterion for eigendecomposition of the Laplacian matrix. If `eigen\_tol="auto"` then the passed tolerance will depend on the `eigen\_solver`:
    
          @defaultValue `'auto'`
         */
        eigen_tol?: number;
        /**
          Number of nearest neighbors for nearest\_neighbors graph building. If `undefined`, n\_neighbors will be set to max(n\_samples/10, 1).
         */
        n_neighbors?: number;
        /**
          The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend "(in joblib v1.4.dev0)") context. `\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.
         */
        n_jobs?: number;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the model from data in X.
     */
    fit(opts: {
        /**
          Training vector, where `n\_samples` is the number of samples and `n\_features` is the number of features.
    
          If affinity is “precomputed” X : {array-like, sparse matrix}, shape (n\_samples, n\_samples), Interpret X as precomputed adjacency graph computed from samples.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Fit the model from data in X and transform X.
     */
    fit_transform(opts: {
        /**
          Training vector, where `n\_samples` is the number of samples and `n\_features` is the number of features.
    
          If affinity is “precomputed” X : {array-like, sparse matrix} of shape (n\_samples, n\_samples), Interpret X as precomputed adjacency graph computed from samples.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present for API consistency by convention.
         */
        y?: any;
    }): Promise<ArrayLike[]>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Spectral embedding of the training matrix.
     */
    get embedding_(): Promise<NDArray[]>;
    /**
      Affinity\_matrix constructed from samples or precomputed.
     */
    get affinity_matrix_(): Promise<NDArray[]>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Number of nearest neighbors effectively used.
     */
    get n_neighbors_(): Promise<number>;
}
//# sourceMappingURL=SpectralEmbedding.d.ts.map