// src/generated/ensemble/BaggingClassifier.ts
import crypto from "node:crypto";
var BaggingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BaggingClassifier${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BaggingClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import BaggingClassifier
try: bridgeBaggingClassifier
except NameError: bridgeBaggingClassifier = {}
`;
    await this._py.ex`ctor_BaggingClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'bootstrap_features': ${this.opts["bootstrap_features"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_BaggingClassifier = {k: v for k, v in ctor_BaggingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeBaggingClassifier[${this.id}] = BaggingClassifier(**ctor_BaggingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBaggingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Average of the decision functions of the base classifiers.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_decision_function = {k: v for k, v in pms_BaggingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_decision_function = bridgeBaggingClassifier[${this.id}].decision_function(**pms_BaggingClassifier_decision_function)`;
    return this._py`res_BaggingClassifier_decision_function.tolist() if hasattr(res_BaggingClassifier_decision_function, 'tolist') else res_BaggingClassifier_decision_function`;
  }
  /**
    Build a Bagging ensemble of estimators from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_BaggingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingClassifier_fit = {k: v for k, v in pms_BaggingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_fit = bridgeBaggingClassifier[${this.id}].fit(**pms_BaggingClassifier_fit)`;
    return this._py`res_BaggingClassifier_fit.tolist() if hasattr(res_BaggingClassifier_fit, 'tolist') else res_BaggingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BaggingClassifier_get_metadata_routing = {k: v for k, v in pms_BaggingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_get_metadata_routing = bridgeBaggingClassifier[${this.id}].get_metadata_routing(**pms_BaggingClassifier_get_metadata_routing)`;
    return this._py`res_BaggingClassifier_get_metadata_routing.tolist() if hasattr(res_BaggingClassifier_get_metadata_routing, 'tolist') else res_BaggingClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is computed as the class with the highest mean predicted probability. If base estimators do not implement a `predict\_proba` method, then it resorts to voting.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before predict()");
    }
    await this._py.ex`pms_BaggingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict = {k: v for k, v in pms_BaggingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict = bridgeBaggingClassifier[${this.id}].predict(**pms_BaggingClassifier_predict)`;
    return this._py`res_BaggingClassifier_predict.tolist() if hasattr(res_BaggingClassifier_predict, 'tolist') else res_BaggingClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the base estimators in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_log_proba = {k: v for k, v in pms_BaggingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_log_proba = bridgeBaggingClassifier[${this.id}].predict_log_proba(**pms_BaggingClassifier_predict_log_proba)`;
    return this._py`res_BaggingClassifier_predict_log_proba.tolist() if hasattr(res_BaggingClassifier_predict_log_proba, 'tolist') else res_BaggingClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the mean predicted class probabilities of the base estimators in the ensemble. If base estimators do not implement a `predict\_proba` method, then it resorts to voting and the predicted class probabilities of an input sample represents the proportion of estimators predicting each class.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_proba = {k: v for k, v in pms_BaggingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_proba = bridgeBaggingClassifier[${this.id}].predict_proba(**pms_BaggingClassifier_predict_proba)`;
    return this._py`res_BaggingClassifier_predict_proba.tolist() if hasattr(res_BaggingClassifier_predict_proba, 'tolist') else res_BaggingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before score()");
    }
    await this._py.ex`pms_BaggingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingClassifier_score = {k: v for k, v in pms_BaggingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_score = bridgeBaggingClassifier[${this.id}].score(**pms_BaggingClassifier_score)`;
    return this._py`res_BaggingClassifier_score.tolist() if hasattr(res_BaggingClassifier_score, 'tolist') else res_BaggingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_fit_request = {k: v for k, v in pms_BaggingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_fit_request = bridgeBaggingClassifier[${this.id}].set_fit_request(**pms_BaggingClassifier_set_fit_request)`;
    return this._py`res_BaggingClassifier_set_fit_request.tolist() if hasattr(res_BaggingClassifier_set_fit_request, 'tolist') else res_BaggingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_score_request = {k: v for k, v in pms_BaggingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_score_request = bridgeBaggingClassifier[${this.id}].set_score_request(**pms_BaggingClassifier_set_score_request)`;
    return this._py`res_BaggingClassifier_set_score_request.tolist() if hasattr(res_BaggingClassifier_set_score_request, 'tolist') else res_BaggingClassifier_set_score_request`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimator_ = bridgeBaggingClassifier[${this.id}].estimator_`;
      return this._py`attr_BaggingClassifier_estimator_.tolist() if hasattr(attr_BaggingClassifier_estimator_, 'tolist') else attr_BaggingClassifier_estimator_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_features_in_ = bridgeBaggingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_BaggingClassifier_n_features_in_.tolist() if hasattr(attr_BaggingClassifier_n_features_in_, 'tolist') else attr_BaggingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_feature_names_in_ = bridgeBaggingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_BaggingClassifier_feature_names_in_.tolist() if hasattr(attr_BaggingClassifier_feature_names_in_, 'tolist') else attr_BaggingClassifier_feature_names_in_`;
    })();
  }
  /**
    The collection of fitted base estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_ = bridgeBaggingClassifier[${this.id}].estimators_`;
      return this._py`attr_BaggingClassifier_estimators_.tolist() if hasattr(attr_BaggingClassifier_estimators_, 'tolist') else attr_BaggingClassifier_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_features_ = bridgeBaggingClassifier[${this.id}].estimators_features_`;
      return this._py`attr_BaggingClassifier_estimators_features_.tolist() if hasattr(attr_BaggingClassifier_estimators_features_, 'tolist') else attr_BaggingClassifier_estimators_features_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_classes_ = bridgeBaggingClassifier[${this.id}].classes_`;
      return this._py`attr_BaggingClassifier_classes_.tolist() if hasattr(attr_BaggingClassifier_classes_, 'tolist') else attr_BaggingClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_classes_ = bridgeBaggingClassifier[${this.id}].n_classes_`;
      return this._py`attr_BaggingClassifier_n_classes_.tolist() if hasattr(attr_BaggingClassifier_n_classes_, 'tolist') else attr_BaggingClassifier_n_classes_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_score_ = bridgeBaggingClassifier[${this.id}].oob_score_`;
      return this._py`attr_BaggingClassifier_oob_score_.tolist() if hasattr(attr_BaggingClassifier_oob_score_, 'tolist') else attr_BaggingClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_decision\_function\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_decision_function_ = bridgeBaggingClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_BaggingClassifier_oob_decision_function_.tolist() if hasattr(attr_BaggingClassifier_oob_decision_function_, 'tolist') else attr_BaggingClassifier_oob_decision_function_`;
    })();
  }
};
export {
  BaggingClassifier
};
//# sourceMappingURL=BaggingClassifier.js.map