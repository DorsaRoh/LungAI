// src/generated/decomposition/DictionaryLearning.ts
import crypto from "node:crypto";
var DictionaryLearning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DictionaryLearning${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import DictionaryLearning
try: bridgeDictionaryLearning
except NameError: bridgeDictionaryLearning = {}
`;
    await this._py.ex`ctor_DictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'code_init': np.array(${this.opts["code_init"] ?? void 0}) if ${this.opts["code_init"] !== void 0} else None, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'callback': ${this.opts["callback"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_DictionaryLearning = {k: v for k, v in ctor_DictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeDictionaryLearning[${this.id}] = DictionaryLearning(**ctor_DictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before fit()");
    }
    await this._py.ex`pms_DictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit = {k: v for k, v in pms_DictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit = bridgeDictionaryLearning[${this.id}].fit(**pms_DictionaryLearning_fit)`;
    return this._py`res_DictionaryLearning_fit.tolist() if hasattr(res_DictionaryLearning_fit, 'tolist') else res_DictionaryLearning_fit`;
  }
  /**
    Fit the model from data in X and return the transformed data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit_transform = {k: v for k, v in pms_DictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit_transform = bridgeDictionaryLearning[${this.id}].fit_transform(**pms_DictionaryLearning_fit_transform)`;
    return this._py`res_DictionaryLearning_fit_transform.tolist() if hasattr(res_DictionaryLearning_fit_transform, 'tolist') else res_DictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_DictionaryLearning_get_feature_names_out = {k: v for k, v in pms_DictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_feature_names_out = bridgeDictionaryLearning[${this.id}].get_feature_names_out(**pms_DictionaryLearning_get_feature_names_out)`;
    return this._py`res_DictionaryLearning_get_feature_names_out.tolist() if hasattr(res_DictionaryLearning_get_feature_names_out, 'tolist') else res_DictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DictionaryLearning_get_metadata_routing = {k: v for k, v in pms_DictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_metadata_routing = bridgeDictionaryLearning[${this.id}].get_metadata_routing(**pms_DictionaryLearning_get_metadata_routing)`;
    return this._py`res_DictionaryLearning_get_metadata_routing.tolist() if hasattr(res_DictionaryLearning_get_metadata_routing, 'tolist') else res_DictionaryLearning_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before set_output()");
    }
    await this._py.ex`pms_DictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_DictionaryLearning_set_output = {k: v for k, v in pms_DictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_set_output = bridgeDictionaryLearning[${this.id}].set_output(**pms_DictionaryLearning_set_output)`;
    return this._py`res_DictionaryLearning_set_output.tolist() if hasattr(res_DictionaryLearning_set_output, 'tolist') else res_DictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before transform()");
    }
    await this._py.ex`pms_DictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DictionaryLearning_transform = {k: v for k, v in pms_DictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_transform = bridgeDictionaryLearning[${this.id}].transform(**pms_DictionaryLearning_transform)`;
    return this._py`res_DictionaryLearning_transform.tolist() if hasattr(res_DictionaryLearning_transform, 'tolist') else res_DictionaryLearning_transform`;
  }
  /**
    dictionary atoms extracted from the data
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_components_ = bridgeDictionaryLearning[${this.id}].components_`;
      return this._py`attr_DictionaryLearning_components_.tolist() if hasattr(attr_DictionaryLearning_components_, 'tolist') else attr_DictionaryLearning_components_`;
    })();
  }
  /**
    vector of errors at each iteration
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing error_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_error_ = bridgeDictionaryLearning[${this.id}].error_`;
      return this._py`attr_DictionaryLearning_error_.tolist() if hasattr(attr_DictionaryLearning_error_, 'tolist') else attr_DictionaryLearning_error_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_features_in_ = bridgeDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_DictionaryLearning_n_features_in_.tolist() if hasattr(attr_DictionaryLearning_n_features_in_, 'tolist') else attr_DictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_feature_names_in_ = bridgeDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_DictionaryLearning_feature_names_in_.tolist() if hasattr(attr_DictionaryLearning_feature_names_in_, 'tolist') else attr_DictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_iter_ = bridgeDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_DictionaryLearning_n_iter_.tolist() if hasattr(attr_DictionaryLearning_n_iter_, 'tolist') else attr_DictionaryLearning_n_iter_`;
    })();
  }
};

// src/generated/decomposition/FactorAnalysis.ts
import crypto2 from "node:crypto";
var FactorAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FactorAnalysis${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FactorAnalysis.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FactorAnalysis
try: bridgeFactorAnalysis
except NameError: bridgeFactorAnalysis = {}
`;
    await this._py.ex`ctor_FactorAnalysis = {'n_components': ${this.opts["n_components"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'noise_variance_init': np.array(${this.opts["noise_variance_init"] ?? void 0}) if ${this.opts["noise_variance_init"] !== void 0} else None, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'rotation': ${this.opts["rotation"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FactorAnalysis = {k: v for k, v in ctor_FactorAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeFactorAnalysis[${this.id}] = FactorAnalysis(**ctor_FactorAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFactorAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the FactorAnalysis model to X using SVD based approach.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit()");
    }
    await this._py.ex`pms_FactorAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_fit = {k: v for k, v in pms_FactorAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit = bridgeFactorAnalysis[${this.id}].fit(**pms_FactorAnalysis_fit)`;
    return this._py`res_FactorAnalysis_fit.tolist() if hasattr(res_FactorAnalysis_fit, 'tolist') else res_FactorAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit_transform()");
    }
    await this._py.ex`pms_FactorAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FactorAnalysis_fit_transform = {k: v for k, v in pms_FactorAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit_transform = bridgeFactorAnalysis[${this.id}].fit_transform(**pms_FactorAnalysis_fit_transform)`;
    return this._py`res_FactorAnalysis_fit_transform.tolist() if hasattr(res_FactorAnalysis_fit_transform, 'tolist') else res_FactorAnalysis_fit_transform`;
  }
  /**
      Compute data covariance with the FactorAnalysis model.
  
      `cov \= components\_.T \* components\_ + diag(noise\_variance)`
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_covariance()");
    }
    await this._py.ex`pms_FactorAnalysis_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_FactorAnalysis_get_covariance = {k: v for k, v in pms_FactorAnalysis_get_covariance.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_covariance = bridgeFactorAnalysis[${this.id}].get_covariance(**pms_FactorAnalysis_get_covariance)`;
    return this._py`res_FactorAnalysis_get_covariance.tolist() if hasattr(res_FactorAnalysis_get_covariance, 'tolist') else res_FactorAnalysis_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FactorAnalysis_get_feature_names_out = {k: v for k, v in pms_FactorAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_feature_names_out = bridgeFactorAnalysis[${this.id}].get_feature_names_out(**pms_FactorAnalysis_get_feature_names_out)`;
    return this._py`res_FactorAnalysis_get_feature_names_out.tolist() if hasattr(res_FactorAnalysis_get_feature_names_out, 'tolist') else res_FactorAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FactorAnalysis_get_metadata_routing = {k: v for k, v in pms_FactorAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_metadata_routing = bridgeFactorAnalysis[${this.id}].get_metadata_routing(**pms_FactorAnalysis_get_metadata_routing)`;
    return this._py`res_FactorAnalysis_get_metadata_routing.tolist() if hasattr(res_FactorAnalysis_get_metadata_routing, 'tolist') else res_FactorAnalysis_get_metadata_routing`;
  }
  /**
    Compute data precision matrix with the FactorAnalysis model.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_precision()");
    }
    await this._py.ex`pms_FactorAnalysis_get_precision = {'precision': np.array(${opts["precision"] ?? void 0}) if ${opts["precision"] !== void 0} else None}

pms_FactorAnalysis_get_precision = {k: v for k, v in pms_FactorAnalysis_get_precision.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_precision = bridgeFactorAnalysis[${this.id}].get_precision(**pms_FactorAnalysis_get_precision)`;
    return this._py`res_FactorAnalysis_get_precision.tolist() if hasattr(res_FactorAnalysis_get_precision, 'tolist') else res_FactorAnalysis_get_precision`;
  }
  /**
    Compute the average log-likelihood of the samples.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score()");
    }
    await this._py.ex`pms_FactorAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_score = {k: v for k, v in pms_FactorAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score = bridgeFactorAnalysis[${this.id}].score(**pms_FactorAnalysis_score)`;
    return this._py`res_FactorAnalysis_score.tolist() if hasattr(res_FactorAnalysis_score, 'tolist') else res_FactorAnalysis_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score_samples()");
    }
    await this._py.ex`pms_FactorAnalysis_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_score_samples = {k: v for k, v in pms_FactorAnalysis_score_samples.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score_samples = bridgeFactorAnalysis[${this.id}].score_samples(**pms_FactorAnalysis_score_samples)`;
    return this._py`res_FactorAnalysis_score_samples.tolist() if hasattr(res_FactorAnalysis_score_samples, 'tolist') else res_FactorAnalysis_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before set_output()");
    }
    await this._py.ex`pms_FactorAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FactorAnalysis_set_output = {k: v for k, v in pms_FactorAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_set_output = bridgeFactorAnalysis[${this.id}].set_output(**pms_FactorAnalysis_set_output)`;
    return this._py`res_FactorAnalysis_set_output.tolist() if hasattr(res_FactorAnalysis_set_output, 'tolist') else res_FactorAnalysis_set_output`;
  }
  /**
      Apply dimensionality reduction to X using the model.
  
      Compute the expected mean of the latent variables. See Barber, 21.2.33 (or Bishop, 12.66).
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before transform()");
    }
    await this._py.ex`pms_FactorAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_transform = {k: v for k, v in pms_FactorAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_transform = bridgeFactorAnalysis[${this.id}].transform(**pms_FactorAnalysis_transform)`;
    return this._py`res_FactorAnalysis_transform.tolist() if hasattr(res_FactorAnalysis_transform, 'tolist') else res_FactorAnalysis_transform`;
  }
  /**
    Components with maximum variance.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_components_ = bridgeFactorAnalysis[${this.id}].components_`;
      return this._py`attr_FactorAnalysis_components_.tolist() if hasattr(attr_FactorAnalysis_components_, 'tolist') else attr_FactorAnalysis_components_`;
    })();
  }
  /**
    The log likelihood at each iteration.
   */
  get loglike_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing loglike_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_loglike_ = bridgeFactorAnalysis[${this.id}].loglike_`;
      return this._py`attr_FactorAnalysis_loglike_.tolist() if hasattr(attr_FactorAnalysis_loglike_, 'tolist') else attr_FactorAnalysis_loglike_`;
    })();
  }
  /**
    The estimated noise variance for each feature.
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_noise_variance_ = bridgeFactorAnalysis[${this.id}].noise_variance_`;
      return this._py`attr_FactorAnalysis_noise_variance_.tolist() if hasattr(attr_FactorAnalysis_noise_variance_, 'tolist') else attr_FactorAnalysis_noise_variance_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_iter_ = bridgeFactorAnalysis[${this.id}].n_iter_`;
      return this._py`attr_FactorAnalysis_n_iter_.tolist() if hasattr(attr_FactorAnalysis_n_iter_, 'tolist') else attr_FactorAnalysis_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_mean_ = bridgeFactorAnalysis[${this.id}].mean_`;
      return this._py`attr_FactorAnalysis_mean_.tolist() if hasattr(attr_FactorAnalysis_mean_, 'tolist') else attr_FactorAnalysis_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_features_in_ = bridgeFactorAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_FactorAnalysis_n_features_in_.tolist() if hasattr(attr_FactorAnalysis_n_features_in_, 'tolist') else attr_FactorAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_feature_names_in_ = bridgeFactorAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_FactorAnalysis_feature_names_in_.tolist() if hasattr(attr_FactorAnalysis_feature_names_in_, 'tolist') else attr_FactorAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/FastICA.ts
import crypto3 from "node:crypto";
var FastICA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FastICA${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FastICA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FastICA
try: bridgeFastICA
except NameError: bridgeFastICA = {}
`;
    await this._py.ex`ctor_FastICA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'fun': ${this.opts["fun"] ?? void 0}, 'fun_args': ${this.opts["fun_args"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'w_init': np.array(${this.opts["w_init"] ?? void 0}) if ${this.opts["w_init"] !== void 0} else None, 'whiten_solver': ${this.opts["whiten_solver"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FastICA = {k: v for k, v in ctor_FastICA.items() if v is not None}`;
    await this._py.ex`bridgeFastICA[${this.id}] = FastICA(**ctor_FastICA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFastICA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit()");
    }
    await this._py.ex`pms_FastICA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit = {k: v for k, v in pms_FastICA_fit.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit = bridgeFastICA[${this.id}].fit(**pms_FastICA_fit)`;
    return this._py`res_FastICA_fit.tolist() if hasattr(res_FastICA_fit, 'tolist') else res_FastICA_fit`;
  }
  /**
    Fit the model and recover the sources from X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit_transform()");
    }
    await this._py.ex`pms_FastICA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit_transform = {k: v for k, v in pms_FastICA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit_transform = bridgeFastICA[${this.id}].fit_transform(**pms_FastICA_fit_transform)`;
    return this._py`res_FastICA_fit_transform.tolist() if hasattr(res_FastICA_fit_transform, 'tolist') else res_FastICA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_FastICA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FastICA_get_feature_names_out = {k: v for k, v in pms_FastICA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_feature_names_out = bridgeFastICA[${this.id}].get_feature_names_out(**pms_FastICA_get_feature_names_out)`;
    return this._py`res_FastICA_get_feature_names_out.tolist() if hasattr(res_FastICA_get_feature_names_out, 'tolist') else res_FastICA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_FastICA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FastICA_get_metadata_routing = {k: v for k, v in pms_FastICA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_metadata_routing = bridgeFastICA[${this.id}].get_metadata_routing(**pms_FastICA_get_metadata_routing)`;
    return this._py`res_FastICA_get_metadata_routing.tolist() if hasattr(res_FastICA_get_metadata_routing, 'tolist') else res_FastICA_get_metadata_routing`;
  }
  /**
    Transform the sources back to the mixed data (apply mixing matrix).
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_FastICA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_inverse_transform = {k: v for k, v in pms_FastICA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_inverse_transform = bridgeFastICA[${this.id}].inverse_transform(**pms_FastICA_inverse_transform)`;
    return this._py`res_FastICA_inverse_transform.tolist() if hasattr(res_FastICA_inverse_transform, 'tolist') else res_FastICA_inverse_transform`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_FastICA_set_inverse_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_inverse_transform_request = {k: v for k, v in pms_FastICA_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_inverse_transform_request = bridgeFastICA[${this.id}].set_inverse_transform_request(**pms_FastICA_set_inverse_transform_request)`;
    return this._py`res_FastICA_set_inverse_transform_request.tolist() if hasattr(res_FastICA_set_inverse_transform_request, 'tolist') else res_FastICA_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_output()");
    }
    await this._py.ex`pms_FastICA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FastICA_set_output = {k: v for k, v in pms_FastICA_set_output.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_output = bridgeFastICA[${this.id}].set_output(**pms_FastICA_set_output)`;
    return this._py`res_FastICA_set_output.tolist() if hasattr(res_FastICA_set_output, 'tolist') else res_FastICA_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_transform_request()");
    }
    await this._py.ex`pms_FastICA_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_transform_request = {k: v for k, v in pms_FastICA_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_transform_request = bridgeFastICA[${this.id}].set_transform_request(**pms_FastICA_set_transform_request)`;
    return this._py`res_FastICA_set_transform_request.tolist() if hasattr(res_FastICA_set_transform_request, 'tolist') else res_FastICA_set_transform_request`;
  }
  /**
    Recover the sources from X (apply the unmixing matrix).
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before transform()");
    }
    await this._py.ex`pms_FastICA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_transform = {k: v for k, v in pms_FastICA_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_transform = bridgeFastICA[${this.id}].transform(**pms_FastICA_transform)`;
    return this._py`res_FastICA_transform.tolist() if hasattr(res_FastICA_transform, 'tolist') else res_FastICA_transform`;
  }
  /**
    The linear operator to apply to the data to get the independent sources. This is equal to the unmixing matrix when `whiten` is `false`, and equal to `np.dot(unmixing\_matrix, self.whitening\_)` when `whiten` is `true`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_components_ = bridgeFastICA[${this.id}].components_`;
      return this._py`attr_FastICA_components_.tolist() if hasattr(attr_FastICA_components_, 'tolist') else attr_FastICA_components_`;
    })();
  }
  /**
    The pseudo-inverse of `components\_`. It is the linear operator that maps independent sources to the data.
   */
  get mixing_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mixing_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mixing_ = bridgeFastICA[${this.id}].mixing_`;
      return this._py`attr_FastICA_mixing_.tolist() if hasattr(attr_FastICA_mixing_, 'tolist') else attr_FastICA_mixing_`;
    })();
  }
  /**
    The mean over features. Only set if `self.whiten` is `true`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mean_ = bridgeFastICA[${this.id}].mean_`;
      return this._py`attr_FastICA_mean_.tolist() if hasattr(attr_FastICA_mean_, 'tolist') else attr_FastICA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_features_in_ = bridgeFastICA[${this.id}].n_features_in_`;
      return this._py`attr_FastICA_n_features_in_.tolist() if hasattr(attr_FastICA_n_features_in_, 'tolist') else attr_FastICA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_feature_names_in_ = bridgeFastICA[${this.id}].feature_names_in_`;
      return this._py`attr_FastICA_feature_names_in_.tolist() if hasattr(attr_FastICA_feature_names_in_, 'tolist') else attr_FastICA_feature_names_in_`;
    })();
  }
  /**
    If the algorithm is “deflation”, n\_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_iter_ = bridgeFastICA[${this.id}].n_iter_`;
      return this._py`attr_FastICA_n_iter_.tolist() if hasattr(attr_FastICA_n_iter_, 'tolist') else attr_FastICA_n_iter_`;
    })();
  }
  /**
    Only set if whiten is ‘`true`’. This is the pre-whitening matrix that projects data onto the first `n\_components` principal components.
   */
  get whitening_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing whitening_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_whitening_ = bridgeFastICA[${this.id}].whitening_`;
      return this._py`attr_FastICA_whitening_.tolist() if hasattr(attr_FastICA_whitening_, 'tolist') else attr_FastICA_whitening_`;
    })();
  }
};

// src/generated/decomposition/IncrementalPCA.ts
import crypto4 from "node:crypto";
var IncrementalPCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `IncrementalPCA${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IncrementalPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import IncrementalPCA
try: bridgeIncrementalPCA
except NameError: bridgeIncrementalPCA = {}
`;
    await this._py.ex`ctor_IncrementalPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}}

ctor_IncrementalPCA = {k: v for k, v in ctor_IncrementalPCA.items() if v is not None}`;
    await this._py.ex`bridgeIncrementalPCA[${this.id}] = IncrementalPCA(**ctor_IncrementalPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIncrementalPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X, using minibatches of size batch\_size.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit()");
    }
    await this._py.ex`pms_IncrementalPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_IncrementalPCA_fit = {k: v for k, v in pms_IncrementalPCA_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit = bridgeIncrementalPCA[${this.id}].fit(**pms_IncrementalPCA_fit)`;
    return this._py`res_IncrementalPCA_fit.tolist() if hasattr(res_IncrementalPCA_fit, 'tolist') else res_IncrementalPCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_IncrementalPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_IncrementalPCA_fit_transform = {k: v for k, v in pms_IncrementalPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit_transform = bridgeIncrementalPCA[${this.id}].fit_transform(**pms_IncrementalPCA_fit_transform)`;
    return this._py`res_IncrementalPCA_fit_transform.tolist() if hasattr(res_IncrementalPCA_fit_transform, 'tolist') else res_IncrementalPCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components\_.T \* S\*\*2 \* components\_ + sigma2 \* eye(n\_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_IncrementalPCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_IncrementalPCA_get_covariance = {k: v for k, v in pms_IncrementalPCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_covariance = bridgeIncrementalPCA[${this.id}].get_covariance(**pms_IncrementalPCA_get_covariance)`;
    return this._py`res_IncrementalPCA_get_covariance.tolist() if hasattr(res_IncrementalPCA_get_covariance, 'tolist') else res_IncrementalPCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_IncrementalPCA_get_feature_names_out = {k: v for k, v in pms_IncrementalPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_feature_names_out = bridgeIncrementalPCA[${this.id}].get_feature_names_out(**pms_IncrementalPCA_get_feature_names_out)`;
    return this._py`res_IncrementalPCA_get_feature_names_out.tolist() if hasattr(res_IncrementalPCA_get_feature_names_out, 'tolist') else res_IncrementalPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IncrementalPCA_get_metadata_routing = {k: v for k, v in pms_IncrementalPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_metadata_routing = bridgeIncrementalPCA[${this.id}].get_metadata_routing(**pms_IncrementalPCA_get_metadata_routing)`;
    return this._py`res_IncrementalPCA_get_metadata_routing.tolist() if hasattr(res_IncrementalPCA_get_metadata_routing, 'tolist') else res_IncrementalPCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_precision()");
    }
    await this._py.ex`pms_IncrementalPCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_IncrementalPCA_get_precision = {k: v for k, v in pms_IncrementalPCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_precision = bridgeIncrementalPCA[${this.id}].get_precision(**pms_IncrementalPCA_get_precision)`;
    return this._py`res_IncrementalPCA_get_precision.tolist() if hasattr(res_IncrementalPCA_get_precision, 'tolist') else res_IncrementalPCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X\_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_inverse_transform = {k: v for k, v in pms_IncrementalPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_inverse_transform = bridgeIncrementalPCA[${this.id}].inverse_transform(**pms_IncrementalPCA_inverse_transform)`;
    return this._py`res_IncrementalPCA_inverse_transform.tolist() if hasattr(res_IncrementalPCA_inverse_transform, 'tolist') else res_IncrementalPCA_inverse_transform`;
  }
  /**
    Incremental fit with X. All of X is processed as a single batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before partial_fit()");
    }
    await this._py.ex`pms_IncrementalPCA_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_partial_fit = {k: v for k, v in pms_IncrementalPCA_partial_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_partial_fit = bridgeIncrementalPCA[${this.id}].partial_fit(**pms_IncrementalPCA_partial_fit)`;
    return this._py`res_IncrementalPCA_partial_fit.tolist() if hasattr(res_IncrementalPCA_partial_fit, 'tolist') else res_IncrementalPCA_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before set_output()");
    }
    await this._py.ex`pms_IncrementalPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_IncrementalPCA_set_output = {k: v for k, v in pms_IncrementalPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_output = bridgeIncrementalPCA[${this.id}].set_output(**pms_IncrementalPCA_set_output)`;
    return this._py`res_IncrementalPCA_set_output.tolist() if hasattr(res_IncrementalPCA_set_output, 'tolist') else res_IncrementalPCA_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_set_partial_fit_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_set_partial_fit_request = {k: v for k, v in pms_IncrementalPCA_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_partial_fit_request = bridgeIncrementalPCA[${this.id}].set_partial_fit_request(**pms_IncrementalPCA_set_partial_fit_request)`;
    return this._py`res_IncrementalPCA_set_partial_fit_request.tolist() if hasattr(res_IncrementalPCA_set_partial_fit_request, 'tolist') else res_IncrementalPCA_set_partial_fit_request`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set, using minibatches of size batch\_size if X is sparse.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before transform()");
    }
    await this._py.ex`pms_IncrementalPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_transform = {k: v for k, v in pms_IncrementalPCA_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_transform = bridgeIncrementalPCA[${this.id}].transform(**pms_IncrementalPCA_transform)`;
    return this._py`res_IncrementalPCA_transform.tolist() if hasattr(res_IncrementalPCA_transform, 'tolist') else res_IncrementalPCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\_variance\_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_components_ = bridgeIncrementalPCA[${this.id}].components_`;
      return this._py`attr_IncrementalPCA_components_.tolist() if hasattr(attr_IncrementalPCA_components_, 'tolist') else attr_IncrementalPCA_components_`;
    })();
  }
  /**
    Variance explained by each of the selected components.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ = bridgeIncrementalPCA[${this.id}].explained_variance_`;
      return this._py`attr_IncrementalPCA_explained_variance_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_, 'tolist') else attr_IncrementalPCA_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ratio_ = bridgeIncrementalPCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_IncrementalPCA_explained_variance_ratio_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_ratio_, 'tolist') else attr_IncrementalPCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_singular_values_ = bridgeIncrementalPCA[${this.id}].singular_values_`;
      return this._py`attr_IncrementalPCA_singular_values_.tolist() if hasattr(attr_IncrementalPCA_singular_values_, 'tolist') else attr_IncrementalPCA_singular_values_`;
    })();
  }
  /**
    Per-feature empirical mean, aggregate over calls to `partial\_fit`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_mean_ = bridgeIncrementalPCA[${this.id}].mean_`;
      return this._py`attr_IncrementalPCA_mean_.tolist() if hasattr(attr_IncrementalPCA_mean_, 'tolist') else attr_IncrementalPCA_mean_`;
    })();
  }
  /**
    Per-feature empirical variance, aggregate over calls to `partial\_fit`.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_var_ = bridgeIncrementalPCA[${this.id}].var_`;
      return this._py`attr_IncrementalPCA_var_.tolist() if hasattr(attr_IncrementalPCA_var_, 'tolist') else attr_IncrementalPCA_var_`;
    })();
  }
  /**
    The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf).
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_noise_variance_ = bridgeIncrementalPCA[${this.id}].noise_variance_`;
      return this._py`attr_IncrementalPCA_noise_variance_.tolist() if hasattr(attr_IncrementalPCA_noise_variance_, 'tolist') else attr_IncrementalPCA_noise_variance_`;
    })();
  }
  /**
    The estimated number of components. Relevant when `n\_components=None`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_components_ = bridgeIncrementalPCA[${this.id}].n_components_`;
      return this._py`attr_IncrementalPCA_n_components_.tolist() if hasattr(attr_IncrementalPCA_n_components_, 'tolist') else attr_IncrementalPCA_n_components_`;
    })();
  }
  /**
    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_samples_seen_ = bridgeIncrementalPCA[${this.id}].n_samples_seen_`;
      return this._py`attr_IncrementalPCA_n_samples_seen_.tolist() if hasattr(attr_IncrementalPCA_n_samples_seen_, 'tolist') else attr_IncrementalPCA_n_samples_seen_`;
    })();
  }
  /**
    Inferred batch size from `batch\_size`.
   */
  get batch_size_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing batch_size_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_batch_size_ = bridgeIncrementalPCA[${this.id}].batch_size_`;
      return this._py`attr_IncrementalPCA_batch_size_.tolist() if hasattr(attr_IncrementalPCA_batch_size_, 'tolist') else attr_IncrementalPCA_batch_size_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_features_in_ = bridgeIncrementalPCA[${this.id}].n_features_in_`;
      return this._py`attr_IncrementalPCA_n_features_in_.tolist() if hasattr(attr_IncrementalPCA_n_features_in_, 'tolist') else attr_IncrementalPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_feature_names_in_ = bridgeIncrementalPCA[${this.id}].feature_names_in_`;
      return this._py`attr_IncrementalPCA_feature_names_in_.tolist() if hasattr(attr_IncrementalPCA_feature_names_in_, 'tolist') else attr_IncrementalPCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/KernelPCA.ts
import crypto5 from "node:crypto";
var KernelPCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelPCA${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import KernelPCA
try: bridgeKernelPCA
except NameError: bridgeKernelPCA = {}
`;
    await this._py.ex`ctor_KernelPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_inverse_transform': ${this.opts["fit_inverse_transform"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'remove_zero_eig': ${this.opts["remove_zero_eig"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KernelPCA = {k: v for k, v in ctor_KernelPCA.items() if v is not None}`;
    await this._py.ex`bridgeKernelPCA[${this.id}] = KernelPCA(**ctor_KernelPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit()");
    }
    await this._py.ex`pms_KernelPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelPCA_fit = {k: v for k, v in pms_KernelPCA_fit.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit = bridgeKernelPCA[${this.id}].fit(**pms_KernelPCA_fit)`;
    return this._py`res_KernelPCA_fit.tolist() if hasattr(res_KernelPCA_fit, 'tolist') else res_KernelPCA_fit`;
  }
  /**
    Fit the model from data in X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_KernelPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_KernelPCA_fit_transform = {k: v for k, v in pms_KernelPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit_transform = bridgeKernelPCA[${this.id}].fit_transform(**pms_KernelPCA_fit_transform)`;
    return this._py`res_KernelPCA_fit_transform.tolist() if hasattr(res_KernelPCA_fit_transform, 'tolist') else res_KernelPCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KernelPCA_get_feature_names_out = {k: v for k, v in pms_KernelPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_feature_names_out = bridgeKernelPCA[${this.id}].get_feature_names_out(**pms_KernelPCA_get_feature_names_out)`;
    return this._py`res_KernelPCA_get_feature_names_out.tolist() if hasattr(res_KernelPCA_get_feature_names_out, 'tolist') else res_KernelPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelPCA_get_metadata_routing = {k: v for k, v in pms_KernelPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_metadata_routing = bridgeKernelPCA[${this.id}].get_metadata_routing(**pms_KernelPCA_get_metadata_routing)`;
    return this._py`res_KernelPCA_get_metadata_routing.tolist() if hasattr(res_KernelPCA_get_metadata_routing, 'tolist') else res_KernelPCA_get_metadata_routing`;
  }
  /**
      Transform X back to original space.
  
      `inverse\_transform` approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_KernelPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_inverse_transform = {k: v for k, v in pms_KernelPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_inverse_transform = bridgeKernelPCA[${this.id}].inverse_transform(**pms_KernelPCA_inverse_transform)`;
    return this._py`res_KernelPCA_inverse_transform.tolist() if hasattr(res_KernelPCA_inverse_transform, 'tolist') else res_KernelPCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before set_output()");
    }
    await this._py.ex`pms_KernelPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KernelPCA_set_output = {k: v for k, v in pms_KernelPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_set_output = bridgeKernelPCA[${this.id}].set_output(**pms_KernelPCA_set_output)`;
    return this._py`res_KernelPCA_set_output.tolist() if hasattr(res_KernelPCA_set_output, 'tolist') else res_KernelPCA_set_output`;
  }
  /**
    Transform X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before transform()");
    }
    await this._py.ex`pms_KernelPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_transform = {k: v for k, v in pms_KernelPCA_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_transform = bridgeKernelPCA[${this.id}].transform(**pms_KernelPCA_transform)`;
    return this._py`res_KernelPCA_transform.tolist() if hasattr(res_KernelPCA_transform, 'tolist') else res_KernelPCA_transform`;
  }
  /**
    Eigenvalues of the centered kernel matrix in decreasing order. If `n\_components` and `remove\_zero\_eig` are not set, then all values are stored.
   */
  get eigenvalues_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvalues_ = bridgeKernelPCA[${this.id}].eigenvalues_`;
      return this._py`attr_KernelPCA_eigenvalues_.tolist() if hasattr(attr_KernelPCA_eigenvalues_, 'tolist') else attr_KernelPCA_eigenvalues_`;
    })();
  }
  /**
    Eigenvectors of the centered kernel matrix. If `n\_components` and `remove\_zero\_eig` are not set, then all components are stored.
   */
  get eigenvectors_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvectors_ = bridgeKernelPCA[${this.id}].eigenvectors_`;
      return this._py`attr_KernelPCA_eigenvectors_.tolist() if hasattr(attr_KernelPCA_eigenvectors_, 'tolist') else attr_KernelPCA_eigenvectors_`;
    })();
  }
  /**
    Inverse transform matrix. Only available when `fit\_inverse\_transform` is `true`.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_dual_coef_ = bridgeKernelPCA[${this.id}].dual_coef_`;
      return this._py`attr_KernelPCA_dual_coef_.tolist() if hasattr(attr_KernelPCA_dual_coef_, 'tolist') else attr_KernelPCA_dual_coef_`;
    })();
  }
  /**
    Projection of the fitted data on the kernel principal components. Only available when `fit\_inverse\_transform` is `true`.
   */
  get X_transformed_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing X_transformed_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_transformed_fit_ = bridgeKernelPCA[${this.id}].X_transformed_fit_`;
      return this._py`attr_KernelPCA_X_transformed_fit_.tolist() if hasattr(attr_KernelPCA_X_transformed_fit_, 'tolist') else attr_KernelPCA_X_transformed_fit_`;
    })();
  }
  /**
    The data used to fit the model. If `copy\_X=False`, then `X\_fit\_` is a reference. This attribute is used for the calls to transform.
   */
  get X_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing X_fit_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_fit_ = bridgeKernelPCA[${this.id}].X_fit_`;
      return this._py`attr_KernelPCA_X_fit_.tolist() if hasattr(attr_KernelPCA_X_fit_, 'tolist') else attr_KernelPCA_X_fit_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_n_features_in_ = bridgeKernelPCA[${this.id}].n_features_in_`;
      return this._py`attr_KernelPCA_n_features_in_.tolist() if hasattr(attr_KernelPCA_n_features_in_, 'tolist') else attr_KernelPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_feature_names_in_ = bridgeKernelPCA[${this.id}].feature_names_in_`;
      return this._py`attr_KernelPCA_feature_names_in_.tolist() if hasattr(attr_KernelPCA_feature_names_in_, 'tolist') else attr_KernelPCA_feature_names_in_`;
    })();
  }
  /**
    Kernel coefficient for rbf, poly and sigmoid kernels. When `gamma` is explicitly provided, this is just the same as `gamma`. When `gamma` is `undefined`, this is the actual value of kernel coefficient.
   */
  get gamma_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing gamma_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_gamma_ = bridgeKernelPCA[${this.id}].gamma_`;
      return this._py`attr_KernelPCA_gamma_.tolist() if hasattr(attr_KernelPCA_gamma_, 'tolist') else attr_KernelPCA_gamma_`;
    })();
  }
};

// src/generated/decomposition/LatentDirichletAllocation.ts
import crypto6 from "node:crypto";
var LatentDirichletAllocation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LatentDirichletAllocation${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LatentDirichletAllocation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import LatentDirichletAllocation
try: bridgeLatentDirichletAllocation
except NameError: bridgeLatentDirichletAllocation = {}
`;
    await this._py.ex`ctor_LatentDirichletAllocation = {'n_components': ${this.opts["n_components"] ?? void 0}, 'doc_topic_prior': ${this.opts["doc_topic_prior"] ?? void 0}, 'topic_word_prior': ${this.opts["topic_word_prior"] ?? void 0}, 'learning_method': ${this.opts["learning_method"] ?? void 0}, 'learning_decay': ${this.opts["learning_decay"] ?? void 0}, 'learning_offset': ${this.opts["learning_offset"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'evaluate_every': ${this.opts["evaluate_every"] ?? void 0}, 'total_samples': ${this.opts["total_samples"] ?? void 0}, 'perp_tol': ${this.opts["perp_tol"] ?? void 0}, 'mean_change_tol': ${this.opts["mean_change_tol"] ?? void 0}, 'max_doc_update_iter': ${this.opts["max_doc_update_iter"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_LatentDirichletAllocation = {k: v for k, v in ctor_LatentDirichletAllocation.items() if v is not None}`;
    await this._py.ex`bridgeLatentDirichletAllocation[${this.id}] = LatentDirichletAllocation(**ctor_LatentDirichletAllocation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLatentDirichletAllocation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Learn model for the data X with variational Bayes method.
  
      When `learning\_method` is ‘online’, use mini-batch update. Otherwise, use batch update.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LatentDirichletAllocation must call init() before fit()");
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_fit = {k: v for k, v in pms_LatentDirichletAllocation_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit = bridgeLatentDirichletAllocation[${this.id}].fit(**pms_LatentDirichletAllocation_fit)`;
    return this._py`res_LatentDirichletAllocation_fit.tolist() if hasattr(res_LatentDirichletAllocation_fit, 'tolist') else res_LatentDirichletAllocation_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_LatentDirichletAllocation_fit_transform = {k: v for k, v in pms_LatentDirichletAllocation_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit_transform = bridgeLatentDirichletAllocation[${this.id}].fit_transform(**pms_LatentDirichletAllocation_fit_transform)`;
    return this._py`res_LatentDirichletAllocation_fit_transform.tolist() if hasattr(res_LatentDirichletAllocation_fit_transform, 'tolist') else res_LatentDirichletAllocation_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LatentDirichletAllocation_get_feature_names_out = {k: v for k, v in pms_LatentDirichletAllocation_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_feature_names_out = bridgeLatentDirichletAllocation[${this.id}].get_feature_names_out(**pms_LatentDirichletAllocation_get_feature_names_out)`;
    return this._py`res_LatentDirichletAllocation_get_feature_names_out.tolist() if hasattr(res_LatentDirichletAllocation_get_feature_names_out, 'tolist') else res_LatentDirichletAllocation_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LatentDirichletAllocation_get_metadata_routing = {k: v for k, v in pms_LatentDirichletAllocation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_metadata_routing = bridgeLatentDirichletAllocation[${this.id}].get_metadata_routing(**pms_LatentDirichletAllocation_get_metadata_routing)`;
    return this._py`res_LatentDirichletAllocation_get_metadata_routing.tolist() if hasattr(res_LatentDirichletAllocation_get_metadata_routing, 'tolist') else res_LatentDirichletAllocation_get_metadata_routing`;
  }
  /**
    Online VB with Mini-Batch update.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_partial_fit = {k: v for k, v in pms_LatentDirichletAllocation_partial_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_partial_fit = bridgeLatentDirichletAllocation[${this.id}].partial_fit(**pms_LatentDirichletAllocation_partial_fit)`;
    return this._py`res_LatentDirichletAllocation_partial_fit.tolist() if hasattr(res_LatentDirichletAllocation_partial_fit, 'tolist') else res_LatentDirichletAllocation_partial_fit`;
  }
  /**
      Calculate approximate perplexity for data X.
  
      Perplexity is defined as exp(-1. \* log-likelihood per word)
     */
  async perplexity(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before perplexity()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_perplexity = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sub_sampling': ${opts["sub_sampling"] ?? void 0}}

pms_LatentDirichletAllocation_perplexity = {k: v for k, v in pms_LatentDirichletAllocation_perplexity.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_perplexity = bridgeLatentDirichletAllocation[${this.id}].perplexity(**pms_LatentDirichletAllocation_perplexity)`;
    return this._py`res_LatentDirichletAllocation_perplexity.tolist() if hasattr(res_LatentDirichletAllocation_perplexity, 'tolist') else res_LatentDirichletAllocation_perplexity`;
  }
  /**
    Calculate approximate log-likelihood as score.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before score()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_score = {k: v for k, v in pms_LatentDirichletAllocation_score.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_score = bridgeLatentDirichletAllocation[${this.id}].score(**pms_LatentDirichletAllocation_score)`;
    return this._py`res_LatentDirichletAllocation_score.tolist() if hasattr(res_LatentDirichletAllocation_score, 'tolist') else res_LatentDirichletAllocation_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LatentDirichletAllocation_set_output = {k: v for k, v in pms_LatentDirichletAllocation_set_output.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_set_output = bridgeLatentDirichletAllocation[${this.id}].set_output(**pms_LatentDirichletAllocation_set_output)`;
    return this._py`res_LatentDirichletAllocation_set_output.tolist() if hasattr(res_LatentDirichletAllocation_set_output, 'tolist') else res_LatentDirichletAllocation_set_output`;
  }
  /**
    Transform data X according to the fitted model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LatentDirichletAllocation_transform = {k: v for k, v in pms_LatentDirichletAllocation_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_transform = bridgeLatentDirichletAllocation[${this.id}].transform(**pms_LatentDirichletAllocation_transform)`;
    return this._py`res_LatentDirichletAllocation_transform.tolist() if hasattr(res_LatentDirichletAllocation_transform, 'tolist') else res_LatentDirichletAllocation_transform`;
  }
  /**
    Variational parameters for topic word distribution. Since the complete conditional for topic word distribution is a Dirichlet, `components\_\[i, j\]` can be viewed as pseudocount that represents the number of times word `j` was assigned to topic `i`. It can also be viewed as distribution over the words for each topic after normalization: `model.components\_ / model.components\_.sum(axis=1)\[:, np.newaxis\]`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_components_ = bridgeLatentDirichletAllocation[${this.id}].components_`;
      return this._py`attr_LatentDirichletAllocation_components_.tolist() if hasattr(attr_LatentDirichletAllocation_components_, 'tolist') else attr_LatentDirichletAllocation_components_`;
    })();
  }
  /**
    Exponential value of expectation of log topic word distribution. In the literature, this is `exp(E\[log(beta)\])`.
   */
  get exp_dirichlet_component_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing exp_dirichlet_component_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_exp_dirichlet_component_ = bridgeLatentDirichletAllocation[${this.id}].exp_dirichlet_component_`;
      return this._py`attr_LatentDirichletAllocation_exp_dirichlet_component_.tolist() if hasattr(attr_LatentDirichletAllocation_exp_dirichlet_component_, 'tolist') else attr_LatentDirichletAllocation_exp_dirichlet_component_`;
    })();
  }
  /**
    Number of iterations of the EM step.
   */
  get n_batch_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_batch_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_batch_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_batch_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_batch_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_batch_iter_, 'tolist') else attr_LatentDirichletAllocation_n_batch_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_features_in_ = bridgeLatentDirichletAllocation[${this.id}].n_features_in_`;
      return this._py`attr_LatentDirichletAllocation_n_features_in_.tolist() if hasattr(attr_LatentDirichletAllocation_n_features_in_, 'tolist') else attr_LatentDirichletAllocation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_feature_names_in_ = bridgeLatentDirichletAllocation[${this.id}].feature_names_in_`;
      return this._py`attr_LatentDirichletAllocation_feature_names_in_.tolist() if hasattr(attr_LatentDirichletAllocation_feature_names_in_, 'tolist') else attr_LatentDirichletAllocation_feature_names_in_`;
    })();
  }
  /**
    Number of passes over the dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_iter_, 'tolist') else attr_LatentDirichletAllocation_n_iter_`;
    })();
  }
  /**
    Final perplexity score on training set.
   */
  get bound_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_bound_ = bridgeLatentDirichletAllocation[${this.id}].bound_`;
      return this._py`attr_LatentDirichletAllocation_bound_.tolist() if hasattr(attr_LatentDirichletAllocation_bound_, 'tolist') else attr_LatentDirichletAllocation_bound_`;
    })();
  }
  /**
    Prior of document topic distribution `theta`. If the value is `undefined`, it is `1 / n\_components`.
   */
  get doc_topic_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing doc_topic_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_doc_topic_prior_ = bridgeLatentDirichletAllocation[${this.id}].doc_topic_prior_`;
      return this._py`attr_LatentDirichletAllocation_doc_topic_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_doc_topic_prior_, 'tolist') else attr_LatentDirichletAllocation_doc_topic_prior_`;
    })();
  }
  /**
    RandomState instance that is generated either from a seed, the random number generator or by `np.random`.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_random_state_ = bridgeLatentDirichletAllocation[${this.id}].random_state_`;
      return this._py`attr_LatentDirichletAllocation_random_state_.tolist() if hasattr(attr_LatentDirichletAllocation_random_state_, 'tolist') else attr_LatentDirichletAllocation_random_state_`;
    })();
  }
  /**
    Prior of topic word distribution `beta`. If the value is `undefined`, it is `1 / n\_components`.
   */
  get topic_word_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing topic_word_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_topic_word_prior_ = bridgeLatentDirichletAllocation[${this.id}].topic_word_prior_`;
      return this._py`attr_LatentDirichletAllocation_topic_word_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_topic_word_prior_, 'tolist') else attr_LatentDirichletAllocation_topic_word_prior_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchDictionaryLearning.ts
import crypto7 from "node:crypto";
var MiniBatchDictionaryLearning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchDictionaryLearning${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchDictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchDictionaryLearning
try: bridgeMiniBatchDictionaryLearning
except NameError: bridgeMiniBatchDictionaryLearning = {}
`;
    await this._py.ex`ctor_MiniBatchDictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchDictionaryLearning = {k: v for k, v in ctor_MiniBatchDictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchDictionaryLearning[${this.id}] = MiniBatchDictionaryLearning(**ctor_MiniBatchDictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit = bridgeMiniBatchDictionaryLearning[${this.id}].fit(**pms_MiniBatchDictionaryLearning_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit, 'tolist') else res_MiniBatchDictionaryLearning_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit_transform = bridgeMiniBatchDictionaryLearning[${this.id}].fit_transform(**pms_MiniBatchDictionaryLearning_fit_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_fit_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit_transform, 'tolist') else res_MiniBatchDictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_feature_names_out = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_feature_names_out = bridgeMiniBatchDictionaryLearning[${this.id}].get_feature_names_out(**pms_MiniBatchDictionaryLearning_get_feature_names_out)`;
    return this._py`res_MiniBatchDictionaryLearning_get_feature_names_out.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_feature_names_out, 'tolist') else res_MiniBatchDictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_metadata_routing = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_metadata_routing = bridgeMiniBatchDictionaryLearning[${this.id}].get_metadata_routing(**pms_MiniBatchDictionaryLearning_get_metadata_routing)`;
    return this._py`res_MiniBatchDictionaryLearning_get_metadata_routing.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_metadata_routing, 'tolist') else res_MiniBatchDictionaryLearning_get_metadata_routing`;
  }
  /**
    Update the model using the data in X as a mini-batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_partial_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_partial_fit = bridgeMiniBatchDictionaryLearning[${this.id}].partial_fit(**pms_MiniBatchDictionaryLearning_partial_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_partial_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_partial_fit, 'tolist') else res_MiniBatchDictionaryLearning_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before set_output()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchDictionaryLearning_set_output = {k: v for k, v in pms_MiniBatchDictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_set_output = bridgeMiniBatchDictionaryLearning[${this.id}].set_output(**pms_MiniBatchDictionaryLearning_set_output)`;
    return this._py`res_MiniBatchDictionaryLearning_set_output.tolist() if hasattr(res_MiniBatchDictionaryLearning_set_output, 'tolist') else res_MiniBatchDictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchDictionaryLearning_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_transform = bridgeMiniBatchDictionaryLearning[${this.id}].transform(**pms_MiniBatchDictionaryLearning_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_transform, 'tolist') else res_MiniBatchDictionaryLearning_transform`;
  }
  /**
    Components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_components_ = bridgeMiniBatchDictionaryLearning[${this.id}].components_`;
      return this._py`attr_MiniBatchDictionaryLearning_components_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_components_, 'tolist') else attr_MiniBatchDictionaryLearning_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_features_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_features_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_features_in_, 'tolist') else attr_MiniBatchDictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_feature_names_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_feature_names_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_feature_names_in_, 'tolist') else attr_MiniBatchDictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_iter_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_iter_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_iter_, 'tolist') else attr_MiniBatchDictionaryLearning_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_steps_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_steps_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_steps_, 'tolist') else attr_MiniBatchDictionaryLearning_n_steps_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchNMF.ts
import crypto8 from "node:crypto";
var MiniBatchNMF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchNMF${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchNMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchNMF
try: bridgeMiniBatchNMF
except NameError: bridgeMiniBatchNMF = {}
`;
    await this._py.ex`ctor_MiniBatchNMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'forget_factor': ${this.opts["forget_factor"] ?? void 0}, 'fresh_restarts': ${this.opts["fresh_restarts"] ?? void 0}, 'fresh_restarts_max_iter': ${this.opts["fresh_restarts_max_iter"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_MiniBatchNMF = {k: v for k, v in ctor_MiniBatchNMF.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchNMF[${this.id}] = MiniBatchNMF(**ctor_MiniBatchNMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MiniBatchNMF_fit = {k: v for k, v in pms_MiniBatchNMF_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit = bridgeMiniBatchNMF[${this.id}].fit(**pms_MiniBatchNMF_fit)`;
    return this._py`res_MiniBatchNMF_fit.tolist() if hasattr(res_MiniBatchNMF_fit, 'tolist') else res_MiniBatchNMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_fit_transform = {k: v for k, v in pms_MiniBatchNMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit_transform = bridgeMiniBatchNMF[${this.id}].fit_transform(**pms_MiniBatchNMF_fit_transform)`;
    return this._py`res_MiniBatchNMF_fit_transform.tolist() if hasattr(res_MiniBatchNMF_fit_transform, 'tolist') else res_MiniBatchNMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchNMF_get_feature_names_out = {k: v for k, v in pms_MiniBatchNMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_feature_names_out = bridgeMiniBatchNMF[${this.id}].get_feature_names_out(**pms_MiniBatchNMF_get_feature_names_out)`;
    return this._py`res_MiniBatchNMF_get_feature_names_out.tolist() if hasattr(res_MiniBatchNMF_get_feature_names_out, 'tolist') else res_MiniBatchNMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchNMF_get_metadata_routing = {k: v for k, v in pms_MiniBatchNMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_metadata_routing = bridgeMiniBatchNMF[${this.id}].get_metadata_routing(**pms_MiniBatchNMF_get_metadata_routing)`;
    return this._py`res_MiniBatchNMF_get_metadata_routing.tolist() if hasattr(res_MiniBatchNMF_get_metadata_routing, 'tolist') else res_MiniBatchNMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'W': ${opts["W"] ?? void 0}}

pms_MiniBatchNMF_inverse_transform = {k: v for k, v in pms_MiniBatchNMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_inverse_transform = bridgeMiniBatchNMF[${this.id}].inverse_transform(**pms_MiniBatchNMF_inverse_transform)`;
    return this._py`res_MiniBatchNMF_inverse_transform.tolist() if hasattr(res_MiniBatchNMF_inverse_transform, 'tolist') else res_MiniBatchNMF_inverse_transform`;
  }
  /**
      Update the model using the data in `X` as a mini-batch.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once (see [Strategies to scale computationally: bigger data](../../computing/scaling_strategies.html#scaling-strategies)).
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_partial_fit = {k: v for k, v in pms_MiniBatchNMF_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_partial_fit = bridgeMiniBatchNMF[${this.id}].partial_fit(**pms_MiniBatchNMF_partial_fit)`;
    return this._py`res_MiniBatchNMF_partial_fit.tolist() if hasattr(res_MiniBatchNMF_partial_fit, 'tolist') else res_MiniBatchNMF_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchNMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchNMF_set_output = {k: v for k, v in pms_MiniBatchNMF_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_set_output = bridgeMiniBatchNMF[${this.id}].set_output(**pms_MiniBatchNMF_set_output)`;
    return this._py`res_MiniBatchNMF_set_output.tolist() if hasattr(res_MiniBatchNMF_set_output, 'tolist') else res_MiniBatchNMF_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_set_partial_fit_request = {'H': ${opts["H"] ?? void 0}, 'W': ${opts["W"] ?? void 0}}

pms_MiniBatchNMF_set_partial_fit_request = {k: v for k, v in pms_MiniBatchNMF_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_set_partial_fit_request = bridgeMiniBatchNMF[${this.id}].set_partial_fit_request(**pms_MiniBatchNMF_set_partial_fit_request)`;
    return this._py`res_MiniBatchNMF_set_partial_fit_request.tolist() if hasattr(res_MiniBatchNMF_set_partial_fit_request, 'tolist') else res_MiniBatchNMF_set_partial_fit_request`;
  }
  /**
    Transform the data X according to the fitted MiniBatchNMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchNMF_transform = {k: v for k, v in pms_MiniBatchNMF_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_transform = bridgeMiniBatchNMF[${this.id}].transform(**pms_MiniBatchNMF_transform)`;
    return this._py`res_MiniBatchNMF_transform.tolist() if hasattr(res_MiniBatchNMF_transform, 'tolist') else res_MiniBatchNMF_transform`;
  }
  /**
    Factorization matrix, sometimes called ‘dictionary’.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_components_ = bridgeMiniBatchNMF[${this.id}].components_`;
      return this._py`attr_MiniBatchNMF_components_.tolist() if hasattr(attr_MiniBatchNMF_components_, 'tolist') else attr_MiniBatchNMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n\_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_components_ = bridgeMiniBatchNMF[${this.id}].n_components_`;
      return this._py`attr_MiniBatchNMF_n_components_.tolist() if hasattr(attr_MiniBatchNMF_n_components_, 'tolist') else attr_MiniBatchNMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_reconstruction_err_ = bridgeMiniBatchNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_MiniBatchNMF_reconstruction_err_.tolist() if hasattr(attr_MiniBatchNMF_reconstruction_err_, 'tolist') else attr_MiniBatchNMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of started iterations over the whole dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_iter_ = bridgeMiniBatchNMF[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchNMF_n_iter_.tolist() if hasattr(attr_MiniBatchNMF_n_iter_, 'tolist') else attr_MiniBatchNMF_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_steps_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_steps_ = bridgeMiniBatchNMF[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchNMF_n_steps_.tolist() if hasattr(attr_MiniBatchNMF_n_steps_, 'tolist') else attr_MiniBatchNMF_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_features_in_ = bridgeMiniBatchNMF[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchNMF_n_features_in_.tolist() if hasattr(attr_MiniBatchNMF_n_features_in_, 'tolist') else attr_MiniBatchNMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_feature_names_in_ = bridgeMiniBatchNMF[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchNMF_feature_names_in_.tolist() if hasattr(attr_MiniBatchNMF_feature_names_in_, 'tolist') else attr_MiniBatchNMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchSparsePCA.ts
import crypto9 from "node:crypto";
var MiniBatchSparsePCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchSparsePCA${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchSparsePCA.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchSparsePCA
try: bridgeMiniBatchSparsePCA
except NameError: bridgeMiniBatchSparsePCA = {}
`;
    await this._py.ex`ctor_MiniBatchSparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchSparsePCA = {k: v for k, v in ctor_MiniBatchSparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchSparsePCA[${this.id}] = MiniBatchSparsePCA(**ctor_MiniBatchSparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchSparsePCA_fit = {k: v for k, v in pms_MiniBatchSparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit = bridgeMiniBatchSparsePCA[${this.id}].fit(**pms_MiniBatchSparsePCA_fit)`;
    return this._py`res_MiniBatchSparsePCA_fit.tolist() if hasattr(res_MiniBatchSparsePCA_fit, 'tolist') else res_MiniBatchSparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchSparsePCA_fit_transform = {k: v for k, v in pms_MiniBatchSparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit_transform = bridgeMiniBatchSparsePCA[${this.id}].fit_transform(**pms_MiniBatchSparsePCA_fit_transform)`;
    return this._py`res_MiniBatchSparsePCA_fit_transform.tolist() if hasattr(res_MiniBatchSparsePCA_fit_transform, 'tolist') else res_MiniBatchSparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchSparsePCA_get_feature_names_out = {k: v for k, v in pms_MiniBatchSparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_feature_names_out = bridgeMiniBatchSparsePCA[${this.id}].get_feature_names_out(**pms_MiniBatchSparsePCA_get_feature_names_out)`;
    return this._py`res_MiniBatchSparsePCA_get_feature_names_out.tolist() if hasattr(res_MiniBatchSparsePCA_get_feature_names_out, 'tolist') else res_MiniBatchSparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchSparsePCA_get_metadata_routing = {k: v for k, v in pms_MiniBatchSparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_metadata_routing = bridgeMiniBatchSparsePCA[${this.id}].get_metadata_routing(**pms_MiniBatchSparsePCA_get_metadata_routing)`;
    return this._py`res_MiniBatchSparsePCA_get_metadata_routing.tolist() if hasattr(res_MiniBatchSparsePCA_get_metadata_routing, 'tolist') else res_MiniBatchSparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_inverse_transform = {k: v for k, v in pms_MiniBatchSparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_inverse_transform = bridgeMiniBatchSparsePCA[${this.id}].inverse_transform(**pms_MiniBatchSparsePCA_inverse_transform)`;
    return this._py`res_MiniBatchSparsePCA_inverse_transform.tolist() if hasattr(res_MiniBatchSparsePCA_inverse_transform, 'tolist') else res_MiniBatchSparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchSparsePCA_set_output = {k: v for k, v in pms_MiniBatchSparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_set_output = bridgeMiniBatchSparsePCA[${this.id}].set_output(**pms_MiniBatchSparsePCA_set_output)`;
    return this._py`res_MiniBatchSparsePCA_set_output.tolist() if hasattr(res_MiniBatchSparsePCA_set_output, 'tolist') else res_MiniBatchSparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_transform = {k: v for k, v in pms_MiniBatchSparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_transform = bridgeMiniBatchSparsePCA[${this.id}].transform(**pms_MiniBatchSparsePCA_transform)`;
    return this._py`res_MiniBatchSparsePCA_transform.tolist() if hasattr(res_MiniBatchSparsePCA_transform, 'tolist') else res_MiniBatchSparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_components_ = bridgeMiniBatchSparsePCA[${this.id}].components_`;
      return this._py`attr_MiniBatchSparsePCA_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_components_, 'tolist') else attr_MiniBatchSparsePCA_components_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_components_ = bridgeMiniBatchSparsePCA[${this.id}].n_components_`;
      return this._py`attr_MiniBatchSparsePCA_n_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_components_, 'tolist') else attr_MiniBatchSparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_iter_ = bridgeMiniBatchSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchSparsePCA_n_iter_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_iter_, 'tolist') else attr_MiniBatchSparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing mean_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_mean_ = bridgeMiniBatchSparsePCA[${this.id}].mean_`;
      return this._py`attr_MiniBatchSparsePCA_mean_.tolist() if hasattr(attr_MiniBatchSparsePCA_mean_, 'tolist') else attr_MiniBatchSparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_features_in_ = bridgeMiniBatchSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchSparsePCA_n_features_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_features_in_, 'tolist') else attr_MiniBatchSparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_feature_names_in_ = bridgeMiniBatchSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchSparsePCA_feature_names_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_feature_names_in_, 'tolist') else attr_MiniBatchSparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/NMF.ts
import crypto10 from "node:crypto";
var NMF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NMF${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import NMF
try: bridgeNMF
except NameError: bridgeNMF = {}
`;
    await this._py.ex`ctor_NMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}}

ctor_NMF = {k: v for k, v in ctor_NMF.items() if v is not None}`;
    await this._py.ex`bridgeNMF[${this.id}] = NMF(**ctor_NMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit()");
    }
    await this._py.ex`pms_NMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_NMF_fit = {k: v for k, v in pms_NMF_fit.items() if v is not None}`;
    await this._py.ex`res_NMF_fit = bridgeNMF[${this.id}].fit(**pms_NMF_fit)`;
    return this._py`res_NMF_fit.tolist() if hasattr(res_NMF_fit, 'tolist') else res_NMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_NMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_NMF_fit_transform = {k: v for k, v in pms_NMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_fit_transform = bridgeNMF[${this.id}].fit_transform(**pms_NMF_fit_transform)`;
    return this._py`res_NMF_fit_transform.tolist() if hasattr(res_NMF_fit_transform, 'tolist') else res_NMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_NMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_NMF_get_feature_names_out = {k: v for k, v in pms_NMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_NMF_get_feature_names_out = bridgeNMF[${this.id}].get_feature_names_out(**pms_NMF_get_feature_names_out)`;
    return this._py`res_NMF_get_feature_names_out.tolist() if hasattr(res_NMF_get_feature_names_out, 'tolist') else res_NMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_NMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NMF_get_metadata_routing = {k: v for k, v in pms_NMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NMF_get_metadata_routing = bridgeNMF[${this.id}].get_metadata_routing(**pms_NMF_get_metadata_routing)`;
    return this._py`res_NMF_get_metadata_routing.tolist() if hasattr(res_NMF_get_metadata_routing, 'tolist') else res_NMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before inverse_transform()");
    }
    await this._py.ex`pms_NMF_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'W': ${opts["W"] ?? void 0}}

pms_NMF_inverse_transform = {k: v for k, v in pms_NMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_inverse_transform = bridgeNMF[${this.id}].inverse_transform(**pms_NMF_inverse_transform)`;
    return this._py`res_NMF_inverse_transform.tolist() if hasattr(res_NMF_inverse_transform, 'tolist') else res_NMF_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before set_output()");
    }
    await this._py.ex`pms_NMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_NMF_set_output = {k: v for k, v in pms_NMF_set_output.items() if v is not None}`;
    await this._py.ex`res_NMF_set_output = bridgeNMF[${this.id}].set_output(**pms_NMF_set_output)`;
    return this._py`res_NMF_set_output.tolist() if hasattr(res_NMF_set_output, 'tolist') else res_NMF_set_output`;
  }
  /**
    Transform the data X according to the fitted NMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before transform()");
    }
    await this._py.ex`pms_NMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NMF_transform = {k: v for k, v in pms_NMF_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_transform = bridgeNMF[${this.id}].transform(**pms_NMF_transform)`;
    return this._py`res_NMF_transform.tolist() if hasattr(res_NMF_transform, 'tolist') else res_NMF_transform`;
  }
  /**
    Factorization matrix, sometimes called ‘dictionary’.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_components_ = bridgeNMF[${this.id}].components_`;
      return this._py`attr_NMF_components_.tolist() if hasattr(attr_NMF_components_, 'tolist') else attr_NMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n\_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_components_ = bridgeNMF[${this.id}].n_components_`;
      return this._py`attr_NMF_n_components_.tolist() if hasattr(attr_NMF_n_components_, 'tolist') else attr_NMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NMF_reconstruction_err_ = bridgeNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_NMF_reconstruction_err_.tolist() if hasattr(attr_NMF_reconstruction_err_, 'tolist') else attr_NMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of iterations.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_iter_ = bridgeNMF[${this.id}].n_iter_`;
      return this._py`attr_NMF_n_iter_.tolist() if hasattr(attr_NMF_n_iter_, 'tolist') else attr_NMF_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_features_in_ = bridgeNMF[${this.id}].n_features_in_`;
      return this._py`attr_NMF_n_features_in_.tolist() if hasattr(attr_NMF_n_features_in_, 'tolist') else attr_NMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_feature_names_in_ = bridgeNMF[${this.id}].feature_names_in_`;
      return this._py`attr_NMF_feature_names_in_.tolist() if hasattr(attr_NMF_feature_names_in_, 'tolist') else attr_NMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/PCA.ts
import crypto11 from "node:crypto";
var PCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PCA${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import PCA
try: bridgePCA
except NameError: bridgePCA = {}
`;
    await this._py.ex`ctor_PCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'svd_solver': ${this.opts["svd_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_PCA = {k: v for k, v in ctor_PCA.items() if v is not None}`;
    await this._py.ex`bridgePCA[${this.id}] = PCA(**ctor_PCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit()");
    }
    await this._py.ex`pms_PCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit = {k: v for k, v in pms_PCA_fit.items() if v is not None}`;
    await this._py.ex`res_PCA_fit = bridgePCA[${this.id}].fit(**pms_PCA_fit)`;
    return this._py`res_PCA_fit.tolist() if hasattr(res_PCA_fit, 'tolist') else res_PCA_fit`;
  }
  /**
    Fit the model with X and apply the dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_PCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit_transform = {k: v for k, v in pms_PCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_fit_transform = bridgePCA[${this.id}].fit_transform(**pms_PCA_fit_transform)`;
    return this._py`res_PCA_fit_transform.tolist() if hasattr(res_PCA_fit_transform, 'tolist') else res_PCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components\_.T \* S\*\*2 \* components\_ + sigma2 \* eye(n\_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_PCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_PCA_get_covariance = {k: v for k, v in pms_PCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_PCA_get_covariance = bridgePCA[${this.id}].get_covariance(**pms_PCA_get_covariance)`;
    return this._py`res_PCA_get_covariance.tolist() if hasattr(res_PCA_get_covariance, 'tolist') else res_PCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_PCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PCA_get_feature_names_out = {k: v for k, v in pms_PCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PCA_get_feature_names_out = bridgePCA[${this.id}].get_feature_names_out(**pms_PCA_get_feature_names_out)`;
    return this._py`res_PCA_get_feature_names_out.tolist() if hasattr(res_PCA_get_feature_names_out, 'tolist') else res_PCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_PCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PCA_get_metadata_routing = {k: v for k, v in pms_PCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PCA_get_metadata_routing = bridgePCA[${this.id}].get_metadata_routing(**pms_PCA_get_metadata_routing)`;
    return this._py`res_PCA_get_metadata_routing.tolist() if hasattr(res_PCA_get_metadata_routing, 'tolist') else res_PCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_precision()");
    }
    await this._py.ex`pms_PCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_PCA_get_precision = {k: v for k, v in pms_PCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_PCA_get_precision = bridgePCA[${this.id}].get_precision(**pms_PCA_get_precision)`;
    return this._py`res_PCA_get_precision.tolist() if hasattr(res_PCA_get_precision, 'tolist') else res_PCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X\_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_PCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_inverse_transform = {k: v for k, v in pms_PCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_inverse_transform = bridgePCA[${this.id}].inverse_transform(**pms_PCA_inverse_transform)`;
    return this._py`res_PCA_inverse_transform.tolist() if hasattr(res_PCA_inverse_transform, 'tolist') else res_PCA_inverse_transform`;
  }
  /**
      Return the average log-likelihood of all samples.
  
      See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score()");
    }
    await this._py.ex`pms_PCA_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_score = {k: v for k, v in pms_PCA_score.items() if v is not None}`;
    await this._py.ex`res_PCA_score = bridgePCA[${this.id}].score(**pms_PCA_score)`;
    return this._py`res_PCA_score.tolist() if hasattr(res_PCA_score, 'tolist') else res_PCA_score`;
  }
  /**
      Return the log-likelihood of each sample.
  
      See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score_samples()");
    }
    await this._py.ex`pms_PCA_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_score_samples = {k: v for k, v in pms_PCA_score_samples.items() if v is not None}`;
    await this._py.ex`res_PCA_score_samples = bridgePCA[${this.id}].score_samples(**pms_PCA_score_samples)`;
    return this._py`res_PCA_score_samples.tolist() if hasattr(res_PCA_score_samples, 'tolist') else res_PCA_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before set_output()");
    }
    await this._py.ex`pms_PCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PCA_set_output = {k: v for k, v in pms_PCA_set_output.items() if v is not None}`;
    await this._py.ex`res_PCA_set_output = bridgePCA[${this.id}].set_output(**pms_PCA_set_output)`;
    return this._py`res_PCA_set_output.tolist() if hasattr(res_PCA_set_output, 'tolist') else res_PCA_set_output`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before transform()");
    }
    await this._py.ex`pms_PCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_transform = {k: v for k, v in pms_PCA_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_transform = bridgePCA[${this.id}].transform(**pms_PCA_transform)`;
    return this._py`res_PCA_transform.tolist() if hasattr(res_PCA_transform, 'tolist') else res_PCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\_variance\_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_components_ = bridgePCA[${this.id}].components_`;
      return this._py`attr_PCA_components_.tolist() if hasattr(attr_PCA_components_, 'tolist') else attr_PCA_components_`;
    })();
  }
  /**
      The amount of variance explained by each of the selected components. The variance estimation uses `n\_samples \- 1` degrees of freedom.
  
      Equal to n\_components largest eigenvalues of the covariance matrix of X.
     */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ = bridgePCA[${this.id}].explained_variance_`;
      return this._py`attr_PCA_explained_variance_.tolist() if hasattr(attr_PCA_explained_variance_, 'tolist') else attr_PCA_explained_variance_`;
    })();
  }
  /**
      Percentage of variance explained by each of the selected components.
  
      If `n\_components` is not set then all components are stored and the sum of the ratios is equal to 1.0.
     */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ratio_ = bridgePCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_PCA_explained_variance_ratio_.tolist() if hasattr(attr_PCA_explained_variance_ratio_, 'tolist') else attr_PCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing singular_values_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_singular_values_ = bridgePCA[${this.id}].singular_values_`;
      return this._py`attr_PCA_singular_values_.tolist() if hasattr(attr_PCA_singular_values_, 'tolist') else attr_PCA_singular_values_`;
    })();
  }
  /**
      Per-feature empirical mean, estimated from the training set.
  
      Equal to `X.mean(axis=0)`.
     */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_mean_ = bridgePCA[${this.id}].mean_`;
      return this._py`attr_PCA_mean_.tolist() if hasattr(attr_PCA_mean_, 'tolist') else attr_PCA_mean_`;
    })();
  }
  /**
    The estimated number of components. When n\_components is set to ‘mle’ or a number between 0 and 1 (with svd\_solver == ‘full’) this number is estimated from input data. Otherwise it equals the parameter n\_components, or the lesser value of n\_features and n\_samples if n\_components is `undefined`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_components_ = bridgePCA[${this.id}].n_components_`;
      return this._py`attr_PCA_n_components_.tolist() if hasattr(attr_PCA_n_components_, 'tolist') else attr_PCA_n_components_`;
    })();
  }
  /**
    Number of features in the training data.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_features_ = bridgePCA[${this.id}].n_features_`;
      return this._py`attr_PCA_n_features_.tolist() if hasattr(attr_PCA_n_features_, 'tolist') else attr_PCA_n_features_`;
    })();
  }
  /**
    Number of samples in the training data.
   */
  get n_samples_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_samples_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_samples_ = bridgePCA[${this.id}].n_samples_`;
      return this._py`attr_PCA_n_samples_.tolist() if hasattr(attr_PCA_n_samples_, 'tolist') else attr_PCA_n_samples_`;
    })();
  }
  /**
      The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf). It is required to compute the estimated data covariance and score samples.
  
      Equal to the average of (min(n\_features, n\_samples) - n\_components) smallest eigenvalues of the covariance matrix of X.
     */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing noise_variance_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_noise_variance_ = bridgePCA[${this.id}].noise_variance_`;
      return this._py`attr_PCA_noise_variance_.tolist() if hasattr(attr_PCA_noise_variance_, 'tolist') else attr_PCA_noise_variance_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_features_in_ = bridgePCA[${this.id}].n_features_in_`;
      return this._py`attr_PCA_n_features_in_.tolist() if hasattr(attr_PCA_n_features_in_, 'tolist') else attr_PCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_feature_names_in_ = bridgePCA[${this.id}].feature_names_in_`;
      return this._py`attr_PCA_feature_names_in_.tolist() if hasattr(attr_PCA_feature_names_in_, 'tolist') else attr_PCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparseCoder.ts
import crypto12 from "node:crypto";
var SparseCoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SparseCoder${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparseCoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparseCoder
try: bridgeSparseCoder
except NameError: bridgeSparseCoder = {}
`;
    await this._py.ex`ctor_SparseCoder = {'dictionary': np.array(${this.opts["dictionary"] ?? void 0}) if ${this.opts["dictionary"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_SparseCoder = {k: v for k, v in ctor_SparseCoder.items() if v is not None}`;
    await this._py.ex`bridgeSparseCoder[${this.id}] = SparseCoder(**ctor_SparseCoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparseCoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Do nothing and return the estimator unchanged.
  
      This method is just there to implement the usual API and hence work in pipelines.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit()");
    }
    await this._py.ex`pms_SparseCoder_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_fit = {k: v for k, v in pms_SparseCoder_fit.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit = bridgeSparseCoder[${this.id}].fit(**pms_SparseCoder_fit)`;
    return this._py`res_SparseCoder_fit.tolist() if hasattr(res_SparseCoder_fit, 'tolist') else res_SparseCoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparseCoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparseCoder_fit_transform = {k: v for k, v in pms_SparseCoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit_transform = bridgeSparseCoder[${this.id}].fit_transform(**pms_SparseCoder_fit_transform)`;
    return this._py`res_SparseCoder_fit_transform.tolist() if hasattr(res_SparseCoder_fit_transform, 'tolist') else res_SparseCoder_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparseCoder_get_feature_names_out = {k: v for k, v in pms_SparseCoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_feature_names_out = bridgeSparseCoder[${this.id}].get_feature_names_out(**pms_SparseCoder_get_feature_names_out)`;
    return this._py`res_SparseCoder_get_feature_names_out.tolist() if hasattr(res_SparseCoder_get_feature_names_out, 'tolist') else res_SparseCoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparseCoder_get_metadata_routing = {k: v for k, v in pms_SparseCoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_metadata_routing = bridgeSparseCoder[${this.id}].get_metadata_routing(**pms_SparseCoder_get_metadata_routing)`;
    return this._py`res_SparseCoder_get_metadata_routing.tolist() if hasattr(res_SparseCoder_get_metadata_routing, 'tolist') else res_SparseCoder_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before set_output()");
    }
    await this._py.ex`pms_SparseCoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparseCoder_set_output = {k: v for k, v in pms_SparseCoder_set_output.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_set_output = bridgeSparseCoder[${this.id}].set_output(**pms_SparseCoder_set_output)`;
    return this._py`res_SparseCoder_set_output.tolist() if hasattr(res_SparseCoder_set_output, 'tolist') else res_SparseCoder_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before transform()");
    }
    await this._py.ex`pms_SparseCoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_transform = {k: v for k, v in pms_SparseCoder_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_transform = bridgeSparseCoder[${this.id}].transform(**pms_SparseCoder_transform)`;
    return this._py`res_SparseCoder_transform.tolist() if hasattr(res_SparseCoder_transform, 'tolist') else res_SparseCoder_transform`;
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseCoder_feature_names_in_ = bridgeSparseCoder[${this.id}].feature_names_in_`;
      return this._py`attr_SparseCoder_feature_names_in_.tolist() if hasattr(attr_SparseCoder_feature_names_in_, 'tolist') else attr_SparseCoder_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparsePCA.ts
import crypto13 from "node:crypto";
var SparsePCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SparsePCA${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparsePCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparsePCA
try: bridgeSparsePCA
except NameError: bridgeSparsePCA = {}
`;
    await this._py.ex`ctor_SparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'U_init': np.array(${this.opts["U_init"] ?? void 0}) if ${this.opts["U_init"] !== void 0} else None, 'V_init': np.array(${this.opts["V_init"] ?? void 0}) if ${this.opts["V_init"] !== void 0} else None, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SparsePCA = {k: v for k, v in ctor_SparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeSparsePCA[${this.id}] = SparsePCA(**ctor_SparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_SparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparsePCA_fit = {k: v for k, v in pms_SparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit = bridgeSparsePCA[${this.id}].fit(**pms_SparsePCA_fit)`;
    return this._py`res_SparsePCA_fit.tolist() if hasattr(res_SparsePCA_fit, 'tolist') else res_SparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparsePCA_fit_transform = {k: v for k, v in pms_SparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit_transform = bridgeSparsePCA[${this.id}].fit_transform(**pms_SparsePCA_fit_transform)`;
    return this._py`res_SparsePCA_fit_transform.tolist() if hasattr(res_SparsePCA_fit_transform, 'tolist') else res_SparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparsePCA_get_feature_names_out = {k: v for k, v in pms_SparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_feature_names_out = bridgeSparsePCA[${this.id}].get_feature_names_out(**pms_SparsePCA_get_feature_names_out)`;
    return this._py`res_SparsePCA_get_feature_names_out.tolist() if hasattr(res_SparsePCA_get_feature_names_out, 'tolist') else res_SparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparsePCA_get_metadata_routing = {k: v for k, v in pms_SparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_metadata_routing = bridgeSparsePCA[${this.id}].get_metadata_routing(**pms_SparsePCA_get_metadata_routing)`;
    return this._py`res_SparsePCA_get_metadata_routing.tolist() if hasattr(res_SparsePCA_get_metadata_routing, 'tolist') else res_SparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_inverse_transform = {k: v for k, v in pms_SparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_inverse_transform = bridgeSparsePCA[${this.id}].inverse_transform(**pms_SparsePCA_inverse_transform)`;
    return this._py`res_SparsePCA_inverse_transform.tolist() if hasattr(res_SparsePCA_inverse_transform, 'tolist') else res_SparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_SparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparsePCA_set_output = {k: v for k, v in pms_SparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_set_output = bridgeSparsePCA[${this.id}].set_output(**pms_SparsePCA_set_output)`;
    return this._py`res_SparsePCA_set_output.tolist() if hasattr(res_SparsePCA_set_output, 'tolist') else res_SparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_SparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_transform = {k: v for k, v in pms_SparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_transform = bridgeSparsePCA[${this.id}].transform(**pms_SparsePCA_transform)`;
    return this._py`res_SparsePCA_transform.tolist() if hasattr(res_SparsePCA_transform, 'tolist') else res_SparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_components_ = bridgeSparsePCA[${this.id}].components_`;
      return this._py`attr_SparsePCA_components_.tolist() if hasattr(attr_SparsePCA_components_, 'tolist') else attr_SparsePCA_components_`;
    })();
  }
  /**
    Vector of errors at each iteration.
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing error_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_error_ = bridgeSparsePCA[${this.id}].error_`;
      return this._py`attr_SparsePCA_error_.tolist() if hasattr(attr_SparsePCA_error_, 'tolist') else attr_SparsePCA_error_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_components_ = bridgeSparsePCA[${this.id}].n_components_`;
      return this._py`attr_SparsePCA_n_components_.tolist() if hasattr(attr_SparsePCA_n_components_, 'tolist') else attr_SparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_iter_ = bridgeSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_SparsePCA_n_iter_.tolist() if hasattr(attr_SparsePCA_n_iter_, 'tolist') else attr_SparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_mean_ = bridgeSparsePCA[${this.id}].mean_`;
      return this._py`attr_SparsePCA_mean_.tolist() if hasattr(attr_SparsePCA_mean_, 'tolist') else attr_SparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_features_in_ = bridgeSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_SparsePCA_n_features_in_.tolist() if hasattr(attr_SparsePCA_n_features_in_, 'tolist') else attr_SparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_feature_names_in_ = bridgeSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_SparsePCA_feature_names_in_.tolist() if hasattr(attr_SparsePCA_feature_names_in_, 'tolist') else attr_SparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/TruncatedSVD.ts
import crypto14 from "node:crypto";
var TruncatedSVD = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TruncatedSVD${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TruncatedSVD.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import TruncatedSVD
try: bridgeTruncatedSVD
except NameError: bridgeTruncatedSVD = {}
`;
    await this._py.ex`ctor_TruncatedSVD = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_TruncatedSVD = {k: v for k, v in ctor_TruncatedSVD.items() if v is not None}`;
    await this._py.ex`bridgeTruncatedSVD[${this.id}] = TruncatedSVD(**ctor_TruncatedSVD)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTruncatedSVD[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model on training data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit()");
    }
    await this._py.ex`pms_TruncatedSVD_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit = {k: v for k, v in pms_TruncatedSVD_fit.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit = bridgeTruncatedSVD[${this.id}].fit(**pms_TruncatedSVD_fit)`;
    return this._py`res_TruncatedSVD_fit.tolist() if hasattr(res_TruncatedSVD_fit, 'tolist') else res_TruncatedSVD_fit`;
  }
  /**
    Fit model to X and perform dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit_transform()");
    }
    await this._py.ex`pms_TruncatedSVD_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit_transform = {k: v for k, v in pms_TruncatedSVD_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit_transform = bridgeTruncatedSVD[${this.id}].fit_transform(**pms_TruncatedSVD_fit_transform)`;
    return this._py`res_TruncatedSVD_fit_transform.tolist() if hasattr(res_TruncatedSVD_fit_transform, 'tolist') else res_TruncatedSVD_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TruncatedSVD_get_feature_names_out = {k: v for k, v in pms_TruncatedSVD_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_feature_names_out = bridgeTruncatedSVD[${this.id}].get_feature_names_out(**pms_TruncatedSVD_get_feature_names_out)`;
    return this._py`res_TruncatedSVD_get_feature_names_out.tolist() if hasattr(res_TruncatedSVD_get_feature_names_out, 'tolist') else res_TruncatedSVD_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TruncatedSVD_get_metadata_routing = {k: v for k, v in pms_TruncatedSVD_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_metadata_routing = bridgeTruncatedSVD[${this.id}].get_metadata_routing(**pms_TruncatedSVD_get_metadata_routing)`;
    return this._py`res_TruncatedSVD_get_metadata_routing.tolist() if hasattr(res_TruncatedSVD_get_metadata_routing, 'tolist') else res_TruncatedSVD_get_metadata_routing`;
  }
  /**
      Transform X back to its original space.
  
      Returns an array X\_original whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_inverse_transform = {k: v for k, v in pms_TruncatedSVD_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_inverse_transform = bridgeTruncatedSVD[${this.id}].inverse_transform(**pms_TruncatedSVD_inverse_transform)`;
    return this._py`res_TruncatedSVD_inverse_transform.tolist() if hasattr(res_TruncatedSVD_inverse_transform, 'tolist') else res_TruncatedSVD_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before set_output()");
    }
    await this._py.ex`pms_TruncatedSVD_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TruncatedSVD_set_output = {k: v for k, v in pms_TruncatedSVD_set_output.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_set_output = bridgeTruncatedSVD[${this.id}].set_output(**pms_TruncatedSVD_set_output)`;
    return this._py`res_TruncatedSVD_set_output.tolist() if hasattr(res_TruncatedSVD_set_output, 'tolist') else res_TruncatedSVD_set_output`;
  }
  /**
    Perform dimensionality reduction on X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before transform()");
    }
    await this._py.ex`pms_TruncatedSVD_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_transform = {k: v for k, v in pms_TruncatedSVD_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_transform = bridgeTruncatedSVD[${this.id}].transform(**pms_TruncatedSVD_transform)`;
    return this._py`res_TruncatedSVD_transform.tolist() if hasattr(res_TruncatedSVD_transform, 'tolist') else res_TruncatedSVD_transform`;
  }
  /**
    The right singular vectors of the input data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_components_ = bridgeTruncatedSVD[${this.id}].components_`;
      return this._py`attr_TruncatedSVD_components_.tolist() if hasattr(attr_TruncatedSVD_components_, 'tolist') else attr_TruncatedSVD_components_`;
    })();
  }
  /**
    The variance of the training samples transformed by a projection to each component.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ = bridgeTruncatedSVD[${this.id}].explained_variance_`;
      return this._py`attr_TruncatedSVD_explained_variance_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_, 'tolist') else attr_TruncatedSVD_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ratio_ = bridgeTruncatedSVD[${this.id}].explained_variance_ratio_`;
      return this._py`attr_TruncatedSVD_explained_variance_ratio_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_ratio_, 'tolist') else attr_TruncatedSVD_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_singular_values_ = bridgeTruncatedSVD[${this.id}].singular_values_`;
      return this._py`attr_TruncatedSVD_singular_values_.tolist() if hasattr(attr_TruncatedSVD_singular_values_, 'tolist') else attr_TruncatedSVD_singular_values_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_n_features_in_ = bridgeTruncatedSVD[${this.id}].n_features_in_`;
      return this._py`attr_TruncatedSVD_n_features_in_.tolist() if hasattr(attr_TruncatedSVD_n_features_in_, 'tolist') else attr_TruncatedSVD_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_feature_names_in_ = bridgeTruncatedSVD[${this.id}].feature_names_in_`;
      return this._py`attr_TruncatedSVD_feature_names_in_.tolist() if hasattr(attr_TruncatedSVD_feature_names_in_, 'tolist') else attr_TruncatedSVD_feature_names_in_`;
    })();
  }
};
export {
  DictionaryLearning,
  FactorAnalysis,
  FastICA,
  IncrementalPCA,
  KernelPCA,
  LatentDirichletAllocation,
  MiniBatchDictionaryLearning,
  MiniBatchNMF,
  MiniBatchSparsePCA,
  NMF,
  PCA,
  SparseCoder,
  SparsePCA,
  TruncatedSVD
};
//# sourceMappingURL=index.js.map