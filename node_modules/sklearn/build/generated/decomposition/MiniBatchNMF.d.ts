import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Mini-Batch Non-Negative Matrix Factorization (NMF).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.MiniBatchNMF.html)
 */
export declare class MiniBatchNMF {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          Number of components, if `n\_components` is not set all features are kept.
         */
        n_components?: number;
        /**
          Method used to initialize the procedure. Valid options:
         */
        init?: 'random' | 'nndsvd' | 'nndsvda' | 'nndsvdar' | 'custom';
        /**
          Number of samples in each mini-batch. Large batch sizes give better long-term convergence at the cost of a slower start.
    
          @defaultValue `1024`
         */
        batch_size?: number;
        /**
          Beta divergence to be minimized, measuring the distance between `X` and the dot product `WH`. Note that values different from ‘frobenius’ (or 2) and ‘kullback-leibler’ (or 1) lead to significantly slower fits. Note that for `beta\_loss <= 0` (or ‘itakura-saito’), the input matrix `X` cannot contain zeros.
    
          @defaultValue `'frobenius'`
         */
        beta_loss?: number | 'frobenius' | 'kullback-leibler' | 'itakura-saito';
        /**
          Control early stopping based on the norm of the differences in `H` between 2 steps. To disable early stopping based on changes in `H`, set `tol` to 0.0.
    
          @defaultValue `0.0001`
         */
        tol?: number;
        /**
          Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. To disable convergence detection based on cost function, set `max\_no\_improvement` to `undefined`.
    
          @defaultValue `10`
         */
        max_no_improvement?: number;
        /**
          Maximum number of iterations over the complete dataset before timing out.
    
          @defaultValue `200`
         */
        max_iter?: number;
        /**
          Constant that multiplies the regularization terms of `W`. Set it to zero (default) to have no regularization on `W`.
    
          @defaultValue `0`
         */
        alpha_W?: number;
        /**
          Constant that multiplies the regularization terms of `H`. Set it to zero to have no regularization on `H`. If “same” (default), it takes the same value as `alpha\_W`.
    
          @defaultValue `'same'`
         */
        alpha_H?: number | 'same';
        /**
          The regularization mixing parameter, with 0 <= l1\_ratio <= 1. For l1\_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1\_ratio = 1 it is an elementwise L1 penalty. For 0 < l1\_ratio < 1, the penalty is a combination of L1 and L2.
    
          @defaultValue `0`
         */
        l1_ratio?: number;
        /**
          Amount of rescaling of past information. Its value could be 1 with finite datasets. Choosing values < 1 is recommended with online learning as more recent batches will weight more than past batches.
    
          @defaultValue `0.7`
         */
        forget_factor?: number;
        /**
          Whether to completely solve for W at each step. Doing fresh restarts will likely lead to a better solution for a same number of iterations but it is much slower.
    
          @defaultValue `false`
         */
        fresh_restarts?: boolean;
        /**
          Maximum number of iterations when solving for W at each step. Only used when doing fresh restarts. These iterations may be stopped early based on a small change of W controlled by `tol`.
    
          @defaultValue `30`
         */
        fresh_restarts_max_iter?: number;
        /**
          Maximum number of iterations when solving for W at transform time. If `undefined`, it defaults to `max\_iter`.
         */
        transform_max_iter?: number;
        /**
          Used for initialisation (when `init` == ‘nndsvdar’ or ‘random’), and in Coordinate Descent. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
        /**
          Whether to be verbose.
    
          @defaultValue `false`
         */
        verbose?: boolean;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Learn a NMF model for the data X.
     */
    fit(opts: {
        /**
          Training vector, where `n\_samples` is the number of samples and `n\_features` is the number of features.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present for API consistency by convention.
         */
        y?: any;
        /**
          Parameters (keyword arguments) and values passed to the fit\_transform instance.
         */
        params?: any;
    }): Promise<any>;
    /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
    fit_transform(opts: {
        /**
          Data matrix to be decomposed.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
        /**
          If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.
         */
        W?: ArrayLike[];
        /**
          If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.
         */
        H?: ArrayLike[];
    }): Promise<NDArray[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
    get_feature_names_out(opts: {
        /**
          Only used to validate feature names with the names seen in `fit`.
         */
        input_features?: any;
    }): Promise<any>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Transform data back to its original space.
     */
    inverse_transform(opts: {
        /**
          Transformed data matrix.
         */
        Xt?: NDArray | SparseMatrix[];
        /**
          Use `Xt` instead.
         */
        W?: any;
    }): Promise<NDArray | SparseMatrix[]>;
    /**
      Update the model using the data in `X` as a mini-batch.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once (see [Strategies to scale computationally: bigger data](../../computing/scaling_strategies.html#scaling-strategies)).
     */
    partial_fit(opts: {
        /**
          Data matrix to be decomposed.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
        /**
          If `init='custom'`, it is used as initial guess for the solution. Only used for the first call to `partial\_fit`.
         */
        W?: ArrayLike[];
        /**
          If `init='custom'`, it is used as initial guess for the solution. Only used for the first call to `partial\_fit`.
         */
        H?: ArrayLike[];
    }): Promise<any>;
    /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
    set_output(opts: {
        /**
          Configure output of `transform` and `fit\_transform`.
         */
        transform?: 'default' | 'pandas';
    }): Promise<any>;
    /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
    set_partial_fit_request(opts: {
        /**
          Metadata routing for `H` parameter in `partial\_fit`.
         */
        H?: string | boolean;
        /**
          Metadata routing for `W` parameter in `partial\_fit`.
         */
        W?: string | boolean;
    }): Promise<any>;
    /**
      Transform the data X according to the fitted MiniBatchNMF model.
     */
    transform(opts: {
        /**
          Data matrix to be transformed by the model.
         */
        X?: ArrayLike | SparseMatrix[];
    }): Promise<NDArray[]>;
    /**
      Factorization matrix, sometimes called ‘dictionary’.
     */
    get components_(): Promise<NDArray[]>;
    /**
      The number of components. It is same as the `n\_components` parameter if it was given. Otherwise, it will be same as the number of features.
     */
    get n_components_(): Promise<number>;
    /**
      Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
     */
    get reconstruction_err_(): Promise<number>;
    /**
      Actual number of started iterations over the whole dataset.
     */
    get n_iter_(): Promise<number>;
    /**
      Number of mini-batches processed.
     */
    get n_steps_(): Promise<number>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=MiniBatchNMF.d.ts.map