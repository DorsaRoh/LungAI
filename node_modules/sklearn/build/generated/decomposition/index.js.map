{"version":3,"sources":["../../../src/generated/decomposition/DictionaryLearning.ts","../../../src/generated/decomposition/FactorAnalysis.ts","../../../src/generated/decomposition/FastICA.ts","../../../src/generated/decomposition/IncrementalPCA.ts","../../../src/generated/decomposition/KernelPCA.ts","../../../src/generated/decomposition/LatentDirichletAllocation.ts","../../../src/generated/decomposition/MiniBatchDictionaryLearning.ts","../../../src/generated/decomposition/MiniBatchNMF.ts","../../../src/generated/decomposition/MiniBatchSparsePCA.ts","../../../src/generated/decomposition/NMF.ts","../../../src/generated/decomposition/PCA.ts","../../../src/generated/decomposition/SparseCoder.ts","../../../src/generated/decomposition/SparsePCA.ts","../../../src/generated/decomposition/TruncatedSVD.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Dictionary learning.\n\n  Finds a dictionary (a set of atoms) that performs well at sparsely encoding the fitted data.\n\n  Solves the optimization problem:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.DictionaryLearning.html)\n */\nexport class DictionaryLearning {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of dictionary elements to extract. If `undefined`, then `n\\_components` is set to `n\\_features`.\n     */\n    n_components?: number\n\n    /**\n      Sparsity controlling parameter.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Maximum number of iterations to perform.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      Tolerance for numerical error.\n\n      @defaultValue `1e-8`\n     */\n    tol?: number\n\n    /**\n      `'lars'`: uses the least angle regression method to solve the lasso problem ([`lars\\_path`](sklearn.linear_model.lars_path.html#sklearn.linear_model.lars_path \"sklearn.linear_model.lars_path\"));\n\n      @defaultValue `'lars'`\n     */\n    fit_algorithm?: 'lars' | 'cd'\n\n    /**\n      Algorithm used to transform the data:\n\n      @defaultValue `'omp'`\n     */\n    transform_algorithm?:\n      | 'lasso_lars'\n      | 'lasso_cd'\n      | 'lars'\n      | 'omp'\n      | 'threshold'\n\n    /**\n      Number of nonzero coefficients to target in each column of the solution. This is only used by `algorithm='lars'` and `algorithm='omp'`. If `undefined`, then `transform\\_n\\_nonzero\\_coefs=int(n\\_features / 10)`.\n     */\n    transform_n_nonzero_coefs?: number\n\n    /**\n      If `algorithm='lasso\\_lars'` or `algorithm='lasso\\_cd'`, `alpha` is the penalty applied to the L1 norm. If `algorithm='threshold'`, `alpha` is the absolute value of the threshold below which coefficients will be squashed to zero. If `undefined`, defaults to `alpha`.\n     */\n    transform_alpha?: number\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Initial value for the code, for warm restart. Only used if `code\\_init` and `dict\\_init` are not `undefined`.\n     */\n    code_init?: NDArray[]\n\n    /**\n      Initial values for the dictionary, for warm restart. Only used if `code\\_init` and `dict\\_init` are not `undefined`.\n     */\n    dict_init?: NDArray[]\n\n    /**\n      Callable that gets invoked every five iterations.\n     */\n    callback?: any\n\n    /**\n      To control the verbosity of the procedure.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.\n\n      @defaultValue `false`\n     */\n    split_sign?: boolean\n\n    /**\n      Used for initializing the dictionary when `dict\\_init` is not specified, randomly shuffling the data when `shuffle` is set to `true`, and updating the dictionary. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Whether to enforce positivity when finding the code.\n\n      @defaultValue `false`\n     */\n    positive_code?: boolean\n\n    /**\n      Whether to enforce positivity when finding the dictionary.\n\n      @defaultValue `false`\n     */\n    positive_dict?: boolean\n\n    /**\n      Maximum number of iterations to perform if `algorithm='lasso\\_cd'` or `'lasso\\_lars'`.\n\n      @defaultValue `1000`\n     */\n    transform_max_iter?: number\n  }) {\n    this.id = `DictionaryLearning${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'DictionaryLearning.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import DictionaryLearning\ntry: bridgeDictionaryLearning\nexcept NameError: bridgeDictionaryLearning = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_DictionaryLearning = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'fit_algorithm': ${\n      this.opts['fit_algorithm'] ?? undefined\n    }, 'transform_algorithm': ${\n      this.opts['transform_algorithm'] ?? undefined\n    }, 'transform_n_nonzero_coefs': ${\n      this.opts['transform_n_nonzero_coefs'] ?? undefined\n    }, 'transform_alpha': ${\n      this.opts['transform_alpha'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'code_init': np.array(${\n      this.opts['code_init'] ?? undefined\n    }) if ${\n      this.opts['code_init'] !== undefined\n    } else None, 'dict_init': np.array(${\n      this.opts['dict_init'] ?? undefined\n    }) if ${this.opts['dict_init'] !== undefined} else None, 'callback': ${\n      this.opts['callback'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'split_sign': ${\n      this.opts['split_sign'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'positive_code': ${\n      this.opts['positive_code'] ?? undefined\n    }, 'positive_dict': ${\n      this.opts['positive_dict'] ?? undefined\n    }, 'transform_max_iter': ${this.opts['transform_max_iter'] ?? undefined}}\n\nctor_DictionaryLearning = {k: v for k, v in ctor_DictionaryLearning.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeDictionaryLearning[${this.id}] = DictionaryLearning(**ctor_DictionaryLearning)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeDictionaryLearning[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DictionaryLearning must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DictionaryLearning_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_DictionaryLearning_fit = {k: v for k, v in pms_DictionaryLearning_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_fit = bridgeDictionaryLearning[${this.id}].fit(**pms_DictionaryLearning_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_fit.tolist() if hasattr(res_DictionaryLearning_fit, 'tolist') else res_DictionaryLearning_fit`\n  }\n\n  /**\n    Fit the model from data in X and return the transformed data.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_DictionaryLearning_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_DictionaryLearning_fit_transform = {k: v for k, v in pms_DictionaryLearning_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_fit_transform = bridgeDictionaryLearning[${this.id}].fit_transform(**pms_DictionaryLearning_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_fit_transform.tolist() if hasattr(res_DictionaryLearning_fit_transform, 'tolist') else res_DictionaryLearning_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_DictionaryLearning_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_DictionaryLearning_get_feature_names_out = {k: v for k, v in pms_DictionaryLearning_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_get_feature_names_out = bridgeDictionaryLearning[${this.id}].get_feature_names_out(**pms_DictionaryLearning_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_get_feature_names_out.tolist() if hasattr(res_DictionaryLearning_get_feature_names_out, 'tolist') else res_DictionaryLearning_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_DictionaryLearning_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_DictionaryLearning_get_metadata_routing = {k: v for k, v in pms_DictionaryLearning_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_get_metadata_routing = bridgeDictionaryLearning[${this.id}].get_metadata_routing(**pms_DictionaryLearning_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_get_metadata_routing.tolist() if hasattr(res_DictionaryLearning_get_metadata_routing, 'tolist') else res_DictionaryLearning_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DictionaryLearning must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DictionaryLearning_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_DictionaryLearning_set_output = {k: v for k, v in pms_DictionaryLearning_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_set_output = bridgeDictionaryLearning[${this.id}].set_output(**pms_DictionaryLearning_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_set_output.tolist() if hasattr(res_DictionaryLearning_set_output, 'tolist') else res_DictionaryLearning_set_output`\n  }\n\n  /**\n    Encode the data as a sparse combination of the dictionary atoms.\n\n    Coding method is determined by the object parameter `transform\\_algorithm`.\n   */\n  async transform(opts: {\n    /**\n      Test data to be transformed, must have the same number of features as the data used to train the model.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DictionaryLearning must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DictionaryLearning_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_DictionaryLearning_transform = {k: v for k, v in pms_DictionaryLearning_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DictionaryLearning_transform = bridgeDictionaryLearning[${this.id}].transform(**pms_DictionaryLearning_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DictionaryLearning_transform.tolist() if hasattr(res_DictionaryLearning_transform, 'tolist') else res_DictionaryLearning_transform`\n  }\n\n  /**\n    dictionary atoms extracted from the data\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DictionaryLearning_components_ = bridgeDictionaryLearning[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DictionaryLearning_components_.tolist() if hasattr(attr_DictionaryLearning_components_, 'tolist') else attr_DictionaryLearning_components_`\n    })()\n  }\n\n  /**\n    vector of errors at each iteration\n   */\n  get error_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before accessing error_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DictionaryLearning_error_ = bridgeDictionaryLearning[${this.id}].error_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DictionaryLearning_error_.tolist() if hasattr(attr_DictionaryLearning_error_, 'tolist') else attr_DictionaryLearning_error_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DictionaryLearning_n_features_in_ = bridgeDictionaryLearning[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DictionaryLearning_n_features_in_.tolist() if hasattr(attr_DictionaryLearning_n_features_in_, 'tolist') else attr_DictionaryLearning_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DictionaryLearning_feature_names_in_ = bridgeDictionaryLearning[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DictionaryLearning_feature_names_in_.tolist() if hasattr(attr_DictionaryLearning_feature_names_in_, 'tolist') else attr_DictionaryLearning_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This DictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DictionaryLearning must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DictionaryLearning_n_iter_ = bridgeDictionaryLearning[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DictionaryLearning_n_iter_.tolist() if hasattr(attr_DictionaryLearning_n_iter_, 'tolist') else attr_DictionaryLearning_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Factor Analysis (FA).\n\n  A simple linear generative model with Gaussian latent variables.\n\n  The observations are assumed to be caused by a linear transformation of lower dimensional latent factors and added Gaussian noise. Without loss of generality the factors are distributed according to a Gaussian with zero mean and unit covariance. The noise is also zero mean and has an arbitrary diagonal covariance matrix.\n\n  If we would restrict the model further, by assuming that the Gaussian noise is even isotropic (all diagonal entries are the same) we would obtain [`PCA`](sklearn.decomposition.PCA.html#sklearn.decomposition.PCA \"sklearn.decomposition.PCA\").\n\n  FactorAnalysis performs a maximum likelihood estimate of the so-called `loading` matrix, the transformation of the latent variables to the observed ones, using SVD based approach.\n\n  Read more in the [User Guide](../decomposition.html#fa).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FactorAnalysis.html)\n */\nexport class FactorAnalysis {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Dimensionality of latent space, the number of components of `X` that are obtained after `transform`. If `undefined`, n\\_components is set to the number of features.\n     */\n    n_components?: number\n\n    /**\n      Stopping tolerance for log-likelihood increase.\n\n      @defaultValue `0.01`\n     */\n    tol?: number\n\n    /**\n      Whether to make a copy of X. If `false`, the input X gets overwritten during fitting.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      Maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The initial guess of the noise variance for each feature. If `undefined`, it defaults to np.ones(n\\_features).\n     */\n    noise_variance_init?: ArrayLike\n\n    /**\n      Which SVD method to use. If ‘lapack’ use standard SVD from scipy.linalg, if ‘randomized’ use fast `randomized\\_svd` function. Defaults to ‘randomized’. For most applications ‘randomized’ will be sufficiently precise while providing significant speed gains. Accuracy can also be improved by setting higher values for `iterated\\_power`. If this is not sufficient, for maximum precision you should choose ‘lapack’.\n\n      @defaultValue `'randomized'`\n     */\n    svd_method?: 'lapack' | 'randomized'\n\n    /**\n      Number of iterations for the power method. 3 by default. Only used if `svd\\_method` equals ‘randomized’.\n\n      @defaultValue `3`\n     */\n    iterated_power?: number\n\n    /**\n      If not `undefined`, apply the indicated rotation. Currently, varimax and quartimax are implemented. See [“The varimax criterion for analytic rotation in factor analysis”](https://link.springer.com/article/10.1007%2FBF02289233) H. F. Kaiser, 1958.\n     */\n    rotation?: 'varimax' | 'quartimax'\n\n    /**\n      Only used when `svd\\_method` equals ‘randomized’. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n\n      @defaultValue `0`\n     */\n    random_state?: number\n  }) {\n    this.id = `FactorAnalysis${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('FactorAnalysis.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import FactorAnalysis\ntry: bridgeFactorAnalysis\nexcept NameError: bridgeFactorAnalysis = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_FactorAnalysis = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'noise_variance_init': np.array(${\n      this.opts['noise_variance_init'] ?? undefined\n    }) if ${\n      this.opts['noise_variance_init'] !== undefined\n    } else None, 'svd_method': ${\n      this.opts['svd_method'] ?? undefined\n    }, 'iterated_power': ${\n      this.opts['iterated_power'] ?? undefined\n    }, 'rotation': ${this.opts['rotation'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_FactorAnalysis = {k: v for k, v in ctor_FactorAnalysis.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeFactorAnalysis[${this.id}] = FactorAnalysis(**ctor_FactorAnalysis)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeFactorAnalysis[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the FactorAnalysis model to X using SVD based approach.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored parameter.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FactorAnalysis_fit = {k: v for k, v in pms_FactorAnalysis_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_fit = bridgeFactorAnalysis[${this.id}].fit(**pms_FactorAnalysis_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_fit.tolist() if hasattr(res_FactorAnalysis_fit, 'tolist') else res_FactorAnalysis_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_FactorAnalysis_fit_transform = {k: v for k, v in pms_FactorAnalysis_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_fit_transform = bridgeFactorAnalysis[${this.id}].fit_transform(**pms_FactorAnalysis_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_fit_transform.tolist() if hasattr(res_FactorAnalysis_fit_transform, 'tolist') else res_FactorAnalysis_fit_transform`\n  }\n\n  /**\n    Compute data covariance with the FactorAnalysis model.\n\n    `cov \\= components\\_.T \\* components\\_ + diag(noise\\_variance)`\n   */\n  async get_covariance(opts: {\n    /**\n      Estimated covariance of data.\n     */\n    cov?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before get_covariance()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_get_covariance = {'cov': np.array(${\n      opts['cov'] ?? undefined\n    }) if ${opts['cov'] !== undefined} else None}\n\npms_FactorAnalysis_get_covariance = {k: v for k, v in pms_FactorAnalysis_get_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_get_covariance = bridgeFactorAnalysis[${this.id}].get_covariance(**pms_FactorAnalysis_get_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_get_covariance.tolist() if hasattr(res_FactorAnalysis_get_covariance, 'tolist') else res_FactorAnalysis_get_covariance`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FactorAnalysis_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_FactorAnalysis_get_feature_names_out = {k: v for k, v in pms_FactorAnalysis_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_get_feature_names_out = bridgeFactorAnalysis[${this.id}].get_feature_names_out(**pms_FactorAnalysis_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_get_feature_names_out.tolist() if hasattr(res_FactorAnalysis_get_feature_names_out, 'tolist') else res_FactorAnalysis_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_FactorAnalysis_get_metadata_routing = {k: v for k, v in pms_FactorAnalysis_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_get_metadata_routing = bridgeFactorAnalysis[${this.id}].get_metadata_routing(**pms_FactorAnalysis_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_get_metadata_routing.tolist() if hasattr(res_FactorAnalysis_get_metadata_routing, 'tolist') else res_FactorAnalysis_get_metadata_routing`\n  }\n\n  /**\n    Compute data precision matrix with the FactorAnalysis model.\n   */\n  async get_precision(opts: {\n    /**\n      Estimated precision of data.\n     */\n    precision?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FactorAnalysis_get_precision = {'precision': np.array(${\n      opts['precision'] ?? undefined\n    }) if ${opts['precision'] !== undefined} else None}\n\npms_FactorAnalysis_get_precision = {k: v for k, v in pms_FactorAnalysis_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_get_precision = bridgeFactorAnalysis[${this.id}].get_precision(**pms_FactorAnalysis_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_get_precision.tolist() if hasattr(res_FactorAnalysis_get_precision, 'tolist') else res_FactorAnalysis_get_precision`\n  }\n\n  /**\n    Compute the average log-likelihood of the samples.\n   */\n  async score(opts: {\n    /**\n      The data.\n     */\n    X?: NDArray[]\n\n    /**\n      Ignored parameter.\n     */\n    y?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FactorAnalysis_score = {k: v for k, v in pms_FactorAnalysis_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_score = bridgeFactorAnalysis[${this.id}].score(**pms_FactorAnalysis_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_score.tolist() if hasattr(res_FactorAnalysis_score, 'tolist') else res_FactorAnalysis_score`\n  }\n\n  /**\n    Compute the log-likelihood of each sample.\n   */\n  async score_samples(opts: {\n    /**\n      The data.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_FactorAnalysis_score_samples = {k: v for k, v in pms_FactorAnalysis_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_score_samples = bridgeFactorAnalysis[${this.id}].score_samples(**pms_FactorAnalysis_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_score_samples.tolist() if hasattr(res_FactorAnalysis_score_samples, 'tolist') else res_FactorAnalysis_score_samples`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_FactorAnalysis_set_output = {k: v for k, v in pms_FactorAnalysis_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_set_output = bridgeFactorAnalysis[${this.id}].set_output(**pms_FactorAnalysis_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_set_output.tolist() if hasattr(res_FactorAnalysis_set_output, 'tolist') else res_FactorAnalysis_set_output`\n  }\n\n  /**\n    Apply dimensionality reduction to X using the model.\n\n    Compute the expected mean of the latent variables. See Barber, 21.2.33 (or Bishop, 12.66).\n   */\n  async transform(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FactorAnalysis_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_FactorAnalysis_transform = {k: v for k, v in pms_FactorAnalysis_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FactorAnalysis_transform = bridgeFactorAnalysis[${this.id}].transform(**pms_FactorAnalysis_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FactorAnalysis_transform.tolist() if hasattr(res_FactorAnalysis_transform, 'tolist') else res_FactorAnalysis_transform`\n  }\n\n  /**\n    Components with maximum variance.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_components_ = bridgeFactorAnalysis[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_components_.tolist() if hasattr(attr_FactorAnalysis_components_, 'tolist') else attr_FactorAnalysis_components_`\n    })()\n  }\n\n  /**\n    The log likelihood at each iteration.\n   */\n  get loglike_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing loglike_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_loglike_ = bridgeFactorAnalysis[${this.id}].loglike_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_loglike_.tolist() if hasattr(attr_FactorAnalysis_loglike_, 'tolist') else attr_FactorAnalysis_loglike_`\n    })()\n  }\n\n  /**\n    The estimated noise variance for each feature.\n   */\n  get noise_variance_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing noise_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_noise_variance_ = bridgeFactorAnalysis[${this.id}].noise_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_noise_variance_.tolist() if hasattr(attr_FactorAnalysis_noise_variance_, 'tolist') else attr_FactorAnalysis_noise_variance_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_n_iter_ = bridgeFactorAnalysis[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_n_iter_.tolist() if hasattr(attr_FactorAnalysis_n_iter_, 'tolist') else attr_FactorAnalysis_n_iter_`\n    })()\n  }\n\n  /**\n    Per-feature empirical mean, estimated from the training set.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FactorAnalysis must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_mean_ = bridgeFactorAnalysis[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_mean_.tolist() if hasattr(attr_FactorAnalysis_mean_, 'tolist') else attr_FactorAnalysis_mean_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_n_features_in_ = bridgeFactorAnalysis[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_n_features_in_.tolist() if hasattr(attr_FactorAnalysis_n_features_in_, 'tolist') else attr_FactorAnalysis_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This FactorAnalysis instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FactorAnalysis must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FactorAnalysis_feature_names_in_ = bridgeFactorAnalysis[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FactorAnalysis_feature_names_in_.tolist() if hasattr(attr_FactorAnalysis_feature_names_in_, 'tolist') else attr_FactorAnalysis_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  FastICA: a fast algorithm for Independent Component Analysis.\n\n  The implementation is based on [\\[1\\]](#r44c805292efc-1).\n\n  Read more in the [User Guide](../decomposition.html#ica).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html)\n */\nexport class FastICA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components to use. If `undefined` is passed, all are used.\n     */\n    n_components?: number\n\n    /**\n      Specify which algorithm to use for FastICA.\n\n      @defaultValue `'parallel'`\n     */\n    algorithm?: 'parallel' | 'deflation'\n\n    /**\n      Specify the whitening strategy to use.\n\n      @defaultValue `'unit-variance'`\n     */\n    whiten?: string | boolean\n\n    /**\n      The functional form of the G function used in the approximation to neg-entropy. Could be either ‘logcosh’, ‘exp’, or ‘cube’. You can also provide your own function. It should return a tuple containing the value of the function, and of its derivative, in the point. The derivative should be averaged along its last dimension. Example:\n\n      @defaultValue `'logcosh'`\n     */\n    fun?: 'logcosh' | 'exp' | 'cube'\n\n    /**\n      Arguments to send to the functional form. If empty or `undefined` and if fun=’logcosh’, fun\\_args will take value {‘alpha’ : 1.0}.\n     */\n    fun_args?: any\n\n    /**\n      Maximum number of iterations during fit.\n\n      @defaultValue `200`\n     */\n    max_iter?: number\n\n    /**\n      A positive scalar giving the tolerance at which the un-mixing matrix is considered to have converged.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Initial un-mixing array. If `w\\_init=None`, then an array of values drawn from a normal distribution is used.\n     */\n    w_init?: ArrayLike[]\n\n    /**\n      The solver to use for whitening.\n\n      @defaultValue `'svd'`\n     */\n    whiten_solver?: 'eigh' | 'svd'\n\n    /**\n      Used to initialize `w\\_init` when not specified, with a normal distribution. Pass an int, for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `FastICA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('FastICA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import FastICA\ntry: bridgeFastICA\nexcept NameError: bridgeFastICA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_FastICA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'whiten': ${\n      this.opts['whiten'] ?? undefined\n    }, 'fun': ${this.opts['fun'] ?? undefined}, 'fun_args': ${\n      this.opts['fun_args'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'w_init': np.array(${this.opts['w_init'] ?? undefined}) if ${\n      this.opts['w_init'] !== undefined\n    } else None, 'whiten_solver': ${\n      this.opts['whiten_solver'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_FastICA = {k: v for k, v in ctor_FastICA.items() if v is not None}`\n\n    await this._py.ex`bridgeFastICA[${this.id}] = FastICA(**ctor_FastICA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeFastICA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model to X.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FastICA_fit = {k: v for k, v in pms_FastICA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_fit = bridgeFastICA[${this.id}].fit(**pms_FastICA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_fit.tolist() if hasattr(res_FastICA_fit, 'tolist') else res_FastICA_fit`\n  }\n\n  /**\n    Fit the model and recover the sources from X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FastICA_fit_transform = {k: v for k, v in pms_FastICA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_fit_transform = bridgeFastICA[${this.id}].fit_transform(**pms_FastICA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_fit_transform.tolist() if hasattr(res_FastICA_fit_transform, 'tolist') else res_FastICA_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_FastICA_get_feature_names_out = {k: v for k, v in pms_FastICA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_get_feature_names_out = bridgeFastICA[${this.id}].get_feature_names_out(**pms_FastICA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_get_feature_names_out.tolist() if hasattr(res_FastICA_get_feature_names_out, 'tolist') else res_FastICA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_FastICA_get_metadata_routing = {k: v for k, v in pms_FastICA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_get_metadata_routing = bridgeFastICA[${this.id}].get_metadata_routing(**pms_FastICA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_get_metadata_routing.tolist() if hasattr(res_FastICA_get_metadata_routing, 'tolist') else res_FastICA_get_metadata_routing`\n  }\n\n  /**\n    Transform the sources back to the mixed data (apply mixing matrix).\n   */\n  async inverse_transform(opts: {\n    /**\n      Sources, where `n\\_samples` is the number of samples and `n\\_components` is the number of components.\n     */\n    X?: ArrayLike[]\n\n    /**\n      If `false`, data passed to fit are overwritten. Defaults to `true`.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_FastICA_inverse_transform = {k: v for k, v in pms_FastICA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_inverse_transform = bridgeFastICA[${this.id}].inverse_transform(**pms_FastICA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_inverse_transform.tolist() if hasattr(res_FastICA_inverse_transform, 'tolist') else res_FastICA_inverse_transform`\n  }\n\n  /**\n    Request metadata passed to the `inverse\\_transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_inverse_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `inverse\\_transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FastICA must call init() before set_inverse_transform_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_set_inverse_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_FastICA_set_inverse_transform_request = {k: v for k, v in pms_FastICA_set_inverse_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_set_inverse_transform_request = bridgeFastICA[${this.id}].set_inverse_transform_request(**pms_FastICA_set_inverse_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_set_inverse_transform_request.tolist() if hasattr(res_FastICA_set_inverse_transform_request, 'tolist') else res_FastICA_set_inverse_transform_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_FastICA_set_output = {k: v for k, v in pms_FastICA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_set_output = bridgeFastICA[${this.id}].set_output(**pms_FastICA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_set_output.tolist() if hasattr(res_FastICA_set_output, 'tolist') else res_FastICA_set_output`\n  }\n\n  /**\n    Request metadata passed to the `transform` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_transform_request(opts: {\n    /**\n      Metadata routing for `copy` parameter in `transform`.\n     */\n    copy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before set_transform_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_set_transform_request = {'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_FastICA_set_transform_request = {k: v for k, v in pms_FastICA_set_transform_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_set_transform_request = bridgeFastICA[${this.id}].set_transform_request(**pms_FastICA_set_transform_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_set_transform_request.tolist() if hasattr(res_FastICA_set_transform_request, 'tolist') else res_FastICA_set_transform_request`\n  }\n\n  /**\n    Recover the sources from X (apply the unmixing matrix).\n   */\n  async transform(opts: {\n    /**\n      Data to transform, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      If `false`, data passed to fit can be overwritten. Defaults to `true`.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FastICA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'copy': ${\n      opts['copy'] ?? undefined\n    }}\n\npms_FastICA_transform = {k: v for k, v in pms_FastICA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FastICA_transform = bridgeFastICA[${this.id}].transform(**pms_FastICA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FastICA_transform.tolist() if hasattr(res_FastICA_transform, 'tolist') else res_FastICA_transform`\n  }\n\n  /**\n    The linear operator to apply to the data to get the independent sources. This is equal to the unmixing matrix when `whiten` is `false`, and equal to `np.dot(unmixing\\_matrix, self.whitening\\_)` when `whiten` is `true`.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_components_ = bridgeFastICA[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_components_.tolist() if hasattr(attr_FastICA_components_, 'tolist') else attr_FastICA_components_`\n    })()\n  }\n\n  /**\n    The pseudo-inverse of `components\\_`. It is the linear operator that maps independent sources to the data.\n   */\n  get mixing_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before accessing mixing_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_mixing_ = bridgeFastICA[${this.id}].mixing_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_mixing_.tolist() if hasattr(attr_FastICA_mixing_, 'tolist') else attr_FastICA_mixing_`\n    })()\n  }\n\n  /**\n    The mean over features. Only set if `self.whiten` is `true`.\n   */\n  get mean_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_FastICA_mean_ = bridgeFastICA[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_mean_.tolist() if hasattr(attr_FastICA_mean_, 'tolist') else attr_FastICA_mean_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FastICA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_n_features_in_ = bridgeFastICA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_n_features_in_.tolist() if hasattr(attr_FastICA_n_features_in_, 'tolist') else attr_FastICA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FastICA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_feature_names_in_ = bridgeFastICA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_feature_names_in_.tolist() if hasattr(attr_FastICA_feature_names_in_, 'tolist') else attr_FastICA_feature_names_in_`\n    })()\n  }\n\n  /**\n    If the algorithm is “deflation”, n\\_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_n_iter_ = bridgeFastICA[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_n_iter_.tolist() if hasattr(attr_FastICA_n_iter_, 'tolist') else attr_FastICA_n_iter_`\n    })()\n  }\n\n  /**\n    Only set if whiten is ‘`true`’. This is the pre-whitening matrix that projects data onto the first `n\\_components` principal components.\n   */\n  get whitening_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This FastICA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FastICA must call init() before accessing whitening_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FastICA_whitening_ = bridgeFastICA[${this.id}].whitening_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FastICA_whitening_.tolist() if hasattr(attr_FastICA_whitening_, 'tolist') else attr_FastICA_whitening_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Incremental principal components analysis (IPCA).\n\n  Linear dimensionality reduction using Singular Value Decomposition of the data, keeping only the most significant singular vectors to project the data to a lower dimensional space. The input data is centered but not scaled for each feature before applying the SVD.\n\n  Depending on the size of the input data, this algorithm can be much more memory efficient than a PCA, and allows sparse input.\n\n  This algorithm has constant memory complexity, on the order of `batch\\_size \\* n\\_features`, enabling use of np.memmap files without loading the entire file into memory. For sparse matrices, the input is converted to dense in batches (in order to be able to subtract the mean) which avoids storing the entire dense matrix at any one time.\n\n  The computational overhead of each SVD is `O(batch\\_size \\* n\\_features \\*\\* 2)`, but only 2 \\* batch\\_size samples remain in memory at a time. There will be `n\\_samples / batch\\_size` SVD computations to get the principal components, versus 1 large SVD of complexity `O(n\\_samples \\* n\\_features \\*\\* 2)` for PCA.\n\n  Read more in the [User Guide](../decomposition.html#incrementalpca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html)\n */\nexport class IncrementalPCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components to keep. If `n\\_components` is `undefined`, then `n\\_components` is set to `min(n\\_samples, n\\_features)`.\n     */\n    n_components?: number\n\n    /**\n      When `true` (`false` by default) the `components\\_` vectors are divided by `n\\_samples` times `components\\_` to ensure uncorrelated outputs with unit component-wise variances.\n\n      Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometimes improve the predictive accuracy of the downstream estimators by making data respect some hard-wired assumptions.\n\n      @defaultValue `false`\n     */\n    whiten?: boolean\n\n    /**\n      If `false`, X will be overwritten. `copy=False` can be used to save memory but is unsafe for general use.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      The number of samples to use for each batch. Only used when calling `fit`. If `batch\\_size` is `undefined`, then `batch\\_size` is inferred from the data and set to `5 \\* n\\_features`, to provide a balance between approximation accuracy and memory consumption.\n     */\n    batch_size?: number\n  }) {\n    this.id = `IncrementalPCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('IncrementalPCA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import IncrementalPCA\ntry: bridgeIncrementalPCA\nexcept NameError: bridgeIncrementalPCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_IncrementalPCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'whiten': ${this.opts['whiten'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }, 'batch_size': ${this.opts['batch_size'] ?? undefined}}\n\nctor_IncrementalPCA = {k: v for k, v in ctor_IncrementalPCA.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeIncrementalPCA[${this.id}] = IncrementalPCA(**ctor_IncrementalPCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeIncrementalPCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model with X, using minibatches of size batch\\_size.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_IncrementalPCA_fit = {k: v for k, v in pms_IncrementalPCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_fit = bridgeIncrementalPCA[${this.id}].fit(**pms_IncrementalPCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_fit.tolist() if hasattr(res_IncrementalPCA_fit, 'tolist') else res_IncrementalPCA_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_IncrementalPCA_fit_transform = {k: v for k, v in pms_IncrementalPCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_fit_transform = bridgeIncrementalPCA[${this.id}].fit_transform(**pms_IncrementalPCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_fit_transform.tolist() if hasattr(res_IncrementalPCA_fit_transform, 'tolist') else res_IncrementalPCA_fit_transform`\n  }\n\n  /**\n    Compute data covariance with the generative model.\n\n    `cov \\= components\\_.T \\* S\\*\\*2 \\* components\\_ + sigma2 \\* eye(n\\_features)` where S\\*\\*2 contains the explained variances, and sigma2 contains the noise variances.\n   */\n  async get_covariance(opts: {\n    /**\n      Estimated covariance of data.\n     */\n    cov?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before get_covariance()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_get_covariance = {'cov': np.array(${\n      opts['cov'] ?? undefined\n    }) if ${opts['cov'] !== undefined} else None}\n\npms_IncrementalPCA_get_covariance = {k: v for k, v in pms_IncrementalPCA_get_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_get_covariance = bridgeIncrementalPCA[${this.id}].get_covariance(**pms_IncrementalPCA_get_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_get_covariance.tolist() if hasattr(res_IncrementalPCA_get_covariance, 'tolist') else res_IncrementalPCA_get_covariance`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_IncrementalPCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_IncrementalPCA_get_feature_names_out = {k: v for k, v in pms_IncrementalPCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_get_feature_names_out = bridgeIncrementalPCA[${this.id}].get_feature_names_out(**pms_IncrementalPCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_get_feature_names_out.tolist() if hasattr(res_IncrementalPCA_get_feature_names_out, 'tolist') else res_IncrementalPCA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_IncrementalPCA_get_metadata_routing = {k: v for k, v in pms_IncrementalPCA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_get_metadata_routing = bridgeIncrementalPCA[${this.id}].get_metadata_routing(**pms_IncrementalPCA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_get_metadata_routing.tolist() if hasattr(res_IncrementalPCA_get_metadata_routing, 'tolist') else res_IncrementalPCA_get_metadata_routing`\n  }\n\n  /**\n    Compute data precision matrix with the generative model.\n\n    Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.\n   */\n  async get_precision(opts: {\n    /**\n      Estimated precision of data.\n     */\n    precision?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_get_precision = {'precision': ${\n      opts['precision'] ?? undefined\n    }}\n\npms_IncrementalPCA_get_precision = {k: v for k, v in pms_IncrementalPCA_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_get_precision = bridgeIncrementalPCA[${this.id}].get_precision(**pms_IncrementalPCA_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_get_precision.tolist() if hasattr(res_IncrementalPCA_get_precision, 'tolist') else res_IncrementalPCA_get_precision`\n  }\n\n  /**\n    Transform data back to its original space.\n\n    In other words, return an input `X\\_original` whose transform would be X.\n   */\n  async inverse_transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_components` is the number of components.\n     */\n    X?: ArrayLike[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_IncrementalPCA_inverse_transform = {k: v for k, v in pms_IncrementalPCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_inverse_transform = bridgeIncrementalPCA[${this.id}].inverse_transform(**pms_IncrementalPCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_inverse_transform.tolist() if hasattr(res_IncrementalPCA_inverse_transform, 'tolist') else res_IncrementalPCA_inverse_transform`\n  }\n\n  /**\n    Incremental fit with X. All of X is processed as a single batch.\n   */\n  async partial_fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Run check\\_array on X.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'check_input': ${opts['check_input'] ?? undefined}}\n\npms_IncrementalPCA_partial_fit = {k: v for k, v in pms_IncrementalPCA_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_partial_fit = bridgeIncrementalPCA[${this.id}].partial_fit(**pms_IncrementalPCA_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_partial_fit.tolist() if hasattr(res_IncrementalPCA_partial_fit, 'tolist') else res_IncrementalPCA_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_IncrementalPCA_set_output = {k: v for k, v in pms_IncrementalPCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_set_output = bridgeIncrementalPCA[${this.id}].set_output(**pms_IncrementalPCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_set_output.tolist() if hasattr(res_IncrementalPCA_set_output, 'tolist') else res_IncrementalPCA_set_output`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `check\\_input` parameter in `partial\\_fit`.\n     */\n    check_input?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_IncrementalPCA_set_partial_fit_request = {'check_input': ${\n      opts['check_input'] ?? undefined\n    }}\n\npms_IncrementalPCA_set_partial_fit_request = {k: v for k, v in pms_IncrementalPCA_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_set_partial_fit_request = bridgeIncrementalPCA[${this.id}].set_partial_fit_request(**pms_IncrementalPCA_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_set_partial_fit_request.tolist() if hasattr(res_IncrementalPCA_set_partial_fit_request, 'tolist') else res_IncrementalPCA_set_partial_fit_request`\n  }\n\n  /**\n    Apply dimensionality reduction to X.\n\n    X is projected on the first principal components previously extracted from a training set, using minibatches of size batch\\_size if X is sparse.\n   */\n  async transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_IncrementalPCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_IncrementalPCA_transform = {k: v for k, v in pms_IncrementalPCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_IncrementalPCA_transform = bridgeIncrementalPCA[${this.id}].transform(**pms_IncrementalPCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_IncrementalPCA_transform.tolist() if hasattr(res_IncrementalPCA_transform, 'tolist') else res_IncrementalPCA_transform`\n  }\n\n  /**\n    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\\_variance\\_`.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_components_ = bridgeIncrementalPCA[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_components_.tolist() if hasattr(attr_IncrementalPCA_components_, 'tolist') else attr_IncrementalPCA_components_`\n    })()\n  }\n\n  /**\n    Variance explained by each of the selected components.\n   */\n  get explained_variance_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing explained_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_explained_variance_ = bridgeIncrementalPCA[${this.id}].explained_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_explained_variance_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_, 'tolist') else attr_IncrementalPCA_explained_variance_`\n    })()\n  }\n\n  /**\n    Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0.\n   */\n  get explained_variance_ratio_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing explained_variance_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_explained_variance_ratio_ = bridgeIncrementalPCA[${this.id}].explained_variance_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_explained_variance_ratio_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_ratio_, 'tolist') else attr_IncrementalPCA_explained_variance_ratio_`\n    })()\n  }\n\n  /**\n    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\\_components` variables in the lower-dimensional space.\n   */\n  get singular_values_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing singular_values_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_singular_values_ = bridgeIncrementalPCA[${this.id}].singular_values_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_singular_values_.tolist() if hasattr(attr_IncrementalPCA_singular_values_, 'tolist') else attr_IncrementalPCA_singular_values_`\n    })()\n  }\n\n  /**\n    Per-feature empirical mean, aggregate over calls to `partial\\_fit`.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_mean_ = bridgeIncrementalPCA[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_mean_.tolist() if hasattr(attr_IncrementalPCA_mean_, 'tolist') else attr_IncrementalPCA_mean_`\n    })()\n  }\n\n  /**\n    Per-feature empirical variance, aggregate over calls to `partial\\_fit`.\n   */\n  get var_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('IncrementalPCA must call init() before accessing var_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_var_ = bridgeIncrementalPCA[${this.id}].var_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_var_.tolist() if hasattr(attr_IncrementalPCA_var_, 'tolist') else attr_IncrementalPCA_var_`\n    })()\n  }\n\n  /**\n    The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf).\n   */\n  get noise_variance_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing noise_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_noise_variance_ = bridgeIncrementalPCA[${this.id}].noise_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_noise_variance_.tolist() if hasattr(attr_IncrementalPCA_noise_variance_, 'tolist') else attr_IncrementalPCA_noise_variance_`\n    })()\n  }\n\n  /**\n    The estimated number of components. Relevant when `n\\_components=None`.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing n_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_n_components_ = bridgeIncrementalPCA[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_n_components_.tolist() if hasattr(attr_IncrementalPCA_n_components_, 'tolist') else attr_IncrementalPCA_n_components_`\n    })()\n  }\n\n  /**\n    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\\_fit` calls.\n   */\n  get n_samples_seen_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing n_samples_seen_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_n_samples_seen_ = bridgeIncrementalPCA[${this.id}].n_samples_seen_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_n_samples_seen_.tolist() if hasattr(attr_IncrementalPCA_n_samples_seen_, 'tolist') else attr_IncrementalPCA_n_samples_seen_`\n    })()\n  }\n\n  /**\n    Inferred batch size from `batch\\_size`.\n   */\n  get batch_size_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing batch_size_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_batch_size_ = bridgeIncrementalPCA[${this.id}].batch_size_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_batch_size_.tolist() if hasattr(attr_IncrementalPCA_batch_size_, 'tolist') else attr_IncrementalPCA_batch_size_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_n_features_in_ = bridgeIncrementalPCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_n_features_in_.tolist() if hasattr(attr_IncrementalPCA_n_features_in_, 'tolist') else attr_IncrementalPCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This IncrementalPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'IncrementalPCA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_IncrementalPCA_feature_names_in_ = bridgeIncrementalPCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_IncrementalPCA_feature_names_in_.tolist() if hasattr(attr_IncrementalPCA_feature_names_in_, 'tolist') else attr_IncrementalPCA_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Kernel Principal component analysis (KPCA) [\\[1\\]](#r396fc7d924b8-1).\n\n  Non-linear dimensionality reduction through the use of kernels (see [Pairwise metrics, Affinities and Kernels](../metrics.html#metrics)).\n\n  It uses the [`scipy.linalg.eigh`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigh.html#scipy.linalg.eigh \"(in SciPy v1.11.3)\") LAPACK implementation of the full SVD or the [`scipy.sparse.linalg.eigsh`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh \"(in SciPy v1.11.3)\") ARPACK implementation of the truncated SVD, depending on the shape of the input data and the number of components to extract. It can also use a randomized truncated SVD by the method proposed in [\\[3\\]](#r396fc7d924b8-3), see `eigen\\_solver`.\n\n  Read more in the [User Guide](../decomposition.html#kernel-pca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html)\n */\nexport class KernelPCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components. If `undefined`, all non-zero components are kept.\n     */\n    n_components?: number\n\n    /**\n      Kernel used for PCA.\n\n      @defaultValue `'linear'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'cosine' | 'precomputed'\n\n    /**\n      Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other kernels. If `gamma` is `undefined`, then it is set to `1/n\\_features`.\n     */\n    gamma?: number\n\n    /**\n      Degree for poly kernels. Ignored by other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Independent term in poly and sigmoid kernels. Ignored by other kernels.\n\n      @defaultValue `1`\n     */\n    coef0?: number\n\n    /**\n      Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.\n     */\n    kernel_params?: any\n\n    /**\n      Hyperparameter of the ridge regression that learns the inverse transform (when fit\\_inverse\\_transform=`true`).\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Learn the inverse transform for non-precomputed kernels (i.e. learn to find the pre-image of a point). This method is based on [\\[2\\]](#r396fc7d924b8-2).\n\n      @defaultValue `false`\n     */\n    fit_inverse_transform?: boolean\n\n    /**\n      Select eigensolver to use. If `n\\_components` is much less than the number of training samples, randomized (or arpack to a smaller extent) may be more efficient than the dense eigensolver. Randomized SVD is performed according to the method of Halko et al [\\[3\\]](#r396fc7d924b8-3).\n\n      @defaultValue `'auto'`\n     */\n    eigen_solver?: 'auto' | 'dense' | 'arpack' | 'randomized'\n\n    /**\n      Convergence tolerance for arpack. If 0, optimal value will be chosen by arpack.\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations for arpack. If `undefined`, optimal value will be chosen by arpack.\n     */\n    max_iter?: number\n\n    /**\n      Number of iterations for the power method computed by svd\\_solver == ‘randomized’. When ‘auto’, it is set to 7 when `n\\_components < 0.1 \\* min(X.shape)`, other it is set to 4.\n\n      @defaultValue `'auto'`\n     */\n    iterated_power?: 'auto'\n\n    /**\n      If `true`, then all components with zero eigenvalues are removed, so that the number of components in the output may be < n\\_components (and sometimes even zero due to numerical instability). When n\\_components is `undefined`, this parameter is ignored and components with zero eigenvalues are removed regardless.\n\n      @defaultValue `false`\n     */\n    remove_zero_eig?: boolean\n\n    /**\n      Used when `eigen\\_solver` == ‘arpack’ or ‘randomized’. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If `true`, input X is copied and stored by the model in the `X\\_fit\\_` attribute. If no further changes will be done to X, setting `copy\\_X=False` saves memory by storing a reference.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `KernelPCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KernelPCA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import KernelPCA\ntry: bridgeKernelPCA\nexcept NameError: bridgeKernelPCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KernelPCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'kernel': ${this.opts['kernel'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'kernel_params': ${this.opts['kernel_params'] ?? undefined}, 'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_inverse_transform': ${\n      this.opts['fit_inverse_transform'] ?? undefined\n    }, 'eigen_solver': ${this.opts['eigen_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'iterated_power': ${\n      this.opts['iterated_power'] ?? undefined\n    }, 'remove_zero_eig': ${\n      this.opts['remove_zero_eig'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_KernelPCA = {k: v for k, v in ctor_KernelPCA.items() if v is not None}`\n\n    await this._py.ex`bridgeKernelPCA[${this.id}] = KernelPCA(**ctor_KernelPCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKernelPCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KernelPCA_fit = {k: v for k, v in pms_KernelPCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_fit = bridgeKernelPCA[${this.id}].fit(**pms_KernelPCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_fit.tolist() if hasattr(res_KernelPCA_fit, 'tolist') else res_KernelPCA_fit`\n  }\n\n  /**\n    Fit the model from data in X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Parameters (keyword arguments) and values passed to the fit\\_transform instance.\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_KernelPCA_fit_transform = {k: v for k, v in pms_KernelPCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_fit_transform = bridgeKernelPCA[${this.id}].fit_transform(**pms_KernelPCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_fit_transform.tolist() if hasattr(res_KernelPCA_fit_transform, 'tolist') else res_KernelPCA_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KernelPCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KernelPCA_get_feature_names_out = {k: v for k, v in pms_KernelPCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_get_feature_names_out = bridgeKernelPCA[${this.id}].get_feature_names_out(**pms_KernelPCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_get_feature_names_out.tolist() if hasattr(res_KernelPCA_get_feature_names_out, 'tolist') else res_KernelPCA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KernelPCA_get_metadata_routing = {k: v for k, v in pms_KernelPCA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_get_metadata_routing = bridgeKernelPCA[${this.id}].get_metadata_routing(**pms_KernelPCA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_get_metadata_routing.tolist() if hasattr(res_KernelPCA_get_metadata_routing, 'tolist') else res_KernelPCA_get_metadata_routing`\n  }\n\n  /**\n    Transform X back to original space.\n\n    `inverse\\_transform` approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.\n   */\n  async inverse_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KernelPCA_inverse_transform = {k: v for k, v in pms_KernelPCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_inverse_transform = bridgeKernelPCA[${this.id}].inverse_transform(**pms_KernelPCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_inverse_transform.tolist() if hasattr(res_KernelPCA_inverse_transform, 'tolist') else res_KernelPCA_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KernelPCA_set_output = {k: v for k, v in pms_KernelPCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_set_output = bridgeKernelPCA[${this.id}].set_output(**pms_KernelPCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_set_output.tolist() if hasattr(res_KernelPCA_set_output, 'tolist') else res_KernelPCA_set_output`\n  }\n\n  /**\n    Transform X.\n   */\n  async transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KernelPCA_transform = {k: v for k, v in pms_KernelPCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_transform = bridgeKernelPCA[${this.id}].transform(**pms_KernelPCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_transform.tolist() if hasattr(res_KernelPCA_transform, 'tolist') else res_KernelPCA_transform`\n  }\n\n  /**\n    Eigenvalues of the centered kernel matrix in decreasing order. If `n\\_components` and `remove\\_zero\\_eig` are not set, then all values are stored.\n   */\n  get eigenvalues_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing eigenvalues_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_eigenvalues_ = bridgeKernelPCA[${this.id}].eigenvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_eigenvalues_.tolist() if hasattr(attr_KernelPCA_eigenvalues_, 'tolist') else attr_KernelPCA_eigenvalues_`\n    })()\n  }\n\n  /**\n    Eigenvectors of the centered kernel matrix. If `n\\_components` and `remove\\_zero\\_eig` are not set, then all components are stored.\n   */\n  get eigenvectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing eigenvectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_eigenvectors_ = bridgeKernelPCA[${this.id}].eigenvectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_eigenvectors_.tolist() if hasattr(attr_KernelPCA_eigenvectors_, 'tolist') else attr_KernelPCA_eigenvectors_`\n    })()\n  }\n\n  /**\n    Inverse transform matrix. Only available when `fit\\_inverse\\_transform` is `true`.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_dual_coef_ = bridgeKernelPCA[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_dual_coef_.tolist() if hasattr(attr_KernelPCA_dual_coef_, 'tolist') else attr_KernelPCA_dual_coef_`\n    })()\n  }\n\n  /**\n    Projection of the fitted data on the kernel principal components. Only available when `fit\\_inverse\\_transform` is `true`.\n   */\n  get X_transformed_fit_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing X_transformed_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_X_transformed_fit_ = bridgeKernelPCA[${this.id}].X_transformed_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_X_transformed_fit_.tolist() if hasattr(attr_KernelPCA_X_transformed_fit_, 'tolist') else attr_KernelPCA_X_transformed_fit_`\n    })()\n  }\n\n  /**\n    The data used to fit the model. If `copy\\_X=False`, then `X\\_fit\\_` is a reference. This attribute is used for the calls to transform.\n   */\n  get X_fit_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before accessing X_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_X_fit_ = bridgeKernelPCA[${this.id}].X_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_X_fit_.tolist() if hasattr(attr_KernelPCA_X_fit_, 'tolist') else attr_KernelPCA_X_fit_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_n_features_in_ = bridgeKernelPCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_n_features_in_.tolist() if hasattr(attr_KernelPCA_n_features_in_, 'tolist') else attr_KernelPCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_feature_names_in_ = bridgeKernelPCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_feature_names_in_.tolist() if hasattr(attr_KernelPCA_feature_names_in_, 'tolist') else attr_KernelPCA_feature_names_in_`\n    })()\n  }\n\n  /**\n    Kernel coefficient for rbf, poly and sigmoid kernels. When `gamma` is explicitly provided, this is just the same as `gamma`. When `gamma` is `undefined`, this is the actual value of kernel coefficient.\n   */\n  get gamma_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before accessing gamma_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_gamma_ = bridgeKernelPCA[${this.id}].gamma_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_gamma_.tolist() if hasattr(attr_KernelPCA_gamma_, 'tolist') else attr_KernelPCA_gamma_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Latent Dirichlet Allocation with online variational Bayes algorithm.\n\n  The implementation is based on [\\[1\\]](#re25e5648fc37-1) and [\\[2\\]](#re25e5648fc37-2).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.LatentDirichletAllocation.html)\n */\nexport class LatentDirichletAllocation {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of topics.\n\n      @defaultValue `10`\n     */\n    n_components?: number\n\n    /**\n      Prior of document topic distribution `theta`. If the value is `undefined`, defaults to `1 / n\\_components`. In [\\[1\\]](#re25e5648fc37-1), this is called `alpha`.\n     */\n    doc_topic_prior?: number\n\n    /**\n      Prior of topic word distribution `beta`. If the value is `undefined`, defaults to `1 / n\\_components`. In [\\[1\\]](#re25e5648fc37-1), this is called `eta`.\n     */\n    topic_word_prior?: number\n\n    /**\n      Method used to update `\\_component`. Only used in [`fit`](#sklearn.decomposition.LatentDirichletAllocation.fit \"sklearn.decomposition.LatentDirichletAllocation.fit\") method. In general, if the data size is large, the online update will be much faster than the batch update.\n\n      Valid options:\n\n      @defaultValue `'batch'`\n     */\n    learning_method?: 'batch' | 'online'\n\n    /**\n      It is a parameter that control learning rate in the online learning method. The value should be set between (0.5, 1.0\\] to guarantee asymptotic convergence. When the value is 0.0 and batch\\_size is `n\\_samples`, the update method is same as batch learning. In the literature, this is called kappa.\n\n      @defaultValue `0.7`\n     */\n    learning_decay?: number\n\n    /**\n      A (positive) parameter that downweights early iterations in online learning. It should be greater than 1.0. In the literature, this is called tau\\_0.\n\n      @defaultValue `10`\n     */\n    learning_offset?: number\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the [`fit`](#sklearn.decomposition.LatentDirichletAllocation.fit \"sklearn.decomposition.LatentDirichletAllocation.fit\") method, and not the [`partial\\_fit`](#sklearn.decomposition.LatentDirichletAllocation.partial_fit \"sklearn.decomposition.LatentDirichletAllocation.partial_fit\") method.\n\n      @defaultValue `10`\n     */\n    max_iter?: number\n\n    /**\n      Number of documents to use in each EM iteration. Only used in online learning.\n\n      @defaultValue `128`\n     */\n    batch_size?: number\n\n    /**\n      How often to evaluate perplexity. Only used in `fit` method. set it to 0 or negative number to not evaluate perplexity in training at all. Evaluating perplexity can help you check convergence in training process, but it will also increase total training time. Evaluating perplexity in every iteration might increase training time up to two-fold.\n\n      @defaultValue `-1`\n     */\n    evaluate_every?: number\n\n    /**\n      Total number of documents. Only used in the [`partial\\_fit`](#sklearn.decomposition.LatentDirichletAllocation.partial_fit \"sklearn.decomposition.LatentDirichletAllocation.partial_fit\") method.\n\n      @defaultValue `1000000`\n     */\n    total_samples?: number\n\n    /**\n      Perplexity tolerance in batch learning. Only used when `evaluate\\_every` is greater than 0.\n\n      @defaultValue `0.1`\n     */\n    perp_tol?: number\n\n    /**\n      Stopping tolerance for updating document topic distribution in E-step.\n\n      @defaultValue `0.001`\n     */\n    mean_change_tol?: number\n\n    /**\n      Max number of iterations for updating document topic distribution in the E-step.\n\n      @defaultValue `100`\n     */\n    max_doc_update_iter?: number\n\n    /**\n      The number of jobs to use in the E-step. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `LatentDirichletAllocation${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'LatentDirichletAllocation.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import LatentDirichletAllocation\ntry: bridgeLatentDirichletAllocation\nexcept NameError: bridgeLatentDirichletAllocation = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LatentDirichletAllocation = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'doc_topic_prior': ${\n      this.opts['doc_topic_prior'] ?? undefined\n    }, 'topic_word_prior': ${\n      this.opts['topic_word_prior'] ?? undefined\n    }, 'learning_method': ${\n      this.opts['learning_method'] ?? undefined\n    }, 'learning_decay': ${\n      this.opts['learning_decay'] ?? undefined\n    }, 'learning_offset': ${\n      this.opts['learning_offset'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'batch_size': ${\n      this.opts['batch_size'] ?? undefined\n    }, 'evaluate_every': ${\n      this.opts['evaluate_every'] ?? undefined\n    }, 'total_samples': ${\n      this.opts['total_samples'] ?? undefined\n    }, 'perp_tol': ${this.opts['perp_tol'] ?? undefined}, 'mean_change_tol': ${\n      this.opts['mean_change_tol'] ?? undefined\n    }, 'max_doc_update_iter': ${\n      this.opts['max_doc_update_iter'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_LatentDirichletAllocation = {k: v for k, v in ctor_LatentDirichletAllocation.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLatentDirichletAllocation[${this.id}] = LatentDirichletAllocation(**ctor_LatentDirichletAllocation)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLatentDirichletAllocation[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Learn model for the data X with variational Bayes method.\n\n    When `learning\\_method` is ‘online’, use mini-batch update. Otherwise, use batch update.\n   */\n  async fit(opts: {\n    /**\n      Document word matrix.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LatentDirichletAllocation must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LatentDirichletAllocation_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LatentDirichletAllocation_fit = {k: v for k, v in pms_LatentDirichletAllocation_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_fit = bridgeLatentDirichletAllocation[${this.id}].fit(**pms_LatentDirichletAllocation_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_fit.tolist() if hasattr(res_LatentDirichletAllocation_fit, 'tolist') else res_LatentDirichletAllocation_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_LatentDirichletAllocation_fit_transform = {k: v for k, v in pms_LatentDirichletAllocation_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_fit_transform = bridgeLatentDirichletAllocation[${this.id}].fit_transform(**pms_LatentDirichletAllocation_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_fit_transform.tolist() if hasattr(res_LatentDirichletAllocation_fit_transform, 'tolist') else res_LatentDirichletAllocation_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_LatentDirichletAllocation_get_feature_names_out = {k: v for k, v in pms_LatentDirichletAllocation_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_get_feature_names_out = bridgeLatentDirichletAllocation[${this.id}].get_feature_names_out(**pms_LatentDirichletAllocation_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_get_feature_names_out.tolist() if hasattr(res_LatentDirichletAllocation_get_feature_names_out, 'tolist') else res_LatentDirichletAllocation_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LatentDirichletAllocation_get_metadata_routing = {k: v for k, v in pms_LatentDirichletAllocation_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_get_metadata_routing = bridgeLatentDirichletAllocation[${this.id}].get_metadata_routing(**pms_LatentDirichletAllocation_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_get_metadata_routing.tolist() if hasattr(res_LatentDirichletAllocation_get_metadata_routing, 'tolist') else res_LatentDirichletAllocation_get_metadata_routing`\n  }\n\n  /**\n    Online VB with Mini-Batch update.\n   */\n  async partial_fit(opts: {\n    /**\n      Document word matrix.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LatentDirichletAllocation_partial_fit = {k: v for k, v in pms_LatentDirichletAllocation_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_partial_fit = bridgeLatentDirichletAllocation[${this.id}].partial_fit(**pms_LatentDirichletAllocation_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_partial_fit.tolist() if hasattr(res_LatentDirichletAllocation_partial_fit, 'tolist') else res_LatentDirichletAllocation_partial_fit`\n  }\n\n  /**\n    Calculate approximate perplexity for data X.\n\n    Perplexity is defined as exp(-1. \\* log-likelihood per word)\n   */\n  async perplexity(opts: {\n    /**\n      Document word matrix.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Do sub-sampling or not.\n     */\n    sub_sampling?: boolean\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before perplexity()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_perplexity = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'sub_sampling': ${\n      opts['sub_sampling'] ?? undefined\n    }}\n\npms_LatentDirichletAllocation_perplexity = {k: v for k, v in pms_LatentDirichletAllocation_perplexity.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_perplexity = bridgeLatentDirichletAllocation[${this.id}].perplexity(**pms_LatentDirichletAllocation_perplexity)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_perplexity.tolist() if hasattr(res_LatentDirichletAllocation_perplexity, 'tolist') else res_LatentDirichletAllocation_perplexity`\n  }\n\n  /**\n    Calculate approximate log-likelihood as score.\n   */\n  async score(opts: {\n    /**\n      Document word matrix.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LatentDirichletAllocation_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LatentDirichletAllocation_score = {k: v for k, v in pms_LatentDirichletAllocation_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_score = bridgeLatentDirichletAllocation[${this.id}].score(**pms_LatentDirichletAllocation_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_score.tolist() if hasattr(res_LatentDirichletAllocation_score, 'tolist') else res_LatentDirichletAllocation_score`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_LatentDirichletAllocation_set_output = {k: v for k, v in pms_LatentDirichletAllocation_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_set_output = bridgeLatentDirichletAllocation[${this.id}].set_output(**pms_LatentDirichletAllocation_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_set_output.tolist() if hasattr(res_LatentDirichletAllocation_set_output, 'tolist') else res_LatentDirichletAllocation_set_output`\n  }\n\n  /**\n    Transform data X according to the fitted model.\n   */\n  async transform(opts: {\n    /**\n      Document word matrix.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LatentDirichletAllocation_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LatentDirichletAllocation_transform = {k: v for k, v in pms_LatentDirichletAllocation_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LatentDirichletAllocation_transform = bridgeLatentDirichletAllocation[${this.id}].transform(**pms_LatentDirichletAllocation_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LatentDirichletAllocation_transform.tolist() if hasattr(res_LatentDirichletAllocation_transform, 'tolist') else res_LatentDirichletAllocation_transform`\n  }\n\n  /**\n    Variational parameters for topic word distribution. Since the complete conditional for topic word distribution is a Dirichlet, `components\\_\\[i, j\\]` can be viewed as pseudocount that represents the number of times word `j` was assigned to topic `i`. It can also be viewed as distribution over the words for each topic after normalization: `model.components\\_ / model.components\\_.sum(axis=1)\\[:, np.newaxis\\]`.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_components_ = bridgeLatentDirichletAllocation[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_components_.tolist() if hasattr(attr_LatentDirichletAllocation_components_, 'tolist') else attr_LatentDirichletAllocation_components_`\n    })()\n  }\n\n  /**\n    Exponential value of expectation of log topic word distribution. In the literature, this is `exp(E\\[log(beta)\\])`.\n   */\n  get exp_dirichlet_component_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing exp_dirichlet_component_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_exp_dirichlet_component_ = bridgeLatentDirichletAllocation[${this.id}].exp_dirichlet_component_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_exp_dirichlet_component_.tolist() if hasattr(attr_LatentDirichletAllocation_exp_dirichlet_component_, 'tolist') else attr_LatentDirichletAllocation_exp_dirichlet_component_`\n    })()\n  }\n\n  /**\n    Number of iterations of the EM step.\n   */\n  get n_batch_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing n_batch_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_n_batch_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_batch_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_n_batch_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_batch_iter_, 'tolist') else attr_LatentDirichletAllocation_n_batch_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_n_features_in_ = bridgeLatentDirichletAllocation[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_n_features_in_.tolist() if hasattr(attr_LatentDirichletAllocation_n_features_in_, 'tolist') else attr_LatentDirichletAllocation_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_feature_names_in_ = bridgeLatentDirichletAllocation[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_feature_names_in_.tolist() if hasattr(attr_LatentDirichletAllocation_feature_names_in_, 'tolist') else attr_LatentDirichletAllocation_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of passes over the dataset.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_n_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_n_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_iter_, 'tolist') else attr_LatentDirichletAllocation_n_iter_`\n    })()\n  }\n\n  /**\n    Final perplexity score on training set.\n   */\n  get bound_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing bound_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_bound_ = bridgeLatentDirichletAllocation[${this.id}].bound_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_bound_.tolist() if hasattr(attr_LatentDirichletAllocation_bound_, 'tolist') else attr_LatentDirichletAllocation_bound_`\n    })()\n  }\n\n  /**\n    Prior of document topic distribution `theta`. If the value is `undefined`, it is `1 / n\\_components`.\n   */\n  get doc_topic_prior_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing doc_topic_prior_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_doc_topic_prior_ = bridgeLatentDirichletAllocation[${this.id}].doc_topic_prior_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_doc_topic_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_doc_topic_prior_, 'tolist') else attr_LatentDirichletAllocation_doc_topic_prior_`\n    })()\n  }\n\n  /**\n    RandomState instance that is generated either from a seed, the random number generator or by `np.random`.\n   */\n  get random_state_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing random_state_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_random_state_ = bridgeLatentDirichletAllocation[${this.id}].random_state_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_random_state_.tolist() if hasattr(attr_LatentDirichletAllocation_random_state_, 'tolist') else attr_LatentDirichletAllocation_random_state_`\n    })()\n  }\n\n  /**\n    Prior of topic word distribution `beta`. If the value is `undefined`, it is `1 / n\\_components`.\n   */\n  get topic_word_prior_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LatentDirichletAllocation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LatentDirichletAllocation must call init() before accessing topic_word_prior_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LatentDirichletAllocation_topic_word_prior_ = bridgeLatentDirichletAllocation[${this.id}].topic_word_prior_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LatentDirichletAllocation_topic_word_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_topic_word_prior_, 'tolist') else attr_LatentDirichletAllocation_topic_word_prior_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mini-batch dictionary learning.\n\n  Finds a dictionary (a set of atoms) that performs well at sparsely encoding the fitted data.\n\n  Solves the optimization problem:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.MiniBatchDictionaryLearning.html)\n */\nexport class MiniBatchDictionaryLearning {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of dictionary elements to extract.\n     */\n    n_components?: number\n\n    /**\n      Sparsity controlling parameter.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Total number of iterations over data batches to perform.\n\n      @defaultValue `1000`\n     */\n    n_iter?: number\n\n    /**\n      Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics. If `max\\_iter` is not `undefined`, `n\\_iter` is ignored.\n     */\n    max_iter?: number\n\n    /**\n      The algorithm used:\n\n      @defaultValue `'lars'`\n     */\n    fit_algorithm?: 'lars' | 'cd'\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Number of samples in each mini-batch.\n\n      @defaultValue `256`\n     */\n    batch_size?: number\n\n    /**\n      Whether to shuffle the samples before forming batches.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      Initial value of the dictionary for warm restart scenarios.\n     */\n    dict_init?: NDArray[]\n\n    /**\n      Algorithm used to transform the data:\n\n      @defaultValue `'omp'`\n     */\n    transform_algorithm?:\n      | 'lasso_lars'\n      | 'lasso_cd'\n      | 'lars'\n      | 'omp'\n      | 'threshold'\n\n    /**\n      Number of nonzero coefficients to target in each column of the solution. This is only used by `algorithm='lars'` and `algorithm='omp'`. If `undefined`, then `transform\\_n\\_nonzero\\_coefs=int(n\\_features / 10)`.\n     */\n    transform_n_nonzero_coefs?: number\n\n    /**\n      If `algorithm='lasso\\_lars'` or `algorithm='lasso\\_cd'`, `alpha` is the penalty applied to the L1 norm. If `algorithm='threshold'`, `alpha` is the absolute value of the threshold below which coefficients will be squashed to zero. If `undefined`, defaults to `alpha`.\n     */\n    transform_alpha?: number\n\n    /**\n      To control the verbosity of the procedure.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.\n\n      @defaultValue `false`\n     */\n    split_sign?: boolean\n\n    /**\n      Used for initializing the dictionary when `dict\\_init` is not specified, randomly shuffling the data when `shuffle` is set to `true`, and updating the dictionary. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Whether to enforce positivity when finding the code.\n\n      @defaultValue `false`\n     */\n    positive_code?: boolean\n\n    /**\n      Whether to enforce positivity when finding the dictionary.\n\n      @defaultValue `false`\n     */\n    positive_dict?: boolean\n\n    /**\n      Maximum number of iterations to perform if `algorithm='lasso\\_cd'` or `'lasso\\_lars'`.\n\n      @defaultValue `1000`\n     */\n    transform_max_iter?: number\n\n    /**\n      A callable that gets invoked at the end of each iteration.\n     */\n    callback?: any\n\n    /**\n      Control early stopping based on the norm of the differences in the dictionary between 2 steps. Used only if `max\\_iter` is not `undefined`.\n\n      To disable early stopping based on changes in the dictionary, set `tol` to 0.0.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. Used only if `max\\_iter` is not `undefined`.\n\n      To disable convergence detection based on cost function, set `max\\_no\\_improvement` to `undefined`.\n\n      @defaultValue `10`\n     */\n    max_no_improvement?: number\n  }) {\n    this.id = `MiniBatchDictionaryLearning${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MiniBatchDictionaryLearning.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\ntry: bridgeMiniBatchDictionaryLearning\nexcept NameError: bridgeMiniBatchDictionaryLearning = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MiniBatchDictionaryLearning = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'fit_algorithm': ${\n      this.opts['fit_algorithm'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'batch_size': ${\n      this.opts['batch_size'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'dict_init': np.array(${\n      this.opts['dict_init'] ?? undefined\n    }) if ${\n      this.opts['dict_init'] !== undefined\n    } else None, 'transform_algorithm': ${\n      this.opts['transform_algorithm'] ?? undefined\n    }, 'transform_n_nonzero_coefs': ${\n      this.opts['transform_n_nonzero_coefs'] ?? undefined\n    }, 'transform_alpha': ${\n      this.opts['transform_alpha'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'split_sign': ${\n      this.opts['split_sign'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'positive_code': ${\n      this.opts['positive_code'] ?? undefined\n    }, 'positive_dict': ${\n      this.opts['positive_dict'] ?? undefined\n    }, 'transform_max_iter': ${\n      this.opts['transform_max_iter'] ?? undefined\n    }, 'callback': ${this.opts['callback'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_no_improvement': ${this.opts['max_no_improvement'] ?? undefined}}\n\nctor_MiniBatchDictionaryLearning = {k: v for k, v in ctor_MiniBatchDictionaryLearning.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMiniBatchDictionaryLearning[${this.id}] = MiniBatchDictionaryLearning(**ctor_MiniBatchDictionaryLearning)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMiniBatchDictionaryLearning[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchDictionaryLearning_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MiniBatchDictionaryLearning_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_fit = bridgeMiniBatchDictionaryLearning[${this.id}].fit(**pms_MiniBatchDictionaryLearning_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit, 'tolist') else res_MiniBatchDictionaryLearning_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_fit_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_fit_transform = bridgeMiniBatchDictionaryLearning[${this.id}].fit_transform(**pms_MiniBatchDictionaryLearning_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_fit_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit_transform, 'tolist') else res_MiniBatchDictionaryLearning_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_get_feature_names_out = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_get_feature_names_out = bridgeMiniBatchDictionaryLearning[${this.id}].get_feature_names_out(**pms_MiniBatchDictionaryLearning_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_get_feature_names_out.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_feature_names_out, 'tolist') else res_MiniBatchDictionaryLearning_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_get_metadata_routing = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_get_metadata_routing = bridgeMiniBatchDictionaryLearning[${this.id}].get_metadata_routing(**pms_MiniBatchDictionaryLearning_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_get_metadata_routing.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_metadata_routing, 'tolist') else res_MiniBatchDictionaryLearning_get_metadata_routing`\n  }\n\n  /**\n    Update the model using the data in X as a mini-batch.\n   */\n  async partial_fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MiniBatchDictionaryLearning_partial_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_partial_fit = bridgeMiniBatchDictionaryLearning[${this.id}].partial_fit(**pms_MiniBatchDictionaryLearning_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_partial_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_partial_fit, 'tolist') else res_MiniBatchDictionaryLearning_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_set_output = {k: v for k, v in pms_MiniBatchDictionaryLearning_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_set_output = bridgeMiniBatchDictionaryLearning[${this.id}].set_output(**pms_MiniBatchDictionaryLearning_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_set_output.tolist() if hasattr(res_MiniBatchDictionaryLearning_set_output, 'tolist') else res_MiniBatchDictionaryLearning_set_output`\n  }\n\n  /**\n    Encode the data as a sparse combination of the dictionary atoms.\n\n    Coding method is determined by the object parameter `transform\\_algorithm`.\n   */\n  async transform(opts: {\n    /**\n      Test data to be transformed, must have the same number of features as the data used to train the model.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchDictionaryLearning_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_transform = bridgeMiniBatchDictionaryLearning[${this.id}].transform(**pms_MiniBatchDictionaryLearning_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_transform, 'tolist') else res_MiniBatchDictionaryLearning_transform`\n  }\n\n  /**\n    Components extracted from the data.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_components_ = bridgeMiniBatchDictionaryLearning[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_components_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_components_, 'tolist') else attr_MiniBatchDictionaryLearning_components_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_features_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_features_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_features_in_, 'tolist') else attr_MiniBatchDictionaryLearning_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_feature_names_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_feature_names_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_feature_names_in_, 'tolist') else attr_MiniBatchDictionaryLearning_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations over the full dataset.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_iter_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_iter_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_iter_, 'tolist') else attr_MiniBatchDictionaryLearning_n_iter_`\n    })()\n  }\n\n  /**\n    Number of mini-batches processed.\n   */\n  get n_steps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_steps_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_steps_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_steps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_steps_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_steps_, 'tolist') else attr_MiniBatchDictionaryLearning_n_steps_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mini-Batch Non-Negative Matrix Factorization (NMF).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.MiniBatchNMF.html)\n */\nexport class MiniBatchNMF {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components, if `n\\_components` is not set all features are kept.\n     */\n    n_components?: number\n\n    /**\n      Method used to initialize the procedure. Valid options:\n     */\n    init?: 'random' | 'nndsvd' | 'nndsvda' | 'nndsvdar' | 'custom'\n\n    /**\n      Number of samples in each mini-batch. Large batch sizes give better long-term convergence at the cost of a slower start.\n\n      @defaultValue `1024`\n     */\n    batch_size?: number\n\n    /**\n      Beta divergence to be minimized, measuring the distance between `X` and the dot product `WH`. Note that values different from ‘frobenius’ (or 2) and ‘kullback-leibler’ (or 1) lead to significantly slower fits. Note that for `beta\\_loss <= 0` (or ‘itakura-saito’), the input matrix `X` cannot contain zeros.\n\n      @defaultValue `'frobenius'`\n     */\n    beta_loss?: number | 'frobenius' | 'kullback-leibler' | 'itakura-saito'\n\n    /**\n      Control early stopping based on the norm of the differences in `H` between 2 steps. To disable early stopping based on changes in `H`, set `tol` to 0.0.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. To disable convergence detection based on cost function, set `max\\_no\\_improvement` to `undefined`.\n\n      @defaultValue `10`\n     */\n    max_no_improvement?: number\n\n    /**\n      Maximum number of iterations over the complete dataset before timing out.\n\n      @defaultValue `200`\n     */\n    max_iter?: number\n\n    /**\n      Constant that multiplies the regularization terms of `W`. Set it to zero (default) to have no regularization on `W`.\n\n      @defaultValue `0`\n     */\n    alpha_W?: number\n\n    /**\n      Constant that multiplies the regularization terms of `H`. Set it to zero to have no regularization on `H`. If “same” (default), it takes the same value as `alpha\\_W`.\n\n      @defaultValue `'same'`\n     */\n    alpha_H?: number | 'same'\n\n    /**\n      The regularization mixing parameter, with 0 <= l1\\_ratio <= 1. For l1\\_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1\\_ratio = 1 it is an elementwise L1 penalty. For 0 < l1\\_ratio < 1, the penalty is a combination of L1 and L2.\n\n      @defaultValue `0`\n     */\n    l1_ratio?: number\n\n    /**\n      Amount of rescaling of past information. Its value could be 1 with finite datasets. Choosing values < 1 is recommended with online learning as more recent batches will weight more than past batches.\n\n      @defaultValue `0.7`\n     */\n    forget_factor?: number\n\n    /**\n      Whether to completely solve for W at each step. Doing fresh restarts will likely lead to a better solution for a same number of iterations but it is much slower.\n\n      @defaultValue `false`\n     */\n    fresh_restarts?: boolean\n\n    /**\n      Maximum number of iterations when solving for W at each step. Only used when doing fresh restarts. These iterations may be stopped early based on a small change of W controlled by `tol`.\n\n      @defaultValue `30`\n     */\n    fresh_restarts_max_iter?: number\n\n    /**\n      Maximum number of iterations when solving for W at transform time. If `undefined`, it defaults to `max\\_iter`.\n     */\n    transform_max_iter?: number\n\n    /**\n      Used for initialisation (when `init` == ‘nndsvdar’ or ‘random’), and in Coordinate Descent. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Whether to be verbose.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `MiniBatchNMF${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MiniBatchNMF.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import MiniBatchNMF\ntry: bridgeMiniBatchNMF\nexcept NameError: bridgeMiniBatchNMF = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MiniBatchNMF = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'init': ${this.opts['init'] ?? undefined}, 'batch_size': ${\n      this.opts['batch_size'] ?? undefined\n    }, 'beta_loss': ${this.opts['beta_loss'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_no_improvement': ${\n      this.opts['max_no_improvement'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'alpha_W': ${\n      this.opts['alpha_W'] ?? undefined\n    }, 'alpha_H': ${this.opts['alpha_H'] ?? undefined}, 'l1_ratio': ${\n      this.opts['l1_ratio'] ?? undefined\n    }, 'forget_factor': ${\n      this.opts['forget_factor'] ?? undefined\n    }, 'fresh_restarts': ${\n      this.opts['fresh_restarts'] ?? undefined\n    }, 'fresh_restarts_max_iter': ${\n      this.opts['fresh_restarts_max_iter'] ?? undefined\n    }, 'transform_max_iter': ${\n      this.opts['transform_max_iter'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_MiniBatchNMF = {k: v for k, v in ctor_MiniBatchNMF.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMiniBatchNMF[${this.id}] = MiniBatchNMF(**ctor_MiniBatchNMF)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMiniBatchNMF[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Learn a NMF model for the data X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Parameters (keyword arguments) and values passed to the fit\\_transform instance.\n     */\n    params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_MiniBatchNMF_fit = {k: v for k, v in pms_MiniBatchNMF_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_fit = bridgeMiniBatchNMF[${this.id}].fit(**pms_MiniBatchNMF_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_fit.tolist() if hasattr(res_MiniBatchNMF_fit, 'tolist') else res_MiniBatchNMF_fit`\n  }\n\n  /**\n    Learn a NMF model for the data X and returns the transformed data.\n\n    This is more efficient than calling fit followed by transform.\n   */\n  async fit_transform(opts: {\n    /**\n      Data matrix to be decomposed.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.\n     */\n    W?: ArrayLike[]\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.\n     */\n    H?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'W': np.array(${opts['W'] ?? undefined}) if ${\n      opts['W'] !== undefined\n    } else None, 'H': np.array(${opts['H'] ?? undefined}) if ${\n      opts['H'] !== undefined\n    } else None}\n\npms_MiniBatchNMF_fit_transform = {k: v for k, v in pms_MiniBatchNMF_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_fit_transform = bridgeMiniBatchNMF[${this.id}].fit_transform(**pms_MiniBatchNMF_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_fit_transform.tolist() if hasattr(res_MiniBatchNMF_fit_transform, 'tolist') else res_MiniBatchNMF_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchNMF_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MiniBatchNMF_get_feature_names_out = {k: v for k, v in pms_MiniBatchNMF_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_get_feature_names_out = bridgeMiniBatchNMF[${this.id}].get_feature_names_out(**pms_MiniBatchNMF_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_get_feature_names_out.tolist() if hasattr(res_MiniBatchNMF_get_feature_names_out, 'tolist') else res_MiniBatchNMF_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MiniBatchNMF_get_metadata_routing = {k: v for k, v in pms_MiniBatchNMF_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_get_metadata_routing = bridgeMiniBatchNMF[${this.id}].get_metadata_routing(**pms_MiniBatchNMF_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_get_metadata_routing.tolist() if hasattr(res_MiniBatchNMF_get_metadata_routing, 'tolist') else res_MiniBatchNMF_get_metadata_routing`\n  }\n\n  /**\n    Transform data back to its original space.\n   */\n  async inverse_transform(opts: {\n    /**\n      Transformed data matrix.\n     */\n    Xt?: NDArray | SparseMatrix[]\n\n    /**\n      Use `Xt` instead.\n     */\n    W?: any\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_inverse_transform = {'Xt': np.array(${\n      opts['Xt'] ?? undefined\n    }) if ${opts['Xt'] !== undefined} else None, 'W': ${opts['W'] ?? undefined}}\n\npms_MiniBatchNMF_inverse_transform = {k: v for k, v in pms_MiniBatchNMF_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_inverse_transform = bridgeMiniBatchNMF[${this.id}].inverse_transform(**pms_MiniBatchNMF_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_inverse_transform.tolist() if hasattr(res_MiniBatchNMF_inverse_transform, 'tolist') else res_MiniBatchNMF_inverse_transform`\n  }\n\n  /**\n    Update the model using the data in `X` as a mini-batch.\n\n    This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.\n\n    This is especially useful when the whole dataset is too big to fit in memory at once (see [Strategies to scale computationally: bigger data](../../computing/scaling_strategies.html#scaling-strategies)).\n   */\n  async partial_fit(opts: {\n    /**\n      Data matrix to be decomposed.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. Only used for the first call to `partial\\_fit`.\n     */\n    W?: ArrayLike[]\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. Only used for the first call to `partial\\_fit`.\n     */\n    H?: ArrayLike[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'W': np.array(${opts['W'] ?? undefined}) if ${\n      opts['W'] !== undefined\n    } else None, 'H': np.array(${opts['H'] ?? undefined}) if ${\n      opts['H'] !== undefined\n    } else None}\n\npms_MiniBatchNMF_partial_fit = {k: v for k, v in pms_MiniBatchNMF_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_partial_fit = bridgeMiniBatchNMF[${this.id}].partial_fit(**pms_MiniBatchNMF_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_partial_fit.tolist() if hasattr(res_MiniBatchNMF_partial_fit, 'tolist') else res_MiniBatchNMF_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MiniBatchNMF_set_output = {k: v for k, v in pms_MiniBatchNMF_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_set_output = bridgeMiniBatchNMF[${this.id}].set_output(**pms_MiniBatchNMF_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_set_output.tolist() if hasattr(res_MiniBatchNMF_set_output, 'tolist') else res_MiniBatchNMF_set_output`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `H` parameter in `partial\\_fit`.\n     */\n    H?: string | boolean\n\n    /**\n      Metadata routing for `W` parameter in `partial\\_fit`.\n     */\n    W?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_set_partial_fit_request = {'H': ${\n      opts['H'] ?? undefined\n    }, 'W': ${opts['W'] ?? undefined}}\n\npms_MiniBatchNMF_set_partial_fit_request = {k: v for k, v in pms_MiniBatchNMF_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_set_partial_fit_request = bridgeMiniBatchNMF[${this.id}].set_partial_fit_request(**pms_MiniBatchNMF_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_set_partial_fit_request.tolist() if hasattr(res_MiniBatchNMF_set_partial_fit_request, 'tolist') else res_MiniBatchNMF_set_partial_fit_request`\n  }\n\n  /**\n    Transform the data X according to the fitted MiniBatchNMF model.\n   */\n  async transform(opts: {\n    /**\n      Data matrix to be transformed by the model.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchNMF_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchNMF_transform = {k: v for k, v in pms_MiniBatchNMF_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchNMF_transform = bridgeMiniBatchNMF[${this.id}].transform(**pms_MiniBatchNMF_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchNMF_transform.tolist() if hasattr(res_MiniBatchNMF_transform, 'tolist') else res_MiniBatchNMF_transform`\n  }\n\n  /**\n    Factorization matrix, sometimes called ‘dictionary’.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_components_ = bridgeMiniBatchNMF[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_components_.tolist() if hasattr(attr_MiniBatchNMF_components_, 'tolist') else attr_MiniBatchNMF_components_`\n    })()\n  }\n\n  /**\n    The number of components. It is same as the `n\\_components` parameter if it was given. Otherwise, it will be same as the number of features.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before accessing n_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_n_components_ = bridgeMiniBatchNMF[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_n_components_.tolist() if hasattr(attr_MiniBatchNMF_n_components_, 'tolist') else attr_MiniBatchNMF_n_components_`\n    })()\n  }\n\n  /**\n    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.\n   */\n  get reconstruction_err_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before accessing reconstruction_err_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_reconstruction_err_ = bridgeMiniBatchNMF[${this.id}].reconstruction_err_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_reconstruction_err_.tolist() if hasattr(attr_MiniBatchNMF_reconstruction_err_, 'tolist') else attr_MiniBatchNMF_reconstruction_err_`\n    })()\n  }\n\n  /**\n    Actual number of started iterations over the whole dataset.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_n_iter_ = bridgeMiniBatchNMF[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_n_iter_.tolist() if hasattr(attr_MiniBatchNMF_n_iter_, 'tolist') else attr_MiniBatchNMF_n_iter_`\n    })()\n  }\n\n  /**\n    Number of mini-batches processed.\n   */\n  get n_steps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchNMF must call init() before accessing n_steps_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_n_steps_ = bridgeMiniBatchNMF[${this.id}].n_steps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_n_steps_.tolist() if hasattr(attr_MiniBatchNMF_n_steps_, 'tolist') else attr_MiniBatchNMF_n_steps_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_n_features_in_ = bridgeMiniBatchNMF[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_n_features_in_.tolist() if hasattr(attr_MiniBatchNMF_n_features_in_, 'tolist') else attr_MiniBatchNMF_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchNMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchNMF must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchNMF_feature_names_in_ = bridgeMiniBatchNMF[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchNMF_feature_names_in_.tolist() if hasattr(attr_MiniBatchNMF_feature_names_in_, 'tolist') else attr_MiniBatchNMF_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mini-batch Sparse Principal Components Analysis.\n\n  Finds the set of sparse components that can optimally reconstruct the data. The amount of sparseness is controllable by the coefficient of the L1 penalty, given by the parameter alpha.\n\n  Read more in the [User Guide](../decomposition.html#sparsepca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.MiniBatchSparsePCA.html)\n */\nexport class MiniBatchSparsePCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of sparse atoms to extract. If `undefined`, then `n\\_components` is set to `n\\_features`.\n     */\n    n_components?: number\n\n    /**\n      Sparsity controlling parameter. Higher values lead to sparser components.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Amount of ridge shrinkage to apply in order to improve conditioning when calling the transform method.\n\n      @defaultValue `0.01`\n     */\n    ridge_alpha?: number\n\n    /**\n      Number of iterations to perform for each mini batch.\n\n      @defaultValue `100`\n     */\n    n_iter?: number\n\n    /**\n      Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics. If `max\\_iter` is not `undefined`, `n\\_iter` is ignored.\n     */\n    max_iter?: number\n\n    /**\n      Callable that gets invoked every five iterations.\n     */\n    callback?: any\n\n    /**\n      The number of features to take in each mini batch.\n\n      @defaultValue `3`\n     */\n    batch_size?: number\n\n    /**\n      Controls the verbosity; the higher, the more messages. Defaults to 0.\n\n      @defaultValue `false`\n     */\n    verbose?: number | boolean\n\n    /**\n      Whether to shuffle the data before splitting it in batches.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Method to be used for optimization. lars: uses the least angle regression method to solve the lasso problem (linear\\_model.lars\\_path) cd: uses the coordinate descent method to compute the Lasso solution (linear\\_model.Lasso). Lars will be faster if the estimated components are sparse.\n\n      @defaultValue `'lars'`\n     */\n    method?: 'lars' | 'cd'\n\n    /**\n      Used for random shuffling when `shuffle` is set to `true`, during online dictionary learning. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Control early stopping based on the norm of the differences in the dictionary between 2 steps. Used only if `max\\_iter` is not `undefined`.\n\n      To disable early stopping based on changes in the dictionary, set `tol` to 0.0.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. Used only if `max\\_iter` is not `undefined`.\n\n      To disable convergence detection based on cost function, set `max\\_no\\_improvement` to `undefined`.\n\n      @defaultValue `10`\n     */\n    max_no_improvement?: number\n  }) {\n    this.id = `MiniBatchSparsePCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MiniBatchSparsePCA.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import MiniBatchSparsePCA\ntry: bridgeMiniBatchSparsePCA\nexcept NameError: bridgeMiniBatchSparsePCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MiniBatchSparsePCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'ridge_alpha': ${\n      this.opts['ridge_alpha'] ?? undefined\n    }, 'n_iter': ${this.opts['n_iter'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'callback': ${this.opts['callback'] ?? undefined}, 'batch_size': ${\n      this.opts['batch_size'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'shuffle': ${\n      this.opts['shuffle'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'method': ${\n      this.opts['method'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_no_improvement': ${this.opts['max_no_improvement'] ?? undefined}}\n\nctor_MiniBatchSparsePCA = {k: v for k, v in ctor_MiniBatchSparsePCA.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMiniBatchSparsePCA[${this.id}] = MiniBatchSparsePCA(**ctor_MiniBatchSparsePCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMiniBatchSparsePCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchSparsePCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchSparsePCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MiniBatchSparsePCA_fit = {k: v for k, v in pms_MiniBatchSparsePCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_fit = bridgeMiniBatchSparsePCA[${this.id}].fit(**pms_MiniBatchSparsePCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_fit.tolist() if hasattr(res_MiniBatchSparsePCA_fit, 'tolist') else res_MiniBatchSparsePCA_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchSparsePCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_MiniBatchSparsePCA_fit_transform = {k: v for k, v in pms_MiniBatchSparsePCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_fit_transform = bridgeMiniBatchSparsePCA[${this.id}].fit_transform(**pms_MiniBatchSparsePCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_fit_transform.tolist() if hasattr(res_MiniBatchSparsePCA_fit_transform, 'tolist') else res_MiniBatchSparsePCA_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchSparsePCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MiniBatchSparsePCA_get_feature_names_out = {k: v for k, v in pms_MiniBatchSparsePCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_get_feature_names_out = bridgeMiniBatchSparsePCA[${this.id}].get_feature_names_out(**pms_MiniBatchSparsePCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_get_feature_names_out.tolist() if hasattr(res_MiniBatchSparsePCA_get_feature_names_out, 'tolist') else res_MiniBatchSparsePCA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchSparsePCA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MiniBatchSparsePCA_get_metadata_routing = {k: v for k, v in pms_MiniBatchSparsePCA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_get_metadata_routing = bridgeMiniBatchSparsePCA[${this.id}].get_metadata_routing(**pms_MiniBatchSparsePCA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_get_metadata_routing.tolist() if hasattr(res_MiniBatchSparsePCA_get_metadata_routing, 'tolist') else res_MiniBatchSparsePCA_get_metadata_routing`\n  }\n\n  /**\n    Transform data from the latent space to the original space.\n\n    This inversion is an approximation due to the loss of information induced by the forward decomposition.\n   */\n  async inverse_transform(opts: {\n    /**\n      Data in the latent space.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchSparsePCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchSparsePCA_inverse_transform = {k: v for k, v in pms_MiniBatchSparsePCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_inverse_transform = bridgeMiniBatchSparsePCA[${this.id}].inverse_transform(**pms_MiniBatchSparsePCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_inverse_transform.tolist() if hasattr(res_MiniBatchSparsePCA_inverse_transform, 'tolist') else res_MiniBatchSparsePCA_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchSparsePCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchSparsePCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MiniBatchSparsePCA_set_output = {k: v for k, v in pms_MiniBatchSparsePCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_set_output = bridgeMiniBatchSparsePCA[${this.id}].set_output(**pms_MiniBatchSparsePCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_set_output.tolist() if hasattr(res_MiniBatchSparsePCA_set_output, 'tolist') else res_MiniBatchSparsePCA_set_output`\n  }\n\n  /**\n    Least Squares projection of the data onto the sparse components.\n\n    To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\\_alpha` parameter.\n\n    Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.\n   */\n  async transform(opts: {\n    /**\n      Test data to be transformed, must have the same number of features as the data used to train the model.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchSparsePCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchSparsePCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchSparsePCA_transform = {k: v for k, v in pms_MiniBatchSparsePCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchSparsePCA_transform = bridgeMiniBatchSparsePCA[${this.id}].transform(**pms_MiniBatchSparsePCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchSparsePCA_transform.tolist() if hasattr(res_MiniBatchSparsePCA_transform, 'tolist') else res_MiniBatchSparsePCA_transform`\n  }\n\n  /**\n    Sparse components extracted from the data.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_components_ = bridgeMiniBatchSparsePCA[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_components_, 'tolist') else attr_MiniBatchSparsePCA_components_`\n    })()\n  }\n\n  /**\n    Estimated number of components.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing n_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_n_components_ = bridgeMiniBatchSparsePCA[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_n_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_components_, 'tolist') else attr_MiniBatchSparsePCA_n_components_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_n_iter_ = bridgeMiniBatchSparsePCA[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_n_iter_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_iter_, 'tolist') else attr_MiniBatchSparsePCA_n_iter_`\n    })()\n  }\n\n  /**\n    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing mean_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_mean_ = bridgeMiniBatchSparsePCA[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_mean_.tolist() if hasattr(attr_MiniBatchSparsePCA_mean_, 'tolist') else attr_MiniBatchSparsePCA_mean_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_n_features_in_ = bridgeMiniBatchSparsePCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_n_features_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_features_in_, 'tolist') else attr_MiniBatchSparsePCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchSparsePCA instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchSparsePCA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchSparsePCA_feature_names_in_ = bridgeMiniBatchSparsePCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchSparsePCA_feature_names_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_feature_names_in_, 'tolist') else attr_MiniBatchSparsePCA_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Non-Negative Matrix Factorization (NMF).\n\n  Find two non-negative matrices, i.e. matrices with all non-negative elements, (W, H) whose product approximates the non-negative matrix X. This factorization can be used for example for dimensionality reduction, source separation or topic extraction.\n\n  The objective function is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.NMF.html)\n */\nexport class NMF {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components, if n\\_components is not set all features are kept.\n     */\n    n_components?: number\n\n    /**\n      Method used to initialize the procedure. Valid options:\n     */\n    init?: 'random' | 'nndsvd' | 'nndsvda' | 'nndsvdar' | 'custom'\n\n    /**\n      Numerical solver to use:\n\n      @defaultValue `'cd'`\n     */\n    solver?: 'cd' | 'mu'\n\n    /**\n      Beta divergence to be minimized, measuring the distance between X and the dot product WH. Note that values different from ‘frobenius’ (or 2) and ‘kullback-leibler’ (or 1) lead to significantly slower fits. Note that for beta\\_loss <= 0 (or ‘itakura-saito’), the input matrix X cannot contain zeros. Used only in ‘mu’ solver.\n\n      @defaultValue `'frobenius'`\n     */\n    beta_loss?: number | 'frobenius' | 'kullback-leibler' | 'itakura-saito'\n\n    /**\n      Tolerance of the stopping condition.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations before timing out.\n\n      @defaultValue `200`\n     */\n    max_iter?: number\n\n    /**\n      Used for initialisation (when `init` == ‘nndsvdar’ or ‘random’), and in Coordinate Descent. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Constant that multiplies the regularization terms of `W`. Set it to zero (default) to have no regularization on `W`.\n\n      @defaultValue `0`\n     */\n    alpha_W?: number\n\n    /**\n      Constant that multiplies the regularization terms of `H`. Set it to zero to have no regularization on `H`. If “same” (default), it takes the same value as `alpha\\_W`.\n\n      @defaultValue `'same'`\n     */\n    alpha_H?: number | 'same'\n\n    /**\n      The regularization mixing parameter, with 0 <= l1\\_ratio <= 1. For l1\\_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1\\_ratio = 1 it is an elementwise L1 penalty. For 0 < l1\\_ratio < 1, the penalty is a combination of L1 and L2.\n\n      @defaultValue `0`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether to be verbose.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      If true, randomize the order of coordinates in the CD solver.\n\n      @defaultValue `false`\n     */\n    shuffle?: boolean\n  }) {\n    this.id = `NMF${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NMF.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import NMF\ntry: bridgeNMF\nexcept NameError: bridgeNMF = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NMF = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'init': ${this.opts['init'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'beta_loss': ${this.opts['beta_loss'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'alpha_W': ${this.opts['alpha_W'] ?? undefined}, 'alpha_H': ${\n      this.opts['alpha_H'] ?? undefined\n    }, 'l1_ratio': ${this.opts['l1_ratio'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}}\n\nctor_NMF = {k: v for k, v in ctor_NMF.items() if v is not None}`\n\n    await this._py.ex`bridgeNMF[${this.id}] = NMF(**ctor_NMF)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNMF[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Learn a NMF model for the data X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Parameters (keyword arguments) and values passed to the fit\\_transform instance.\n     */\n    params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_NMF_fit = {k: v for k, v in pms_NMF_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_NMF_fit = bridgeNMF[${this.id}].fit(**pms_NMF_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_fit.tolist() if hasattr(res_NMF_fit, 'tolist') else res_NMF_fit`\n  }\n\n  /**\n    Learn a NMF model for the data X and returns the transformed data.\n\n    This is more efficient than calling fit followed by transform.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.\n     */\n    W?: ArrayLike[]\n\n    /**\n      If `init='custom'`, it is used as initial guess for the solution. If `undefined`, uses the initialisation method specified in `init`.\n     */\n    H?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'W': np.array(${opts['W'] ?? undefined}) if ${\n      opts['W'] !== undefined\n    } else None, 'H': np.array(${opts['H'] ?? undefined}) if ${\n      opts['H'] !== undefined\n    } else None}\n\npms_NMF_fit_transform = {k: v for k, v in pms_NMF_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_fit_transform = bridgeNMF[${this.id}].fit_transform(**pms_NMF_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_fit_transform.tolist() if hasattr(res_NMF_fit_transform, 'tolist') else res_NMF_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_NMF_get_feature_names_out = {k: v for k, v in pms_NMF_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_get_feature_names_out = bridgeNMF[${this.id}].get_feature_names_out(**pms_NMF_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_get_feature_names_out.tolist() if hasattr(res_NMF_get_feature_names_out, 'tolist') else res_NMF_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NMF_get_metadata_routing = {k: v for k, v in pms_NMF_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_get_metadata_routing = bridgeNMF[${this.id}].get_metadata_routing(**pms_NMF_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_get_metadata_routing.tolist() if hasattr(res_NMF_get_metadata_routing, 'tolist') else res_NMF_get_metadata_routing`\n  }\n\n  /**\n    Transform data back to its original space.\n   */\n  async inverse_transform(opts: {\n    /**\n      Transformed data matrix.\n     */\n    Xt?: NDArray | SparseMatrix[]\n\n    /**\n      Use `Xt` instead.\n     */\n    W?: any\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_inverse_transform = {'Xt': np.array(${\n      opts['Xt'] ?? undefined\n    }) if ${opts['Xt'] !== undefined} else None, 'W': ${opts['W'] ?? undefined}}\n\npms_NMF_inverse_transform = {k: v for k, v in pms_NMF_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_inverse_transform = bridgeNMF[${this.id}].inverse_transform(**pms_NMF_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_inverse_transform.tolist() if hasattr(res_NMF_inverse_transform, 'tolist') else res_NMF_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_NMF_set_output = {k: v for k, v in pms_NMF_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_set_output = bridgeNMF[${this.id}].set_output(**pms_NMF_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_set_output.tolist() if hasattr(res_NMF_set_output, 'tolist') else res_NMF_set_output`\n  }\n\n  /**\n    Transform the data X according to the fitted NMF model.\n   */\n  async transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NMF_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NMF_transform = {k: v for k, v in pms_NMF_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NMF_transform = bridgeNMF[${this.id}].transform(**pms_NMF_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NMF_transform.tolist() if hasattr(res_NMF_transform, 'tolist') else res_NMF_transform`\n  }\n\n  /**\n    Factorization matrix, sometimes called ‘dictionary’.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NMF_components_ = bridgeNMF[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_components_.tolist() if hasattr(attr_NMF_components_, 'tolist') else attr_NMF_components_`\n    })()\n  }\n\n  /**\n    The number of components. It is same as the `n\\_components` parameter if it was given. Otherwise, it will be same as the number of features.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before accessing n_components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NMF_n_components_ = bridgeNMF[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_n_components_.tolist() if hasattr(attr_NMF_n_components_, 'tolist') else attr_NMF_n_components_`\n    })()\n  }\n\n  /**\n    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.\n   */\n  get reconstruction_err_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NMF must call init() before accessing reconstruction_err_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NMF_reconstruction_err_ = bridgeNMF[${this.id}].reconstruction_err_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_reconstruction_err_.tolist() if hasattr(attr_NMF_reconstruction_err_, 'tolist') else attr_NMF_reconstruction_err_`\n    })()\n  }\n\n  /**\n    Actual number of iterations.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NMF_n_iter_ = bridgeNMF[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_n_iter_.tolist() if hasattr(attr_NMF_n_iter_, 'tolist') else attr_NMF_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NMF_n_features_in_ = bridgeNMF[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_n_features_in_.tolist() if hasattr(attr_NMF_n_features_in_, 'tolist') else attr_NMF_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NMF instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NMF must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NMF_feature_names_in_ = bridgeNMF[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NMF_feature_names_in_.tolist() if hasattr(attr_NMF_feature_names_in_, 'tolist') else attr_NMF_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Principal component analysis (PCA).\n\n  Linear dimensionality reduction using Singular Value Decomposition of the data to project it to a lower dimensional space. The input data is centered but not scaled for each feature before applying the SVD.\n\n  It uses the LAPACK implementation of the full SVD or a randomized truncated SVD by the method of Halko et al. 2009, depending on the shape of the input data and the number of components to extract.\n\n  It can also use the scipy.sparse.linalg ARPACK implementation of the truncated SVD.\n\n  Notice that this class does not support sparse input. See [`TruncatedSVD`](sklearn.decomposition.TruncatedSVD.html#sklearn.decomposition.TruncatedSVD \"sklearn.decomposition.TruncatedSVD\") for an alternative with sparse data.\n\n  Read more in the [User Guide](../decomposition.html#pca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html)\n */\nexport class PCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components to keep. if n\\_components is not set all components are kept:\n     */\n    n_components?: number | 'mle'\n\n    /**\n      If `false`, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit\\_transform(X) instead.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      When `true` (`false` by default) the `components\\_` vectors are multiplied by the square root of n\\_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances.\n\n      Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometime improve the predictive accuracy of the downstream estimators by making their data respect some hard-wired assumptions.\n\n      @defaultValue `false`\n     */\n    whiten?: boolean\n\n    /**\n      The solver is selected by a default policy based on `X.shape` and `n\\_components`: if the input data is larger than 500x500 and the number of components to extract is lower than 80% of the smallest dimension of the data, then the more efficient ‘randomized’ method is enabled. Otherwise the exact full SVD is computed and optionally truncated afterwards.\n\n      @defaultValue `'auto'`\n     */\n    svd_solver?: 'auto' | 'full' | 'arpack' | 'randomized'\n\n    /**\n      Tolerance for singular values computed by svd\\_solver == ‘arpack’. Must be of range \\[0.0, infinity).\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Number of iterations for the power method computed by svd\\_solver == ‘randomized’. Must be of range \\[0, infinity).\n\n      @defaultValue `'auto'`\n     */\n    iterated_power?: number | 'auto'\n\n    /**\n      This parameter is only relevant when `svd\\_solver=\"randomized\"`. It corresponds to the additional number of random vectors to sample the range of `X` so as to ensure proper conditioning. See [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\") for more details.\n\n      @defaultValue `10`\n     */\n    n_oversamples?: number\n\n    /**\n      Power iteration normalizer for randomized SVD solver. Not used by ARPACK. See [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\") for more details.\n\n      @defaultValue `'auto'`\n     */\n    power_iteration_normalizer?: 'auto' | 'QR' | 'LU' | 'none'\n\n    /**\n      Used when the ‘arpack’ or ‘randomized’ solvers are used. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `PCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('PCA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import PCA\ntry: bridgePCA\nexcept NameError: bridgePCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}, 'whiten': ${\n      this.opts['whiten'] ?? undefined\n    }, 'svd_solver': ${this.opts['svd_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'iterated_power': ${\n      this.opts['iterated_power'] ?? undefined\n    }, 'n_oversamples': ${\n      this.opts['n_oversamples'] ?? undefined\n    }, 'power_iteration_normalizer': ${\n      this.opts['power_iteration_normalizer'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_PCA = {k: v for k, v in ctor_PCA.items() if v is not None}`\n\n    await this._py.ex`bridgePCA[${this.id}] = PCA(**ctor_PCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model with X.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PCA_fit = {k: v for k, v in pms_PCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_PCA_fit = bridgePCA[${this.id}].fit(**pms_PCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_fit.tolist() if hasattr(res_PCA_fit, 'tolist') else res_PCA_fit`\n  }\n\n  /**\n    Fit the model with X and apply the dimensionality reduction on X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PCA_fit_transform = {k: v for k, v in pms_PCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_fit_transform = bridgePCA[${this.id}].fit_transform(**pms_PCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_fit_transform.tolist() if hasattr(res_PCA_fit_transform, 'tolist') else res_PCA_fit_transform`\n  }\n\n  /**\n    Compute data covariance with the generative model.\n\n    `cov \\= components\\_.T \\* S\\*\\*2 \\* components\\_ + sigma2 \\* eye(n\\_features)` where S\\*\\*2 contains the explained variances, and sigma2 contains the noise variances.\n   */\n  async get_covariance(opts: {\n    /**\n      Estimated covariance of data.\n     */\n    cov?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before get_covariance()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_get_covariance = {'cov': np.array(${\n      opts['cov'] ?? undefined\n    }) if ${opts['cov'] !== undefined} else None}\n\npms_PCA_get_covariance = {k: v for k, v in pms_PCA_get_covariance.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_get_covariance = bridgePCA[${this.id}].get_covariance(**pms_PCA_get_covariance)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_get_covariance.tolist() if hasattr(res_PCA_get_covariance, 'tolist') else res_PCA_get_covariance`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_PCA_get_feature_names_out = {k: v for k, v in pms_PCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_get_feature_names_out = bridgePCA[${this.id}].get_feature_names_out(**pms_PCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_get_feature_names_out.tolist() if hasattr(res_PCA_get_feature_names_out, 'tolist') else res_PCA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PCA_get_metadata_routing = {k: v for k, v in pms_PCA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_get_metadata_routing = bridgePCA[${this.id}].get_metadata_routing(**pms_PCA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_get_metadata_routing.tolist() if hasattr(res_PCA_get_metadata_routing, 'tolist') else res_PCA_get_metadata_routing`\n  }\n\n  /**\n    Compute data precision matrix with the generative model.\n\n    Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.\n   */\n  async get_precision(opts: {\n    /**\n      Estimated precision of data.\n     */\n    precision?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before get_precision()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_get_precision = {'precision': ${\n      opts['precision'] ?? undefined\n    }}\n\npms_PCA_get_precision = {k: v for k, v in pms_PCA_get_precision.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_get_precision = bridgePCA[${this.id}].get_precision(**pms_PCA_get_precision)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_get_precision.tolist() if hasattr(res_PCA_get_precision, 'tolist') else res_PCA_get_precision`\n  }\n\n  /**\n    Transform data back to its original space.\n\n    In other words, return an input `X\\_original` whose transform would be X.\n   */\n  async inverse_transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_components` is the number of components.\n     */\n    X?: ArrayLike[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PCA_inverse_transform = {k: v for k, v in pms_PCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_inverse_transform = bridgePCA[${this.id}].inverse_transform(**pms_PCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_inverse_transform.tolist() if hasattr(res_PCA_inverse_transform, 'tolist') else res_PCA_inverse_transform`\n  }\n\n  /**\n    Return the average log-likelihood of all samples.\n\n    See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)\n   */\n  async score(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_PCA_score = {k: v for k, v in pms_PCA_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_score = bridgePCA[${this.id}].score(**pms_PCA_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_score.tolist() if hasattr(res_PCA_score, 'tolist') else res_PCA_score`\n  }\n\n  /**\n    Return the log-likelihood of each sample.\n\n    See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)\n   */\n  async score_samples(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PCA_score_samples = {k: v for k, v in pms_PCA_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_score_samples = bridgePCA[${this.id}].score_samples(**pms_PCA_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_score_samples.tolist() if hasattr(res_PCA_score_samples, 'tolist') else res_PCA_score_samples`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_PCA_set_output = {k: v for k, v in pms_PCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_set_output = bridgePCA[${this.id}].set_output(**pms_PCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_set_output.tolist() if hasattr(res_PCA_set_output, 'tolist') else res_PCA_set_output`\n  }\n\n  /**\n    Apply dimensionality reduction to X.\n\n    X is projected on the first principal components previously extracted from a training set.\n   */\n  async transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PCA_transform = {k: v for k, v in pms_PCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PCA_transform = bridgePCA[${this.id}].transform(**pms_PCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PCA_transform.tolist() if hasattr(res_PCA_transform, 'tolist') else res_PCA_transform`\n  }\n\n  /**\n    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\\_variance\\_`.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_components_ = bridgePCA[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_components_.tolist() if hasattr(attr_PCA_components_, 'tolist') else attr_PCA_components_`\n    })()\n  }\n\n  /**\n    The amount of variance explained by each of the selected components. The variance estimation uses `n\\_samples \\- 1` degrees of freedom.\n\n    Equal to n\\_components largest eigenvalues of the covariance matrix of X.\n   */\n  get explained_variance_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PCA must call init() before accessing explained_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_explained_variance_ = bridgePCA[${this.id}].explained_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_explained_variance_.tolist() if hasattr(attr_PCA_explained_variance_, 'tolist') else attr_PCA_explained_variance_`\n    })()\n  }\n\n  /**\n    Percentage of variance explained by each of the selected components.\n\n    If `n\\_components` is not set then all components are stored and the sum of the ratios is equal to 1.0.\n   */\n  get explained_variance_ratio_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PCA must call init() before accessing explained_variance_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_explained_variance_ratio_ = bridgePCA[${this.id}].explained_variance_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_explained_variance_ratio_.tolist() if hasattr(attr_PCA_explained_variance_ratio_, 'tolist') else attr_PCA_explained_variance_ratio_`\n    })()\n  }\n\n  /**\n    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\\_components` variables in the lower-dimensional space.\n   */\n  get singular_values_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing singular_values_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_singular_values_ = bridgePCA[${this.id}].singular_values_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_singular_values_.tolist() if hasattr(attr_PCA_singular_values_, 'tolist') else attr_PCA_singular_values_`\n    })()\n  }\n\n  /**\n    Per-feature empirical mean, estimated from the training set.\n\n    Equal to `X.mean(axis=0)`.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_PCA_mean_ = bridgePCA[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_mean_.tolist() if hasattr(attr_PCA_mean_, 'tolist') else attr_PCA_mean_`\n    })()\n  }\n\n  /**\n    The estimated number of components. When n\\_components is set to ‘mle’ or a number between 0 and 1 (with svd\\_solver == ‘full’) this number is estimated from input data. Otherwise it equals the parameter n\\_components, or the lesser value of n\\_features and n\\_samples if n\\_components is `undefined`.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing n_components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_n_components_ = bridgePCA[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_n_components_.tolist() if hasattr(attr_PCA_n_components_, 'tolist') else attr_PCA_n_components_`\n    })()\n  }\n\n  /**\n    Number of features in the training data.\n   */\n  get n_features_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing n_features_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_n_features_ = bridgePCA[${this.id}].n_features_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_n_features_.tolist() if hasattr(attr_PCA_n_features_, 'tolist') else attr_PCA_n_features_`\n    })()\n  }\n\n  /**\n    Number of samples in the training data.\n   */\n  get n_samples_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing n_samples_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_PCA_n_samples_ = bridgePCA[${this.id}].n_samples_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_n_samples_.tolist() if hasattr(attr_PCA_n_samples_, 'tolist') else attr_PCA_n_samples_`\n    })()\n  }\n\n  /**\n    The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf). It is required to compute the estimated data covariance and score samples.\n\n    Equal to the average of (min(n\\_features, n\\_samples) - n\\_components) smallest eigenvalues of the covariance matrix of X.\n   */\n  get noise_variance_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing noise_variance_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_noise_variance_ = bridgePCA[${this.id}].noise_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_noise_variance_.tolist() if hasattr(attr_PCA_noise_variance_, 'tolist') else attr_PCA_noise_variance_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_n_features_in_ = bridgePCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_n_features_in_.tolist() if hasattr(attr_PCA_n_features_in_, 'tolist') else attr_PCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This PCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PCA must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PCA_feature_names_in_ = bridgePCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PCA_feature_names_in_.tolist() if hasattr(attr_PCA_feature_names_in_, 'tolist') else attr_PCA_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Sparse coding.\n\n  Finds a sparse representation of data against a fixed, precomputed dictionary.\n\n  Each row of the result is the solution to a sparse coding problem. The goal is to find a sparse array `code` such that:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.SparseCoder.html)\n */\nexport class SparseCoder {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The dictionary atoms used for sparse coding. Lines are assumed to be normalized to unit norm.\n     */\n    dictionary?: NDArray[]\n\n    /**\n      Algorithm used to transform the data:\n\n      @defaultValue `'omp'`\n     */\n    transform_algorithm?:\n      | 'lasso_lars'\n      | 'lasso_cd'\n      | 'lars'\n      | 'omp'\n      | 'threshold'\n\n    /**\n      Number of nonzero coefficients to target in each column of the solution. This is only used by `algorithm='lars'` and `algorithm='omp'` and is overridden by `alpha` in the `omp` case. If `undefined`, then `transform\\_n\\_nonzero\\_coefs=int(n\\_features / 10)`.\n     */\n    transform_n_nonzero_coefs?: number\n\n    /**\n      If `algorithm='lasso\\_lars'` or `algorithm='lasso\\_cd'`, `alpha` is the penalty applied to the L1 norm. If `algorithm='threshold'`, `alpha` is the absolute value of the threshold below which coefficients will be squashed to zero. If `algorithm='omp'`, `alpha` is the tolerance parameter: the value of the reconstruction error targeted. In this case, it overrides `n\\_nonzero\\_coefs`. If `undefined`, default to 1.\n     */\n    transform_alpha?: number\n\n    /**\n      Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.\n\n      @defaultValue `false`\n     */\n    split_sign?: boolean\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Whether to enforce positivity when finding the code.\n\n      @defaultValue `false`\n     */\n    positive_code?: boolean\n\n    /**\n      Maximum number of iterations to perform if `algorithm='lasso\\_cd'` or `lasso\\_lars`.\n\n      @defaultValue `1000`\n     */\n    transform_max_iter?: number\n  }) {\n    this.id = `SparseCoder${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SparseCoder.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import SparseCoder\ntry: bridgeSparseCoder\nexcept NameError: bridgeSparseCoder = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SparseCoder = {'dictionary': np.array(${\n      this.opts['dictionary'] ?? undefined\n    }) if ${\n      this.opts['dictionary'] !== undefined\n    } else None, 'transform_algorithm': ${\n      this.opts['transform_algorithm'] ?? undefined\n    }, 'transform_n_nonzero_coefs': ${\n      this.opts['transform_n_nonzero_coefs'] ?? undefined\n    }, 'transform_alpha': ${\n      this.opts['transform_alpha'] ?? undefined\n    }, 'split_sign': ${this.opts['split_sign'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'positive_code': ${\n      this.opts['positive_code'] ?? undefined\n    }, 'transform_max_iter': ${this.opts['transform_max_iter'] ?? undefined}}\n\nctor_SparseCoder = {k: v for k, v in ctor_SparseCoder.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSparseCoder[${this.id}] = SparseCoder(**ctor_SparseCoder)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSparseCoder[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Do nothing and return the estimator unchanged.\n\n    This method is just there to implement the usual API and hence work in pipelines.\n   */\n  async fit(opts: {\n    /**\n      Not used, present for API consistency by convention.\n     */\n    X?: any\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparseCoder must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparseCoder_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_SparseCoder_fit = {k: v for k, v in pms_SparseCoder_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_fit = bridgeSparseCoder[${this.id}].fit(**pms_SparseCoder_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_fit.tolist() if hasattr(res_SparseCoder_fit, 'tolist') else res_SparseCoder_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparseCoder must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparseCoder_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SparseCoder_fit_transform = {k: v for k, v in pms_SparseCoder_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_fit_transform = bridgeSparseCoder[${this.id}].fit_transform(**pms_SparseCoder_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_fit_transform.tolist() if hasattr(res_SparseCoder_fit_transform, 'tolist') else res_SparseCoder_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparseCoder must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SparseCoder_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SparseCoder_get_feature_names_out = {k: v for k, v in pms_SparseCoder_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_get_feature_names_out = bridgeSparseCoder[${this.id}].get_feature_names_out(**pms_SparseCoder_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_get_feature_names_out.tolist() if hasattr(res_SparseCoder_get_feature_names_out, 'tolist') else res_SparseCoder_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparseCoder must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparseCoder_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SparseCoder_get_metadata_routing = {k: v for k, v in pms_SparseCoder_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_get_metadata_routing = bridgeSparseCoder[${this.id}].get_metadata_routing(**pms_SparseCoder_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_get_metadata_routing.tolist() if hasattr(res_SparseCoder_get_metadata_routing, 'tolist') else res_SparseCoder_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparseCoder must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparseCoder_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SparseCoder_set_output = {k: v for k, v in pms_SparseCoder_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_set_output = bridgeSparseCoder[${this.id}].set_output(**pms_SparseCoder_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_set_output.tolist() if hasattr(res_SparseCoder_set_output, 'tolist') else res_SparseCoder_set_output`\n  }\n\n  /**\n    Encode the data as a sparse combination of the dictionary atoms.\n\n    Coding method is determined by the object parameter `transform\\_algorithm`.\n   */\n  async transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: NDArray[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparseCoder must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparseCoder_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SparseCoder_transform = {k: v for k, v in pms_SparseCoder_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparseCoder_transform = bridgeSparseCoder[${this.id}].transform(**pms_SparseCoder_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparseCoder_transform.tolist() if hasattr(res_SparseCoder_transform, 'tolist') else res_SparseCoder_transform`\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SparseCoder instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparseCoder must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparseCoder_feature_names_in_ = bridgeSparseCoder[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparseCoder_feature_names_in_.tolist() if hasattr(attr_SparseCoder_feature_names_in_, 'tolist') else attr_SparseCoder_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Sparse Principal Components Analysis (SparsePCA).\n\n  Finds the set of sparse components that can optimally reconstruct the data. The amount of sparseness is controllable by the coefficient of the L1 penalty, given by the parameter alpha.\n\n  Read more in the [User Guide](../decomposition.html#sparsepca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.SparsePCA.html)\n */\nexport class SparsePCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of sparse atoms to extract. If `undefined`, then `n\\_components` is set to `n\\_features`.\n     */\n    n_components?: number\n\n    /**\n      Sparsity controlling parameter. Higher values lead to sparser components.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Amount of ridge shrinkage to apply in order to improve conditioning when calling the transform method.\n\n      @defaultValue `0.01`\n     */\n    ridge_alpha?: number\n\n    /**\n      Maximum number of iterations to perform.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      Tolerance for the stopping condition.\n\n      @defaultValue `1e-8`\n     */\n    tol?: number\n\n    /**\n      Method to be used for optimization. lars: uses the least angle regression method to solve the lasso problem (linear\\_model.lars\\_path) cd: uses the coordinate descent method to compute the Lasso solution (linear\\_model.Lasso). Lars will be faster if the estimated components are sparse.\n\n      @defaultValue `'lars'`\n     */\n    method?: 'lars' | 'cd'\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Initial values for the loadings for warm restart scenarios. Only used if `U\\_init` and `V\\_init` are not `undefined`.\n     */\n    U_init?: NDArray[]\n\n    /**\n      Initial values for the components for warm restart scenarios. Only used if `U\\_init` and `V\\_init` are not `undefined`.\n     */\n    V_init?: NDArray[]\n\n    /**\n      Controls the verbosity; the higher, the more messages. Defaults to 0.\n\n      @defaultValue `false`\n     */\n    verbose?: number | boolean\n\n    /**\n      Used during dictionary learning. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SparsePCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SparsePCA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import SparsePCA\ntry: bridgeSparsePCA\nexcept NameError: bridgeSparsePCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SparsePCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'ridge_alpha': ${\n      this.opts['ridge_alpha'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'method': ${this.opts['method'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'U_init': np.array(${this.opts['U_init'] ?? undefined}) if ${\n      this.opts['U_init'] !== undefined\n    } else None, 'V_init': np.array(${this.opts['V_init'] ?? undefined}) if ${\n      this.opts['V_init'] !== undefined\n    } else None, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_SparsePCA = {k: v for k, v in ctor_SparsePCA.items() if v is not None}`\n\n    await this._py.ex`bridgeSparsePCA[${this.id}] = SparsePCA(**ctor_SparsePCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSparsePCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SparsePCA_fit = {k: v for k, v in pms_SparsePCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_fit = bridgeSparsePCA[${this.id}].fit(**pms_SparsePCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_fit.tolist() if hasattr(res_SparsePCA_fit, 'tolist') else res_SparsePCA_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SparsePCA_fit_transform = {k: v for k, v in pms_SparsePCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_fit_transform = bridgeSparsePCA[${this.id}].fit_transform(**pms_SparsePCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_fit_transform.tolist() if hasattr(res_SparsePCA_fit_transform, 'tolist') else res_SparsePCA_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparsePCA must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SparsePCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SparsePCA_get_feature_names_out = {k: v for k, v in pms_SparsePCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_get_feature_names_out = bridgeSparsePCA[${this.id}].get_feature_names_out(**pms_SparsePCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_get_feature_names_out.tolist() if hasattr(res_SparsePCA_get_feature_names_out, 'tolist') else res_SparsePCA_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparsePCA must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SparsePCA_get_metadata_routing = {k: v for k, v in pms_SparsePCA_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_get_metadata_routing = bridgeSparsePCA[${this.id}].get_metadata_routing(**pms_SparsePCA_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_get_metadata_routing.tolist() if hasattr(res_SparsePCA_get_metadata_routing, 'tolist') else res_SparsePCA_get_metadata_routing`\n  }\n\n  /**\n    Transform data from the latent space to the original space.\n\n    This inversion is an approximation due to the loss of information induced by the forward decomposition.\n   */\n  async inverse_transform(opts: {\n    /**\n      Data in the latent space.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SparsePCA_inverse_transform = {k: v for k, v in pms_SparsePCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_inverse_transform = bridgeSparsePCA[${this.id}].inverse_transform(**pms_SparsePCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_inverse_transform.tolist() if hasattr(res_SparsePCA_inverse_transform, 'tolist') else res_SparsePCA_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SparsePCA_set_output = {k: v for k, v in pms_SparsePCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_set_output = bridgeSparsePCA[${this.id}].set_output(**pms_SparsePCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_set_output.tolist() if hasattr(res_SparsePCA_set_output, 'tolist') else res_SparsePCA_set_output`\n  }\n\n  /**\n    Least Squares projection of the data onto the sparse components.\n\n    To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\\_alpha` parameter.\n\n    Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.\n   */\n  async transform(opts: {\n    /**\n      Test data to be transformed, must have the same number of features as the data used to train the model.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SparsePCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SparsePCA_transform = {k: v for k, v in pms_SparsePCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SparsePCA_transform = bridgeSparsePCA[${this.id}].transform(**pms_SparsePCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SparsePCA_transform.tolist() if hasattr(res_SparsePCA_transform, 'tolist') else res_SparsePCA_transform`\n  }\n\n  /**\n    Sparse components extracted from the data.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_components_ = bridgeSparsePCA[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_components_.tolist() if hasattr(attr_SparsePCA_components_, 'tolist') else attr_SparsePCA_components_`\n    })()\n  }\n\n  /**\n    Vector of errors at each iteration.\n   */\n  get error_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before accessing error_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_error_ = bridgeSparsePCA[${this.id}].error_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_error_.tolist() if hasattr(attr_SparsePCA_error_, 'tolist') else attr_SparsePCA_error_`\n    })()\n  }\n\n  /**\n    Estimated number of components.\n   */\n  get n_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparsePCA must call init() before accessing n_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_n_components_ = bridgeSparsePCA[${this.id}].n_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_n_components_.tolist() if hasattr(attr_SparsePCA_n_components_, 'tolist') else attr_SparsePCA_n_components_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_n_iter_ = bridgeSparsePCA[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_n_iter_.tolist() if hasattr(attr_SparsePCA_n_iter_, 'tolist') else attr_SparsePCA_n_iter_`\n    })()\n  }\n\n  /**\n    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.\n   */\n  get mean_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SparsePCA must call init() before accessing mean_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_mean_ = bridgeSparsePCA[${this.id}].mean_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_mean_.tolist() if hasattr(attr_SparsePCA_mean_, 'tolist') else attr_SparsePCA_mean_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparsePCA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_n_features_in_ = bridgeSparsePCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_n_features_in_.tolist() if hasattr(attr_SparsePCA_n_features_in_, 'tolist') else attr_SparsePCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SparsePCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SparsePCA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SparsePCA_feature_names_in_ = bridgeSparsePCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SparsePCA_feature_names_in_.tolist() if hasattr(attr_SparsePCA_feature_names_in_, 'tolist') else attr_SparsePCA_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Dimensionality reduction using truncated SVD (aka LSA).\n\n  This transformer performs linear dimensionality reduction by means of truncated singular value decomposition (SVD). Contrary to PCA, this estimator does not center the data before computing the singular value decomposition. This means it can work with sparse matrices efficiently.\n\n  In particular, truncated SVD works on term count/tf-idf matrices as returned by the vectorizers in [`sklearn.feature\\_extraction.text`](../classes.html#module-sklearn.feature_extraction.text \"sklearn.feature_extraction.text\"). In that context, it is known as latent semantic analysis (LSA).\n\n  This estimator supports two algorithms: a fast randomized SVD solver, and a “naive” algorithm that uses ARPACK as an eigensolver on `X \\* X.T` or `X.T \\* X`, whichever is more efficient.\n\n  Read more in the [User Guide](../decomposition.html#lsa).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html)\n */\nexport class TruncatedSVD {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Desired dimensionality of output data. If algorithm=’arpack’, must be strictly less than the number of features. If algorithm=’randomized’, must be less than or equal to the number of features. The default value is useful for visualisation. For LSA, a value of 100 is recommended.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      SVD solver to use. Either “arpack” for the ARPACK wrapper in SciPy (scipy.sparse.linalg.svds), or “randomized” for the randomized algorithm due to Halko (2009).\n\n      @defaultValue `'randomized'`\n     */\n    algorithm?: 'arpack' | 'randomized'\n\n    /**\n      Number of iterations for randomized SVD solver. Not used by ARPACK. The default is larger than the default in [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\") to handle sparse matrices that may have large slowly decaying spectrum.\n\n      @defaultValue `5`\n     */\n    n_iter?: number\n\n    /**\n      Number of oversamples for randomized SVD solver. Not used by ARPACK. See [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\") for a complete description.\n\n      @defaultValue `10`\n     */\n    n_oversamples?: number\n\n    /**\n      Power iteration normalizer for randomized SVD solver. Not used by ARPACK. See [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\") for more details.\n\n      @defaultValue `'auto'`\n     */\n    power_iteration_normalizer?: 'auto' | 'QR' | 'LU' | 'none'\n\n    /**\n      Used during randomized svd. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Tolerance for ARPACK. 0 means machine precision. Ignored by randomized SVD solver.\n\n      @defaultValue `0`\n     */\n    tol?: number\n  }) {\n    this.id = `TruncatedSVD${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('TruncatedSVD.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import TruncatedSVD\ntry: bridgeTruncatedSVD\nexcept NameError: bridgeTruncatedSVD = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_TruncatedSVD = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }, 'n_oversamples': ${\n      this.opts['n_oversamples'] ?? undefined\n    }, 'power_iteration_normalizer': ${\n      this.opts['power_iteration_normalizer'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }}\n\nctor_TruncatedSVD = {k: v for k, v in ctor_TruncatedSVD.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeTruncatedSVD[${this.id}] = TruncatedSVD(**ctor_TruncatedSVD)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTruncatedSVD[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit model on training data X.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TruncatedSVD must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_TruncatedSVD_fit = {k: v for k, v in pms_TruncatedSVD_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_fit = bridgeTruncatedSVD[${this.id}].fit(**pms_TruncatedSVD_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_fit.tolist() if hasattr(res_TruncatedSVD_fit, 'tolist') else res_TruncatedSVD_fit`\n  }\n\n  /**\n    Fit model to X and perform dimensionality reduction on X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TruncatedSVD must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_TruncatedSVD_fit_transform = {k: v for k, v in pms_TruncatedSVD_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_fit_transform = bridgeTruncatedSVD[${this.id}].fit_transform(**pms_TruncatedSVD_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_fit_transform.tolist() if hasattr(res_TruncatedSVD_fit_transform, 'tolist') else res_TruncatedSVD_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TruncatedSVD_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_TruncatedSVD_get_feature_names_out = {k: v for k, v in pms_TruncatedSVD_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_get_feature_names_out = bridgeTruncatedSVD[${this.id}].get_feature_names_out(**pms_TruncatedSVD_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_get_feature_names_out.tolist() if hasattr(res_TruncatedSVD_get_feature_names_out, 'tolist') else res_TruncatedSVD_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_TruncatedSVD_get_metadata_routing = {k: v for k, v in pms_TruncatedSVD_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_get_metadata_routing = bridgeTruncatedSVD[${this.id}].get_metadata_routing(**pms_TruncatedSVD_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_get_metadata_routing.tolist() if hasattr(res_TruncatedSVD_get_metadata_routing, 'tolist') else res_TruncatedSVD_get_metadata_routing`\n  }\n\n  /**\n    Transform X back to its original space.\n\n    Returns an array X\\_original whose transform would be X.\n   */\n  async inverse_transform(opts: {\n    /**\n      New data.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_TruncatedSVD_inverse_transform = {k: v for k, v in pms_TruncatedSVD_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_inverse_transform = bridgeTruncatedSVD[${this.id}].inverse_transform(**pms_TruncatedSVD_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_inverse_transform.tolist() if hasattr(res_TruncatedSVD_inverse_transform, 'tolist') else res_TruncatedSVD_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TruncatedSVD must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_TruncatedSVD_set_output = {k: v for k, v in pms_TruncatedSVD_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_set_output = bridgeTruncatedSVD[${this.id}].set_output(**pms_TruncatedSVD_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_set_output.tolist() if hasattr(res_TruncatedSVD_set_output, 'tolist') else res_TruncatedSVD_set_output`\n  }\n\n  /**\n    Perform dimensionality reduction on X.\n   */\n  async transform(opts: {\n    /**\n      New data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TruncatedSVD must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TruncatedSVD_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_TruncatedSVD_transform = {k: v for k, v in pms_TruncatedSVD_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TruncatedSVD_transform = bridgeTruncatedSVD[${this.id}].transform(**pms_TruncatedSVD_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TruncatedSVD_transform.tolist() if hasattr(res_TruncatedSVD_transform, 'tolist') else res_TruncatedSVD_transform`\n  }\n\n  /**\n    The right singular vectors of the input data.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_components_ = bridgeTruncatedSVD[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_components_.tolist() if hasattr(attr_TruncatedSVD_components_, 'tolist') else attr_TruncatedSVD_components_`\n    })()\n  }\n\n  /**\n    The variance of the training samples transformed by a projection to each component.\n   */\n  get explained_variance_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing explained_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_explained_variance_ = bridgeTruncatedSVD[${this.id}].explained_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_explained_variance_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_, 'tolist') else attr_TruncatedSVD_explained_variance_`\n    })()\n  }\n\n  /**\n    Percentage of variance explained by each of the selected components.\n   */\n  get explained_variance_ratio_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing explained_variance_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_explained_variance_ratio_ = bridgeTruncatedSVD[${this.id}].explained_variance_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_explained_variance_ratio_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_ratio_, 'tolist') else attr_TruncatedSVD_explained_variance_ratio_`\n    })()\n  }\n\n  /**\n    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\\_components` variables in the lower-dimensional space.\n   */\n  get singular_values_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing singular_values_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_singular_values_ = bridgeTruncatedSVD[${this.id}].singular_values_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_singular_values_.tolist() if hasattr(attr_TruncatedSVD_singular_values_, 'tolist') else attr_TruncatedSVD_singular_values_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_n_features_in_ = bridgeTruncatedSVD[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_n_features_in_.tolist() if hasattr(attr_TruncatedSVD_n_features_in_, 'tolist') else attr_TruncatedSVD_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This TruncatedSVD instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TruncatedSVD must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TruncatedSVD_feature_names_in_ = bridgeTruncatedSVD[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TruncatedSVD_feature_names_in_.tolist() if hasattr(attr_TruncatedSVD_feature_names_in_, 'tolist') else attr_TruncatedSVD_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}