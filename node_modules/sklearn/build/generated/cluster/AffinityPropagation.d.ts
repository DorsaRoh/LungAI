import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Perform Affinity Propagation Clustering of data.

  Read more in the [User Guide](../clustering.html#affinity-propagation).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AffinityPropagation.html)
 */
export declare class AffinityPropagation {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          Damping factor in the range `\[0.5, 1.0)` is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). This in order to avoid numerical oscillations when updating these values (messages).
    
          @defaultValue `0.5`
         */
        damping?: number;
        /**
          Maximum number of iterations.
    
          @defaultValue `200`
         */
        max_iter?: number;
        /**
          Number of iterations with no change in the number of estimated clusters that stops the convergence.
    
          @defaultValue `15`
         */
        convergence_iter?: number;
        /**
          Make a copy of input data.
    
          @defaultValue `true`
         */
        copy?: boolean;
        /**
          Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. The number of exemplars, ie of clusters, is influenced by the input preferences value. If the preferences are not passed as arguments, they will be set to the median of the input similarities.
         */
        preference?: ArrayLike | number;
        /**
          Which affinity to use. At the moment ‘precomputed’ and `euclidean` are supported. ‘euclidean’ uses the negative squared euclidean distance between points.
    
          @defaultValue `'euclidean'`
         */
        affinity?: 'euclidean' | 'precomputed';
        /**
          Whether to be verbose.
    
          @defaultValue `false`
         */
        verbose?: boolean;
        /**
          Pseudo-random number generator to control the starting state. Use an int for reproducible results across function calls. See the [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the clustering from features, or affinity matrix.
     */
    fit(opts: {
        /**
          Training instances to cluster, or similarities / affinities between instances if `affinity='precomputed'`. If a sparse feature matrix is provided, it will be converted into a sparse `csr\_matrix`.
         */
        X?: ArrayLike[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Fit clustering from features/affinity matrix; return cluster labels.
     */
    fit_predict(opts: {
        /**
          Training instances to cluster, or similarities / affinities between instances if `affinity='precomputed'`. If a sparse feature matrix is provided, it will be converted into a sparse `csr\_matrix`.
         */
        X?: ArrayLike[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<NDArray>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Predict the closest cluster each sample in X belongs to.
     */
    predict(opts: {
        /**
          New data to predict. If a sparse matrix is provided, it will be converted into a sparse `csr\_matrix`.
         */
        X?: ArrayLike | SparseMatrix[];
    }): Promise<NDArray>;
    /**
      Indices of cluster centers.
     */
    get cluster_centers_indices_(): Promise<NDArray>;
    /**
      Cluster centers (if affinity != `precomputed`).
     */
    get cluster_centers_(): Promise<NDArray[]>;
    /**
      Labels of each point.
     */
    get labels_(): Promise<NDArray>;
    /**
      Stores the affinity matrix used in `fit`.
     */
    get affinity_matrix_(): Promise<NDArray[]>;
    /**
      Number of iterations taken to converge.
     */
    get n_iter_(): Promise<number>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=AffinityPropagation.d.ts.map