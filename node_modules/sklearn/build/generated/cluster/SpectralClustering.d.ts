import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Apply clustering to a projection of the normalized Laplacian.

  In practice Spectral Clustering is very useful when the structure of the individual clusters is highly non-convex, or more generally when a measure of the center and spread of the cluster is not a suitable description of the complete cluster, such as when clusters are nested circles on the 2D plane.

  If the affinity matrix is the adjacency matrix of a graph, this method can be used to find normalized graph cuts [\[1\]](#r5f6cbeb1558e-1), [\[2\]](#r5f6cbeb1558e-2).

  When calling `fit`, an affinity matrix is constructed using either a kernel function such the Gaussian (aka RBF) kernel with Euclidean distance `d(X, X)`:

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html)
 */
export declare class SpectralClustering {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          The dimension of the projection subspace.
    
          @defaultValue `8`
         */
        n_clusters?: number;
        /**
          The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems, but may also lead to instabilities. If `undefined`, then `'arpack'` is used. See [\[4\]](#r5f6cbeb1558e-4) for more details regarding `'lobpcg'`.
         */
        eigen_solver?: 'arpack' | 'lobpcg' | 'amg';
        /**
          Number of eigenvectors to use for the spectral embedding. If `undefined`, defaults to `n\_clusters`.
         */
        n_components?: number;
        /**
          A pseudo random number generator used for the initialization of the lobpcg eigenvectors decomposition when `eigen\_solver \== 'amg'`, and for the K-Means initialization. Use an int to make the results deterministic across calls (See [Glossary](../../glossary.html#term-random_state)).
         */
        random_state?: number;
        /**
          Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n\_init consecutive runs in terms of inertia. Only used if `assign\_labels='kmeans'`.
    
          @defaultValue `10`
         */
        n_init?: number;
        /**
          Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels. Ignored for `affinity='nearest\_neighbors'`.
    
          @defaultValue `1`
         */
        gamma?: number;
        /**
          ‘nearest\_neighbors’: construct the affinity matrix by computing a graph of nearest neighbors.
    
          @defaultValue `'rbf'`
         */
        affinity?: string;
        /**
          Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method. Ignored for `affinity='rbf'`.
    
          @defaultValue `10`
         */
        n_neighbors?: number;
        /**
          Stopping criterion for eigen decomposition of the Laplacian matrix. If `eigen\_tol="auto"` then the passed tolerance will depend on the `eigen\_solver`:
    
          @defaultValue `'auto'`
         */
        eigen_tol?: number;
        /**
          The strategy for assigning labels in the embedding space. There are two ways to assign labels after the Laplacian embedding. k-means is a popular choice, but it can be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization [\[3\]](#r5f6cbeb1558e-3). The cluster\_qr method [\[5\]](#r5f6cbeb1558e-5) directly extract clusters from eigenvectors in spectral clustering. In contrast to k-means and discretization, cluster\_qr has no tuning parameters and runs no iterations, yet may outperform k-means and discretization in terms of both quality and speed.
    
          @defaultValue `'kmeans'`
         */
        assign_labels?: 'kmeans' | 'discretize' | 'cluster_qr';
        /**
          Degree of the polynomial kernel. Ignored by other kernels.
    
          @defaultValue `3`
         */
        degree?: number;
        /**
          Zero coefficient for polynomial and sigmoid kernels. Ignored by other kernels.
    
          @defaultValue `1`
         */
        coef0?: number;
        /**
          Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.
         */
        kernel_params?: any;
        /**
          The number of parallel jobs to run when `affinity='nearest\_neighbors'` or `affinity='precomputed\_nearest\_neighbors'`. The neighbors search will be done in parallel. `undefined` means 1 unless in a [`joblib.parallel\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend "(in joblib v1.4.dev0)") context. `\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.
         */
        n_jobs?: number;
        /**
          Verbosity mode.
    
          @defaultValue `false`
         */
        verbose?: boolean;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Perform spectral clustering from features, or affinity matrix.
     */
    fit(opts: {
        /**
          Training instances to cluster, similarities / affinities between instances if `affinity='precomputed'`, or distances between instances if `affinity='precomputed\_nearest\_neighbors`. If a sparse matrix is provided in a format other than `csr\_matrix`, `csc\_matrix`, or `coo\_matrix`, it will be converted into a sparse `csr\_matrix`.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Perform spectral clustering on `X` and return cluster labels.
     */
    fit_predict(opts: {
        /**
          Training instances to cluster, similarities / affinities between instances if `affinity='precomputed'`, or distances between instances if `affinity='precomputed\_nearest\_neighbors`. If a sparse matrix is provided in a format other than `csr\_matrix`, `csc\_matrix`, or `coo\_matrix`, it will be converted into a sparse `csr\_matrix`.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<NDArray>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Affinity matrix used for clustering. Available only after calling `fit`.
     */
    get affinity_matrix_(): Promise<ArrayLike[]>;
    /**
      Labels of each point
     */
    get labels_(): Promise<NDArray>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=SpectralClustering.d.ts.map