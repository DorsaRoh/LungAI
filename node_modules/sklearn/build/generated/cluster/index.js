// src/generated/cluster/AffinityPropagation.ts
import crypto from "node:crypto";
var AffinityPropagation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AffinityPropagation${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AffinityPropagation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AffinityPropagation
try: bridgeAffinityPropagation
except NameError: bridgeAffinityPropagation = {}
`;
    await this._py.ex`ctor_AffinityPropagation = {'damping': ${this.opts["damping"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'convergence_iter': ${this.opts["convergence_iter"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'preference': np.array(${this.opts["preference"] ?? void 0}) if ${this.opts["preference"] !== void 0} else None, 'affinity': ${this.opts["affinity"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_AffinityPropagation = {k: v for k, v in ctor_AffinityPropagation.items() if v is not None}`;
    await this._py.ex`bridgeAffinityPropagation[${this.id}] = AffinityPropagation(**ctor_AffinityPropagation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAffinityPropagation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before fit()");
    }
    await this._py.ex`pms_AffinityPropagation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit = {k: v for k, v in pms_AffinityPropagation_fit.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit = bridgeAffinityPropagation[${this.id}].fit(**pms_AffinityPropagation_fit)`;
    return this._py`res_AffinityPropagation_fit.tolist() if hasattr(res_AffinityPropagation_fit, 'tolist') else res_AffinityPropagation_fit`;
  }
  /**
    Fit clustering from features/affinity matrix; return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit_predict = {k: v for k, v in pms_AffinityPropagation_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit_predict = bridgeAffinityPropagation[${this.id}].fit_predict(**pms_AffinityPropagation_fit_predict)`;
    return this._py`res_AffinityPropagation_fit_predict.tolist() if hasattr(res_AffinityPropagation_fit_predict, 'tolist') else res_AffinityPropagation_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AffinityPropagation_get_metadata_routing = {k: v for k, v in pms_AffinityPropagation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_get_metadata_routing = bridgeAffinityPropagation[${this.id}].get_metadata_routing(**pms_AffinityPropagation_get_metadata_routing)`;
    return this._py`res_AffinityPropagation_get_metadata_routing.tolist() if hasattr(res_AffinityPropagation_get_metadata_routing, 'tolist') else res_AffinityPropagation_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before predict()");
    }
    await this._py.ex`pms_AffinityPropagation_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AffinityPropagation_predict = {k: v for k, v in pms_AffinityPropagation_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_predict = bridgeAffinityPropagation[${this.id}].predict(**pms_AffinityPropagation_predict)`;
    return this._py`res_AffinityPropagation_predict.tolist() if hasattr(res_AffinityPropagation_predict, 'tolist') else res_AffinityPropagation_predict`;
  }
  /**
    Indices of cluster centers.
   */
  get cluster_centers_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_indices_ = bridgeAffinityPropagation[${this.id}].cluster_centers_indices_`;
      return this._py`attr_AffinityPropagation_cluster_centers_indices_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_indices_, 'tolist') else attr_AffinityPropagation_cluster_centers_indices_`;
    })();
  }
  /**
    Cluster centers (if affinity != `precomputed`).
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_ = bridgeAffinityPropagation[${this.id}].cluster_centers_`;
      return this._py`attr_AffinityPropagation_cluster_centers_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_, 'tolist') else attr_AffinityPropagation_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_labels_ = bridgeAffinityPropagation[${this.id}].labels_`;
      return this._py`attr_AffinityPropagation_labels_.tolist() if hasattr(attr_AffinityPropagation_labels_, 'tolist') else attr_AffinityPropagation_labels_`;
    })();
  }
  /**
    Stores the affinity matrix used in `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_affinity_matrix_ = bridgeAffinityPropagation[${this.id}].affinity_matrix_`;
      return this._py`attr_AffinityPropagation_affinity_matrix_.tolist() if hasattr(attr_AffinityPropagation_affinity_matrix_, 'tolist') else attr_AffinityPropagation_affinity_matrix_`;
    })();
  }
  /**
    Number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_iter_ = bridgeAffinityPropagation[${this.id}].n_iter_`;
      return this._py`attr_AffinityPropagation_n_iter_.tolist() if hasattr(attr_AffinityPropagation_n_iter_, 'tolist') else attr_AffinityPropagation_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_features_in_ = bridgeAffinityPropagation[${this.id}].n_features_in_`;
      return this._py`attr_AffinityPropagation_n_features_in_.tolist() if hasattr(attr_AffinityPropagation_n_features_in_, 'tolist') else attr_AffinityPropagation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_feature_names_in_ = bridgeAffinityPropagation[${this.id}].feature_names_in_`;
      return this._py`attr_AffinityPropagation_feature_names_in_.tolist() if hasattr(attr_AffinityPropagation_feature_names_in_, 'tolist') else attr_AffinityPropagation_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/AgglomerativeClustering.ts
import crypto2 from "node:crypto";
var AgglomerativeClustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AgglomerativeClustering${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AgglomerativeClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AgglomerativeClustering
try: bridgeAgglomerativeClustering
except NameError: bridgeAgglomerativeClustering = {}
`;
    await this._py.ex`ctor_AgglomerativeClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_AgglomerativeClustering = {k: v for k, v in ctor_AgglomerativeClustering.items() if v is not None}`;
    await this._py.ex`bridgeAgglomerativeClustering[${this.id}] = AgglomerativeClustering(**ctor_AgglomerativeClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAgglomerativeClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AgglomerativeClustering must call init() before fit()");
    }
    await this._py.ex`pms_AgglomerativeClustering_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit = {k: v for k, v in pms_AgglomerativeClustering_fit.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit = bridgeAgglomerativeClustering[${this.id}].fit(**pms_AgglomerativeClustering_fit)`;
    return this._py`res_AgglomerativeClustering_fit.tolist() if hasattr(res_AgglomerativeClustering_fit, 'tolist') else res_AgglomerativeClustering_fit`;
  }
  /**
      Fit and return the result of each sampleâ€™s clustering assignment.
  
      In addition to fitting, this method also return the result of the clustering assignment for each sample in the training set.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit_predict = {k: v for k, v in pms_AgglomerativeClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit_predict = bridgeAgglomerativeClustering[${this.id}].fit_predict(**pms_AgglomerativeClustering_fit_predict)`;
    return this._py`res_AgglomerativeClustering_fit_predict.tolist() if hasattr(res_AgglomerativeClustering_fit_predict, 'tolist') else res_AgglomerativeClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AgglomerativeClustering_get_metadata_routing = {k: v for k, v in pms_AgglomerativeClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_get_metadata_routing = bridgeAgglomerativeClustering[${this.id}].get_metadata_routing(**pms_AgglomerativeClustering_get_metadata_routing)`;
    return this._py`res_AgglomerativeClustering_get_metadata_routing.tolist() if hasattr(res_AgglomerativeClustering_get_metadata_routing, 'tolist') else res_AgglomerativeClustering_get_metadata_routing`;
  }
  /**
    The number of clusters found by the algorithm. If `distance\_threshold=None`, it will be equal to the given `n\_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_clusters_ = bridgeAgglomerativeClustering[${this.id}].n_clusters_`;
      return this._py`attr_AgglomerativeClustering_n_clusters_.tolist() if hasattr(attr_AgglomerativeClustering_n_clusters_, 'tolist') else attr_AgglomerativeClustering_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_labels_ = bridgeAgglomerativeClustering[${this.id}].labels_`;
      return this._py`attr_AgglomerativeClustering_labels_.tolist() if hasattr(attr_AgglomerativeClustering_labels_, 'tolist') else attr_AgglomerativeClustering_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_leaves_ = bridgeAgglomerativeClustering[${this.id}].n_leaves_`;
      return this._py`attr_AgglomerativeClustering_n_leaves_.tolist() if hasattr(attr_AgglomerativeClustering_n_leaves_, 'tolist') else attr_AgglomerativeClustering_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_connected_components_ = bridgeAgglomerativeClustering[${this.id}].n_connected_components_`;
      return this._py`attr_AgglomerativeClustering_n_connected_components_.tolist() if hasattr(attr_AgglomerativeClustering_n_connected_components_, 'tolist') else attr_AgglomerativeClustering_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_features_in_ = bridgeAgglomerativeClustering[${this.id}].n_features_in_`;
      return this._py`attr_AgglomerativeClustering_n_features_in_.tolist() if hasattr(attr_AgglomerativeClustering_n_features_in_, 'tolist') else attr_AgglomerativeClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_feature_names_in_ = bridgeAgglomerativeClustering[${this.id}].feature_names_in_`;
      return this._py`attr_AgglomerativeClustering_feature_names_in_.tolist() if hasattr(attr_AgglomerativeClustering_feature_names_in_, 'tolist') else attr_AgglomerativeClustering_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n\_samples` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\_samples` is a non-leaf node and has children `children\_\[i \- n\_samples\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n\_samples + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_children_ = bridgeAgglomerativeClustering[${this.id}].children_`;
      return this._py`attr_AgglomerativeClustering_children_.tolist() if hasattr(attr_AgglomerativeClustering_children_, 'tolist') else attr_AgglomerativeClustering_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children\_`. Only computed if `distance\_threshold` is used or `compute\_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_distances_ = bridgeAgglomerativeClustering[${this.id}].distances_`;
      return this._py`attr_AgglomerativeClustering_distances_.tolist() if hasattr(attr_AgglomerativeClustering_distances_, 'tolist') else attr_AgglomerativeClustering_distances_`;
    })();
  }
};

// src/generated/cluster/Birch.ts
import crypto3 from "node:crypto";
var Birch = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Birch${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Birch.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import Birch
try: bridgeBirch
except NameError: bridgeBirch = {}
`;
    await this._py.ex`ctor_Birch = {'threshold': ${this.opts["threshold"] ?? void 0}, 'branching_factor': ${this.opts["branching_factor"] ?? void 0}, 'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Birch = {k: v for k, v in ctor_Birch.items() if v is not None}`;
    await this._py.ex`bridgeBirch[${this.id}] = Birch(**ctor_Birch)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBirch[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a CF Tree for the input data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit()");
    }
    await this._py.ex`pms_Birch_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_fit = {k: v for k, v in pms_Birch_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_fit = bridgeBirch[${this.id}].fit(**pms_Birch_fit)`;
    return this._py`res_Birch_fit.tolist() if hasattr(res_Birch_fit, 'tolist') else res_Birch_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_predict()");
    }
    await this._py.ex`pms_Birch_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_fit_predict = {k: v for k, v in pms_Birch_fit_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_predict = bridgeBirch[${this.id}].fit_predict(**pms_Birch_fit_predict)`;
    return this._py`res_Birch_fit_predict.tolist() if hasattr(res_Birch_fit_predict, 'tolist') else res_Birch_fit_predict`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_transform()");
    }
    await this._py.ex`pms_Birch_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Birch_fit_transform = {k: v for k, v in pms_Birch_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_transform = bridgeBirch[${this.id}].fit_transform(**pms_Birch_fit_transform)`;
    return this._py`res_Birch_fit_transform.tolist() if hasattr(res_Birch_fit_transform, 'tolist') else res_Birch_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_Birch_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Birch_get_feature_names_out = {k: v for k, v in pms_Birch_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Birch_get_feature_names_out = bridgeBirch[${this.id}].get_feature_names_out(**pms_Birch_get_feature_names_out)`;
    return this._py`res_Birch_get_feature_names_out.tolist() if hasattr(res_Birch_get_feature_names_out, 'tolist') else res_Birch_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Birch_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Birch_get_metadata_routing = {k: v for k, v in pms_Birch_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Birch_get_metadata_routing = bridgeBirch[${this.id}].get_metadata_routing(**pms_Birch_get_metadata_routing)`;
    return this._py`res_Birch_get_metadata_routing.tolist() if hasattr(res_Birch_get_metadata_routing, 'tolist') else res_Birch_get_metadata_routing`;
  }
  /**
    Online learning. Prevents rebuilding of CFTree from scratch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before partial_fit()");
    }
    await this._py.ex`pms_Birch_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_partial_fit = {k: v for k, v in pms_Birch_partial_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_partial_fit = bridgeBirch[${this.id}].partial_fit(**pms_Birch_partial_fit)`;
    return this._py`res_Birch_partial_fit.tolist() if hasattr(res_Birch_partial_fit, 'tolist') else res_Birch_partial_fit`;
  }
  /**
      Predict data using the `centroids\_` of subclusters.
  
      Avoid computation of the row norms of X.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before predict()");
    }
    await this._py.ex`pms_Birch_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_predict = {k: v for k, v in pms_Birch_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_predict = bridgeBirch[${this.id}].predict(**pms_Birch_predict)`;
    return this._py`res_Birch_predict.tolist() if hasattr(res_Birch_predict, 'tolist') else res_Birch_predict`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before set_output()");
    }
    await this._py.ex`pms_Birch_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Birch_set_output = {k: v for k, v in pms_Birch_set_output.items() if v is not None}`;
    await this._py.ex`res_Birch_set_output = bridgeBirch[${this.id}].set_output(**pms_Birch_set_output)`;
    return this._py`res_Birch_set_output.tolist() if hasattr(res_Birch_set_output, 'tolist') else res_Birch_set_output`;
  }
  /**
      Transform X into subcluster centroids dimension.
  
      Each dimension represents the distance from the sample point to each cluster centroid.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before transform()");
    }
    await this._py.ex`pms_Birch_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_transform = {k: v for k, v in pms_Birch_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_transform = bridgeBirch[${this.id}].transform(**pms_Birch_transform)`;
    return this._py`res_Birch_transform.tolist() if hasattr(res_Birch_transform, 'tolist') else res_Birch_transform`;
  }
  /**
    Root of the CFTree.
   */
  get root_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing root_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_root_ = bridgeBirch[${this.id}].root_`;
      return this._py`attr_Birch_root_.tolist() if hasattr(attr_Birch_root_, 'tolist') else attr_Birch_root_`;
    })();
  }
  /**
    Start pointer to all the leaves.
   */
  get dummy_leaf_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing dummy_leaf_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_dummy_leaf_ = bridgeBirch[${this.id}].dummy_leaf_`;
      return this._py`attr_Birch_dummy_leaf_.tolist() if hasattr(attr_Birch_dummy_leaf_, 'tolist') else attr_Birch_dummy_leaf_`;
    })();
  }
  /**
    Centroids of all subclusters read directly from the leaves.
   */
  get subcluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_centers_ = bridgeBirch[${this.id}].subcluster_centers_`;
      return this._py`attr_Birch_subcluster_centers_.tolist() if hasattr(attr_Birch_subcluster_centers_, 'tolist') else attr_Birch_subcluster_centers_`;
    })();
  }
  /**
    Labels assigned to the centroids of the subclusters after they are clustered globally.
   */
  get subcluster_labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_labels_ = bridgeBirch[${this.id}].subcluster_labels_`;
      return this._py`attr_Birch_subcluster_labels_.tolist() if hasattr(attr_Birch_subcluster_labels_, 'tolist') else attr_Birch_subcluster_labels_`;
    })();
  }
  /**
    Array of labels assigned to the input data. if partial\_fit is used instead of fit, they are assigned to the last batch of data.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_labels_ = bridgeBirch[${this.id}].labels_`;
      return this._py`attr_Birch_labels_.tolist() if hasattr(attr_Birch_labels_, 'tolist') else attr_Birch_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_n_features_in_ = bridgeBirch[${this.id}].n_features_in_`;
      return this._py`attr_Birch_n_features_in_.tolist() if hasattr(attr_Birch_n_features_in_, 'tolist') else attr_Birch_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_feature_names_in_ = bridgeBirch[${this.id}].feature_names_in_`;
      return this._py`attr_Birch_feature_names_in_.tolist() if hasattr(attr_Birch_feature_names_in_, 'tolist') else attr_Birch_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/BisectingKMeans.ts
import crypto4 from "node:crypto";
var BisectingKMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BisectingKMeans${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BisectingKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import BisectingKMeans
try: bridgeBisectingKMeans
except NameError: bridgeBisectingKMeans = {}
`;
    await this._py.ex`ctor_BisectingKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'bisecting_strategy': ${this.opts["bisecting_strategy"] ?? void 0}}

ctor_BisectingKMeans = {k: v for k, v in ctor_BisectingKMeans.items() if v is not None}`;
    await this._py.ex`bridgeBisectingKMeans[${this.id}] = BisectingKMeans(**ctor_BisectingKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBisectingKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute bisecting k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit()");
    }
    await this._py.ex`pms_BisectingKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit = {k: v for k, v in pms_BisectingKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit = bridgeBisectingKMeans[${this.id}].fit(**pms_BisectingKMeans_fit)`;
    return this._py`res_BisectingKMeans_fit.tolist() if hasattr(res_BisectingKMeans_fit, 'tolist') else res_BisectingKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_predict = {k: v for k, v in pms_BisectingKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_predict = bridgeBisectingKMeans[${this.id}].fit_predict(**pms_BisectingKMeans_fit_predict)`;
    return this._py`res_BisectingKMeans_fit_predict.tolist() if hasattr(res_BisectingKMeans_fit_predict, 'tolist') else res_BisectingKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_transform = {k: v for k, v in pms_BisectingKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_transform = bridgeBisectingKMeans[${this.id}].fit_transform(**pms_BisectingKMeans_fit_transform)`;
    return this._py`res_BisectingKMeans_fit_transform.tolist() if hasattr(res_BisectingKMeans_fit_transform, 'tolist') else res_BisectingKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_BisectingKMeans_get_feature_names_out = {k: v for k, v in pms_BisectingKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_feature_names_out = bridgeBisectingKMeans[${this.id}].get_feature_names_out(**pms_BisectingKMeans_get_feature_names_out)`;
    return this._py`res_BisectingKMeans_get_feature_names_out.tolist() if hasattr(res_BisectingKMeans_get_feature_names_out, 'tolist') else res_BisectingKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BisectingKMeans_get_metadata_routing = {k: v for k, v in pms_BisectingKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_metadata_routing = bridgeBisectingKMeans[${this.id}].get_metadata_routing(**pms_BisectingKMeans_get_metadata_routing)`;
    return this._py`res_BisectingKMeans_get_metadata_routing.tolist() if hasattr(res_BisectingKMeans_get_metadata_routing, 'tolist') else res_BisectingKMeans_get_metadata_routing`;
  }
  /**
      Predict which cluster each sample in X belongs to.
  
      Prediction is made by going down the hierarchical tree in searching of closest leaf cluster.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before predict()");
    }
    await this._py.ex`pms_BisectingKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_predict = {k: v for k, v in pms_BisectingKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_predict = bridgeBisectingKMeans[${this.id}].predict(**pms_BisectingKMeans_predict)`;
    return this._py`res_BisectingKMeans_predict.tolist() if hasattr(res_BisectingKMeans_predict, 'tolist') else res_BisectingKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before score()");
    }
    await this._py.ex`pms_BisectingKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_score = {k: v for k, v in pms_BisectingKMeans_score.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_score = bridgeBisectingKMeans[${this.id}].score(**pms_BisectingKMeans_score)`;
    return this._py`res_BisectingKMeans_score.tolist() if hasattr(res_BisectingKMeans_score, 'tolist') else res_BisectingKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_fit_request = {k: v for k, v in pms_BisectingKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_fit_request = bridgeBisectingKMeans[${this.id}].set_fit_request(**pms_BisectingKMeans_set_fit_request)`;
    return this._py`res_BisectingKMeans_set_fit_request.tolist() if hasattr(res_BisectingKMeans_set_fit_request, 'tolist') else res_BisectingKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_BisectingKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_BisectingKMeans_set_output = {k: v for k, v in pms_BisectingKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_output = bridgeBisectingKMeans[${this.id}].set_output(**pms_BisectingKMeans_set_output)`;
    return this._py`res_BisectingKMeans_set_output.tolist() if hasattr(res_BisectingKMeans_set_output, 'tolist') else res_BisectingKMeans_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_predict_request = {k: v for k, v in pms_BisectingKMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_predict_request = bridgeBisectingKMeans[${this.id}].set_predict_request(**pms_BisectingKMeans_set_predict_request)`;
    return this._py`res_BisectingKMeans_set_predict_request.tolist() if hasattr(res_BisectingKMeans_set_predict_request, 'tolist') else res_BisectingKMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_score_request = {k: v for k, v in pms_BisectingKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_score_request = bridgeBisectingKMeans[${this.id}].set_score_request(**pms_BisectingKMeans_set_score_request)`;
    return this._py`res_BisectingKMeans_set_score_request.tolist() if hasattr(res_BisectingKMeans_set_score_request, 'tolist') else res_BisectingKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before transform()");
    }
    await this._py.ex`pms_BisectingKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_transform = {k: v for k, v in pms_BisectingKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_transform = bridgeBisectingKMeans[${this.id}].transform(**pms_BisectingKMeans_transform)`;
    return this._py`res_BisectingKMeans_transform.tolist() if hasattr(res_BisectingKMeans_transform, 'tolist') else res_BisectingKMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\_iter`), these will not be consistent with `labels\_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_cluster_centers_ = bridgeBisectingKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_BisectingKMeans_cluster_centers_.tolist() if hasattr(attr_BisectingKMeans_cluster_centers_, 'tolist') else attr_BisectingKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_labels_ = bridgeBisectingKMeans[${this.id}].labels_`;
      return this._py`attr_BisectingKMeans_labels_.tolist() if hasattr(attr_BisectingKMeans_labels_, 'tolist') else attr_BisectingKMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_inertia_ = bridgeBisectingKMeans[${this.id}].inertia_`;
      return this._py`attr_BisectingKMeans_inertia_.tolist() if hasattr(attr_BisectingKMeans_inertia_, 'tolist') else attr_BisectingKMeans_inertia_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_n_features_in_ = bridgeBisectingKMeans[${this.id}].n_features_in_`;
      return this._py`attr_BisectingKMeans_n_features_in_.tolist() if hasattr(attr_BisectingKMeans_n_features_in_, 'tolist') else attr_BisectingKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_feature_names_in_ = bridgeBisectingKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_BisectingKMeans_feature_names_in_.tolist() if hasattr(attr_BisectingKMeans_feature_names_in_, 'tolist') else attr_BisectingKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/DBSCAN.ts
import crypto5 from "node:crypto";
var DBSCAN = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DBSCAN${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import DBSCAN
try: bridgeDBSCAN
except NameError: bridgeDBSCAN = {}
`;
    await this._py.ex`ctor_DBSCAN = {'eps': ${this.opts["eps"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_DBSCAN = {k: v for k, v in ctor_DBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeDBSCAN[${this.id}] = DBSCAN(**ctor_DBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform DBSCAN clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_DBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit = {k: v for k, v in pms_DBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit = bridgeDBSCAN[${this.id}].fit(**pms_DBSCAN_fit)`;
    return this._py`res_DBSCAN_fit.tolist() if hasattr(res_DBSCAN_fit, 'tolist') else res_DBSCAN_fit`;
  }
  /**
    Compute clusters from a data or distance matrix and predict labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_DBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit_predict = {k: v for k, v in pms_DBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit_predict = bridgeDBSCAN[${this.id}].fit_predict(**pms_DBSCAN_fit_predict)`;
    return this._py`res_DBSCAN_fit_predict.tolist() if hasattr(res_DBSCAN_fit_predict, 'tolist') else res_DBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_DBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DBSCAN_get_metadata_routing = {k: v for k, v in pms_DBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_get_metadata_routing = bridgeDBSCAN[${this.id}].get_metadata_routing(**pms_DBSCAN_get_metadata_routing)`;
    return this._py`res_DBSCAN_get_metadata_routing.tolist() if hasattr(res_DBSCAN_get_metadata_routing, 'tolist') else res_DBSCAN_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before set_fit_request()");
    }
    await this._py.ex`pms_DBSCAN_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DBSCAN_set_fit_request = {k: v for k, v in pms_DBSCAN_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_set_fit_request = bridgeDBSCAN[${this.id}].set_fit_request(**pms_DBSCAN_set_fit_request)`;
    return this._py`res_DBSCAN_set_fit_request.tolist() if hasattr(res_DBSCAN_set_fit_request, 'tolist') else res_DBSCAN_set_fit_request`;
  }
  /**
    Indices of core samples.
   */
  get core_sample_indices_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing core_sample_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_core_sample_indices_ = bridgeDBSCAN[${this.id}].core_sample_indices_`;
      return this._py`attr_DBSCAN_core_sample_indices_.tolist() if hasattr(attr_DBSCAN_core_sample_indices_, 'tolist') else attr_DBSCAN_core_sample_indices_`;
    })();
  }
  /**
    Copy of each core sample found by training.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_components_ = bridgeDBSCAN[${this.id}].components_`;
      return this._py`attr_DBSCAN_components_.tolist() if hasattr(attr_DBSCAN_components_, 'tolist') else attr_DBSCAN_components_`;
    })();
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples are given the label -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_labels_ = bridgeDBSCAN[${this.id}].labels_`;
      return this._py`attr_DBSCAN_labels_.tolist() if hasattr(attr_DBSCAN_labels_, 'tolist') else attr_DBSCAN_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_n_features_in_ = bridgeDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_DBSCAN_n_features_in_.tolist() if hasattr(attr_DBSCAN_n_features_in_, 'tolist') else attr_DBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_feature_names_in_ = bridgeDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_DBSCAN_feature_names_in_.tolist() if hasattr(attr_DBSCAN_feature_names_in_, 'tolist') else attr_DBSCAN_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/FeatureAgglomeration.ts
import crypto6 from "node:crypto";
var FeatureAgglomeration = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FeatureAgglomeration${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "FeatureAgglomeration.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import FeatureAgglomeration
try: bridgeFeatureAgglomeration
except NameError: bridgeFeatureAgglomeration = {}
`;
    await this._py.ex`ctor_FeatureAgglomeration = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'pooling_func': ${this.opts["pooling_func"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_FeatureAgglomeration = {k: v for k, v in ctor_FeatureAgglomeration.items() if v is not None}`;
    await this._py.ex`bridgeFeatureAgglomeration[${this.id}] = FeatureAgglomeration(**ctor_FeatureAgglomeration)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFeatureAgglomeration[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering on the data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FeatureAgglomeration must call init() before fit()");
    }
    await this._py.ex`pms_FeatureAgglomeration_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FeatureAgglomeration_fit = {k: v for k, v in pms_FeatureAgglomeration_fit.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit = bridgeFeatureAgglomeration[${this.id}].fit(**pms_FeatureAgglomeration_fit)`;
    return this._py`res_FeatureAgglomeration_fit.tolist() if hasattr(res_FeatureAgglomeration_fit, 'tolist') else res_FeatureAgglomeration_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureAgglomeration_fit_transform = {k: v for k, v in pms_FeatureAgglomeration_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit_transform = bridgeFeatureAgglomeration[${this.id}].fit_transform(**pms_FeatureAgglomeration_fit_transform)`;
    return this._py`res_FeatureAgglomeration_fit_transform.tolist() if hasattr(res_FeatureAgglomeration_fit_transform, 'tolist') else res_FeatureAgglomeration_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FeatureAgglomeration_get_feature_names_out = {k: v for k, v in pms_FeatureAgglomeration_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_feature_names_out = bridgeFeatureAgglomeration[${this.id}].get_feature_names_out(**pms_FeatureAgglomeration_get_feature_names_out)`;
    return this._py`res_FeatureAgglomeration_get_feature_names_out.tolist() if hasattr(res_FeatureAgglomeration_get_feature_names_out, 'tolist') else res_FeatureAgglomeration_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FeatureAgglomeration_get_metadata_routing = {k: v for k, v in pms_FeatureAgglomeration_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_metadata_routing = bridgeFeatureAgglomeration[${this.id}].get_metadata_routing(**pms_FeatureAgglomeration_get_metadata_routing)`;
    return this._py`res_FeatureAgglomeration_get_metadata_routing.tolist() if hasattr(res_FeatureAgglomeration_get_metadata_routing, 'tolist') else res_FeatureAgglomeration_get_metadata_routing`;
  }
  /**
    Inverse the transformation and return a vector of size `n\_features`.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'Xred': ${opts["Xred"] ?? void 0}}

pms_FeatureAgglomeration_inverse_transform = {k: v for k, v in pms_FeatureAgglomeration_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_inverse_transform = bridgeFeatureAgglomeration[${this.id}].inverse_transform(**pms_FeatureAgglomeration_inverse_transform)`;
    return this._py`res_FeatureAgglomeration_inverse_transform.tolist() if hasattr(res_FeatureAgglomeration_inverse_transform, 'tolist') else res_FeatureAgglomeration_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before set_output()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FeatureAgglomeration_set_output = {k: v for k, v in pms_FeatureAgglomeration_set_output.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_set_output = bridgeFeatureAgglomeration[${this.id}].set_output(**pms_FeatureAgglomeration_set_output)`;
    return this._py`res_FeatureAgglomeration_set_output.tolist() if hasattr(res_FeatureAgglomeration_set_output, 'tolist') else res_FeatureAgglomeration_set_output`;
  }
  /**
    Transform a new matrix using the built clustering.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FeatureAgglomeration_transform = {k: v for k, v in pms_FeatureAgglomeration_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_transform = bridgeFeatureAgglomeration[${this.id}].transform(**pms_FeatureAgglomeration_transform)`;
    return this._py`res_FeatureAgglomeration_transform.tolist() if hasattr(res_FeatureAgglomeration_transform, 'tolist') else res_FeatureAgglomeration_transform`;
  }
  /**
    The number of clusters found by the algorithm. If `distance\_threshold=None`, it will be equal to the given `n\_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_clusters_ = bridgeFeatureAgglomeration[${this.id}].n_clusters_`;
      return this._py`attr_FeatureAgglomeration_n_clusters_.tolist() if hasattr(attr_FeatureAgglomeration_n_clusters_, 'tolist') else attr_FeatureAgglomeration_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each feature.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_labels_ = bridgeFeatureAgglomeration[${this.id}].labels_`;
      return this._py`attr_FeatureAgglomeration_labels_.tolist() if hasattr(attr_FeatureAgglomeration_labels_, 'tolist') else attr_FeatureAgglomeration_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_leaves_ = bridgeFeatureAgglomeration[${this.id}].n_leaves_`;
      return this._py`attr_FeatureAgglomeration_n_leaves_.tolist() if hasattr(attr_FeatureAgglomeration_n_leaves_, 'tolist') else attr_FeatureAgglomeration_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_connected_components_ = bridgeFeatureAgglomeration[${this.id}].n_connected_components_`;
      return this._py`attr_FeatureAgglomeration_n_connected_components_.tolist() if hasattr(attr_FeatureAgglomeration_n_connected_components_, 'tolist') else attr_FeatureAgglomeration_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_features_in_ = bridgeFeatureAgglomeration[${this.id}].n_features_in_`;
      return this._py`attr_FeatureAgglomeration_n_features_in_.tolist() if hasattr(attr_FeatureAgglomeration_n_features_in_, 'tolist') else attr_FeatureAgglomeration_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_feature_names_in_ = bridgeFeatureAgglomeration[${this.id}].feature_names_in_`;
      return this._py`attr_FeatureAgglomeration_feature_names_in_.tolist() if hasattr(attr_FeatureAgglomeration_feature_names_in_, 'tolist') else attr_FeatureAgglomeration_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n\_features` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\_features` is a non-leaf node and has children `children\_\[i \- n\_features\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n\_features + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_children_ = bridgeFeatureAgglomeration[${this.id}].children_`;
      return this._py`attr_FeatureAgglomeration_children_.tolist() if hasattr(attr_FeatureAgglomeration_children_, 'tolist') else attr_FeatureAgglomeration_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children\_`. Only computed if `distance\_threshold` is used or `compute\_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_distances_ = bridgeFeatureAgglomeration[${this.id}].distances_`;
      return this._py`attr_FeatureAgglomeration_distances_.tolist() if hasattr(attr_FeatureAgglomeration_distances_, 'tolist') else attr_FeatureAgglomeration_distances_`;
    })();
  }
};

// src/generated/cluster/HDBSCAN.ts
import crypto7 from "node:crypto";
var HDBSCAN = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HDBSCAN${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HDBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import HDBSCAN
try: bridgeHDBSCAN
except NameError: bridgeHDBSCAN = {}
`;
    await this._py.ex`ctor_HDBSCAN = {'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'cluster_selection_epsilon': ${this.opts["cluster_selection_epsilon"] ?? void 0}, 'max_cluster_size': ${this.opts["max_cluster_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'cluster_selection_method': ${this.opts["cluster_selection_method"] ?? void 0}, 'allow_single_cluster': ${this.opts["allow_single_cluster"] ?? void 0}, 'store_centers': ${this.opts["store_centers"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_HDBSCAN = {k: v for k, v in ctor_HDBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeHDBSCAN[${this.id}] = HDBSCAN(**ctor_HDBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return clustering given by DBSCAN without border points.
  
      Return clustering that would be equivalent to running DBSCAN\* for a particular cut\_distance (or epsilon) DBSCAN\* can be thought of as DBSCAN without the border points. As such these results may differ slightly from `cluster.DBSCAN` due to the difference in implementation over the non-core points.
  
      This can also be thought of as a flat clustering derived from constant height cut through the single linkage tree.
  
      This represents the result of selecting a cut value for robust single linkage clustering. The `min\_cluster\_size` allows the flat clustering to declare noise points (and cluster smaller than `min\_cluster\_size`).
     */
  async dbscan_clustering(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before dbscan_clustering()");
    }
    await this._py.ex`pms_HDBSCAN_dbscan_clustering = {'cut_distance': ${opts["cut_distance"] ?? void 0}, 'min_cluster_size': ${opts["min_cluster_size"] ?? void 0}}

pms_HDBSCAN_dbscan_clustering = {k: v for k, v in pms_HDBSCAN_dbscan_clustering.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_dbscan_clustering = bridgeHDBSCAN[${this.id}].dbscan_clustering(**pms_HDBSCAN_dbscan_clustering)`;
    return this._py`res_HDBSCAN_dbscan_clustering.tolist() if hasattr(res_HDBSCAN_dbscan_clustering, 'tolist') else res_HDBSCAN_dbscan_clustering`;
  }
  /**
    Find clusters based on hierarchical density-based clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_HDBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit = {k: v for k, v in pms_HDBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit = bridgeHDBSCAN[${this.id}].fit(**pms_HDBSCAN_fit)`;
    return this._py`res_HDBSCAN_fit.tolist() if hasattr(res_HDBSCAN_fit, 'tolist') else res_HDBSCAN_fit`;
  }
  /**
    Cluster X and return the associated cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_HDBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit_predict = {k: v for k, v in pms_HDBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit_predict = bridgeHDBSCAN[${this.id}].fit_predict(**pms_HDBSCAN_fit_predict)`;
    return this._py`res_HDBSCAN_fit_predict.tolist() if hasattr(res_HDBSCAN_fit_predict, 'tolist') else res_HDBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_HDBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HDBSCAN_get_metadata_routing = {k: v for k, v in pms_HDBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_get_metadata_routing = bridgeHDBSCAN[${this.id}].get_metadata_routing(**pms_HDBSCAN_get_metadata_routing)`;
    return this._py`res_HDBSCAN_get_metadata_routing.tolist() if hasattr(res_HDBSCAN_get_metadata_routing, 'tolist') else res_HDBSCAN_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to [fit](../../glossary.html#term-fit). Outliers are labeled as follows:
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_labels_ = bridgeHDBSCAN[${this.id}].labels_`;
      return this._py`attr_HDBSCAN_labels_.tolist() if hasattr(attr_HDBSCAN_labels_, 'tolist') else attr_HDBSCAN_labels_`;
    })();
  }
  /**
    The strength with which each sample is a member of its assigned cluster.
   */
  get probabilities_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing probabilities_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_probabilities_ = bridgeHDBSCAN[${this.id}].probabilities_`;
      return this._py`attr_HDBSCAN_probabilities_.tolist() if hasattr(attr_HDBSCAN_probabilities_, 'tolist') else attr_HDBSCAN_probabilities_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_n_features_in_ = bridgeHDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_HDBSCAN_n_features_in_.tolist() if hasattr(attr_HDBSCAN_n_features_in_, 'tolist') else attr_HDBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_feature_names_in_ = bridgeHDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_HDBSCAN_feature_names_in_.tolist() if hasattr(attr_HDBSCAN_feature_names_in_, 'tolist') else attr_HDBSCAN_feature_names_in_`;
    })();
  }
  /**
      A collection containing the centroid of each cluster calculated under the standard euclidean metric. The centroids may fall â€œoutsideâ€ their respective clusters if the clusters themselves are non-convex.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing centroids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_centroids_ = bridgeHDBSCAN[${this.id}].centroids_`;
      return this._py`attr_HDBSCAN_centroids_.tolist() if hasattr(attr_HDBSCAN_centroids_, 'tolist') else attr_HDBSCAN_centroids_`;
    })();
  }
  /**
      A collection containing the medoid of each cluster calculated under the whichever metric was passed to the `metric` parameter. The medoids are points in the original cluster which minimize the average distance to all other points in that cluster under the chosen metric. These can be thought of as the result of projecting the `metric`\-based centroid back onto the cluster.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get medoids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing medoids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_medoids_ = bridgeHDBSCAN[${this.id}].medoids_`;
      return this._py`attr_HDBSCAN_medoids_.tolist() if hasattr(attr_HDBSCAN_medoids_, 'tolist') else attr_HDBSCAN_medoids_`;
    })();
  }
};

// src/generated/cluster/KMeans.ts
import crypto8 from "node:crypto";
var KMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KMeans${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import KMeans
try: bridgeKMeans
except NameError: bridgeKMeans = {}
`;
    await this._py.ex`ctor_KMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}}

ctor_KMeans = {k: v for k, v in ctor_KMeans.items() if v is not None}`;
    await this._py.ex`bridgeKMeans[${this.id}] = KMeans(**ctor_KMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit()");
    }
    await this._py.ex`pms_KMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit = {k: v for k, v in pms_KMeans_fit.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit = bridgeKMeans[${this.id}].fit(**pms_KMeans_fit)`;
    return this._py`res_KMeans_fit.tolist() if hasattr(res_KMeans_fit, 'tolist') else res_KMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_KMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_predict = {k: v for k, v in pms_KMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_predict = bridgeKMeans[${this.id}].fit_predict(**pms_KMeans_fit_predict)`;
    return this._py`res_KMeans_fit_predict.tolist() if hasattr(res_KMeans_fit_predict, 'tolist') else res_KMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_KMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_transform = {k: v for k, v in pms_KMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_transform = bridgeKMeans[${this.id}].fit_transform(**pms_KMeans_fit_transform)`;
    return this._py`res_KMeans_fit_transform.tolist() if hasattr(res_KMeans_fit_transform, 'tolist') else res_KMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_KMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KMeans_get_feature_names_out = {k: v for k, v in pms_KMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_feature_names_out = bridgeKMeans[${this.id}].get_feature_names_out(**pms_KMeans_get_feature_names_out)`;
    return this._py`res_KMeans_get_feature_names_out.tolist() if hasattr(res_KMeans_get_feature_names_out, 'tolist') else res_KMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_KMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KMeans_get_metadata_routing = {k: v for k, v in pms_KMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_metadata_routing = bridgeKMeans[${this.id}].get_metadata_routing(**pms_KMeans_get_metadata_routing)`;
    return this._py`res_KMeans_get_metadata_routing.tolist() if hasattr(res_KMeans_get_metadata_routing, 'tolist') else res_KMeans_get_metadata_routing`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before predict()");
    }
    await this._py.ex`pms_KMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_predict = {k: v for k, v in pms_KMeans_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_predict = bridgeKMeans[${this.id}].predict(**pms_KMeans_predict)`;
    return this._py`res_KMeans_predict.tolist() if hasattr(res_KMeans_predict, 'tolist') else res_KMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before score()");
    }
    await this._py.ex`pms_KMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_score = {k: v for k, v in pms_KMeans_score.items() if v is not None}`;
    await this._py.ex`res_KMeans_score = bridgeKMeans[${this.id}].score(**pms_KMeans_score)`;
    return this._py`res_KMeans_score.tolist() if hasattr(res_KMeans_score, 'tolist') else res_KMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_fit_request = {k: v for k, v in pms_KMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_fit_request = bridgeKMeans[${this.id}].set_fit_request(**pms_KMeans_set_fit_request)`;
    return this._py`res_KMeans_set_fit_request.tolist() if hasattr(res_KMeans_set_fit_request, 'tolist') else res_KMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_output()");
    }
    await this._py.ex`pms_KMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KMeans_set_output = {k: v for k, v in pms_KMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_output = bridgeKMeans[${this.id}].set_output(**pms_KMeans_set_output)`;
    return this._py`res_KMeans_set_output.tolist() if hasattr(res_KMeans_set_output, 'tolist') else res_KMeans_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_predict_request()");
    }
    await this._py.ex`pms_KMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_predict_request = {k: v for k, v in pms_KMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_predict_request = bridgeKMeans[${this.id}].set_predict_request(**pms_KMeans_set_predict_request)`;
    return this._py`res_KMeans_set_predict_request.tolist() if hasattr(res_KMeans_set_predict_request, 'tolist') else res_KMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_score_request()");
    }
    await this._py.ex`pms_KMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_score_request = {k: v for k, v in pms_KMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_score_request = bridgeKMeans[${this.id}].set_score_request(**pms_KMeans_set_score_request)`;
    return this._py`res_KMeans_set_score_request.tolist() if hasattr(res_KMeans_set_score_request, 'tolist') else res_KMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before transform()");
    }
    await this._py.ex`pms_KMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KMeans_transform = {k: v for k, v in pms_KMeans_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_transform = bridgeKMeans[${this.id}].transform(**pms_KMeans_transform)`;
    return this._py`res_KMeans_transform.tolist() if hasattr(res_KMeans_transform, 'tolist') else res_KMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\_iter`), these will not be consistent with `labels\_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_cluster_centers_ = bridgeKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_KMeans_cluster_centers_.tolist() if hasattr(attr_KMeans_cluster_centers_, 'tolist') else attr_KMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_labels_ = bridgeKMeans[${this.id}].labels_`;
      return this._py`attr_KMeans_labels_.tolist() if hasattr(attr_KMeans_labels_, 'tolist') else attr_KMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing inertia_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_inertia_ = bridgeKMeans[${this.id}].inertia_`;
      return this._py`attr_KMeans_inertia_.tolist() if hasattr(attr_KMeans_inertia_, 'tolist') else attr_KMeans_inertia_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_iter_ = bridgeKMeans[${this.id}].n_iter_`;
      return this._py`attr_KMeans_n_iter_.tolist() if hasattr(attr_KMeans_n_iter_, 'tolist') else attr_KMeans_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_features_in_ = bridgeKMeans[${this.id}].n_features_in_`;
      return this._py`attr_KMeans_n_features_in_.tolist() if hasattr(attr_KMeans_n_features_in_, 'tolist') else attr_KMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_feature_names_in_ = bridgeKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_KMeans_feature_names_in_.tolist() if hasattr(attr_KMeans_feature_names_in_, 'tolist') else attr_KMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MeanShift.ts
import crypto9 from "node:crypto";
var MeanShift = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MeanShift${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MeanShift.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MeanShift
try: bridgeMeanShift
except NameError: bridgeMeanShift = {}
`;
    await this._py.ex`ctor_MeanShift = {'bandwidth': ${this.opts["bandwidth"] ?? void 0}, 'seeds': np.array(${this.opts["seeds"] ?? void 0}) if ${this.opts["seeds"] !== void 0} else None, 'bin_seeding': ${this.opts["bin_seeding"] ?? void 0}, 'min_bin_freq': ${this.opts["min_bin_freq"] ?? void 0}, 'cluster_all': ${this.opts["cluster_all"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_MeanShift = {k: v for k, v in ctor_MeanShift.items() if v is not None}`;
    await this._py.ex`bridgeMeanShift[${this.id}] = MeanShift(**ctor_MeanShift)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMeanShift[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit()");
    }
    await this._py.ex`pms_MeanShift_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MeanShift_fit = {k: v for k, v in pms_MeanShift_fit.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit = bridgeMeanShift[${this.id}].fit(**pms_MeanShift_fit)`;
    return this._py`res_MeanShift_fit.tolist() if hasattr(res_MeanShift_fit, 'tolist') else res_MeanShift_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit_predict()");
    }
    await this._py.ex`pms_MeanShift_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MeanShift_fit_predict = {k: v for k, v in pms_MeanShift_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit_predict = bridgeMeanShift[${this.id}].fit_predict(**pms_MeanShift_fit_predict)`;
    return this._py`res_MeanShift_fit_predict.tolist() if hasattr(res_MeanShift_fit_predict, 'tolist') else res_MeanShift_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MeanShift_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MeanShift_get_metadata_routing = {k: v for k, v in pms_MeanShift_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MeanShift_get_metadata_routing = bridgeMeanShift[${this.id}].get_metadata_routing(**pms_MeanShift_get_metadata_routing)`;
    return this._py`res_MeanShift_get_metadata_routing.tolist() if hasattr(res_MeanShift_get_metadata_routing, 'tolist') else res_MeanShift_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before predict()");
    }
    await this._py.ex`pms_MeanShift_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MeanShift_predict = {k: v for k, v in pms_MeanShift_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_predict = bridgeMeanShift[${this.id}].predict(**pms_MeanShift_predict)`;
    return this._py`res_MeanShift_predict.tolist() if hasattr(res_MeanShift_predict, 'tolist') else res_MeanShift_predict`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_cluster_centers_ = bridgeMeanShift[${this.id}].cluster_centers_`;
      return this._py`attr_MeanShift_cluster_centers_.tolist() if hasattr(attr_MeanShift_cluster_centers_, 'tolist') else attr_MeanShift_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_labels_ = bridgeMeanShift[${this.id}].labels_`;
      return this._py`attr_MeanShift_labels_.tolist() if hasattr(attr_MeanShift_labels_, 'tolist') else attr_MeanShift_labels_`;
    })();
  }
  /**
    Maximum number of iterations performed on each seed.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_iter_ = bridgeMeanShift[${this.id}].n_iter_`;
      return this._py`attr_MeanShift_n_iter_.tolist() if hasattr(attr_MeanShift_n_iter_, 'tolist') else attr_MeanShift_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_features_in_ = bridgeMeanShift[${this.id}].n_features_in_`;
      return this._py`attr_MeanShift_n_features_in_.tolist() if hasattr(attr_MeanShift_n_features_in_, 'tolist') else attr_MeanShift_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_feature_names_in_ = bridgeMeanShift[${this.id}].feature_names_in_`;
      return this._py`attr_MeanShift_feature_names_in_.tolist() if hasattr(attr_MeanShift_feature_names_in_, 'tolist') else attr_MeanShift_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MiniBatchKMeans.ts
import crypto10 from "node:crypto";
var MiniBatchKMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchKMeans${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MiniBatchKMeans
try: bridgeMiniBatchKMeans
except NameError: bridgeMiniBatchKMeans = {}
`;
    await this._py.ex`ctor_MiniBatchKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'init_size': ${this.opts["init_size"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'reassignment_ratio': ${this.opts["reassignment_ratio"] ?? void 0}}

ctor_MiniBatchKMeans = {k: v for k, v in ctor_MiniBatchKMeans.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchKMeans[${this.id}] = MiniBatchKMeans(**ctor_MiniBatchKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the centroids on X by chunking it into mini-batches.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit = {k: v for k, v in pms_MiniBatchKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit = bridgeMiniBatchKMeans[${this.id}].fit(**pms_MiniBatchKMeans_fit)`;
    return this._py`res_MiniBatchKMeans_fit.tolist() if hasattr(res_MiniBatchKMeans_fit, 'tolist') else res_MiniBatchKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_predict = {k: v for k, v in pms_MiniBatchKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_predict = bridgeMiniBatchKMeans[${this.id}].fit_predict(**pms_MiniBatchKMeans_fit_predict)`;
    return this._py`res_MiniBatchKMeans_fit_predict.tolist() if hasattr(res_MiniBatchKMeans_fit_predict, 'tolist') else res_MiniBatchKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_transform = {k: v for k, v in pms_MiniBatchKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_transform = bridgeMiniBatchKMeans[${this.id}].fit_transform(**pms_MiniBatchKMeans_fit_transform)`;
    return this._py`res_MiniBatchKMeans_fit_transform.tolist() if hasattr(res_MiniBatchKMeans_fit_transform, 'tolist') else res_MiniBatchKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchKMeans_get_feature_names_out = {k: v for k, v in pms_MiniBatchKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_feature_names_out = bridgeMiniBatchKMeans[${this.id}].get_feature_names_out(**pms_MiniBatchKMeans_get_feature_names_out)`;
    return this._py`res_MiniBatchKMeans_get_feature_names_out.tolist() if hasattr(res_MiniBatchKMeans_get_feature_names_out, 'tolist') else res_MiniBatchKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchKMeans_get_metadata_routing = {k: v for k, v in pms_MiniBatchKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_metadata_routing = bridgeMiniBatchKMeans[${this.id}].get_metadata_routing(**pms_MiniBatchKMeans_get_metadata_routing)`;
    return this._py`res_MiniBatchKMeans_get_metadata_routing.tolist() if hasattr(res_MiniBatchKMeans_get_metadata_routing, 'tolist') else res_MiniBatchKMeans_get_metadata_routing`;
  }
  /**
    Update k means estimate on a single mini-batch X.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_partial_fit = {k: v for k, v in pms_MiniBatchKMeans_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_partial_fit = bridgeMiniBatchKMeans[${this.id}].partial_fit(**pms_MiniBatchKMeans_partial_fit)`;
    return this._py`res_MiniBatchKMeans_partial_fit.tolist() if hasattr(res_MiniBatchKMeans_partial_fit, 'tolist') else res_MiniBatchKMeans_partial_fit`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_predict = {k: v for k, v in pms_MiniBatchKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_predict = bridgeMiniBatchKMeans[${this.id}].predict(**pms_MiniBatchKMeans_predict)`;
    return this._py`res_MiniBatchKMeans_predict.tolist() if hasattr(res_MiniBatchKMeans_predict, 'tolist') else res_MiniBatchKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before score()");
    }
    await this._py.ex`pms_MiniBatchKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_score = {k: v for k, v in pms_MiniBatchKMeans_score.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_score = bridgeMiniBatchKMeans[${this.id}].score(**pms_MiniBatchKMeans_score)`;
    return this._py`res_MiniBatchKMeans_score.tolist() if hasattr(res_MiniBatchKMeans_score, 'tolist') else res_MiniBatchKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_fit_request = bridgeMiniBatchKMeans[${this.id}].set_fit_request(**pms_MiniBatchKMeans_set_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_fit_request, 'tolist') else res_MiniBatchKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchKMeans_set_output = {k: v for k, v in pms_MiniBatchKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_output = bridgeMiniBatchKMeans[${this.id}].set_output(**pms_MiniBatchKMeans_set_output)`;
    return this._py`res_MiniBatchKMeans_set_output.tolist() if hasattr(res_MiniBatchKMeans_set_output, 'tolist') else res_MiniBatchKMeans_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_partial_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_partial_fit_request = bridgeMiniBatchKMeans[${this.id}].set_partial_fit_request(**pms_MiniBatchKMeans_set_partial_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_partial_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_partial_fit_request, 'tolist') else res_MiniBatchKMeans_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_predict_request = {k: v for k, v in pms_MiniBatchKMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_predict_request = bridgeMiniBatchKMeans[${this.id}].set_predict_request(**pms_MiniBatchKMeans_set_predict_request)`;
    return this._py`res_MiniBatchKMeans_set_predict_request.tolist() if hasattr(res_MiniBatchKMeans_set_predict_request, 'tolist') else res_MiniBatchKMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_score_request = {k: v for k, v in pms_MiniBatchKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_score_request = bridgeMiniBatchKMeans[${this.id}].set_score_request(**pms_MiniBatchKMeans_set_score_request)`;
    return this._py`res_MiniBatchKMeans_set_score_request.tolist() if hasattr(res_MiniBatchKMeans_set_score_request, 'tolist') else res_MiniBatchKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchKMeans_transform = {k: v for k, v in pms_MiniBatchKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_transform = bridgeMiniBatchKMeans[${this.id}].transform(**pms_MiniBatchKMeans_transform)`;
    return this._py`res_MiniBatchKMeans_transform.tolist() if hasattr(res_MiniBatchKMeans_transform, 'tolist') else res_MiniBatchKMeans_transform`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_cluster_centers_ = bridgeMiniBatchKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_MiniBatchKMeans_cluster_centers_.tolist() if hasattr(attr_MiniBatchKMeans_cluster_centers_, 'tolist') else attr_MiniBatchKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point (if compute\_labels is set to `true`).
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_labels_ = bridgeMiniBatchKMeans[${this.id}].labels_`;
      return this._py`attr_MiniBatchKMeans_labels_.tolist() if hasattr(attr_MiniBatchKMeans_labels_, 'tolist') else attr_MiniBatchKMeans_labels_`;
    })();
  }
  /**
    The value of the inertia criterion associated with the chosen partition if compute\_labels is set to `true`. If compute\_labels is set to `false`, itâ€™s an approximation of the inertia based on an exponentially weighted average of the batch inertiae. The inertia is defined as the sum of square distances of samples to their cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_inertia_ = bridgeMiniBatchKMeans[${this.id}].inertia_`;
      return this._py`attr_MiniBatchKMeans_inertia_.tolist() if hasattr(attr_MiniBatchKMeans_inertia_, 'tolist') else attr_MiniBatchKMeans_inertia_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_iter_ = bridgeMiniBatchKMeans[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchKMeans_n_iter_.tolist() if hasattr(attr_MiniBatchKMeans_n_iter_, 'tolist') else attr_MiniBatchKMeans_n_iter_`;
    })();
  }
  /**
    Number of minibatches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_steps_ = bridgeMiniBatchKMeans[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchKMeans_n_steps_.tolist() if hasattr(attr_MiniBatchKMeans_n_steps_, 'tolist') else attr_MiniBatchKMeans_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_features_in_ = bridgeMiniBatchKMeans[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchKMeans_n_features_in_.tolist() if hasattr(attr_MiniBatchKMeans_n_features_in_, 'tolist') else attr_MiniBatchKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_feature_names_in_ = bridgeMiniBatchKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchKMeans_feature_names_in_.tolist() if hasattr(attr_MiniBatchKMeans_feature_names_in_, 'tolist') else attr_MiniBatchKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/OPTICS.ts
import crypto11 from "node:crypto";
var OPTICS = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OPTICS${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OPTICS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import OPTICS
try: bridgeOPTICS
except NameError: bridgeOPTICS = {}
`;
    await this._py.ex`ctor_OPTICS = {'min_samples': ${this.opts["min_samples"] ?? void 0}, 'max_eps': ${this.opts["max_eps"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'cluster_method': ${this.opts["cluster_method"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'xi': ${this.opts["xi"] ?? void 0}, 'predecessor_correction': ${this.opts["predecessor_correction"] ?? void 0}, 'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OPTICS = {k: v for k, v in ctor_OPTICS.items() if v is not None}`;
    await this._py.ex`bridgeOPTICS[${this.id}] = OPTICS(**ctor_OPTICS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOPTICS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Perform OPTICS clustering.
  
      Extracts an ordered list of points and reachability distances, and performs initial clustering using `max\_eps` distance specified at OPTICS object instantiation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit()");
    }
    await this._py.ex`pms_OPTICS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OPTICS_fit = {k: v for k, v in pms_OPTICS_fit.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit = bridgeOPTICS[${this.id}].fit(**pms_OPTICS_fit)`;
    return this._py`res_OPTICS_fit.tolist() if hasattr(res_OPTICS_fit, 'tolist') else res_OPTICS_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit_predict()");
    }
    await this._py.ex`pms_OPTICS_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OPTICS_fit_predict = {k: v for k, v in pms_OPTICS_fit_predict.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit_predict = bridgeOPTICS[${this.id}].fit_predict(**pms_OPTICS_fit_predict)`;
    return this._py`res_OPTICS_fit_predict.tolist() if hasattr(res_OPTICS_fit_predict, 'tolist') else res_OPTICS_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_OPTICS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OPTICS_get_metadata_routing = {k: v for k, v in pms_OPTICS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OPTICS_get_metadata_routing = bridgeOPTICS[${this.id}].get_metadata_routing(**pms_OPTICS_get_metadata_routing)`;
    return this._py`res_OPTICS_get_metadata_routing.tolist() if hasattr(res_OPTICS_get_metadata_routing, 'tolist') else res_OPTICS_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples and points which are not included in a leaf cluster of `cluster\_hierarchy\_` are labeled as -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_labels_ = bridgeOPTICS[${this.id}].labels_`;
      return this._py`attr_OPTICS_labels_.tolist() if hasattr(attr_OPTICS_labels_, 'tolist') else attr_OPTICS_labels_`;
    })();
  }
  /**
    Reachability distances per sample, indexed by object order. Use `clust.reachability\_\[clust.ordering\_\]` to access in cluster order.
   */
  get reachability_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing reachability_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_reachability_ = bridgeOPTICS[${this.id}].reachability_`;
      return this._py`attr_OPTICS_reachability_.tolist() if hasattr(attr_OPTICS_reachability_, 'tolist') else attr_OPTICS_reachability_`;
    })();
  }
  /**
    The cluster ordered list of sample indices.
   */
  get ordering_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing ordering_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_ordering_ = bridgeOPTICS[${this.id}].ordering_`;
      return this._py`attr_OPTICS_ordering_.tolist() if hasattr(attr_OPTICS_ordering_, 'tolist') else attr_OPTICS_ordering_`;
    })();
  }
  /**
    Distance at which each sample becomes a core point, indexed by object order. Points which will never be core have a distance of inf. Use `clust.core\_distances\_\[clust.ordering\_\]` to access in cluster order.
   */
  get core_distances_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing core_distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_core_distances_ = bridgeOPTICS[${this.id}].core_distances_`;
      return this._py`attr_OPTICS_core_distances_.tolist() if hasattr(attr_OPTICS_core_distances_, 'tolist') else attr_OPTICS_core_distances_`;
    })();
  }
  /**
    Point that a sample was reached from, indexed by object order. Seed points have a predecessor of -1.
   */
  get predecessor_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing predecessor_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_predecessor_ = bridgeOPTICS[${this.id}].predecessor_`;
      return this._py`attr_OPTICS_predecessor_.tolist() if hasattr(attr_OPTICS_predecessor_, 'tolist') else attr_OPTICS_predecessor_`;
    })();
  }
  /**
    The list of clusters in the form of `\[start, end\]` in each row, with all indices inclusive. The clusters are ordered according to `(end, \-start)` (ascending) so that larger clusters encompassing smaller clusters come after those smaller ones. Since `labels\_` does not reflect the hierarchy, usually `len(cluster\_hierarchy\_) > np.unique(optics.labels\_)`. Please also note that these indices are of the `ordering\_`, i.e. `X\[ordering\_\]\[start:end + 1\]` form a cluster. Only available when `cluster\_method='xi'`.
   */
  get cluster_hierarchy_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing cluster_hierarchy_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_cluster_hierarchy_ = bridgeOPTICS[${this.id}].cluster_hierarchy_`;
      return this._py`attr_OPTICS_cluster_hierarchy_.tolist() if hasattr(attr_OPTICS_cluster_hierarchy_, 'tolist') else attr_OPTICS_cluster_hierarchy_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_n_features_in_ = bridgeOPTICS[${this.id}].n_features_in_`;
      return this._py`attr_OPTICS_n_features_in_.tolist() if hasattr(attr_OPTICS_n_features_in_, 'tolist') else attr_OPTICS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_feature_names_in_ = bridgeOPTICS[${this.id}].feature_names_in_`;
      return this._py`attr_OPTICS_feature_names_in_.tolist() if hasattr(attr_OPTICS_feature_names_in_, 'tolist') else attr_OPTICS_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralBiclustering.ts
import crypto12 from "node:crypto";
var SpectralBiclustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralBiclustering${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralBiclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralBiclustering
try: bridgeSpectralBiclustering
except NameError: bridgeSpectralBiclustering = {}
`;
    await this._py.ex`ctor_SpectralBiclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'n_best': ${this.opts["n_best"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralBiclustering = {k: v for k, v in ctor_SpectralBiclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralBiclustering[${this.id}] = SpectralBiclustering(**ctor_SpectralBiclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralBiclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralBiclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralBiclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralBiclustering_fit = {k: v for k, v in pms_SpectralBiclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_fit = bridgeSpectralBiclustering[${this.id}].fit(**pms_SpectralBiclustering_fit)`;
    return this._py`res_SpectralBiclustering_fit.tolist() if hasattr(res_SpectralBiclustering_fit, 'tolist') else res_SpectralBiclustering_fit`;
  }
  /**
      Row and column indices of the `i`â€™th bicluster.
  
      Only works if `rows\_` and `columns\_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_indices = {k: v for k, v in pms_SpectralBiclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_indices = bridgeSpectralBiclustering[${this.id}].get_indices(**pms_SpectralBiclustering_get_indices)`;
    return this._py`res_SpectralBiclustering_get_indices.tolist() if hasattr(res_SpectralBiclustering_get_indices, 'tolist') else res_SpectralBiclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralBiclustering_get_metadata_routing = {k: v for k, v in pms_SpectralBiclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_metadata_routing = bridgeSpectralBiclustering[${this.id}].get_metadata_routing(**pms_SpectralBiclustering_get_metadata_routing)`;
    return this._py`res_SpectralBiclustering_get_metadata_routing.tolist() if hasattr(res_SpectralBiclustering_get_metadata_routing, 'tolist') else res_SpectralBiclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`â€™th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_shape = {k: v for k, v in pms_SpectralBiclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_shape = bridgeSpectralBiclustering[${this.id}].get_shape(**pms_SpectralBiclustering_get_shape)`;
    return this._py`res_SpectralBiclustering_get_shape.tolist() if hasattr(res_SpectralBiclustering_get_shape, 'tolist') else res_SpectralBiclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralBiclustering_get_submatrix = {k: v for k, v in pms_SpectralBiclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_submatrix = bridgeSpectralBiclustering[${this.id}].get_submatrix(**pms_SpectralBiclustering_get_submatrix)`;
    return this._py`res_SpectralBiclustering_get_submatrix.tolist() if hasattr(res_SpectralBiclustering_get_submatrix, 'tolist') else res_SpectralBiclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_rows_ = bridgeSpectralBiclustering[${this.id}].rows_`;
      return this._py`attr_SpectralBiclustering_rows_.tolist() if hasattr(attr_SpectralBiclustering_rows_, 'tolist') else attr_SpectralBiclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_columns_ = bridgeSpectralBiclustering[${this.id}].columns_`;
      return this._py`attr_SpectralBiclustering_columns_.tolist() if hasattr(attr_SpectralBiclustering_columns_, 'tolist') else attr_SpectralBiclustering_columns_`;
    })();
  }
  /**
    Row partition labels.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_row_labels_ = bridgeSpectralBiclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralBiclustering_row_labels_.tolist() if hasattr(attr_SpectralBiclustering_row_labels_, 'tolist') else attr_SpectralBiclustering_row_labels_`;
    })();
  }
  /**
    Column partition labels.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_column_labels_ = bridgeSpectralBiclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralBiclustering_column_labels_.tolist() if hasattr(attr_SpectralBiclustering_column_labels_, 'tolist') else attr_SpectralBiclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_n_features_in_ = bridgeSpectralBiclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralBiclustering_n_features_in_.tolist() if hasattr(attr_SpectralBiclustering_n_features_in_, 'tolist') else attr_SpectralBiclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_feature_names_in_ = bridgeSpectralBiclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralBiclustering_feature_names_in_.tolist() if hasattr(attr_SpectralBiclustering_feature_names_in_, 'tolist') else attr_SpectralBiclustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralClustering.ts
import crypto13 from "node:crypto";
var SpectralClustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralClustering${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralClustering
try: bridgeSpectralClustering
except NameError: bridgeSpectralClustering = {}
`;
    await this._py.ex`ctor_SpectralClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'eigen_tol': ${this.opts["eigen_tol"] ?? void 0}, 'assign_labels': ${this.opts["assign_labels"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_SpectralClustering = {k: v for k, v in ctor_SpectralClustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralClustering[${this.id}] = SpectralClustering(**ctor_SpectralClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform spectral clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralClustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralClustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit = {k: v for k, v in pms_SpectralClustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit = bridgeSpectralClustering[${this.id}].fit(**pms_SpectralClustering_fit)`;
    return this._py`res_SpectralClustering_fit.tolist() if hasattr(res_SpectralClustering_fit, 'tolist') else res_SpectralClustering_fit`;
  }
  /**
    Perform spectral clustering on `X` and return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_SpectralClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit_predict = {k: v for k, v in pms_SpectralClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit_predict = bridgeSpectralClustering[${this.id}].fit_predict(**pms_SpectralClustering_fit_predict)`;
    return this._py`res_SpectralClustering_fit_predict.tolist() if hasattr(res_SpectralClustering_fit_predict, 'tolist') else res_SpectralClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralClustering_get_metadata_routing = {k: v for k, v in pms_SpectralClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_get_metadata_routing = bridgeSpectralClustering[${this.id}].get_metadata_routing(**pms_SpectralClustering_get_metadata_routing)`;
    return this._py`res_SpectralClustering_get_metadata_routing.tolist() if hasattr(res_SpectralClustering_get_metadata_routing, 'tolist') else res_SpectralClustering_get_metadata_routing`;
  }
  /**
    Affinity matrix used for clustering. Available only after calling `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_affinity_matrix_ = bridgeSpectralClustering[${this.id}].affinity_matrix_`;
      return this._py`attr_SpectralClustering_affinity_matrix_.tolist() if hasattr(attr_SpectralClustering_affinity_matrix_, 'tolist') else attr_SpectralClustering_affinity_matrix_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_labels_ = bridgeSpectralClustering[${this.id}].labels_`;
      return this._py`attr_SpectralClustering_labels_.tolist() if hasattr(attr_SpectralClustering_labels_, 'tolist') else attr_SpectralClustering_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_n_features_in_ = bridgeSpectralClustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralClustering_n_features_in_.tolist() if hasattr(attr_SpectralClustering_n_features_in_, 'tolist') else attr_SpectralClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_feature_names_in_ = bridgeSpectralClustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralClustering_feature_names_in_.tolist() if hasattr(attr_SpectralClustering_feature_names_in_, 'tolist') else attr_SpectralClustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralCoclustering.ts
import crypto14 from "node:crypto";
var SpectralCoclustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralCoclustering${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralCoclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralCoclustering
try: bridgeSpectralCoclustering
except NameError: bridgeSpectralCoclustering = {}
`;
    await this._py.ex`ctor_SpectralCoclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralCoclustering = {k: v for k, v in ctor_SpectralCoclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralCoclustering[${this.id}] = SpectralCoclustering(**ctor_SpectralCoclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralCoclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralCoclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralCoclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralCoclustering_fit = {k: v for k, v in pms_SpectralCoclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_fit = bridgeSpectralCoclustering[${this.id}].fit(**pms_SpectralCoclustering_fit)`;
    return this._py`res_SpectralCoclustering_fit.tolist() if hasattr(res_SpectralCoclustering_fit, 'tolist') else res_SpectralCoclustering_fit`;
  }
  /**
      Row and column indices of the `i`â€™th bicluster.
  
      Only works if `rows\_` and `columns\_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_indices = {k: v for k, v in pms_SpectralCoclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_indices = bridgeSpectralCoclustering[${this.id}].get_indices(**pms_SpectralCoclustering_get_indices)`;
    return this._py`res_SpectralCoclustering_get_indices.tolist() if hasattr(res_SpectralCoclustering_get_indices, 'tolist') else res_SpectralCoclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralCoclustering_get_metadata_routing = {k: v for k, v in pms_SpectralCoclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_metadata_routing = bridgeSpectralCoclustering[${this.id}].get_metadata_routing(**pms_SpectralCoclustering_get_metadata_routing)`;
    return this._py`res_SpectralCoclustering_get_metadata_routing.tolist() if hasattr(res_SpectralCoclustering_get_metadata_routing, 'tolist') else res_SpectralCoclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`â€™th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_shape = {k: v for k, v in pms_SpectralCoclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_shape = bridgeSpectralCoclustering[${this.id}].get_shape(**pms_SpectralCoclustering_get_shape)`;
    return this._py`res_SpectralCoclustering_get_shape.tolist() if hasattr(res_SpectralCoclustering_get_shape, 'tolist') else res_SpectralCoclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralCoclustering_get_submatrix = {k: v for k, v in pms_SpectralCoclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_submatrix = bridgeSpectralCoclustering[${this.id}].get_submatrix(**pms_SpectralCoclustering_get_submatrix)`;
    return this._py`res_SpectralCoclustering_get_submatrix.tolist() if hasattr(res_SpectralCoclustering_get_submatrix, 'tolist') else res_SpectralCoclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_rows_ = bridgeSpectralCoclustering[${this.id}].rows_`;
      return this._py`attr_SpectralCoclustering_rows_.tolist() if hasattr(attr_SpectralCoclustering_rows_, 'tolist') else attr_SpectralCoclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_columns_ = bridgeSpectralCoclustering[${this.id}].columns_`;
      return this._py`attr_SpectralCoclustering_columns_.tolist() if hasattr(attr_SpectralCoclustering_columns_, 'tolist') else attr_SpectralCoclustering_columns_`;
    })();
  }
  /**
    The bicluster label of each row.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_row_labels_ = bridgeSpectralCoclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralCoclustering_row_labels_.tolist() if hasattr(attr_SpectralCoclustering_row_labels_, 'tolist') else attr_SpectralCoclustering_row_labels_`;
    })();
  }
  /**
    The bicluster label of each column.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_column_labels_ = bridgeSpectralCoclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralCoclustering_column_labels_.tolist() if hasattr(attr_SpectralCoclustering_column_labels_, 'tolist') else attr_SpectralCoclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_n_features_in_ = bridgeSpectralCoclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralCoclustering_n_features_in_.tolist() if hasattr(attr_SpectralCoclustering_n_features_in_, 'tolist') else attr_SpectralCoclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_feature_names_in_ = bridgeSpectralCoclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralCoclustering_feature_names_in_.tolist() if hasattr(attr_SpectralCoclustering_feature_names_in_, 'tolist') else attr_SpectralCoclustering_feature_names_in_`;
    })();
  }
};
export {
  AffinityPropagation,
  AgglomerativeClustering,
  Birch,
  BisectingKMeans,
  DBSCAN,
  FeatureAgglomeration,
  HDBSCAN,
  KMeans,
  MeanShift,
  MiniBatchKMeans,
  OPTICS,
  SpectralBiclustering,
  SpectralClustering,
  SpectralCoclustering
};
//# sourceMappingURL=index.js.map