{"version":3,"sources":["../../../src/generated/cluster/AffinityPropagation.ts","../../../src/generated/cluster/AgglomerativeClustering.ts","../../../src/generated/cluster/Birch.ts","../../../src/generated/cluster/BisectingKMeans.ts","../../../src/generated/cluster/DBSCAN.ts","../../../src/generated/cluster/FeatureAgglomeration.ts","../../../src/generated/cluster/HDBSCAN.ts","../../../src/generated/cluster/KMeans.ts","../../../src/generated/cluster/MeanShift.ts","../../../src/generated/cluster/MiniBatchKMeans.ts","../../../src/generated/cluster/OPTICS.ts","../../../src/generated/cluster/SpectralBiclustering.ts","../../../src/generated/cluster/SpectralClustering.ts","../../../src/generated/cluster/SpectralCoclustering.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Perform Affinity Propagation Clustering of data.\n\n  Read more in the [User Guide](../clustering.html#affinity-propagation).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AffinityPropagation.html)\n */\nexport class AffinityPropagation {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Damping factor in the range `\\[0.5, 1.0)` is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). This in order to avoid numerical oscillations when updating these values (messages).\n\n      @defaultValue `0.5`\n     */\n    damping?: number\n\n    /**\n      Maximum number of iterations.\n\n      @defaultValue `200`\n     */\n    max_iter?: number\n\n    /**\n      Number of iterations with no change in the number of estimated clusters that stops the convergence.\n\n      @defaultValue `15`\n     */\n    convergence_iter?: number\n\n    /**\n      Make a copy of input data.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. The number of exemplars, ie of clusters, is influenced by the input preferences value. If the preferences are not passed as arguments, they will be set to the median of the input similarities.\n     */\n    preference?: ArrayLike | number\n\n    /**\n      Which affinity to use. At the moment ‘precomputed’ and `euclidean` are supported. ‘euclidean’ uses the negative squared euclidean distance between points.\n\n      @defaultValue `'euclidean'`\n     */\n    affinity?: 'euclidean' | 'precomputed'\n\n    /**\n      Whether to be verbose.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Pseudo-random number generator to control the starting state. Use an int for reproducible results across function calls. See the [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `AffinityPropagation${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'AffinityPropagation.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import AffinityPropagation\ntry: bridgeAffinityPropagation\nexcept NameError: bridgeAffinityPropagation = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_AffinityPropagation = {'damping': ${\n      this.opts['damping'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'convergence_iter': ${\n      this.opts['convergence_iter'] ?? undefined\n    }, 'copy': ${this.opts['copy'] ?? undefined}, 'preference': np.array(${\n      this.opts['preference'] ?? undefined\n    }) if ${this.opts['preference'] !== undefined} else None, 'affinity': ${\n      this.opts['affinity'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_AffinityPropagation = {k: v for k, v in ctor_AffinityPropagation.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeAffinityPropagation[${this.id}] = AffinityPropagation(**ctor_AffinityPropagation)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeAffinityPropagation[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the clustering from features, or affinity matrix.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster, or similarities / affinities between instances if `affinity='precomputed'`. If a sparse feature matrix is provided, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('AffinityPropagation must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_AffinityPropagation_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_AffinityPropagation_fit = {k: v for k, v in pms_AffinityPropagation_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AffinityPropagation_fit = bridgeAffinityPropagation[${this.id}].fit(**pms_AffinityPropagation_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AffinityPropagation_fit.tolist() if hasattr(res_AffinityPropagation_fit, 'tolist') else res_AffinityPropagation_fit`\n  }\n\n  /**\n    Fit clustering from features/affinity matrix; return cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Training instances to cluster, or similarities / affinities between instances if `affinity='precomputed'`. If a sparse feature matrix is provided, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before fit_predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_AffinityPropagation_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_AffinityPropagation_fit_predict = {k: v for k, v in pms_AffinityPropagation_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AffinityPropagation_fit_predict = bridgeAffinityPropagation[${this.id}].fit_predict(**pms_AffinityPropagation_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AffinityPropagation_fit_predict.tolist() if hasattr(res_AffinityPropagation_fit_predict, 'tolist') else res_AffinityPropagation_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_AffinityPropagation_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_AffinityPropagation_get_metadata_routing = {k: v for k, v in pms_AffinityPropagation_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AffinityPropagation_get_metadata_routing = bridgeAffinityPropagation[${this.id}].get_metadata_routing(**pms_AffinityPropagation_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AffinityPropagation_get_metadata_routing.tolist() if hasattr(res_AffinityPropagation_get_metadata_routing, 'tolist') else res_AffinityPropagation_get_metadata_routing`\n  }\n\n  /**\n    Predict the closest cluster each sample in X belongs to.\n   */\n  async predict(opts: {\n    /**\n      New data to predict. If a sparse matrix is provided, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('AffinityPropagation must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_AffinityPropagation_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_AffinityPropagation_predict = {k: v for k, v in pms_AffinityPropagation_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AffinityPropagation_predict = bridgeAffinityPropagation[${this.id}].predict(**pms_AffinityPropagation_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AffinityPropagation_predict.tolist() if hasattr(res_AffinityPropagation_predict, 'tolist') else res_AffinityPropagation_predict`\n  }\n\n  /**\n    Indices of cluster centers.\n   */\n  get cluster_centers_indices_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing cluster_centers_indices_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_cluster_centers_indices_ = bridgeAffinityPropagation[${this.id}].cluster_centers_indices_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_cluster_centers_indices_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_indices_, 'tolist') else attr_AffinityPropagation_cluster_centers_indices_`\n    })()\n  }\n\n  /**\n    Cluster centers (if affinity != `precomputed`).\n   */\n  get cluster_centers_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing cluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_cluster_centers_ = bridgeAffinityPropagation[${this.id}].cluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_cluster_centers_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_, 'tolist') else attr_AffinityPropagation_cluster_centers_`\n    })()\n  }\n\n  /**\n    Labels of each point.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_labels_ = bridgeAffinityPropagation[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_labels_.tolist() if hasattr(attr_AffinityPropagation_labels_, 'tolist') else attr_AffinityPropagation_labels_`\n    })()\n  }\n\n  /**\n    Stores the affinity matrix used in `fit`.\n   */\n  get affinity_matrix_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing affinity_matrix_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_affinity_matrix_ = bridgeAffinityPropagation[${this.id}].affinity_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_affinity_matrix_.tolist() if hasattr(attr_AffinityPropagation_affinity_matrix_, 'tolist') else attr_AffinityPropagation_affinity_matrix_`\n    })()\n  }\n\n  /**\n    Number of iterations taken to converge.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_n_iter_ = bridgeAffinityPropagation[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_n_iter_.tolist() if hasattr(attr_AffinityPropagation_n_iter_, 'tolist') else attr_AffinityPropagation_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_n_features_in_ = bridgeAffinityPropagation[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_n_features_in_.tolist() if hasattr(attr_AffinityPropagation_n_features_in_, 'tolist') else attr_AffinityPropagation_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AffinityPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AffinityPropagation must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AffinityPropagation_feature_names_in_ = bridgeAffinityPropagation[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AffinityPropagation_feature_names_in_.tolist() if hasattr(attr_AffinityPropagation_feature_names_in_, 'tolist') else attr_AffinityPropagation_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Agglomerative Clustering.\n\n  Recursively merges pair of clusters of sample data; uses linkage distance.\n\n  Read more in the [User Guide](../clustering.html#hierarchical-clustering).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html)\n */\nexport class AgglomerativeClustering {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of clusters to find. It must be `undefined` if `distance\\_threshold` is not `undefined`.\n\n      @defaultValue `2`\n     */\n    n_clusters?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\") for its metric parameter. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix (instead of a similarity matrix) is needed as input for the fit method.\n\n      @defaultValue `'euclidean'`\n     */\n    affinity?: string\n\n    /**\n      Metric used to compute the linkage. Can be “euclidean”, “l1”, “l2”, “manhattan”, “cosine”, or “precomputed”. If set to `undefined` then “euclidean” is used. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix is needed as input for the fit method.\n     */\n    metric?: string\n\n    /**\n      Used to cache the output of the computation of the tree. By default, no caching is done. If a string is given, it is the path to the caching directory.\n     */\n    memory?: string\n\n    /**\n      Connectivity matrix. Defines for each sample the neighboring samples following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix, such as derived from `kneighbors\\_graph`. Default is `undefined`, i.e, the hierarchical clustering algorithm is unstructured.\n     */\n    connectivity?: ArrayLike\n\n    /**\n      Stop early the construction of the tree at `n\\_clusters`. This is useful to decrease computation time if the number of clusters is not small compared to the number of samples. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree. It must be `true` if `distance\\_threshold` is not `undefined`. By default `compute\\_full\\_tree` is “auto”, which is equivalent to `true` when `distance\\_threshold` is not `undefined` or that `n\\_clusters` is inferior to the maximum between 100 or `0.02 \\* n\\_samples`. Otherwise, “auto” is equivalent to `false`.\n\n      @defaultValue `'auto'`\n     */\n    compute_full_tree?: 'auto' | boolean\n\n    /**\n      Which linkage criterion to use. The linkage criterion determines which distance to use between sets of observation. The algorithm will merge the pairs of cluster that minimize this criterion.\n\n      @defaultValue `'ward'`\n     */\n    linkage?: 'ward' | 'complete' | 'average' | 'single'\n\n    /**\n      The linkage distance threshold at or above which clusters will not be merged. If not `undefined`, `n\\_clusters` must be `undefined` and `compute\\_full\\_tree` must be `true`.\n     */\n    distance_threshold?: number\n\n    /**\n      Computes distances between clusters even if `distance\\_threshold` is not used. This can be used to make dendrogram visualization, but introduces a computational and memory overhead.\n\n      @defaultValue `false`\n     */\n    compute_distances?: boolean\n  }) {\n    this.id = `AgglomerativeClustering${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'AgglomerativeClustering.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import AgglomerativeClustering\ntry: bridgeAgglomerativeClustering\nexcept NameError: bridgeAgglomerativeClustering = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_AgglomerativeClustering = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'affinity': ${this.opts['affinity'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'memory': ${this.opts['memory'] ?? undefined}, 'connectivity': ${\n      this.opts['connectivity'] ?? undefined\n    }, 'compute_full_tree': ${\n      this.opts['compute_full_tree'] ?? undefined\n    }, 'linkage': ${this.opts['linkage'] ?? undefined}, 'distance_threshold': ${\n      this.opts['distance_threshold'] ?? undefined\n    }, 'compute_distances': ${this.opts['compute_distances'] ?? undefined}}\n\nctor_AgglomerativeClustering = {k: v for k, v in ctor_AgglomerativeClustering.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeAgglomerativeClustering[${this.id}] = AgglomerativeClustering(**ctor_AgglomerativeClustering)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeAgglomerativeClustering[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the hierarchical clustering from features, or distance matrix.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster, or distances between instances if `metric='precomputed'`.\n     */\n    X?: ArrayLike\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('AgglomerativeClustering must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_AgglomerativeClustering_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_AgglomerativeClustering_fit = {k: v for k, v in pms_AgglomerativeClustering_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AgglomerativeClustering_fit = bridgeAgglomerativeClustering[${this.id}].fit(**pms_AgglomerativeClustering_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AgglomerativeClustering_fit.tolist() if hasattr(res_AgglomerativeClustering_fit, 'tolist') else res_AgglomerativeClustering_fit`\n  }\n\n  /**\n    Fit and return the result of each sample’s clustering assignment.\n\n    In addition to fitting, this method also return the result of the clustering assignment for each sample in the training set.\n   */\n  async fit_predict(opts: {\n    /**\n      Training instances to cluster, or distances between instances if `affinity='precomputed'`.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before fit_predict()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_AgglomerativeClustering_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_AgglomerativeClustering_fit_predict = {k: v for k, v in pms_AgglomerativeClustering_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AgglomerativeClustering_fit_predict = bridgeAgglomerativeClustering[${this.id}].fit_predict(**pms_AgglomerativeClustering_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AgglomerativeClustering_fit_predict.tolist() if hasattr(res_AgglomerativeClustering_fit_predict, 'tolist') else res_AgglomerativeClustering_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_AgglomerativeClustering_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_AgglomerativeClustering_get_metadata_routing = {k: v for k, v in pms_AgglomerativeClustering_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AgglomerativeClustering_get_metadata_routing = bridgeAgglomerativeClustering[${this.id}].get_metadata_routing(**pms_AgglomerativeClustering_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AgglomerativeClustering_get_metadata_routing.tolist() if hasattr(res_AgglomerativeClustering_get_metadata_routing, 'tolist') else res_AgglomerativeClustering_get_metadata_routing`\n  }\n\n  /**\n    The number of clusters found by the algorithm. If `distance\\_threshold=None`, it will be equal to the given `n\\_clusters`.\n   */\n  get n_clusters_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing n_clusters_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_n_clusters_ = bridgeAgglomerativeClustering[${this.id}].n_clusters_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_n_clusters_.tolist() if hasattr(attr_AgglomerativeClustering_n_clusters_, 'tolist') else attr_AgglomerativeClustering_n_clusters_`\n    })()\n  }\n\n  /**\n    Cluster labels for each point.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_labels_ = bridgeAgglomerativeClustering[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_labels_.tolist() if hasattr(attr_AgglomerativeClustering_labels_, 'tolist') else attr_AgglomerativeClustering_labels_`\n    })()\n  }\n\n  /**\n    Number of leaves in the hierarchical tree.\n   */\n  get n_leaves_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing n_leaves_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_n_leaves_ = bridgeAgglomerativeClustering[${this.id}].n_leaves_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_n_leaves_.tolist() if hasattr(attr_AgglomerativeClustering_n_leaves_, 'tolist') else attr_AgglomerativeClustering_n_leaves_`\n    })()\n  }\n\n  /**\n    The estimated number of connected components in the graph.\n   */\n  get n_connected_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing n_connected_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_n_connected_components_ = bridgeAgglomerativeClustering[${this.id}].n_connected_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_n_connected_components_.tolist() if hasattr(attr_AgglomerativeClustering_n_connected_components_, 'tolist') else attr_AgglomerativeClustering_n_connected_components_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_n_features_in_ = bridgeAgglomerativeClustering[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_n_features_in_.tolist() if hasattr(attr_AgglomerativeClustering_n_features_in_, 'tolist') else attr_AgglomerativeClustering_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_feature_names_in_ = bridgeAgglomerativeClustering[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_feature_names_in_.tolist() if hasattr(attr_AgglomerativeClustering_feature_names_in_, 'tolist') else attr_AgglomerativeClustering_feature_names_in_`\n    })()\n  }\n\n  /**\n    The children of each non-leaf node. Values less than `n\\_samples` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\\_samples` is a non-leaf node and has children `children\\_\\[i \\- n\\_samples\\]`. Alternatively at the i-th iteration, children\\[i\\]\\[0\\] and children\\[i\\]\\[1\\] are merged to form node `n\\_samples + i`.\n   */\n  get children_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing children_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_children_ = bridgeAgglomerativeClustering[${this.id}].children_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_children_.tolist() if hasattr(attr_AgglomerativeClustering_children_, 'tolist') else attr_AgglomerativeClustering_children_`\n    })()\n  }\n\n  /**\n    Distances between nodes in the corresponding place in `children\\_`. Only computed if `distance\\_threshold` is used or `compute\\_distances` is set to `true`.\n   */\n  get distances_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AgglomerativeClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AgglomerativeClustering must call init() before accessing distances_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AgglomerativeClustering_distances_ = bridgeAgglomerativeClustering[${this.id}].distances_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AgglomerativeClustering_distances_.tolist() if hasattr(attr_AgglomerativeClustering_distances_, 'tolist') else attr_AgglomerativeClustering_distances_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Implements the BIRCH clustering algorithm.\n\n  It is a memory-efficient, online-learning algorithm provided as an alternative to [`MiniBatchKMeans`](sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans \"sklearn.cluster.MiniBatchKMeans\"). It constructs a tree data structure with the cluster centroids being read off the leaf. These can be either the final cluster centroids or can be provided as input to another clustering algorithm such as [`AgglomerativeClustering`](sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering \"sklearn.cluster.AgglomerativeClustering\").\n\n  Read more in the [User Guide](../clustering.html#birch).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Birch.html)\n */\nexport class Birch {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.\n\n      @defaultValue `0.5`\n     */\n    threshold?: number\n\n    /**\n      Maximum number of CF subclusters in each node. If a new samples enters such that the number of subclusters exceed the branching\\_factor then that node is split into two nodes with the subclusters redistributed in each. The parent subcluster of that node is removed and two new subclusters are added as parents of the 2 split nodes.\n\n      @defaultValue `50`\n     */\n    branching_factor?: number\n\n    /**\n      Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.\n\n      @defaultValue `3`\n     */\n    n_clusters?: number\n\n    /**\n      Whether or not to compute labels for each fit.\n\n      @defaultValue `true`\n     */\n    compute_labels?: boolean\n\n    /**\n      Whether or not to make a copy of the given data. If set to `false`, the initial data will be overwritten.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n  }) {\n    this.id = `Birch${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Birch.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import Birch\ntry: bridgeBirch\nexcept NameError: bridgeBirch = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Birch = {'threshold': ${\n      this.opts['threshold'] ?? undefined\n    }, 'branching_factor': ${\n      this.opts['branching_factor'] ?? undefined\n    }, 'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'compute_labels': ${this.opts['compute_labels'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }}\n\nctor_Birch = {k: v for k, v in ctor_Birch.items() if v is not None}`\n\n    await this._py.ex`bridgeBirch[${this.id}] = Birch(**ctor_Birch)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeBirch[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Build a CF Tree for the input data.\n   */\n  async fit(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_Birch_fit = {k: v for k, v in pms_Birch_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_fit = bridgeBirch[${this.id}].fit(**pms_Birch_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_fit.tolist() if hasattr(res_Birch_fit, 'tolist') else res_Birch_fit`\n  }\n\n  /**\n    Perform clustering on `X` and returns cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_Birch_fit_predict = {k: v for k, v in pms_Birch_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_fit_predict = bridgeBirch[${this.id}].fit_predict(**pms_Birch_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_fit_predict.tolist() if hasattr(res_Birch_fit_predict, 'tolist') else res_Birch_fit_predict`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_Birch_fit_transform = {k: v for k, v in pms_Birch_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_fit_transform = bridgeBirch[${this.id}].fit_transform(**pms_Birch_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_fit_transform.tolist() if hasattr(res_Birch_fit_transform, 'tolist') else res_Birch_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Birch_get_feature_names_out = {k: v for k, v in pms_Birch_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_get_feature_names_out = bridgeBirch[${this.id}].get_feature_names_out(**pms_Birch_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_get_feature_names_out.tolist() if hasattr(res_Birch_get_feature_names_out, 'tolist') else res_Birch_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Birch_get_metadata_routing = {k: v for k, v in pms_Birch_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_get_metadata_routing = bridgeBirch[${this.id}].get_metadata_routing(**pms_Birch_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_get_metadata_routing.tolist() if hasattr(res_Birch_get_metadata_routing, 'tolist') else res_Birch_get_metadata_routing`\n  }\n\n  /**\n    Online learning. Prevents rebuilding of CFTree from scratch.\n   */\n  async partial_fit(opts: {\n    /**\n      Input data. If X is not provided, only the global clustering step is done.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_Birch_partial_fit = {k: v for k, v in pms_Birch_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_partial_fit = bridgeBirch[${this.id}].partial_fit(**pms_Birch_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_partial_fit.tolist() if hasattr(res_Birch_partial_fit, 'tolist') else res_Birch_partial_fit`\n  }\n\n  /**\n    Predict data using the `centroids\\_` of subclusters.\n\n    Avoid computation of the row norms of X.\n   */\n  async predict(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_Birch_predict = {k: v for k, v in pms_Birch_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_predict = bridgeBirch[${this.id}].predict(**pms_Birch_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_predict.tolist() if hasattr(res_Birch_predict, 'tolist') else res_Birch_predict`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Birch_set_output = {k: v for k, v in pms_Birch_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_set_output = bridgeBirch[${this.id}].set_output(**pms_Birch_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_set_output.tolist() if hasattr(res_Birch_set_output, 'tolist') else res_Birch_set_output`\n  }\n\n  /**\n    Transform X into subcluster centroids dimension.\n\n    Each dimension represents the distance from the sample point to each cluster centroid.\n   */\n  async transform(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Birch_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_Birch_transform = {k: v for k, v in pms_Birch_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Birch_transform = bridgeBirch[${this.id}].transform(**pms_Birch_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Birch_transform.tolist() if hasattr(res_Birch_transform, 'tolist') else res_Birch_transform`\n  }\n\n  /**\n    Root of the CFTree.\n   */\n  get root_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before accessing root_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Birch_root_ = bridgeBirch[${this.id}].root_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_root_.tolist() if hasattr(attr_Birch_root_, 'tolist') else attr_Birch_root_`\n    })()\n  }\n\n  /**\n    Start pointer to all the leaves.\n   */\n  get dummy_leaf_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before accessing dummy_leaf_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Birch_dummy_leaf_ = bridgeBirch[${this.id}].dummy_leaf_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_dummy_leaf_.tolist() if hasattr(attr_Birch_dummy_leaf_, 'tolist') else attr_Birch_dummy_leaf_`\n    })()\n  }\n\n  /**\n    Centroids of all subclusters read directly from the leaves.\n   */\n  get subcluster_centers_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Birch must call init() before accessing subcluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Birch_subcluster_centers_ = bridgeBirch[${this.id}].subcluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_subcluster_centers_.tolist() if hasattr(attr_Birch_subcluster_centers_, 'tolist') else attr_Birch_subcluster_centers_`\n    })()\n  }\n\n  /**\n    Labels assigned to the centroids of the subclusters after they are clustered globally.\n   */\n  get subcluster_labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Birch must call init() before accessing subcluster_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Birch_subcluster_labels_ = bridgeBirch[${this.id}].subcluster_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_subcluster_labels_.tolist() if hasattr(attr_Birch_subcluster_labels_, 'tolist') else attr_Birch_subcluster_labels_`\n    })()\n  }\n\n  /**\n    Array of labels assigned to the input data. if partial\\_fit is used instead of fit, they are assigned to the last batch of data.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Birch_labels_ = bridgeBirch[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_labels_.tolist() if hasattr(attr_Birch_labels_, 'tolist') else attr_Birch_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Birch must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Birch_n_features_in_ = bridgeBirch[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_n_features_in_.tolist() if hasattr(attr_Birch_n_features_in_, 'tolist') else attr_Birch_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Birch instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Birch must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Birch_feature_names_in_ = bridgeBirch[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Birch_feature_names_in_.tolist() if hasattr(attr_Birch_feature_names_in_, 'tolist') else attr_Birch_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Bisecting K-Means clustering.\n\n  Read more in the [User Guide](../clustering.html#bisect-k-means).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.BisectingKMeans.html)\n */\nexport class BisectingKMeans {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of clusters to form as well as the number of centroids to generate.\n\n      @defaultValue `8`\n     */\n    n_clusters?: number\n\n    /**\n      Method for initialization:\n\n      ‘k-means++’ : selects initial cluster centers for k-mean clustering in a smart way to speed up convergence. See section Notes in k\\_init for more details.\n\n      ‘random’: choose `n\\_clusters` observations (rows) at random from data for the initial centroids.\n\n      If a callable is passed, it should take arguments X, n\\_clusters and a random state and return an initialization.\n\n      @defaultValue `'random'`\n     */\n    init?: 'k-means++' | 'random'\n\n    /**\n      Number of time the inner k-means algorithm will be run with different centroid seeds in each bisection. That will result producing for each bisection best output of n\\_init consecutive runs in terms of inertia.\n\n      @defaultValue `1`\n     */\n    n_init?: number\n\n    /**\n      Determines random number generation for centroid initialization in inner K-Means. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Maximum number of iterations of the inner k-means algorithm at each bisection.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n\n    /**\n      Verbosity mode.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Relative tolerance with regards to Frobenius norm of the difference in the cluster centers of two consecutive iterations to declare convergence. Used in inner k-means algorithm at each bisection to pick best possible clusters.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      When pre-computing distances it is more numerically accurate to center the data first. If copy\\_x is `true` (default), then the original data is not modified. If `false`, the original data is modified, and put back before the function returns, but small numerical differences may be introduced by subtracting and then adding the data mean. Note that if the original data is not C-contiguous, a copy will be made even if copy\\_x is `false`. If the original data is sparse, but not in CSR format, a copy will be made even if copy\\_x is `false`.\n\n      @defaultValue `true`\n     */\n    copy_x?: boolean\n\n    /**\n      Inner K-means algorithm used in bisection. The classical EM-style algorithm is `\"lloyd\"`. The `\"elkan\"` variation can be more efficient on some datasets with well-defined clusters, by using the triangle inequality. However it’s more memory intensive due to the allocation of an extra array of shape `(n\\_samples, n\\_clusters)`.\n\n      @defaultValue `'lloyd'`\n     */\n    algorithm?: 'lloyd' | 'elkan'\n\n    /**\n      Defines how bisection should be performed:\n\n      @defaultValue `'biggest_inertia'`\n     */\n    bisecting_strategy?: 'biggest_inertia' | 'largest_cluster'\n  }) {\n    this.id = `BisectingKMeans${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('BisectingKMeans.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import BisectingKMeans\ntry: bridgeBisectingKMeans\nexcept NameError: bridgeBisectingKMeans = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_BisectingKMeans = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'init': ${this.opts['init'] ?? undefined}, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'copy_x': ${this.opts['copy_x'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'bisecting_strategy': ${this.opts['bisecting_strategy'] ?? undefined}}\n\nctor_BisectingKMeans = {k: v for k, v in ctor_BisectingKMeans.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeBisectingKMeans[${this.id}] = BisectingKMeans(**ctor_BisectingKMeans)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeBisectingKMeans[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute bisecting k-means clustering.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight. `sample\\_weight` is not used during initialization if `init` is a callable.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_BisectingKMeans_fit = {k: v for k, v in pms_BisectingKMeans_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_fit = bridgeBisectingKMeans[${this.id}].fit(**pms_BisectingKMeans_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_fit.tolist() if hasattr(res_BisectingKMeans_fit, 'tolist') else res_BisectingKMeans_fit`\n  }\n\n  /**\n    Compute cluster centers and predict cluster index for each sample.\n\n    Convenience method; equivalent to calling fit(X) followed by predict(X).\n   */\n  async fit_predict(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_BisectingKMeans_fit_predict = {k: v for k, v in pms_BisectingKMeans_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_fit_predict = bridgeBisectingKMeans[${this.id}].fit_predict(**pms_BisectingKMeans_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_fit_predict.tolist() if hasattr(res_BisectingKMeans_fit_predict, 'tolist') else res_BisectingKMeans_fit_predict`\n  }\n\n  /**\n    Compute clustering and transform X to cluster-distance space.\n\n    Equivalent to fit(X).transform(X), but more efficiently implemented.\n   */\n  async fit_transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_BisectingKMeans_fit_transform = {k: v for k, v in pms_BisectingKMeans_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_fit_transform = bridgeBisectingKMeans[${this.id}].fit_transform(**pms_BisectingKMeans_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_fit_transform.tolist() if hasattr(res_BisectingKMeans_fit_transform, 'tolist') else res_BisectingKMeans_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_BisectingKMeans_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_BisectingKMeans_get_feature_names_out = {k: v for k, v in pms_BisectingKMeans_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_get_feature_names_out = bridgeBisectingKMeans[${this.id}].get_feature_names_out(**pms_BisectingKMeans_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_get_feature_names_out.tolist() if hasattr(res_BisectingKMeans_get_feature_names_out, 'tolist') else res_BisectingKMeans_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_BisectingKMeans_get_metadata_routing = {k: v for k, v in pms_BisectingKMeans_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_get_metadata_routing = bridgeBisectingKMeans[${this.id}].get_metadata_routing(**pms_BisectingKMeans_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_get_metadata_routing.tolist() if hasattr(res_BisectingKMeans_get_metadata_routing, 'tolist') else res_BisectingKMeans_get_metadata_routing`\n  }\n\n  /**\n    Predict which cluster each sample in X belongs to.\n\n    Prediction is made by going down the hierarchical tree in searching of closest leaf cluster.\n\n    In the vector quantization literature, `cluster\\_centers\\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.\n   */\n  async predict(opts: {\n    /**\n      New data to predict.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_BisectingKMeans_predict = {k: v for k, v in pms_BisectingKMeans_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_predict = bridgeBisectingKMeans[${this.id}].predict(**pms_BisectingKMeans_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_predict.tolist() if hasattr(res_BisectingKMeans_predict, 'tolist') else res_BisectingKMeans_predict`\n  }\n\n  /**\n    Opposite of the value of X on the K-means objective.\n   */\n  async score(opts: {\n    /**\n      New data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_BisectingKMeans_score = {k: v for k, v in pms_BisectingKMeans_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_score = bridgeBisectingKMeans[${this.id}].score(**pms_BisectingKMeans_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_score.tolist() if hasattr(res_BisectingKMeans_score, 'tolist') else res_BisectingKMeans_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_BisectingKMeans_set_fit_request = {k: v for k, v in pms_BisectingKMeans_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_set_fit_request = bridgeBisectingKMeans[${this.id}].set_fit_request(**pms_BisectingKMeans_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_set_fit_request.tolist() if hasattr(res_BisectingKMeans_set_fit_request, 'tolist') else res_BisectingKMeans_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_BisectingKMeans_set_output = {k: v for k, v in pms_BisectingKMeans_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_set_output = bridgeBisectingKMeans[${this.id}].set_output(**pms_BisectingKMeans_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_set_output.tolist() if hasattr(res_BisectingKMeans_set_output, 'tolist') else res_BisectingKMeans_set_output`\n  }\n\n  /**\n    Request metadata passed to the `predict` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_predict_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `predict`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before set_predict_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_BisectingKMeans_set_predict_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_BisectingKMeans_set_predict_request = {k: v for k, v in pms_BisectingKMeans_set_predict_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_set_predict_request = bridgeBisectingKMeans[${this.id}].set_predict_request(**pms_BisectingKMeans_set_predict_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_set_predict_request.tolist() if hasattr(res_BisectingKMeans_set_predict_request, 'tolist') else res_BisectingKMeans_set_predict_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_BisectingKMeans_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_BisectingKMeans_set_score_request = {k: v for k, v in pms_BisectingKMeans_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_set_score_request = bridgeBisectingKMeans[${this.id}].set_score_request(**pms_BisectingKMeans_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_set_score_request.tolist() if hasattr(res_BisectingKMeans_set_score_request, 'tolist') else res_BisectingKMeans_set_score_request`\n  }\n\n  /**\n    Transform X to a cluster-distance space.\n\n    In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.\n   */\n  async transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BisectingKMeans must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BisectingKMeans_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_BisectingKMeans_transform = {k: v for k, v in pms_BisectingKMeans_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BisectingKMeans_transform = bridgeBisectingKMeans[${this.id}].transform(**pms_BisectingKMeans_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BisectingKMeans_transform.tolist() if hasattr(res_BisectingKMeans_transform, 'tolist') else res_BisectingKMeans_transform`\n  }\n\n  /**\n    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\\_iter`), these will not be consistent with `labels\\_`.\n   */\n  get cluster_centers_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before accessing cluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BisectingKMeans_cluster_centers_ = bridgeBisectingKMeans[${this.id}].cluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BisectingKMeans_cluster_centers_.tolist() if hasattr(attr_BisectingKMeans_cluster_centers_, 'tolist') else attr_BisectingKMeans_cluster_centers_`\n    })()\n  }\n\n  /**\n    Labels of each point.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BisectingKMeans_labels_ = bridgeBisectingKMeans[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BisectingKMeans_labels_.tolist() if hasattr(attr_BisectingKMeans_labels_, 'tolist') else attr_BisectingKMeans_labels_`\n    })()\n  }\n\n  /**\n    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.\n   */\n  get inertia_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before accessing inertia_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BisectingKMeans_inertia_ = bridgeBisectingKMeans[${this.id}].inertia_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BisectingKMeans_inertia_.tolist() if hasattr(attr_BisectingKMeans_inertia_, 'tolist') else attr_BisectingKMeans_inertia_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BisectingKMeans_n_features_in_ = bridgeBisectingKMeans[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BisectingKMeans_n_features_in_.tolist() if hasattr(attr_BisectingKMeans_n_features_in_, 'tolist') else attr_BisectingKMeans_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BisectingKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BisectingKMeans must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BisectingKMeans_feature_names_in_ = bridgeBisectingKMeans[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BisectingKMeans_feature_names_in_.tolist() if hasattr(attr_BisectingKMeans_feature_names_in_, 'tolist') else attr_BisectingKMeans_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Perform DBSCAN clustering from vector array or distance matrix.\n\n  DBSCAN - Density-Based Spatial Clustering of Applications with Noise. Finds core samples of high density and expands clusters from them. Good for data which contains clusters of similar density.\n\n  The worst case memory complexity of DBSCAN is \\\\(O({n}^2)\\\\), which can occur when the `eps` param is large and `min\\_samples` is low.\n\n  Read more in the [User Guide](../clustering.html#dbscan).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html)\n */\nexport class DBSCAN {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The maximum distance between two samples for one to be considered as in the neighborhood of the other. This is not a maximum bound on the distances of points within a cluster. This is the most important DBSCAN parameter to choose appropriately for your data set and distance function.\n\n      @defaultValue `0.5`\n     */\n    eps?: number\n\n    /**\n      The number of samples (or total weight) in a neighborhood for a point to be considered as a core point. This includes the point itself. If `min\\_samples` is set to a higher value, DBSCAN will find denser clusters, whereas if it is set to a lower value, the found clusters will be more sparse.\n\n      @defaultValue `5`\n     */\n    min_samples?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\") for its metric parameter. If metric is “precomputed”, X is assumed to be a distance matrix and must be square. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors for DBSCAN.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: any\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors. See NearestNeighbors module documentation for details.\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or cKDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      The power of the Minkowski metric to be used to calculate distance between points. If `undefined`, then `p=2` (equivalent to the Euclidean distance).\n     */\n    p?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `DBSCAN${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('DBSCAN.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import DBSCAN\ntry: bridgeDBSCAN\nexcept NameError: bridgeDBSCAN = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_DBSCAN = {'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'min_samples': ${this.opts['min_samples'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'leaf_size': ${\n      this.opts['leaf_size'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_DBSCAN = {k: v for k, v in ctor_DBSCAN.items() if v is not None}`\n\n    await this._py.ex`bridgeDBSCAN[${this.id}] = DBSCAN(**ctor_DBSCAN)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeDBSCAN[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Perform DBSCAN clustering from features, or distance matrix.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster, or distances between instances if `metric='precomputed'`. If a sparse matrix is provided, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: any\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Weight of each sample, such that a sample with a weight of at least `min\\_samples` is by itself a core sample; a sample with a negative weight may inhibit its eps-neighbor from being core. Note that weights are absolute, and default to 1.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DBSCAN_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_DBSCAN_fit = {k: v for k, v in pms_DBSCAN_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DBSCAN_fit = bridgeDBSCAN[${this.id}].fit(**pms_DBSCAN_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DBSCAN_fit.tolist() if hasattr(res_DBSCAN_fit, 'tolist') else res_DBSCAN_fit`\n  }\n\n  /**\n    Compute clusters from a data or distance matrix and predict labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Training instances to cluster, or distances between instances if `metric='precomputed'`. If a sparse matrix is provided, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: any\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Weight of each sample, such that a sample with a weight of at least `min\\_samples` is by itself a core sample; a sample with a negative weight may inhibit its eps-neighbor from being core. Note that weights are absolute, and default to 1.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DBSCAN_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_DBSCAN_fit_predict = {k: v for k, v in pms_DBSCAN_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DBSCAN_fit_predict = bridgeDBSCAN[${this.id}].fit_predict(**pms_DBSCAN_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DBSCAN_fit_predict.tolist() if hasattr(res_DBSCAN_fit_predict, 'tolist') else res_DBSCAN_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DBSCAN_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_DBSCAN_get_metadata_routing = {k: v for k, v in pms_DBSCAN_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DBSCAN_get_metadata_routing = bridgeDBSCAN[${this.id}].get_metadata_routing(**pms_DBSCAN_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DBSCAN_get_metadata_routing.tolist() if hasattr(res_DBSCAN_get_metadata_routing, 'tolist') else res_DBSCAN_get_metadata_routing`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_DBSCAN_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_DBSCAN_set_fit_request = {k: v for k, v in pms_DBSCAN_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_DBSCAN_set_fit_request = bridgeDBSCAN[${this.id}].set_fit_request(**pms_DBSCAN_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_DBSCAN_set_fit_request.tolist() if hasattr(res_DBSCAN_set_fit_request, 'tolist') else res_DBSCAN_set_fit_request`\n  }\n\n  /**\n    Indices of core samples.\n   */\n  get core_sample_indices_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DBSCAN must call init() before accessing core_sample_indices_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DBSCAN_core_sample_indices_ = bridgeDBSCAN[${this.id}].core_sample_indices_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DBSCAN_core_sample_indices_.tolist() if hasattr(attr_DBSCAN_core_sample_indices_, 'tolist') else attr_DBSCAN_core_sample_indices_`\n    })()\n  }\n\n  /**\n    Copy of each core sample found by training.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DBSCAN_components_ = bridgeDBSCAN[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DBSCAN_components_.tolist() if hasattr(attr_DBSCAN_components_, 'tolist') else attr_DBSCAN_components_`\n    })()\n  }\n\n  /**\n    Cluster labels for each point in the dataset given to fit(). Noisy samples are given the label -1.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_DBSCAN_labels_ = bridgeDBSCAN[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DBSCAN_labels_.tolist() if hasattr(attr_DBSCAN_labels_, 'tolist') else attr_DBSCAN_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('DBSCAN must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DBSCAN_n_features_in_ = bridgeDBSCAN[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DBSCAN_n_features_in_.tolist() if hasattr(attr_DBSCAN_n_features_in_, 'tolist') else attr_DBSCAN_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This DBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'DBSCAN must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_DBSCAN_feature_names_in_ = bridgeDBSCAN[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_DBSCAN_feature_names_in_.tolist() if hasattr(attr_DBSCAN_feature_names_in_, 'tolist') else attr_DBSCAN_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Agglomerate features.\n\n  Recursively merges pair of clusters of features.\n\n  Read more in the [User Guide](../clustering.html#hierarchical-clustering).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.FeatureAgglomeration.html)\n */\nexport class FeatureAgglomeration {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of clusters to find. It must be `undefined` if `distance\\_threshold` is not `undefined`.\n\n      @defaultValue `2`\n     */\n    n_clusters?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\") for its metric parameter. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix (instead of a similarity matrix) is needed as input for the fit method.\n\n      @defaultValue `'euclidean'`\n     */\n    affinity?: string\n\n    /**\n      Metric used to compute the linkage. Can be “euclidean”, “l1”, “l2”, “manhattan”, “cosine”, or “precomputed”. If set to `undefined` then “euclidean” is used. If linkage is “ward”, only “euclidean” is accepted. If “precomputed”, a distance matrix is needed as input for the fit method.\n     */\n    metric?: string\n\n    /**\n      Used to cache the output of the computation of the tree. By default, no caching is done. If a string is given, it is the path to the caching directory.\n     */\n    memory?: string\n\n    /**\n      Connectivity matrix. Defines for each feature the neighboring features following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix, such as derived from `kneighbors\\_graph`. Default is `undefined`, i.e, the hierarchical clustering algorithm is unstructured.\n     */\n    connectivity?: ArrayLike\n\n    /**\n      Stop early the construction of the tree at `n\\_clusters`. This is useful to decrease computation time if the number of clusters is not small compared to the number of features. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree. It must be `true` if `distance\\_threshold` is not `undefined`. By default `compute\\_full\\_tree` is “auto”, which is equivalent to `true` when `distance\\_threshold` is not `undefined` or that `n\\_clusters` is inferior to the maximum between 100 or `0.02 \\* n\\_samples`. Otherwise, “auto” is equivalent to `false`.\n\n      @defaultValue `'auto'`\n     */\n    compute_full_tree?: 'auto' | boolean\n\n    /**\n      Which linkage criterion to use. The linkage criterion determines which distance to use between sets of features. The algorithm will merge the pairs of cluster that minimize this criterion.\n\n      @defaultValue `'ward'`\n     */\n    linkage?: 'ward' | 'complete' | 'average' | 'single'\n\n    /**\n      This combines the values of agglomerated features into a single value, and should accept an array of shape \\[M, N\\] and the keyword argument `axis=1`, and reduce it to an array of size \\[M\\].\n     */\n    pooling_func?: any\n\n    /**\n      The linkage distance threshold at or above which clusters will not be merged. If not `undefined`, `n\\_clusters` must be `undefined` and `compute\\_full\\_tree` must be `true`.\n     */\n    distance_threshold?: number\n\n    /**\n      Computes distances between clusters even if `distance\\_threshold` is not used. This can be used to make dendrogram visualization, but introduces a computational and memory overhead.\n\n      @defaultValue `false`\n     */\n    compute_distances?: boolean\n  }) {\n    this.id = `FeatureAgglomeration${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'FeatureAgglomeration.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import FeatureAgglomeration\ntry: bridgeFeatureAgglomeration\nexcept NameError: bridgeFeatureAgglomeration = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_FeatureAgglomeration = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'affinity': ${this.opts['affinity'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'memory': ${this.opts['memory'] ?? undefined}, 'connectivity': ${\n      this.opts['connectivity'] ?? undefined\n    }, 'compute_full_tree': ${\n      this.opts['compute_full_tree'] ?? undefined\n    }, 'linkage': ${this.opts['linkage'] ?? undefined}, 'pooling_func': ${\n      this.opts['pooling_func'] ?? undefined\n    }, 'distance_threshold': ${\n      this.opts['distance_threshold'] ?? undefined\n    }, 'compute_distances': ${this.opts['compute_distances'] ?? undefined}}\n\nctor_FeatureAgglomeration = {k: v for k, v in ctor_FeatureAgglomeration.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeFeatureAgglomeration[${this.id}] = FeatureAgglomeration(**ctor_FeatureAgglomeration)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeFeatureAgglomeration[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the hierarchical clustering on the data.\n   */\n  async fit(opts: {\n    /**\n      The data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FeatureAgglomeration must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_FeatureAgglomeration_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_FeatureAgglomeration_fit = {k: v for k, v in pms_FeatureAgglomeration_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_fit = bridgeFeatureAgglomeration[${this.id}].fit(**pms_FeatureAgglomeration_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_fit.tolist() if hasattr(res_FeatureAgglomeration_fit, 'tolist') else res_FeatureAgglomeration_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FeatureAgglomeration_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_FeatureAgglomeration_fit_transform = {k: v for k, v in pms_FeatureAgglomeration_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_fit_transform = bridgeFeatureAgglomeration[${this.id}].fit_transform(**pms_FeatureAgglomeration_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_fit_transform.tolist() if hasattr(res_FeatureAgglomeration_fit_transform, 'tolist') else res_FeatureAgglomeration_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureAgglomeration_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_FeatureAgglomeration_get_feature_names_out = {k: v for k, v in pms_FeatureAgglomeration_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_get_feature_names_out = bridgeFeatureAgglomeration[${this.id}].get_feature_names_out(**pms_FeatureAgglomeration_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_get_feature_names_out.tolist() if hasattr(res_FeatureAgglomeration_get_feature_names_out, 'tolist') else res_FeatureAgglomeration_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureAgglomeration_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_FeatureAgglomeration_get_metadata_routing = {k: v for k, v in pms_FeatureAgglomeration_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_get_metadata_routing = bridgeFeatureAgglomeration[${this.id}].get_metadata_routing(**pms_FeatureAgglomeration_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_get_metadata_routing.tolist() if hasattr(res_FeatureAgglomeration_get_metadata_routing, 'tolist') else res_FeatureAgglomeration_get_metadata_routing`\n  }\n\n  /**\n    Inverse the transformation and return a vector of size `n\\_features`.\n   */\n  async inverse_transform(opts: {\n    /**\n      The values to be assigned to each cluster of samples.\n     */\n    Xt?: ArrayLike[]\n\n    /**\n      Use `Xt` instead.\n     */\n    Xred?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureAgglomeration_inverse_transform = {'Xt': np.array(${\n      opts['Xt'] ?? undefined\n    }) if ${opts['Xt'] !== undefined} else None, 'Xred': ${\n      opts['Xred'] ?? undefined\n    }}\n\npms_FeatureAgglomeration_inverse_transform = {k: v for k, v in pms_FeatureAgglomeration_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_inverse_transform = bridgeFeatureAgglomeration[${this.id}].inverse_transform(**pms_FeatureAgglomeration_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_inverse_transform.tolist() if hasattr(res_FeatureAgglomeration_inverse_transform, 'tolist') else res_FeatureAgglomeration_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FeatureAgglomeration_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_FeatureAgglomeration_set_output = {k: v for k, v in pms_FeatureAgglomeration_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_set_output = bridgeFeatureAgglomeration[${this.id}].set_output(**pms_FeatureAgglomeration_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_set_output.tolist() if hasattr(res_FeatureAgglomeration_set_output, 'tolist') else res_FeatureAgglomeration_set_output`\n  }\n\n  /**\n    Transform a new matrix using the built clustering.\n   */\n  async transform(opts: {\n    /**\n      A M by N array of M observations in N dimensions or a length M array of M one-dimensional observations.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_FeatureAgglomeration_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_FeatureAgglomeration_transform = {k: v for k, v in pms_FeatureAgglomeration_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureAgglomeration_transform = bridgeFeatureAgglomeration[${this.id}].transform(**pms_FeatureAgglomeration_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureAgglomeration_transform.tolist() if hasattr(res_FeatureAgglomeration_transform, 'tolist') else res_FeatureAgglomeration_transform`\n  }\n\n  /**\n    The number of clusters found by the algorithm. If `distance\\_threshold=None`, it will be equal to the given `n\\_clusters`.\n   */\n  get n_clusters_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing n_clusters_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_n_clusters_ = bridgeFeatureAgglomeration[${this.id}].n_clusters_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_n_clusters_.tolist() if hasattr(attr_FeatureAgglomeration_n_clusters_, 'tolist') else attr_FeatureAgglomeration_n_clusters_`\n    })()\n  }\n\n  /**\n    Cluster labels for each feature.\n   */\n  get labels_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_labels_ = bridgeFeatureAgglomeration[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_labels_.tolist() if hasattr(attr_FeatureAgglomeration_labels_, 'tolist') else attr_FeatureAgglomeration_labels_`\n    })()\n  }\n\n  /**\n    Number of leaves in the hierarchical tree.\n   */\n  get n_leaves_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing n_leaves_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_n_leaves_ = bridgeFeatureAgglomeration[${this.id}].n_leaves_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_n_leaves_.tolist() if hasattr(attr_FeatureAgglomeration_n_leaves_, 'tolist') else attr_FeatureAgglomeration_n_leaves_`\n    })()\n  }\n\n  /**\n    The estimated number of connected components in the graph.\n   */\n  get n_connected_components_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing n_connected_components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_n_connected_components_ = bridgeFeatureAgglomeration[${this.id}].n_connected_components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_n_connected_components_.tolist() if hasattr(attr_FeatureAgglomeration_n_connected_components_, 'tolist') else attr_FeatureAgglomeration_n_connected_components_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_n_features_in_ = bridgeFeatureAgglomeration[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_n_features_in_.tolist() if hasattr(attr_FeatureAgglomeration_n_features_in_, 'tolist') else attr_FeatureAgglomeration_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_feature_names_in_ = bridgeFeatureAgglomeration[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_feature_names_in_.tolist() if hasattr(attr_FeatureAgglomeration_feature_names_in_, 'tolist') else attr_FeatureAgglomeration_feature_names_in_`\n    })()\n  }\n\n  /**\n    The children of each non-leaf node. Values less than `n\\_features` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\\_features` is a non-leaf node and has children `children\\_\\[i \\- n\\_features\\]`. Alternatively at the i-th iteration, children\\[i\\]\\[0\\] and children\\[i\\]\\[1\\] are merged to form node `n\\_features + i`.\n   */\n  get children_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing children_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_children_ = bridgeFeatureAgglomeration[${this.id}].children_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_children_.tolist() if hasattr(attr_FeatureAgglomeration_children_, 'tolist') else attr_FeatureAgglomeration_children_`\n    })()\n  }\n\n  /**\n    Distances between nodes in the corresponding place in `children\\_`. Only computed if `distance\\_threshold` is used or `compute\\_distances` is set to `true`.\n   */\n  get distances_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This FeatureAgglomeration instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureAgglomeration must call init() before accessing distances_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureAgglomeration_distances_ = bridgeFeatureAgglomeration[${this.id}].distances_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureAgglomeration_distances_.tolist() if hasattr(attr_FeatureAgglomeration_distances_, 'tolist') else attr_FeatureAgglomeration_distances_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Cluster data using hierarchical density-based clustering.\n\n  HDBSCAN - Hierarchical Density-Based Spatial Clustering of Applications with Noise. Performs [`DBSCAN`](sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN \"sklearn.cluster.DBSCAN\") over varying epsilon values and integrates the result to find a clustering that gives the best stability over epsilon. This allows HDBSCAN to find clusters of varying densities (unlike [`DBSCAN`](sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN \"sklearn.cluster.DBSCAN\")), and be more robust to parameter selection. Read more in the [User Guide](../clustering.html#hdbscan).\n\n  For an example of how to use HDBSCAN, as well as a comparison to [`DBSCAN`](sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN \"sklearn.cluster.DBSCAN\"), please see the [plotting demo](../../auto_examples/cluster/plot_hdbscan.html#sphx-glr-auto-examples-cluster-plot-hdbscan-py).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.HDBSCAN.html)\n */\nexport class HDBSCAN {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The minimum number of samples in a group for that group to be considered a cluster; groupings smaller than this size will be left as noise.\n\n      @defaultValue `5`\n     */\n    min_cluster_size?: number\n\n    /**\n      The number of samples in a neighborhood for a point to be considered as a core point. This includes the point itself. When `undefined`, defaults to `min\\_cluster\\_size`.\n     */\n    min_samples?: number\n\n    /**\n      A distance threshold. Clusters below this value will be merged. See [\\[5\\]](#r6f313792b2b7-5) for more information.\n\n      @defaultValue `0`\n     */\n    cluster_selection_epsilon?: number\n\n    /**\n      A limit to the size of clusters returned by the `\"eom\"` cluster selection algorithm. There is no limit when `max\\_cluster\\_size=None`. Has no effect if `cluster\\_selection\\_method=\"leaf\"`.\n     */\n    max_cluster_size?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: string\n\n    /**\n      Arguments passed to the distance metric.\n     */\n    metric_params?: any\n\n    /**\n      A distance scaling parameter as used in robust single linkage. See [\\[3\\]](#r6f313792b2b7-3) for more information.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Exactly which algorithm to use for computing core distances; By default this is set to `\"auto\"` which attempts to use a [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\") tree if possible, otherwise it uses a [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") tree. Both `\"KDTree\"` and `\"BallTree\"` algorithms use the [`NearestNeighbors`](sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors \"sklearn.neighbors.NearestNeighbors\") estimator.\n\n      If the `X` passed during `fit` is sparse or `metric` is invalid for both [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\") and [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\"), then it resolves to use the `\"brute\"` algorithm.\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'brute' | 'kdtree' | 'balltree'\n\n    /**\n      Leaf size for trees responsible for fast nearest neighbour queries when a KDTree or a BallTree are used as core-distance algorithms. A large dataset size and small `leaf\\_size` may induce excessive memory usage. If you are running out of memory consider increasing the `leaf\\_size` parameter. Ignored for `algorithm=\"brute\"`.\n\n      @defaultValue `40`\n     */\n    leaf_size?: number\n\n    /**\n      Number of jobs to run in parallel to calculate distances. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The method used to select clusters from the condensed tree. The standard approach for HDBSCAN\\* is to use an Excess of Mass (`\"eom\"`) algorithm to find the most persistent clusters. Alternatively you can instead select the clusters at the leaves of the tree – this provides the most fine grained and homogeneous clusters.\n\n      @defaultValue `'eom'`\n     */\n    cluster_selection_method?: 'eom' | 'leaf'\n\n    /**\n      By default HDBSCAN\\* will not produce a single cluster, setting this to `true` will override this and allow single cluster results in the case that you feel this is a valid result for your dataset.\n\n      @defaultValue `false`\n     */\n    allow_single_cluster?: boolean\n\n    /**\n      Which, if any, cluster centers to compute and store. The options are:\n     */\n    store_centers?: string\n\n    /**\n      If `copy=True` then any time an in-place modifications would be made that would overwrite data passed to [fit](../../glossary.html#term-fit), a copy will first be made, guaranteeing that the original data will be unchanged. Currently, it only applies when `metric=\"precomputed\"`, when passing a dense array or a CSR sparse matrix and when `algorithm=\"brute\"`.\n\n      @defaultValue `false`\n     */\n    copy?: boolean\n  }) {\n    this.id = `HDBSCAN${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('HDBSCAN.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import HDBSCAN\ntry: bridgeHDBSCAN\nexcept NameError: bridgeHDBSCAN = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_HDBSCAN = {'min_cluster_size': ${\n      this.opts['min_cluster_size'] ?? undefined\n    }, 'min_samples': ${\n      this.opts['min_samples'] ?? undefined\n    }, 'cluster_selection_epsilon': ${\n      this.opts['cluster_selection_epsilon'] ?? undefined\n    }, 'max_cluster_size': ${\n      this.opts['max_cluster_size'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'cluster_selection_method': ${\n      this.opts['cluster_selection_method'] ?? undefined\n    }, 'allow_single_cluster': ${\n      this.opts['allow_single_cluster'] ?? undefined\n    }, 'store_centers': ${this.opts['store_centers'] ?? undefined}, 'copy': ${\n      this.opts['copy'] ?? undefined\n    }}\n\nctor_HDBSCAN = {k: v for k, v in ctor_HDBSCAN.items() if v is not None}`\n\n    await this._py.ex`bridgeHDBSCAN[${this.id}] = HDBSCAN(**ctor_HDBSCAN)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeHDBSCAN[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Return clustering given by DBSCAN without border points.\n\n    Return clustering that would be equivalent to running DBSCAN\\* for a particular cut\\_distance (or epsilon) DBSCAN\\* can be thought of as DBSCAN without the border points. As such these results may differ slightly from `cluster.DBSCAN` due to the difference in implementation over the non-core points.\n\n    This can also be thought of as a flat clustering derived from constant height cut through the single linkage tree.\n\n    This represents the result of selecting a cut value for robust single linkage clustering. The `min\\_cluster\\_size` allows the flat clustering to declare noise points (and cluster smaller than `min\\_cluster\\_size`).\n   */\n  async dbscan_clustering(opts: {\n    /**\n      The mutual reachability distance cut value to use to generate a flat clustering.\n     */\n    cut_distance?: number\n\n    /**\n      Clusters smaller than this value with be called ‘noise’ and remain unclustered in the resulting flat clustering.\n\n      @defaultValue `5`\n     */\n    min_cluster_size?: number\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before dbscan_clustering()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HDBSCAN_dbscan_clustering = {'cut_distance': ${\n      opts['cut_distance'] ?? undefined\n    }, 'min_cluster_size': ${opts['min_cluster_size'] ?? undefined}}\n\npms_HDBSCAN_dbscan_clustering = {k: v for k, v in pms_HDBSCAN_dbscan_clustering.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HDBSCAN_dbscan_clustering = bridgeHDBSCAN[${this.id}].dbscan_clustering(**pms_HDBSCAN_dbscan_clustering)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HDBSCAN_dbscan_clustering.tolist() if hasattr(res_HDBSCAN_dbscan_clustering, 'tolist') else res_HDBSCAN_dbscan_clustering`\n  }\n\n  /**\n    Find clusters based on hierarchical density-based clustering.\n   */\n  async fit(opts: {\n    /**\n      A feature array, or array of distances between samples if `metric='precomputed'`.\n     */\n    X?: NDArray[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HDBSCAN_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_HDBSCAN_fit = {k: v for k, v in pms_HDBSCAN_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HDBSCAN_fit = bridgeHDBSCAN[${this.id}].fit(**pms_HDBSCAN_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HDBSCAN_fit.tolist() if hasattr(res_HDBSCAN_fit, 'tolist') else res_HDBSCAN_fit`\n  }\n\n  /**\n    Cluster X and return the associated cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      A feature array, or array of distances between samples if `metric='precomputed'`.\n     */\n    X?: NDArray[]\n\n    /**\n      Ignored.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HDBSCAN_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_HDBSCAN_fit_predict = {k: v for k, v in pms_HDBSCAN_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HDBSCAN_fit_predict = bridgeHDBSCAN[${this.id}].fit_predict(**pms_HDBSCAN_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HDBSCAN_fit_predict.tolist() if hasattr(res_HDBSCAN_fit_predict, 'tolist') else res_HDBSCAN_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HDBSCAN_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_HDBSCAN_get_metadata_routing = {k: v for k, v in pms_HDBSCAN_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HDBSCAN_get_metadata_routing = bridgeHDBSCAN[${this.id}].get_metadata_routing(**pms_HDBSCAN_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HDBSCAN_get_metadata_routing.tolist() if hasattr(res_HDBSCAN_get_metadata_routing, 'tolist') else res_HDBSCAN_get_metadata_routing`\n  }\n\n  /**\n    Cluster labels for each point in the dataset given to [fit](../../glossary.html#term-fit). Outliers are labeled as follows:\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_labels_ = bridgeHDBSCAN[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_labels_.tolist() if hasattr(attr_HDBSCAN_labels_, 'tolist') else attr_HDBSCAN_labels_`\n    })()\n  }\n\n  /**\n    The strength with which each sample is a member of its assigned cluster.\n   */\n  get probabilities_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HDBSCAN must call init() before accessing probabilities_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_probabilities_ = bridgeHDBSCAN[${this.id}].probabilities_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_probabilities_.tolist() if hasattr(attr_HDBSCAN_probabilities_, 'tolist') else attr_HDBSCAN_probabilities_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HDBSCAN must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_n_features_in_ = bridgeHDBSCAN[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_n_features_in_.tolist() if hasattr(attr_HDBSCAN_n_features_in_, 'tolist') else attr_HDBSCAN_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HDBSCAN must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_feature_names_in_ = bridgeHDBSCAN[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_feature_names_in_.tolist() if hasattr(attr_HDBSCAN_feature_names_in_, 'tolist') else attr_HDBSCAN_feature_names_in_`\n    })()\n  }\n\n  /**\n    A collection containing the centroid of each cluster calculated under the standard euclidean metric. The centroids may fall “outside” their respective clusters if the clusters themselves are non-convex.\n\n    Note that `n\\_clusters` only counts non-outlier clusters. That is to say, the `\\-1, \\-2, \\-3` labels for the outlier clusters are excluded.\n   */\n  get centroids_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before accessing centroids_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_centroids_ = bridgeHDBSCAN[${this.id}].centroids_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_centroids_.tolist() if hasattr(attr_HDBSCAN_centroids_, 'tolist') else attr_HDBSCAN_centroids_`\n    })()\n  }\n\n  /**\n    A collection containing the medoid of each cluster calculated under the whichever metric was passed to the `metric` parameter. The medoids are points in the original cluster which minimize the average distance to all other points in that cluster under the chosen metric. These can be thought of as the result of projecting the `metric`\\-based centroid back onto the cluster.\n\n    Note that `n\\_clusters` only counts non-outlier clusters. That is to say, the `\\-1, \\-2, \\-3` labels for the outlier clusters are excluded.\n   */\n  get medoids_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This HDBSCAN instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HDBSCAN must call init() before accessing medoids_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HDBSCAN_medoids_ = bridgeHDBSCAN[${this.id}].medoids_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HDBSCAN_medoids_.tolist() if hasattr(attr_HDBSCAN_medoids_, 'tolist') else attr_HDBSCAN_medoids_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  K-Means clustering.\n\n  Read more in the [User Guide](../clustering.html#k-means).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)\n */\nexport class KMeans {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of clusters to form as well as the number of centroids to generate.\n\n      @defaultValue `8`\n     */\n    n_clusters?: number\n\n    /**\n      Method for initialization:\n\n      @defaultValue `'k-means++'`\n     */\n    init?: 'k-means++' | 'random' | ArrayLike[]\n\n    /**\n      Number of times the k-means algorithm is run with different centroid seeds. The final results is the best output of `n\\_init` consecutive runs in terms of inertia. Several runs are recommended for sparse high-dimensional problems (see [Clustering sparse data with k-means](../../auto_examples/text/plot_document_clustering.html#kmeans-sparse-high-dim)).\n\n      When `n\\_init='auto'`, the number of runs depends on the value of init: 10 if using `init='random'` or `init` is a callable; 1 if using `init='k-means++'` or `init` is an array-like.\n\n      @defaultValue `10`\n     */\n    n_init?: 'auto' | number\n\n    /**\n      Maximum number of iterations of the k-means algorithm for a single run.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n\n    /**\n      Relative tolerance with regards to Frobenius norm of the difference in the cluster centers of two consecutive iterations to declare convergence.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Verbosity mode.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Determines random number generation for centroid initialization. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      When pre-computing distances it is more numerically accurate to center the data first. If copy\\_x is `true` (default), then the original data is not modified. If `false`, the original data is modified, and put back before the function returns, but small numerical differences may be introduced by subtracting and then adding the data mean. Note that if the original data is not C-contiguous, a copy will be made even if copy\\_x is `false`. If the original data is sparse, but not in CSR format, a copy will be made even if copy\\_x is `false`.\n\n      @defaultValue `true`\n     */\n    copy_x?: boolean\n\n    /**\n      K-means algorithm to use. The classical EM-style algorithm is `\"lloyd\"`. The `\"elkan\"` variation can be more efficient on some datasets with well-defined clusters, by using the triangle inequality. However it’s more memory intensive due to the allocation of an extra array of shape `(n\\_samples, n\\_clusters)`.\n\n      `\"auto\"` and `\"full\"` are deprecated and they will be removed in Scikit-Learn 1.3. They are both aliases for `\"lloyd\"`.\n\n      @defaultValue `'lloyd'`\n     */\n    algorithm?: 'lloyd' | 'elkan' | 'auto' | 'full'\n  }) {\n    this.id = `KMeans${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KMeans.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import KMeans\ntry: bridgeKMeans\nexcept NameError: bridgeKMeans = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KMeans = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'n_init': ${this.opts['n_init'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'copy_x': ${\n      this.opts['copy_x'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}}\n\nctor_KMeans = {k: v for k, v in ctor_KMeans.items() if v is not None}`\n\n    await this._py.ex`bridgeKMeans[${this.id}] = KMeans(**ctor_KMeans)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKMeans[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute k-means clustering.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster. It must be noted that the data will be converted to C ordering, which will cause a memory copy if the given data is not C-contiguous. If a sparse matrix is passed, a copy will be made if it’s not in CSR format.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight. `sample\\_weight` is not used during initialization if `init` is a callable or a user provided array.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KMeans_fit = {k: v for k, v in pms_KMeans_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_fit = bridgeKMeans[${this.id}].fit(**pms_KMeans_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_fit.tolist() if hasattr(res_KMeans_fit, 'tolist') else res_KMeans_fit`\n  }\n\n  /**\n    Compute cluster centers and predict cluster index for each sample.\n\n    Convenience method; equivalent to calling fit(X) followed by predict(X).\n   */\n  async fit_predict(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KMeans_fit_predict = {k: v for k, v in pms_KMeans_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_fit_predict = bridgeKMeans[${this.id}].fit_predict(**pms_KMeans_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_fit_predict.tolist() if hasattr(res_KMeans_fit_predict, 'tolist') else res_KMeans_fit_predict`\n  }\n\n  /**\n    Compute clustering and transform X to cluster-distance space.\n\n    Equivalent to fit(X).transform(X), but more efficiently implemented.\n   */\n  async fit_transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KMeans_fit_transform = {k: v for k, v in pms_KMeans_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_fit_transform = bridgeKMeans[${this.id}].fit_transform(**pms_KMeans_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_fit_transform.tolist() if hasattr(res_KMeans_fit_transform, 'tolist') else res_KMeans_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KMeans_get_feature_names_out = {k: v for k, v in pms_KMeans_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_get_feature_names_out = bridgeKMeans[${this.id}].get_feature_names_out(**pms_KMeans_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_get_feature_names_out.tolist() if hasattr(res_KMeans_get_feature_names_out, 'tolist') else res_KMeans_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KMeans_get_metadata_routing = {k: v for k, v in pms_KMeans_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_get_metadata_routing = bridgeKMeans[${this.id}].get_metadata_routing(**pms_KMeans_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_get_metadata_routing.tolist() if hasattr(res_KMeans_get_metadata_routing, 'tolist') else res_KMeans_get_metadata_routing`\n  }\n\n  /**\n    Predict the closest cluster each sample in X belongs to.\n\n    In the vector quantization literature, `cluster\\_centers\\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.\n   */\n  async predict(opts: {\n    /**\n      New data to predict.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_KMeans_predict = {k: v for k, v in pms_KMeans_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_predict = bridgeKMeans[${this.id}].predict(**pms_KMeans_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_predict.tolist() if hasattr(res_KMeans_predict, 'tolist') else res_KMeans_predict`\n  }\n\n  /**\n    Opposite of the value of X on the K-means objective.\n   */\n  async score(opts: {\n    /**\n      New data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KMeans_score = {k: v for k, v in pms_KMeans_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_score = bridgeKMeans[${this.id}].score(**pms_KMeans_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_score.tolist() if hasattr(res_KMeans_score, 'tolist') else res_KMeans_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KMeans_set_fit_request = {k: v for k, v in pms_KMeans_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_set_fit_request = bridgeKMeans[${this.id}].set_fit_request(**pms_KMeans_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_set_fit_request.tolist() if hasattr(res_KMeans_set_fit_request, 'tolist') else res_KMeans_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KMeans_set_output = {k: v for k, v in pms_KMeans_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_set_output = bridgeKMeans[${this.id}].set_output(**pms_KMeans_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_set_output.tolist() if hasattr(res_KMeans_set_output, 'tolist') else res_KMeans_set_output`\n  }\n\n  /**\n    Request metadata passed to the `predict` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_predict_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `predict`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before set_predict_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_set_predict_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KMeans_set_predict_request = {k: v for k, v in pms_KMeans_set_predict_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_set_predict_request = bridgeKMeans[${this.id}].set_predict_request(**pms_KMeans_set_predict_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_set_predict_request.tolist() if hasattr(res_KMeans_set_predict_request, 'tolist') else res_KMeans_set_predict_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KMeans_set_score_request = {k: v for k, v in pms_KMeans_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_set_score_request = bridgeKMeans[${this.id}].set_score_request(**pms_KMeans_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_set_score_request.tolist() if hasattr(res_KMeans_set_score_request, 'tolist') else res_KMeans_set_score_request`\n  }\n\n  /**\n    Transform X to a cluster-distance space.\n\n    In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.\n   */\n  async transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KMeans_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KMeans_transform = {k: v for k, v in pms_KMeans_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KMeans_transform = bridgeKMeans[${this.id}].transform(**pms_KMeans_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KMeans_transform.tolist() if hasattr(res_KMeans_transform, 'tolist') else res_KMeans_transform`\n  }\n\n  /**\n    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\\_iter`), these will not be consistent with `labels\\_`.\n   */\n  get cluster_centers_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KMeans must call init() before accessing cluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KMeans_cluster_centers_ = bridgeKMeans[${this.id}].cluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_cluster_centers_.tolist() if hasattr(attr_KMeans_cluster_centers_, 'tolist') else attr_KMeans_cluster_centers_`\n    })()\n  }\n\n  /**\n    Labels of each point\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_KMeans_labels_ = bridgeKMeans[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_labels_.tolist() if hasattr(attr_KMeans_labels_, 'tolist') else attr_KMeans_labels_`\n    })()\n  }\n\n  /**\n    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.\n   */\n  get inertia_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before accessing inertia_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KMeans_inertia_ = bridgeKMeans[${this.id}].inertia_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_inertia_.tolist() if hasattr(attr_KMeans_inertia_, 'tolist') else attr_KMeans_inertia_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_KMeans_n_iter_ = bridgeKMeans[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_n_iter_.tolist() if hasattr(attr_KMeans_n_iter_, 'tolist') else attr_KMeans_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KMeans must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KMeans_n_features_in_ = bridgeKMeans[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_n_features_in_.tolist() if hasattr(attr_KMeans_n_features_in_, 'tolist') else attr_KMeans_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KMeans must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KMeans_feature_names_in_ = bridgeKMeans[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KMeans_feature_names_in_.tolist() if hasattr(attr_KMeans_feature_names_in_, 'tolist') else attr_KMeans_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mean shift clustering using a flat kernel.\n\n  Mean shift clustering aims to discover “blobs” in a smooth density of samples. It is a centroid-based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region. These candidates are then filtered in a post-processing stage to eliminate near-duplicates to form the final set of centroids.\n\n  Seeding is performed using a binning technique for scalability.\n\n  Read more in the [User Guide](../clustering.html#mean-shift).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MeanShift.html)\n */\nexport class MeanShift {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Bandwidth used in the flat kernel.\n\n      If not given, the bandwidth is estimated using sklearn.cluster.estimate\\_bandwidth; see the documentation for that function for hints on scalability (see also the Notes, below).\n     */\n    bandwidth?: number\n\n    /**\n      Seeds used to initialize kernels. If not set, the seeds are calculated by clustering.get\\_bin\\_seeds with bandwidth as the grid size and default values for other parameters.\n     */\n    seeds?: ArrayLike[]\n\n    /**\n      If true, initial kernel locations are not locations of all points, but rather the location of the discretized version of points, where points are binned onto a grid whose coarseness corresponds to the bandwidth. Setting this option to `true` will speed up the algorithm because fewer seeds will be initialized. The default value is `false`. Ignored if seeds argument is not `undefined`.\n\n      @defaultValue `false`\n     */\n    bin_seeding?: boolean\n\n    /**\n      To speed up the algorithm, accept only those bins with at least min\\_bin\\_freq points as seeds.\n\n      @defaultValue `1`\n     */\n    min_bin_freq?: number\n\n    /**\n      If true, then all points are clustered, even those orphans that are not within any kernel. Orphans are assigned to the nearest kernel. If false, then orphans are given cluster label -1.\n\n      @defaultValue `true`\n     */\n    cluster_all?: boolean\n\n    /**\n      The number of jobs to use for the computation. The following tasks benefit from the parallelization:\n     */\n    n_jobs?: number\n\n    /**\n      Maximum number of iterations, per seed point before the clustering operation terminates (for that seed point), if has not converged yet.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n  }) {\n    this.id = `MeanShift${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MeanShift.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import MeanShift\ntry: bridgeMeanShift\nexcept NameError: bridgeMeanShift = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MeanShift = {'bandwidth': ${\n      this.opts['bandwidth'] ?? undefined\n    }, 'seeds': np.array(${this.opts['seeds'] ?? undefined}) if ${\n      this.opts['seeds'] !== undefined\n    } else None, 'bin_seeding': ${\n      this.opts['bin_seeding'] ?? undefined\n    }, 'min_bin_freq': ${\n      this.opts['min_bin_freq'] ?? undefined\n    }, 'cluster_all': ${this.opts['cluster_all'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}}\n\nctor_MeanShift = {k: v for k, v in ctor_MeanShift.items() if v is not None}`\n\n    await this._py.ex`bridgeMeanShift[${this.id}] = MeanShift(**ctor_MeanShift)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMeanShift[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Perform clustering.\n   */\n  async fit(opts: {\n    /**\n      Samples to cluster.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MeanShift must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MeanShift_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MeanShift_fit = {k: v for k, v in pms_MeanShift_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MeanShift_fit = bridgeMeanShift[${this.id}].fit(**pms_MeanShift_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MeanShift_fit.tolist() if hasattr(res_MeanShift_fit, 'tolist') else res_MeanShift_fit`\n  }\n\n  /**\n    Perform clustering on `X` and returns cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MeanShift must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MeanShift_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MeanShift_fit_predict = {k: v for k, v in pms_MeanShift_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MeanShift_fit_predict = bridgeMeanShift[${this.id}].fit_predict(**pms_MeanShift_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MeanShift_fit_predict.tolist() if hasattr(res_MeanShift_fit_predict, 'tolist') else res_MeanShift_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MeanShift must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MeanShift_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MeanShift_get_metadata_routing = {k: v for k, v in pms_MeanShift_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MeanShift_get_metadata_routing = bridgeMeanShift[${this.id}].get_metadata_routing(**pms_MeanShift_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MeanShift_get_metadata_routing.tolist() if hasattr(res_MeanShift_get_metadata_routing, 'tolist') else res_MeanShift_get_metadata_routing`\n  }\n\n  /**\n    Predict the closest cluster each sample in X belongs to.\n   */\n  async predict(opts: {\n    /**\n      New data to predict.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MeanShift must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MeanShift_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MeanShift_predict = {k: v for k, v in pms_MeanShift_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MeanShift_predict = bridgeMeanShift[${this.id}].predict(**pms_MeanShift_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MeanShift_predict.tolist() if hasattr(res_MeanShift_predict, 'tolist') else res_MeanShift_predict`\n  }\n\n  /**\n    Coordinates of cluster centers.\n   */\n  get cluster_centers_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MeanShift must call init() before accessing cluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MeanShift_cluster_centers_ = bridgeMeanShift[${this.id}].cluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MeanShift_cluster_centers_.tolist() if hasattr(attr_MeanShift_cluster_centers_, 'tolist') else attr_MeanShift_cluster_centers_`\n    })()\n  }\n\n  /**\n    Labels of each point.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MeanShift must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MeanShift_labels_ = bridgeMeanShift[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MeanShift_labels_.tolist() if hasattr(attr_MeanShift_labels_, 'tolist') else attr_MeanShift_labels_`\n    })()\n  }\n\n  /**\n    Maximum number of iterations performed on each seed.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MeanShift must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MeanShift_n_iter_ = bridgeMeanShift[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MeanShift_n_iter_.tolist() if hasattr(attr_MeanShift_n_iter_, 'tolist') else attr_MeanShift_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MeanShift must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MeanShift_n_features_in_ = bridgeMeanShift[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MeanShift_n_features_in_.tolist() if hasattr(attr_MeanShift_n_features_in_, 'tolist') else attr_MeanShift_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MeanShift instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MeanShift must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MeanShift_feature_names_in_ = bridgeMeanShift[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MeanShift_feature_names_in_.tolist() if hasattr(attr_MeanShift_feature_names_in_, 'tolist') else attr_MeanShift_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mini-Batch K-Means clustering.\n\n  Read more in the [User Guide](../clustering.html#mini-batch-kmeans).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MiniBatchKMeans.html)\n */\nexport class MiniBatchKMeans {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of clusters to form as well as the number of centroids to generate.\n\n      @defaultValue `8`\n     */\n    n_clusters?: number\n\n    /**\n      Method for initialization:\n\n      ‘k-means++’ : selects initial cluster centroids using sampling based on an empirical probability distribution of the points’ contribution to the overall inertia. This technique speeds up convergence. The algorithm implemented is “greedy k-means++”. It differs from the vanilla k-means++ by making several trials at each sampling step and choosing the best centroid among them.\n\n      ‘random’: choose `n\\_clusters` observations (rows) at random from data for the initial centroids.\n\n      If an array is passed, it should be of shape (n\\_clusters, n\\_features) and gives the initial centers.\n\n      If a callable is passed, it should take arguments X, n\\_clusters and a random state and return an initialization.\n\n      @defaultValue `'k-means++'`\n     */\n    init?: 'k-means++' | 'random' | ArrayLike[]\n\n    /**\n      Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Size of the mini batches. For faster computations, you can set the `batch\\_size` greater than 256 \\* number of cores to enable parallelism on all cores.\n\n      @defaultValue `1024`\n     */\n    batch_size?: number\n\n    /**\n      Verbosity mode.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Compute label assignment and inertia for the complete dataset once the minibatch optimization has converged in fit.\n\n      @defaultValue `true`\n     */\n    compute_labels?: boolean\n\n    /**\n      Determines random number generation for centroid initialization and random reassignment. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Control early stopping based on the relative center changes as measured by a smoothed, variance-normalized of the mean center squared position changes. This early stopping heuristics is closer to the one used for the batch variant of the algorithms but induces a slight computational and memory overhead over the inertia heuristic.\n\n      To disable convergence detection based on normalized center change, set tol to 0.0 (default).\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed inertia.\n\n      To disable convergence detection based on inertia, set max\\_no\\_improvement to `undefined`.\n\n      @defaultValue `10`\n     */\n    max_no_improvement?: number\n\n    /**\n      Number of samples to randomly sample for speeding up the initialization (sometimes at the expense of accuracy): the only algorithm is initialized by running a batch KMeans on a random subset of the data. This needs to be larger than n\\_clusters.\n\n      If `undefined`, the heuristic is `init\\_size \\= 3 \\* batch\\_size` if `3 \\* batch\\_size < n\\_clusters`, else `init\\_size \\= 3 \\* n\\_clusters`.\n     */\n    init_size?: number\n\n    /**\n      Number of random initializations that are tried. In contrast to KMeans, the algorithm is only run once, using the best of the `n\\_init` initializations as measured by inertia. Several runs are recommended for sparse high-dimensional problems (see [Clustering sparse data with k-means](../../auto_examples/text/plot_document_clustering.html#kmeans-sparse-high-dim)).\n\n      When `n\\_init='auto'`, the number of runs depends on the value of init: 3 if using `init='random'` or `init` is a callable; 1 if using `init='k-means++'` or `init` is an array-like.\n\n      @defaultValue `3`\n     */\n    n_init?: 'auto' | number\n\n    /**\n      Control the fraction of the maximum number of counts for a center to be reassigned. A higher value means that low count centers are more easily reassigned, which means that the model will take longer to converge, but should converge in a better clustering. However, too high a value may cause convergence issues, especially with a small batch size.\n\n      @defaultValue `0.01`\n     */\n    reassignment_ratio?: number\n  }) {\n    this.id = `MiniBatchKMeans${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MiniBatchKMeans.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import MiniBatchKMeans\ntry: bridgeMiniBatchKMeans\nexcept NameError: bridgeMiniBatchKMeans = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MiniBatchKMeans = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'batch_size': ${this.opts['batch_size'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'compute_labels': ${\n      this.opts['compute_labels'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_no_improvement': ${\n      this.opts['max_no_improvement'] ?? undefined\n    }, 'init_size': ${this.opts['init_size'] ?? undefined}, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'reassignment_ratio': ${this.opts['reassignment_ratio'] ?? undefined}}\n\nctor_MiniBatchKMeans = {k: v for k, v in ctor_MiniBatchKMeans.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMiniBatchKMeans[${this.id}] = MiniBatchKMeans(**ctor_MiniBatchKMeans)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMiniBatchKMeans[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the centroids on X by chunking it into mini-batches.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster. It must be noted that the data will be converted to C ordering, which will cause a memory copy if the given data is not C-contiguous. If a sparse matrix is passed, a copy will be made if it’s not in CSR format.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight. `sample\\_weight` is not used during initialization if `init` is a callable or a user provided array.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_MiniBatchKMeans_fit = {k: v for k, v in pms_MiniBatchKMeans_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_fit = bridgeMiniBatchKMeans[${this.id}].fit(**pms_MiniBatchKMeans_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_fit.tolist() if hasattr(res_MiniBatchKMeans_fit, 'tolist') else res_MiniBatchKMeans_fit`\n  }\n\n  /**\n    Compute cluster centers and predict cluster index for each sample.\n\n    Convenience method; equivalent to calling fit(X) followed by predict(X).\n   */\n  async fit_predict(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_MiniBatchKMeans_fit_predict = {k: v for k, v in pms_MiniBatchKMeans_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_fit_predict = bridgeMiniBatchKMeans[${this.id}].fit_predict(**pms_MiniBatchKMeans_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_fit_predict.tolist() if hasattr(res_MiniBatchKMeans_fit_predict, 'tolist') else res_MiniBatchKMeans_fit_predict`\n  }\n\n  /**\n    Compute clustering and transform X to cluster-distance space.\n\n    Equivalent to fit(X).transform(X), but more efficiently implemented.\n   */\n  async fit_transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_MiniBatchKMeans_fit_transform = {k: v for k, v in pms_MiniBatchKMeans_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_fit_transform = bridgeMiniBatchKMeans[${this.id}].fit_transform(**pms_MiniBatchKMeans_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_fit_transform.tolist() if hasattr(res_MiniBatchKMeans_fit_transform, 'tolist') else res_MiniBatchKMeans_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchKMeans_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_get_feature_names_out = {k: v for k, v in pms_MiniBatchKMeans_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_get_feature_names_out = bridgeMiniBatchKMeans[${this.id}].get_feature_names_out(**pms_MiniBatchKMeans_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_get_feature_names_out.tolist() if hasattr(res_MiniBatchKMeans_get_feature_names_out, 'tolist') else res_MiniBatchKMeans_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_get_metadata_routing = {k: v for k, v in pms_MiniBatchKMeans_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_get_metadata_routing = bridgeMiniBatchKMeans[${this.id}].get_metadata_routing(**pms_MiniBatchKMeans_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_get_metadata_routing.tolist() if hasattr(res_MiniBatchKMeans_get_metadata_routing, 'tolist') else res_MiniBatchKMeans_get_metadata_routing`\n  }\n\n  /**\n    Update k means estimate on a single mini-batch X.\n   */\n  async partial_fit(opts: {\n    /**\n      Training instances to cluster. It must be noted that the data will be converted to C ordering, which will cause a memory copy if the given data is not C-contiguous. If a sparse matrix is passed, a copy will be made if it’s not in CSR format.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight. `sample\\_weight` is not used during initialization if `init` is a callable or a user provided array.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_MiniBatchKMeans_partial_fit = {k: v for k, v in pms_MiniBatchKMeans_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_partial_fit = bridgeMiniBatchKMeans[${this.id}].partial_fit(**pms_MiniBatchKMeans_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_partial_fit.tolist() if hasattr(res_MiniBatchKMeans_partial_fit, 'tolist') else res_MiniBatchKMeans_partial_fit`\n  }\n\n  /**\n    Predict the closest cluster each sample in X belongs to.\n\n    In the vector quantization literature, `cluster\\_centers\\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.\n   */\n  async predict(opts: {\n    /**\n      New data to predict.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_MiniBatchKMeans_predict = {k: v for k, v in pms_MiniBatchKMeans_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_predict = bridgeMiniBatchKMeans[${this.id}].predict(**pms_MiniBatchKMeans_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_predict.tolist() if hasattr(res_MiniBatchKMeans_predict, 'tolist') else res_MiniBatchKMeans_predict`\n  }\n\n  /**\n    Opposite of the value of X on the K-means objective.\n   */\n  async score(opts: {\n    /**\n      New data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The weights for each observation in X. If `undefined`, all observations are assigned equal weight.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_MiniBatchKMeans_score = {k: v for k, v in pms_MiniBatchKMeans_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_score = bridgeMiniBatchKMeans[${this.id}].score(**pms_MiniBatchKMeans_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_score.tolist() if hasattr(res_MiniBatchKMeans_score, 'tolist') else res_MiniBatchKMeans_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_set_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_set_fit_request = bridgeMiniBatchKMeans[${this.id}].set_fit_request(**pms_MiniBatchKMeans_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_set_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_fit_request, 'tolist') else res_MiniBatchKMeans_set_fit_request`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_set_output = {k: v for k, v in pms_MiniBatchKMeans_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_set_output = bridgeMiniBatchKMeans[${this.id}].set_output(**pms_MiniBatchKMeans_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_set_output.tolist() if hasattr(res_MiniBatchKMeans_set_output, 'tolist') else res_MiniBatchKMeans_set_output`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchKMeans_set_partial_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_set_partial_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_set_partial_fit_request = bridgeMiniBatchKMeans[${this.id}].set_partial_fit_request(**pms_MiniBatchKMeans_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_set_partial_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_partial_fit_request, 'tolist') else res_MiniBatchKMeans_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `predict` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_predict_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `predict`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before set_predict_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchKMeans_set_predict_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_set_predict_request = {k: v for k, v in pms_MiniBatchKMeans_set_predict_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_set_predict_request = bridgeMiniBatchKMeans[${this.id}].set_predict_request(**pms_MiniBatchKMeans_set_predict_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_set_predict_request.tolist() if hasattr(res_MiniBatchKMeans_set_predict_request, 'tolist') else res_MiniBatchKMeans_set_predict_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchKMeans_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MiniBatchKMeans_set_score_request = {k: v for k, v in pms_MiniBatchKMeans_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_set_score_request = bridgeMiniBatchKMeans[${this.id}].set_score_request(**pms_MiniBatchKMeans_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_set_score_request.tolist() if hasattr(res_MiniBatchKMeans_set_score_request, 'tolist') else res_MiniBatchKMeans_set_score_request`\n  }\n\n  /**\n    Transform X to a cluster-distance space.\n\n    In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.\n   */\n  async transform(opts: {\n    /**\n      New data to transform.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MiniBatchKMeans must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchKMeans_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchKMeans_transform = {k: v for k, v in pms_MiniBatchKMeans_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchKMeans_transform = bridgeMiniBatchKMeans[${this.id}].transform(**pms_MiniBatchKMeans_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchKMeans_transform.tolist() if hasattr(res_MiniBatchKMeans_transform, 'tolist') else res_MiniBatchKMeans_transform`\n  }\n\n  /**\n    Coordinates of cluster centers.\n   */\n  get cluster_centers_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing cluster_centers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_cluster_centers_ = bridgeMiniBatchKMeans[${this.id}].cluster_centers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_cluster_centers_.tolist() if hasattr(attr_MiniBatchKMeans_cluster_centers_, 'tolist') else attr_MiniBatchKMeans_cluster_centers_`\n    })()\n  }\n\n  /**\n    Labels of each point (if compute\\_labels is set to `true`).\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_labels_ = bridgeMiniBatchKMeans[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_labels_.tolist() if hasattr(attr_MiniBatchKMeans_labels_, 'tolist') else attr_MiniBatchKMeans_labels_`\n    })()\n  }\n\n  /**\n    The value of the inertia criterion associated with the chosen partition if compute\\_labels is set to `true`. If compute\\_labels is set to `false`, it’s an approximation of the inertia based on an exponentially weighted average of the batch inertiae. The inertia is defined as the sum of square distances of samples to their cluster center, weighted by the sample weights if provided.\n   */\n  get inertia_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing inertia_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_inertia_ = bridgeMiniBatchKMeans[${this.id}].inertia_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_inertia_.tolist() if hasattr(attr_MiniBatchKMeans_inertia_, 'tolist') else attr_MiniBatchKMeans_inertia_`\n    })()\n  }\n\n  /**\n    Number of iterations over the full dataset.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_n_iter_ = bridgeMiniBatchKMeans[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_n_iter_.tolist() if hasattr(attr_MiniBatchKMeans_n_iter_, 'tolist') else attr_MiniBatchKMeans_n_iter_`\n    })()\n  }\n\n  /**\n    Number of minibatches processed.\n   */\n  get n_steps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing n_steps_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_n_steps_ = bridgeMiniBatchKMeans[${this.id}].n_steps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_n_steps_.tolist() if hasattr(attr_MiniBatchKMeans_n_steps_, 'tolist') else attr_MiniBatchKMeans_n_steps_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_n_features_in_ = bridgeMiniBatchKMeans[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_n_features_in_.tolist() if hasattr(attr_MiniBatchKMeans_n_features_in_, 'tolist') else attr_MiniBatchKMeans_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MiniBatchKMeans instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchKMeans must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchKMeans_feature_names_in_ = bridgeMiniBatchKMeans[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchKMeans_feature_names_in_.tolist() if hasattr(attr_MiniBatchKMeans_feature_names_in_, 'tolist') else attr_MiniBatchKMeans_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Estimate clustering structure from vector array.\n\n  OPTICS (Ordering Points To Identify the Clustering Structure), closely related to DBSCAN, finds core sample of high density and expands clusters from them [\\[1\\]](#r2c55e37003fe-1). Unlike DBSCAN, keeps cluster hierarchy for a variable neighborhood radius. Better suited for usage on large datasets than the current sklearn implementation of DBSCAN.\n\n  Clusters are then extracted using a DBSCAN-like method (cluster\\_method = ‘dbscan’) or an automatic technique proposed in [\\[1\\]](#r2c55e37003fe-1) (cluster\\_method = ‘xi’).\n\n  This implementation deviates from the original OPTICS by first performing k-nearest-neighborhood searches on all points to identify core sizes, then computing only the distances to unprocessed points when constructing the cluster order. Note that we do not employ a heap to manage the expansion candidates, so the time complexity will be O(n^2).\n\n  Read more in the [User Guide](../clustering.html#optics).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html)\n */\nexport class OPTICS {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of samples in a neighborhood for a point to be considered as a core point. Also, up and down steep regions can’t have more than `min\\_samples` consecutive non-steep points. Expressed as an absolute number or a fraction of the number of samples (rounded to be at least 2).\n\n      @defaultValue `5`\n     */\n    min_samples?: any\n\n    /**\n      The maximum distance between two samples for one to be considered as in the neighborhood of the other. Default value of `np.inf` will identify clusters across all scales; reducing `max\\_eps` will result in shorter run times.\n     */\n    max_eps?: number\n\n    /**\n      Metric to use for distance computation. Any metric from scikit-learn or scipy.spatial.distance can be used.\n\n      If metric is a callable function, it is called on each pair of instances (rows) and the resulting value recorded. The callable should take two arrays as input and return one value indicating the distance between them. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string. If metric is “precomputed”, `X` is assumed to be a distance matrix and must be square.\n\n      Valid values for metric are:\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Parameter for the Minkowski metric from [`pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\"). When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The extraction method used to extract clusters using the calculated reachability and ordering. Possible values are “xi” and “dbscan”.\n\n      @defaultValue `'xi'`\n     */\n    cluster_method?: string\n\n    /**\n      The maximum distance between two samples for one to be considered as in the neighborhood of the other. By default it assumes the same value as `max\\_eps`. Used only when `cluster\\_method='dbscan'`.\n     */\n    eps?: number\n\n    /**\n      Determines the minimum steepness on the reachability plot that constitutes a cluster boundary. For example, an upwards point in the reachability plot is defined by the ratio from one point to its successor being at most 1-xi. Used only when `cluster\\_method='xi'`.\n\n      @defaultValue `0.05`\n     */\n    xi?: any\n\n    /**\n      Correct clusters according to the predecessors calculated by OPTICS [\\[2\\]](#r2c55e37003fe-2). This parameter has minimal effect on most datasets. Used only when `cluster\\_method='xi'`.\n\n      @defaultValue `true`\n     */\n    predecessor_correction?: boolean\n\n    /**\n      Minimum number of samples in an OPTICS cluster, expressed as an absolute number or a fraction of the number of samples (rounded to be at least 2). If `undefined`, the value of `min\\_samples` is used instead. Used only when `cluster\\_method='xi'`.\n     */\n    min_cluster_size?: any\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\"). This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Used to cache the output of the computation of the tree. By default, no caching is done. If a string is given, it is the path to the caching directory.\n     */\n    memory?: string\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `OPTICS${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('OPTICS.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import OPTICS\ntry: bridgeOPTICS\nexcept NameError: bridgeOPTICS = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OPTICS = {'min_samples': ${\n      this.opts['min_samples'] ?? undefined\n    }, 'max_eps': ${this.opts['max_eps'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'cluster_method': ${this.opts['cluster_method'] ?? undefined}, 'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'xi': ${this.opts['xi'] ?? undefined}, 'predecessor_correction': ${\n      this.opts['predecessor_correction'] ?? undefined\n    }, 'min_cluster_size': ${\n      this.opts['min_cluster_size'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'leaf_size': ${\n      this.opts['leaf_size'] ?? undefined\n    }, 'memory': ${this.opts['memory'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_OPTICS = {k: v for k, v in ctor_OPTICS.items() if v is not None}`\n\n    await this._py.ex`bridgeOPTICS[${this.id}] = OPTICS(**ctor_OPTICS)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOPTICS[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Perform OPTICS clustering.\n\n    Extracts an ordered list of points and reachability distances, and performs initial clustering using `max\\_eps` distance specified at OPTICS object instantiation.\n   */\n  async fit(opts: {\n    /**\n      A feature array, or array of distances between samples if metric=’precomputed’. If a sparse matrix is provided, it will be converted into CSR format.\n     */\n    X?: any\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OPTICS_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OPTICS_fit = {k: v for k, v in pms_OPTICS_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OPTICS_fit = bridgeOPTICS[${this.id}].fit(**pms_OPTICS_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OPTICS_fit.tolist() if hasattr(res_OPTICS_fit, 'tolist') else res_OPTICS_fit`\n  }\n\n  /**\n    Perform clustering on `X` and returns cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OPTICS_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_OPTICS_fit_predict = {k: v for k, v in pms_OPTICS_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OPTICS_fit_predict = bridgeOPTICS[${this.id}].fit_predict(**pms_OPTICS_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OPTICS_fit_predict.tolist() if hasattr(res_OPTICS_fit_predict, 'tolist') else res_OPTICS_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OPTICS_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OPTICS_get_metadata_routing = {k: v for k, v in pms_OPTICS_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OPTICS_get_metadata_routing = bridgeOPTICS[${this.id}].get_metadata_routing(**pms_OPTICS_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OPTICS_get_metadata_routing.tolist() if hasattr(res_OPTICS_get_metadata_routing, 'tolist') else res_OPTICS_get_metadata_routing`\n  }\n\n  /**\n    Cluster labels for each point in the dataset given to fit(). Noisy samples and points which are not included in a leaf cluster of `cluster\\_hierarchy\\_` are labeled as -1.\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before accessing labels_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_OPTICS_labels_ = bridgeOPTICS[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_labels_.tolist() if hasattr(attr_OPTICS_labels_, 'tolist') else attr_OPTICS_labels_`\n    })()\n  }\n\n  /**\n    Reachability distances per sample, indexed by object order. Use `clust.reachability\\_\\[clust.ordering\\_\\]` to access in cluster order.\n   */\n  get reachability_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before accessing reachability_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_reachability_ = bridgeOPTICS[${this.id}].reachability_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_reachability_.tolist() if hasattr(attr_OPTICS_reachability_, 'tolist') else attr_OPTICS_reachability_`\n    })()\n  }\n\n  /**\n    The cluster ordered list of sample indices.\n   */\n  get ordering_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before accessing ordering_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_ordering_ = bridgeOPTICS[${this.id}].ordering_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_ordering_.tolist() if hasattr(attr_OPTICS_ordering_, 'tolist') else attr_OPTICS_ordering_`\n    })()\n  }\n\n  /**\n    Distance at which each sample becomes a core point, indexed by object order. Points which will never be core have a distance of inf. Use `clust.core\\_distances\\_\\[clust.ordering\\_\\]` to access in cluster order.\n   */\n  get core_distances_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OPTICS must call init() before accessing core_distances_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_core_distances_ = bridgeOPTICS[${this.id}].core_distances_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_core_distances_.tolist() if hasattr(attr_OPTICS_core_distances_, 'tolist') else attr_OPTICS_core_distances_`\n    })()\n  }\n\n  /**\n    Point that a sample was reached from, indexed by object order. Seed points have a predecessor of -1.\n   */\n  get predecessor_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before accessing predecessor_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_predecessor_ = bridgeOPTICS[${this.id}].predecessor_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_predecessor_.tolist() if hasattr(attr_OPTICS_predecessor_, 'tolist') else attr_OPTICS_predecessor_`\n    })()\n  }\n\n  /**\n    The list of clusters in the form of `\\[start, end\\]` in each row, with all indices inclusive. The clusters are ordered according to `(end, \\-start)` (ascending) so that larger clusters encompassing smaller clusters come after those smaller ones. Since `labels\\_` does not reflect the hierarchy, usually `len(cluster\\_hierarchy\\_) > np.unique(optics.labels\\_)`. Please also note that these indices are of the `ordering\\_`, i.e. `X\\[ordering\\_\\]\\[start:end + 1\\]` form a cluster. Only available when `cluster\\_method='xi'`.\n   */\n  get cluster_hierarchy_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OPTICS must call init() before accessing cluster_hierarchy_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_cluster_hierarchy_ = bridgeOPTICS[${this.id}].cluster_hierarchy_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_cluster_hierarchy_.tolist() if hasattr(attr_OPTICS_cluster_hierarchy_, 'tolist') else attr_OPTICS_cluster_hierarchy_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OPTICS must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_n_features_in_ = bridgeOPTICS[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_n_features_in_.tolist() if hasattr(attr_OPTICS_n_features_in_, 'tolist') else attr_OPTICS_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This OPTICS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OPTICS must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OPTICS_feature_names_in_ = bridgeOPTICS[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OPTICS_feature_names_in_.tolist() if hasattr(attr_OPTICS_feature_names_in_, 'tolist') else attr_OPTICS_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Spectral biclustering (Kluger, 2003).\n\n  Partitions rows and columns under the assumption that the data has an underlying checkerboard structure. For instance, if there are two row partitions and three column partitions, each row will belong to three biclusters, and each column will belong to two biclusters. The outer product of the corresponding row and column label vectors gives this checkerboard structure.\n\n  Read more in the [User Guide](../biclustering.html#spectral-biclustering).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralBiclustering.html)\n */\nexport class SpectralBiclustering {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of row and column clusters in the checkerboard structure.\n\n      @defaultValue `3`\n     */\n    n_clusters?: number\n\n    /**\n      Method of normalizing and converting singular vectors into biclusters. May be one of ‘scale’, ‘bistochastic’, or ‘log’. The authors recommend using ‘log’. If the data is sparse, however, log normalization will not work, which is why the default is ‘bistochastic’.\n\n      @defaultValue `'bistochastic'`\n     */\n    method?: 'bistochastic' | 'scale' | 'log'\n\n    /**\n      Number of singular vectors to check.\n\n      @defaultValue `6`\n     */\n    n_components?: number\n\n    /**\n      Number of best singular vectors to which to project the data for clustering.\n\n      @defaultValue `3`\n     */\n    n_best?: number\n\n    /**\n      Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, uses [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\"), which may be faster for large matrices. If ‘arpack’, uses `scipy.sparse.linalg.svds`, which is more accurate, but possibly slower in some cases.\n\n      @defaultValue `'randomized'`\n     */\n    svd_method?: 'randomized' | 'arpack'\n\n    /**\n      Number of vectors to use in calculating the SVD. Corresponds to `ncv` when `svd\\_method=arpack` and `n\\_oversamples` when `svd\\_method` is ‘randomized\\`.\n     */\n    n_svd_vecs?: number\n\n    /**\n      Whether to use mini-batch k-means, which is faster but may get different results.\n\n      @defaultValue `false`\n     */\n    mini_batch?: boolean\n\n    /**\n      Method for initialization of k-means algorithm; defaults to ‘k-means++’.\n\n      @defaultValue `'k-means++'`\n     */\n    init?: 'k-means++' | 'random' | NDArray[]\n\n    /**\n      Number of random initializations that are tried with the k-means algorithm.\n\n      If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen.\n\n      @defaultValue `10`\n     */\n    n_init?: number\n\n    /**\n      Used for randomizing the singular value decomposition and the k-means initialization. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SpectralBiclustering${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SpectralBiclustering.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import SpectralBiclustering\ntry: bridgeSpectralBiclustering\nexcept NameError: bridgeSpectralBiclustering = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SpectralBiclustering = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'method': ${this.opts['method'] ?? undefined}, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'n_best': ${this.opts['n_best'] ?? undefined}, 'svd_method': ${\n      this.opts['svd_method'] ?? undefined\n    }, 'n_svd_vecs': ${this.opts['n_svd_vecs'] ?? undefined}, 'mini_batch': ${\n      this.opts['mini_batch'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_SpectralBiclustering = {k: v for k, v in ctor_SpectralBiclustering.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSpectralBiclustering[${this.id}] = SpectralBiclustering(**ctor_SpectralBiclustering)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSpectralBiclustering[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Create a biclustering for X.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SpectralBiclustering must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralBiclustering_fit = {k: v for k, v in pms_SpectralBiclustering_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_fit = bridgeSpectralBiclustering[${this.id}].fit(**pms_SpectralBiclustering_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_fit.tolist() if hasattr(res_SpectralBiclustering_fit, 'tolist') else res_SpectralBiclustering_fit`\n  }\n\n  /**\n    Row and column indices of the `i`’th bicluster.\n\n    Only works if `rows\\_` and `columns\\_` attributes exist.\n   */\n  async get_indices(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_indices()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_indices = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralBiclustering_get_indices = {k: v for k, v in pms_SpectralBiclustering_get_indices.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_indices = bridgeSpectralBiclustering[${this.id}].get_indices(**pms_SpectralBiclustering_get_indices)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_indices.tolist() if hasattr(res_SpectralBiclustering_get_indices, 'tolist') else res_SpectralBiclustering_get_indices`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SpectralBiclustering_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SpectralBiclustering_get_metadata_routing = {k: v for k, v in pms_SpectralBiclustering_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_metadata_routing = bridgeSpectralBiclustering[${this.id}].get_metadata_routing(**pms_SpectralBiclustering_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_metadata_routing.tolist() if hasattr(res_SpectralBiclustering_get_metadata_routing, 'tolist') else res_SpectralBiclustering_get_metadata_routing`\n  }\n\n  /**\n    Shape of the `i`’th bicluster.\n   */\n  async get_shape(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_shape()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_shape = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralBiclustering_get_shape = {k: v for k, v in pms_SpectralBiclustering_get_shape.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_shape = bridgeSpectralBiclustering[${this.id}].get_shape(**pms_SpectralBiclustering_get_shape)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_shape.tolist() if hasattr(res_SpectralBiclustering_get_shape, 'tolist') else res_SpectralBiclustering_get_shape`\n  }\n\n  /**\n    Return the submatrix corresponding to bicluster `i`.\n   */\n  async get_submatrix(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n\n    /**\n      The data.\n     */\n    data?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_submatrix()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_submatrix = {'i': ${\n      opts['i'] ?? undefined\n    }, 'data': np.array(${opts['data'] ?? undefined}) if ${\n      opts['data'] !== undefined\n    } else None}\n\npms_SpectralBiclustering_get_submatrix = {k: v for k, v in pms_SpectralBiclustering_get_submatrix.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_submatrix = bridgeSpectralBiclustering[${this.id}].get_submatrix(**pms_SpectralBiclustering_get_submatrix)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_submatrix.tolist() if hasattr(res_SpectralBiclustering_get_submatrix, 'tolist') else res_SpectralBiclustering_get_submatrix`\n  }\n\n  /**\n    Results of the clustering. `rows\\[i, r\\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.\n   */\n  get rows_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing rows_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_rows_ = bridgeSpectralBiclustering[${this.id}].rows_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_rows_.tolist() if hasattr(attr_SpectralBiclustering_rows_, 'tolist') else attr_SpectralBiclustering_rows_`\n    })()\n  }\n\n  /**\n    Results of the clustering, like `rows`.\n   */\n  get columns_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing columns_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_columns_ = bridgeSpectralBiclustering[${this.id}].columns_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_columns_.tolist() if hasattr(attr_SpectralBiclustering_columns_, 'tolist') else attr_SpectralBiclustering_columns_`\n    })()\n  }\n\n  /**\n    Row partition labels.\n   */\n  get row_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing row_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_row_labels_ = bridgeSpectralBiclustering[${this.id}].row_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_row_labels_.tolist() if hasattr(attr_SpectralBiclustering_row_labels_, 'tolist') else attr_SpectralBiclustering_row_labels_`\n    })()\n  }\n\n  /**\n    Column partition labels.\n   */\n  get column_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing column_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_column_labels_ = bridgeSpectralBiclustering[${this.id}].column_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_column_labels_.tolist() if hasattr(attr_SpectralBiclustering_column_labels_, 'tolist') else attr_SpectralBiclustering_column_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_n_features_in_ = bridgeSpectralBiclustering[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_n_features_in_.tolist() if hasattr(attr_SpectralBiclustering_n_features_in_, 'tolist') else attr_SpectralBiclustering_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_feature_names_in_ = bridgeSpectralBiclustering[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_feature_names_in_.tolist() if hasattr(attr_SpectralBiclustering_feature_names_in_, 'tolist') else attr_SpectralBiclustering_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Apply clustering to a projection of the normalized Laplacian.\n\n  In practice Spectral Clustering is very useful when the structure of the individual clusters is highly non-convex, or more generally when a measure of the center and spread of the cluster is not a suitable description of the complete cluster, such as when clusters are nested circles on the 2D plane.\n\n  If the affinity matrix is the adjacency matrix of a graph, this method can be used to find normalized graph cuts [\\[1\\]](#r5f6cbeb1558e-1), [\\[2\\]](#r5f6cbeb1558e-2).\n\n  When calling `fit`, an affinity matrix is constructed using either a kernel function such the Gaussian (aka RBF) kernel with Euclidean distance `d(X, X)`:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html)\n */\nexport class SpectralClustering {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The dimension of the projection subspace.\n\n      @defaultValue `8`\n     */\n    n_clusters?: number\n\n    /**\n      The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems, but may also lead to instabilities. If `undefined`, then `'arpack'` is used. See [\\[4\\]](#r5f6cbeb1558e-4) for more details regarding `'lobpcg'`.\n     */\n    eigen_solver?: 'arpack' | 'lobpcg' | 'amg'\n\n    /**\n      Number of eigenvectors to use for the spectral embedding. If `undefined`, defaults to `n\\_clusters`.\n     */\n    n_components?: number\n\n    /**\n      A pseudo random number generator used for the initialization of the lobpcg eigenvectors decomposition when `eigen\\_solver \\== 'amg'`, and for the K-Means initialization. Use an int to make the results deterministic across calls (See [Glossary](../../glossary.html#term-random_state)).\n     */\n    random_state?: number\n\n    /**\n      Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n\\_init consecutive runs in terms of inertia. Only used if `assign\\_labels='kmeans'`.\n\n      @defaultValue `10`\n     */\n    n_init?: number\n\n    /**\n      Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels. Ignored for `affinity='nearest\\_neighbors'`.\n\n      @defaultValue `1`\n     */\n    gamma?: number\n\n    /**\n      ‘nearest\\_neighbors’: construct the affinity matrix by computing a graph of nearest neighbors.\n\n      @defaultValue `'rbf'`\n     */\n    affinity?: string\n\n    /**\n      Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method. Ignored for `affinity='rbf'`.\n\n      @defaultValue `10`\n     */\n    n_neighbors?: number\n\n    /**\n      Stopping criterion for eigen decomposition of the Laplacian matrix. If `eigen\\_tol=\"auto\"` then the passed tolerance will depend on the `eigen\\_solver`:\n\n      @defaultValue `'auto'`\n     */\n    eigen_tol?: number\n\n    /**\n      The strategy for assigning labels in the embedding space. There are two ways to assign labels after the Laplacian embedding. k-means is a popular choice, but it can be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization [\\[3\\]](#r5f6cbeb1558e-3). The cluster\\_qr method [\\[5\\]](#r5f6cbeb1558e-5) directly extract clusters from eigenvectors in spectral clustering. In contrast to k-means and discretization, cluster\\_qr has no tuning parameters and runs no iterations, yet may outperform k-means and discretization in terms of both quality and speed.\n\n      @defaultValue `'kmeans'`\n     */\n    assign_labels?: 'kmeans' | 'discretize' | 'cluster_qr'\n\n    /**\n      Degree of the polynomial kernel. Ignored by other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Zero coefficient for polynomial and sigmoid kernels. Ignored by other kernels.\n\n      @defaultValue `1`\n     */\n    coef0?: number\n\n    /**\n      Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.\n     */\n    kernel_params?: any\n\n    /**\n      The number of parallel jobs to run when `affinity='nearest\\_neighbors'` or `affinity='precomputed\\_nearest\\_neighbors'`. The neighbors search will be done in parallel. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Verbosity mode.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `SpectralClustering${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SpectralClustering.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import SpectralClustering\ntry: bridgeSpectralClustering\nexcept NameError: bridgeSpectralClustering = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SpectralClustering = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'eigen_solver': ${\n      this.opts['eigen_solver'] ?? undefined\n    }, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'affinity': ${\n      this.opts['affinity'] ?? undefined\n    }, 'n_neighbors': ${this.opts['n_neighbors'] ?? undefined}, 'eigen_tol': ${\n      this.opts['eigen_tol'] ?? undefined\n    }, 'assign_labels': ${this.opts['assign_labels'] ?? undefined}, 'degree': ${\n      this.opts['degree'] ?? undefined\n    }, 'coef0': ${this.opts['coef0'] ?? undefined}, 'kernel_params': ${\n      this.opts['kernel_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_SpectralClustering = {k: v for k, v in ctor_SpectralClustering.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSpectralClustering[${this.id}] = SpectralClustering(**ctor_SpectralClustering)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSpectralClustering[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Perform spectral clustering from features, or affinity matrix.\n   */\n  async fit(opts: {\n    /**\n      Training instances to cluster, similarities / affinities between instances if `affinity='precomputed'`, or distances between instances if `affinity='precomputed\\_nearest\\_neighbors`. If a sparse matrix is provided in a format other than `csr\\_matrix`, `csc\\_matrix`, or `coo\\_matrix`, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SpectralClustering must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralClustering_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralClustering_fit = {k: v for k, v in pms_SpectralClustering_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralClustering_fit = bridgeSpectralClustering[${this.id}].fit(**pms_SpectralClustering_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralClustering_fit.tolist() if hasattr(res_SpectralClustering_fit, 'tolist') else res_SpectralClustering_fit`\n  }\n\n  /**\n    Perform spectral clustering on `X` and return cluster labels.\n   */\n  async fit_predict(opts: {\n    /**\n      Training instances to cluster, similarities / affinities between instances if `affinity='precomputed'`, or distances between instances if `affinity='precomputed\\_nearest\\_neighbors`. If a sparse matrix is provided in a format other than `csr\\_matrix`, `csc\\_matrix`, or `coo\\_matrix`, it will be converted into a sparse `csr\\_matrix`.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present here for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before fit_predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralClustering_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralClustering_fit_predict = {k: v for k, v in pms_SpectralClustering_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralClustering_fit_predict = bridgeSpectralClustering[${this.id}].fit_predict(**pms_SpectralClustering_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralClustering_fit_predict.tolist() if hasattr(res_SpectralClustering_fit_predict, 'tolist') else res_SpectralClustering_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SpectralClustering_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SpectralClustering_get_metadata_routing = {k: v for k, v in pms_SpectralClustering_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralClustering_get_metadata_routing = bridgeSpectralClustering[${this.id}].get_metadata_routing(**pms_SpectralClustering_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralClustering_get_metadata_routing.tolist() if hasattr(res_SpectralClustering_get_metadata_routing, 'tolist') else res_SpectralClustering_get_metadata_routing`\n  }\n\n  /**\n    Affinity matrix used for clustering. Available only after calling `fit`.\n   */\n  get affinity_matrix_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before accessing affinity_matrix_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralClustering_affinity_matrix_ = bridgeSpectralClustering[${this.id}].affinity_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralClustering_affinity_matrix_.tolist() if hasattr(attr_SpectralClustering_affinity_matrix_, 'tolist') else attr_SpectralClustering_affinity_matrix_`\n    })()\n  }\n\n  /**\n    Labels of each point\n   */\n  get labels_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before accessing labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralClustering_labels_ = bridgeSpectralClustering[${this.id}].labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralClustering_labels_.tolist() if hasattr(attr_SpectralClustering_labels_, 'tolist') else attr_SpectralClustering_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralClustering_n_features_in_ = bridgeSpectralClustering[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralClustering_n_features_in_.tolist() if hasattr(attr_SpectralClustering_n_features_in_, 'tolist') else attr_SpectralClustering_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralClustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralClustering must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralClustering_feature_names_in_ = bridgeSpectralClustering[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralClustering_feature_names_in_.tolist() if hasattr(attr_SpectralClustering_feature_names_in_, 'tolist') else attr_SpectralClustering_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Spectral Co-Clustering algorithm (Dhillon, 2001).\n\n  Clusters rows and columns of an array `X` to solve the relaxed normalized cut of the bipartite graph created from `X` as follows: the edge between row vertex `i` and column vertex `j` has weight `X\\[i, j\\]`.\n\n  The resulting bicluster structure is block-diagonal, since each row and each column belongs to exactly one bicluster.\n\n  Supports sparse matrices, as long as they are nonnegative.\n\n  Read more in the [User Guide](../biclustering.html#spectral-coclustering).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralCoclustering.html)\n */\nexport class SpectralCoclustering {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of biclusters to find.\n\n      @defaultValue `3`\n     */\n    n_clusters?: number\n\n    /**\n      Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, use [`sklearn.utils.extmath.randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\"), which may be faster for large matrices. If ‘arpack’, use [`scipy.sparse.linalg.svds`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.svds.html#scipy.sparse.linalg.svds \"(in SciPy v1.11.3)\"), which is more accurate, but possibly slower in some cases.\n\n      @defaultValue `'randomized'`\n     */\n    svd_method?: 'randomized' | 'arpack'\n\n    /**\n      Number of vectors to use in calculating the SVD. Corresponds to `ncv` when `svd\\_method=arpack` and `n\\_oversamples` when `svd\\_method` is ‘randomized\\`.\n     */\n    n_svd_vecs?: number\n\n    /**\n      Whether to use mini-batch k-means, which is faster but may get different results.\n\n      @defaultValue `false`\n     */\n    mini_batch?: boolean\n\n    /**\n      Method for initialization of k-means algorithm; defaults to ‘k-means++’.\n\n      @defaultValue `'k-means++'`\n     */\n    init?: NDArray[]\n\n    /**\n      Number of random initializations that are tried with the k-means algorithm.\n\n      If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen.\n\n      @defaultValue `10`\n     */\n    n_init?: number\n\n    /**\n      Used for randomizing the singular value decomposition and the k-means initialization. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SpectralCoclustering${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SpectralCoclustering.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import SpectralCoclustering\ntry: bridgeSpectralCoclustering\nexcept NameError: bridgeSpectralCoclustering = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SpectralCoclustering = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'svd_method': ${this.opts['svd_method'] ?? undefined}, 'n_svd_vecs': ${\n      this.opts['n_svd_vecs'] ?? undefined\n    }, 'mini_batch': ${\n      this.opts['mini_batch'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_SpectralCoclustering = {k: v for k, v in ctor_SpectralCoclustering.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSpectralCoclustering[${this.id}] = SpectralCoclustering(**ctor_SpectralCoclustering)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSpectralCoclustering[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Create a biclustering for X.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SpectralCoclustering must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralCoclustering_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralCoclustering_fit = {k: v for k, v in pms_SpectralCoclustering_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralCoclustering_fit = bridgeSpectralCoclustering[${this.id}].fit(**pms_SpectralCoclustering_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralCoclustering_fit.tolist() if hasattr(res_SpectralCoclustering_fit, 'tolist') else res_SpectralCoclustering_fit`\n  }\n\n  /**\n    Row and column indices of the `i`’th bicluster.\n\n    Only works if `rows\\_` and `columns\\_` attributes exist.\n   */\n  async get_indices(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before get_indices()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralCoclustering_get_indices = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralCoclustering_get_indices = {k: v for k, v in pms_SpectralCoclustering_get_indices.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralCoclustering_get_indices = bridgeSpectralCoclustering[${this.id}].get_indices(**pms_SpectralCoclustering_get_indices)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralCoclustering_get_indices.tolist() if hasattr(res_SpectralCoclustering_get_indices, 'tolist') else res_SpectralCoclustering_get_indices`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SpectralCoclustering_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SpectralCoclustering_get_metadata_routing = {k: v for k, v in pms_SpectralCoclustering_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralCoclustering_get_metadata_routing = bridgeSpectralCoclustering[${this.id}].get_metadata_routing(**pms_SpectralCoclustering_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralCoclustering_get_metadata_routing.tolist() if hasattr(res_SpectralCoclustering_get_metadata_routing, 'tolist') else res_SpectralCoclustering_get_metadata_routing`\n  }\n\n  /**\n    Shape of the `i`’th bicluster.\n   */\n  async get_shape(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before get_shape()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralCoclustering_get_shape = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralCoclustering_get_shape = {k: v for k, v in pms_SpectralCoclustering_get_shape.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralCoclustering_get_shape = bridgeSpectralCoclustering[${this.id}].get_shape(**pms_SpectralCoclustering_get_shape)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralCoclustering_get_shape.tolist() if hasattr(res_SpectralCoclustering_get_shape, 'tolist') else res_SpectralCoclustering_get_shape`\n  }\n\n  /**\n    Return the submatrix corresponding to bicluster `i`.\n   */\n  async get_submatrix(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n\n    /**\n      The data.\n     */\n    data?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before get_submatrix()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralCoclustering_get_submatrix = {'i': ${\n      opts['i'] ?? undefined\n    }, 'data': np.array(${opts['data'] ?? undefined}) if ${\n      opts['data'] !== undefined\n    } else None}\n\npms_SpectralCoclustering_get_submatrix = {k: v for k, v in pms_SpectralCoclustering_get_submatrix.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralCoclustering_get_submatrix = bridgeSpectralCoclustering[${this.id}].get_submatrix(**pms_SpectralCoclustering_get_submatrix)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralCoclustering_get_submatrix.tolist() if hasattr(res_SpectralCoclustering_get_submatrix, 'tolist') else res_SpectralCoclustering_get_submatrix`\n  }\n\n  /**\n    Results of the clustering. `rows\\[i, r\\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.\n   */\n  get rows_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing rows_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_rows_ = bridgeSpectralCoclustering[${this.id}].rows_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_rows_.tolist() if hasattr(attr_SpectralCoclustering_rows_, 'tolist') else attr_SpectralCoclustering_rows_`\n    })()\n  }\n\n  /**\n    Results of the clustering, like `rows`.\n   */\n  get columns_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing columns_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_columns_ = bridgeSpectralCoclustering[${this.id}].columns_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_columns_.tolist() if hasattr(attr_SpectralCoclustering_columns_, 'tolist') else attr_SpectralCoclustering_columns_`\n    })()\n  }\n\n  /**\n    The bicluster label of each row.\n   */\n  get row_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing row_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_row_labels_ = bridgeSpectralCoclustering[${this.id}].row_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_row_labels_.tolist() if hasattr(attr_SpectralCoclustering_row_labels_, 'tolist') else attr_SpectralCoclustering_row_labels_`\n    })()\n  }\n\n  /**\n    The bicluster label of each column.\n   */\n  get column_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing column_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_column_labels_ = bridgeSpectralCoclustering[${this.id}].column_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_column_labels_.tolist() if hasattr(attr_SpectralCoclustering_column_labels_, 'tolist') else attr_SpectralCoclustering_column_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_n_features_in_ = bridgeSpectralCoclustering[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_n_features_in_.tolist() if hasattr(attr_SpectralCoclustering_n_features_in_, 'tolist') else attr_SpectralCoclustering_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralCoclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralCoclustering must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralCoclustering_feature_names_in_ = bridgeSpectralCoclustering[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralCoclustering_feature_names_in_.tolist() if hasattr(attr_SpectralCoclustering_feature_names_in_, 'tolist') else attr_SpectralCoclustering_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":";AAGA,OAAO,YAAY;AAWZ,IAAM,sBAAN,MAA0B;AAAA,EAQ/B,YAAY,MAoDT;AAvDH,0BAA0B;AAC1B,uBAAuB;AAuDrB,SAAK,KAAK,sBAAsB,OAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAChE,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,4CACb,KAAK,KAAK,SAAS,KAAK,uBACT,KAAK,KAAK,UAAU,KAAK,+BACxC,KAAK,KAAK,kBAAkB,KAAK,mBACtB,KAAK,KAAK,MAAM,KAAK,kCAChC,KAAK,KAAK,YAAY,KAAK,cACrB,KAAK,KAAK,YAAY,MAAM,iCAClC,KAAK,KAAK,UAAU,KAAK,sBACX,KAAK,KAAK,SAAS,KAAK,2BACtC,KAAK,KAAK,cAAc,KAAK;AAAA;AAAA;AAK/B,UAAM,KAAK,IACR,+BAA+B,KAAK;AAEvC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,mCAAmC,KAAK;AAEvD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,6DAA6D,KAAK;AAGrE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,0DACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,gEACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,8EAA8E,KAAK;AAGtF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,MAKO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,2BAA6C;AAC/C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,mFAAmF,KAAK;AAG3F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kEAAkE,KAAK;AAG1E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kEAAkE,KAAK;AAG1E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,4EAA4E,KAAK;AAGpF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACpfA,OAAOA,aAAY;AAaZ,IAAM,0BAAN,MAA8B;AAAA,EAQnC,YAAY,MAuDT;AA1DH,0BAA0B;AAC1B,uBAAuB;AA0DrB,SAAK,KAAK,0BAA0BA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACpE,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,mDACb,KAAK,KAAK,YAAY,KAAK,uBACZ,KAAK,KAAK,UAAU,KAAK,qBACxC,KAAK,KAAK,QAAQ,KAAK,qBACV,KAAK,KAAK,QAAQ,KAAK,2BACpC,KAAK,KAAK,cAAc,KAAK,gCAE7B,KAAK,KAAK,mBAAmB,KAAK,sBACpB,KAAK,KAAK,SAAS,KAAK,iCACtC,KAAK,KAAK,oBAAoB,KAAK,gCACX,KAAK,KAAK,mBAAmB,KAAK;AAAA;AAAA;AAI5D,UAAM,KAAK,IACR,mCAAmC,KAAK;AAE3C,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,uCAAuC,KAAK;AAE3D,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,6CACb,KAAK,GAAG,KAAK,gBACL,KAAK,GAAG,KAAK;AAAA;AAAA;AAKvB,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,8DACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,6EAA6E,KAAK;AAGrF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,oEACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,sFAAsF,KAAK;AAG9F,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAA+B;AACjC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8EAA8E,KAAK;AAGtF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0EAA0E,KAAK;AAGlF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAA6B;AAC/B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,4EAA4E,KAAK;AAGpF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,0BAA2C;AAC7C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0FAA0F,KAAK;AAGlG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iFAAiF,KAAK;AAGzF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oFAAoF,KAAK;AAG5F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,4EAA4E,KAAK;AAGpF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,6EAA6E,KAAK;AAGrF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACpfA,OAAOC,aAAY;AAaZ,IAAM,QAAN,MAAY;AAAA,EAQjB,YAAY,MAmCT;AAtCH,0BAA0B;AAC1B,uBAAuB;AAsCrB,SAAK,KAAK,QAAQA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAClD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,gCACb,KAAK,KAAK,WAAW,KAAK,+BAE1B,KAAK,KAAK,kBAAkB,KAAK,yBAEjC,KAAK,KAAK,YAAY,KAAK,6BACN,KAAK,KAAK,gBAAgB,KAAK,mBACpD,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAKvB,UAAM,KAAK,IAAI,iBAAiB,KAAK;AAErC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,qBAAqB,KAAK;AAEzC,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAGA,UAAM,KAAK,IAAI,oCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,iCAAiC,KAAK;AAGzC,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAGA,UAAM,KAAK,IAAI,4CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,yCAAyC,KAAK;AAGjD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAeD;AACjB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,UAAM,KAAK,IAAI,8CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,YAAY,KAAK;AAAA;AAAA;AAMxB,UAAM,KAAK,IACR,2CAA2C,KAAK;AAGnD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBAAsB,MAKX;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,0DACb,KAAK,gBAAgB,KAAK;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,mDAAmD,KAAK;AAG3D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,kDAAkD,KAAK;AAG1D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUD;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAGA,UAAM,KAAK,IAAI,4CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,yCAAyC,KAAK;AAGjD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,MAKG;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAGA,UAAM,KAAK,IAAI,wCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,qCAAqC,KAAK;AAG7C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AAGA,UAAM,KAAK,IAAI,0CACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,wCAAwC,KAAK;AAGhD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,MAKwB;AACtC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AAGA,UAAM,KAAK,IAAI,0CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,uCAAuC,KAAK;AAG/C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAsB;AACxB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,oCAAoC,KAAK;AAGxD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0CAA0C,KAAK;AAGlD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,sBAAwC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kDAAkD,KAAK;AAG1D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,qBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,sCAAsC,KAAK;AAG1D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,gDAAgD,KAAK;AAGxD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;AC3nBA,OAAOC,aAAY;AAWZ,IAAM,kBAAN,MAAsB;AAAA,EAQ3B,YAAY,MA0ET;AA7EH,0BAA0B;AAC1B,uBAAuB;AA6ErB,SAAK,KAAK,kBAAkBA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5D,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,2CACb,KAAK,KAAK,YAAY,KAAK,mBAChB,KAAK,KAAK,MAAM,KAAK,qBAChC,KAAK,KAAK,QAAQ,KAAK,2BACJ,KAAK,KAAK,cAAc,KAAK,uBAChD,KAAK,KAAK,UAAU,KAAK,sBACX,KAAK,KAAK,SAAS,KAAK,kBACtC,KAAK,KAAK,KAAK,KAAK,qBACP,KAAK,KAAK,QAAQ,KAAK,wBACpC,KAAK,KAAK,WAAW,KAAK,iCACD,KAAK,KAAK,oBAAoB,KAAK;AAAA;AAAA;AAI9D,UAAM,KAAK,IACR,2BAA2B,KAAK;AAEnC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,+BAA+B,KAAK;AAEnD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAeO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,UAAM,KAAK,IAAI,8CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,qDAAqD,KAAK;AAG7D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAeG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,6DAA6D,KAAK;AAGrE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAeG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAGA,UAAM,KAAK,IAAI,wDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,+DAA+D,KAAK;AAGvE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBAAsB,MAKX;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,oEACD,KAAK,gBAAgB,KAAK;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,4DACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,sEAAsE,KAAK;AAG9E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,QAAQ,MAKO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,yDAAyD,KAAK;AAGjE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,MAeQ;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAGA,UAAM,KAAK,IAAI,gDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,uDAAuD,KAAK;AAG/D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,MAKL;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,6DACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,4DAA4D,KAAK;AAGpE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,oBAAoB,MAKT;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,iEACD,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAkB,MAKP;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,+DACD,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,mEAAmE,KAAK;AAG3E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,MAKO;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,mEAAmE,KAAK;AAG3E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0DAA0D,KAAK;AAGlE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oEAAoE,KAAK;AAG5E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACtxBA,OAAOC,aAAY;AAeZ,IAAM,SAAN,MAAa;AAAA,EAQlB,YAAY,MAkDT;AArDH,0BAA0B;AAC1B,uBAAuB;AAqDrB,SAAK,KAAK,SAASA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACnD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,2BACb,KAAK,KAAK,KAAK,KAAK,0BACF,KAAK,KAAK,aAAa,KAAK,qBAC9C,KAAK,KAAK,QAAQ,KAAK,4BAEvB,KAAK,KAAK,eAAe,KAAK,wBACd,KAAK,KAAK,WAAW,KAAK,wBAC1C,KAAK,KAAK,WAAW,KAAK,gBAClB,KAAK,KAAK,GAAG,KAAK,qBAC1B,KAAK,KAAK,QAAQ,KAAK;AAAA;AAAA;AAKzB,UAAM,KAAK,IAAI,kBAAkB,KAAK;AAEtC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,sBAAsB,KAAK;AAE1C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAeO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAGA,UAAM,KAAK,IAAI,qCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,mCAAmC,KAAK;AAG3C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAeG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAGA,UAAM,KAAK,IAAI,6CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,2CAA2C,KAAK;AAGnD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,oDAAoD,KAAK;AAG5D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,MAKL;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,+CAA+C,KAAK;AAGvD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,uBAAyC;AAC3C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,qDAAqD,KAAK;AAG7D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,4CAA4C,KAAK;AAGpD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,wCAAwC,KAAK;AAG5D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,+CAA+C,KAAK;AAGvD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kDAAkD,KAAK;AAG1D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACnbA,OAAOC,aAAY;AAaZ,IAAM,uBAAN,MAA2B;AAAA,EAQhC,YAAY,MA4DT;AA/DH,0BAA0B;AAC1B,uBAAuB;AA+DrB,SAAK,KAAK,uBAAuBA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACjE,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,gDACb,KAAK,KAAK,YAAY,KAAK,uBACZ,KAAK,KAAK,UAAU,KAAK,qBACxC,KAAK,KAAK,QAAQ,KAAK,qBACV,KAAK,KAAK,QAAQ,KAAK,2BACpC,KAAK,KAAK,cAAc,KAAK,gCAE7B,KAAK,KAAK,mBAAmB,KAAK,sBACpB,KAAK,KAAK,SAAS,KAAK,2BACtC,KAAK,KAAK,cAAc,KAAK,iCAE7B,KAAK,KAAK,oBAAoB,KAAK,gCACX,KAAK,KAAK,mBAAmB,KAAK;AAAA;AAAA;AAI5D,UAAM,KAAK,IACR,gCAAgC,KAAK;AAExC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,oCAAoC,KAAK;AAExD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,+DAA+D,KAAK;AAGvE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAeD;AACjB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,6DACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,YAAY,KAAK;AAAA;AAAA;AAMxB,UAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBAAsB,MAKX;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,yEACD,KAAK,gBAAgB,KAAK;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,iFAAiF,KAAK;AAGzF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,iEACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,gFAAgF,KAAK;AAGxF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,MAUD;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,kEACD,KAAK,IAAI,KAAK,cACR,KAAK,IAAI,MAAM,6BACrB,KAAK,MAAM,KAAK;AAAA;AAAA;AAMlB,UAAM,KAAK,IACR,6EAA6E,KAAK;AAGrF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,yDACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,sEAAsE,KAAK;AAG9E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,MAKO;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,yDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAA+B;AACjC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wEAAwE,KAAK;AAGhF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAwB;AAC1B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oEAAoE,KAAK;AAG5E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAA6B;AAC/B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,sEAAsE,KAAK;AAG9E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,0BAA2C;AAC7C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oFAAoF,KAAK;AAG5F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8EAA8E,KAAK;AAGtF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,sEAAsE,KAAK;AAG9E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACpqBA,OAAOC,aAAY;AAaZ,IAAM,UAAN,MAAc;AAAA,EAQnB,YAAY,MA0FT;AA7FH,0BAA0B;AAC1B,uBAAuB;AA6FrB,SAAK,KAAK,UAAUA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACpD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,yCACb,KAAK,KAAK,kBAAkB,KAAK,0BAEjC,KAAK,KAAK,aAAa,KAAK,wCAE5B,KAAK,KAAK,2BAA2B,KAAK,+BAE1C,KAAK,KAAK,kBAAkB,KAAK,qBACpB,KAAK,KAAK,QAAQ,KAAK,4BACpC,KAAK,KAAK,eAAe,KAAK,oBAClB,KAAK,KAAK,OAAO,KAAK,wBAClC,KAAK,KAAK,WAAW,KAAK,wBACV,KAAK,KAAK,WAAW,KAAK,qBAC1C,KAAK,KAAK,QAAQ,KAAK,uCAEvB,KAAK,KAAK,0BAA0B,KAAK,mCAEzC,KAAK,KAAK,sBAAsB,KAAK,4BACjB,KAAK,KAAK,eAAe,KAAK,mBAClD,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA;AAKvB,UAAM,KAAK,IAAI,mBAAmB,KAAK;AAEvC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,uBAAuB,KAAK;AAE3C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,kBAAkB,MAYH;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,cAAc,KAAK,+BACD,KAAK,kBAAkB,KAAK;AAAA;AAAA;AAKrD,UAAM,KAAK,IACR,mDAAmD,KAAK;AAG3D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AAGA,UAAM,KAAK,IAAI,sCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,qCAAqC,KAAK;AAG7C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,UAAM,KAAK,IAAI,8CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,sDAAsD,KAAK;AAG9D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0CAA0C,KAAK;AAGlD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAmC;AACrC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oDAAoD,KAAK;AAG5D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,aAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,WAA+B;AACjC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2CAA2C,KAAK;AAGnD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACxfA,OAAOC,aAAY;AAWZ,IAAM,SAAN,MAAa;AAAA,EAQlB,YAAY,MAiET;AApEH,0BAA0B;AAC1B,uBAAuB;AAoErB,SAAK,KAAK,SAASA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACnD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,kCACb,KAAK,KAAK,YAAY,KAAK,4BACP,KAAK,KAAK,MAAM,KAAK,cACzC,KAAK,KAAK,MAAM,MAAM,+BACC,KAAK,KAAK,QAAQ,KAAK,uBAC9C,KAAK,KAAK,UAAU,KAAK,kBACf,KAAK,KAAK,KAAK,KAAK,sBAC9B,KAAK,KAAK,SAAS,KAAK,2BACL,KAAK,KAAK,cAAc,KAAK,qBAChD,KAAK,KAAK,QAAQ,KAAK,wBACP,KAAK,KAAK,WAAW,KAAK;AAAA;AAAA;AAI5C,UAAM,KAAK,IAAI,kBAAkB,KAAK;AAEtC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,sBAAsB,KAAK;AAE1C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAeO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAGA,UAAM,KAAK,IAAI,qCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,mCAAmC,KAAK;AAG3C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAeG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAGA,UAAM,KAAK,IAAI,6CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,2CAA2C,KAAK;AAGnD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAeG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAGA,UAAM,KAAK,IAAI,+CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBAAsB,MAKX;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAGA,UAAM,KAAK,IAAI,2DACb,KAAK,gBAAgB,KAAK;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,qDAAqD,KAAK;AAG7D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,oDAAoD,KAAK;AAG5D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,MAUO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAGA,UAAM,KAAK,IAAI,yCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,+CACpB,KAAK,eAAe,KAAK,cACnB,KAAK,eAAe,MAAM;AAAA;AAAA;AAKlC,UAAM,KAAK,IACR,uCAAuC,KAAK;AAG/C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,MAeQ;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAGA,UAAM,KAAK,IAAI,uCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,qCAAqC,KAAK;AAG7C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,MAKL;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,+CAA+C,KAAK;AAGvD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAGA,UAAM,KAAK,IAAI,2CACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,0CAA0C,KAAK;AAGlD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,oBAAoB,MAKT;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAGA,UAAM,KAAK,IAAI,wDACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,mDAAmD,KAAK;AAG3D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAkB,MAKP;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,MAKO;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AAGA,UAAM,KAAK,IAAI,2CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,yCAAyC,KAAK;AAGjD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,wCAAwC,KAAK;AAG5D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,yCAAyC,KAAK;AAGjD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,wCAAwC,KAAK;AAG5D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,+CAA+C,KAAK;AAGvD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kDAAkD,KAAK;AAG1D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACnxBA,OAAOC,aAAY;AAeZ,IAAM,YAAN,MAAgB;AAAA,EAQrB,YAAY,MA6CT;AAhDH,0BAA0B;AAC1B,uBAAuB;AAgDrB,SAAK,KAAK,YAAYA,QAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACtD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,oCACb,KAAK,KAAK,WAAW,KAAK,6BACL,KAAK,KAAK,OAAO,KAAK,cAC3C,KAAK,KAAK,OAAO,MAAM,oCAEvB,KAAK,KAAK,aAAa,KAAK,2BAE5B,KAAK,KAAK,cAAc,KAAK,0BACX,KAAK,KAAK,aAAa,KAAK,qBAC9C,KAAK,KAAK,QAAQ,KAAK,uBACR,KAAK,KAAK,UAAU,KAAK;AAAA;AAAA;AAI1C,UAAM,KAAK,IAAI,qBAAqB,KAAK;AAEzC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,yBAAyB,KAAK;AAE7C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAGA,UAAM,KAAK,IAAI,wCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,yCAAyC,KAAK;AAGjD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAGA,UAAM,KAAK,IAAI,gDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,iDAAiD,KAAK;AAGzD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,0DAA0D,KAAK;AAGlE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,MAKO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAGA,UAAM,KAAK,IAAI,4CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,uDAAuD,KAAK;AAG/D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8CAA8C,KAAK;AAGtD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8CAA8C,KAAK;AAGtD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,qDAAqD,KAAK;AAG7D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wDAAwD,KAAK;AAGhE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;AC7ZA,OAAOC,cAAY;AAWZ,IAAM,kBAAN,MAAsB;AAAA,EAQ3B,YAAY,MAgGT;AAnGH,0BAA0B;AAC1B,uBAAuB;AAmGrB,SAAK,KAAK,kBAAkBA,SAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5D,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,2CACb,KAAK,KAAK,YAAY,KAAK,4BACP,KAAK,KAAK,MAAM,KAAK,cACzC,KAAK,KAAK,MAAM,MAAM,iCAEtB,KAAK,KAAK,UAAU,KAAK,yBACR,KAAK,KAAK,YAAY,KAAK,sBAC5C,KAAK,KAAK,SAAS,KAAK,6BAExB,KAAK,KAAK,gBAAgB,KAAK,2BACZ,KAAK,KAAK,cAAc,KAAK,kBAChD,KAAK,KAAK,KAAK,KAAK,iCAEpB,KAAK,KAAK,oBAAoB,KAAK,wBACnB,KAAK,KAAK,WAAW,KAAK,qBAC1C,KAAK,KAAK,QAAQ,KAAK,iCACE,KAAK,KAAK,oBAAoB,KAAK;AAAA;AAAA;AAI9D,UAAM,KAAK,IACR,2BAA2B,KAAK;AAEnC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,+BAA+B,KAAK;AAEnD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAeO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,UAAM,KAAK,IAAI,8CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,qDAAqD,KAAK;AAG7D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAeG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,6DAA6D,KAAK;AAGrE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAeG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAGA,UAAM,KAAK,IAAI,wDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,+DAA+D,KAAK;AAGvE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBAAsB,MAKX;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,oEACD,KAAK,gBAAgB,KAAK;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,4DACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,sEAAsE,KAAK;AAG9E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAeD;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,sDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,6DAA6D,KAAK;AAGrE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,MAUO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,+CACpB,KAAK,eAAe,KAAK,cACnB,KAAK,eAAe,MAAM;AAAA;AAAA;AAKlC,UAAM,KAAK,IACR,yDAAyD,KAAK;AAGjE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,MAeQ;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAGA,UAAM,KAAK,IAAI,gDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BACpB,KAAK,GAAG,KAAK,qCACgB,KAAK,eAAe,KAAK,cACtD,KAAK,eAAe,MAAM;AAAA;AAAA;AAM5B,UAAM,KAAK,IACR,uDAAuD,KAAK;AAG/D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,MAKL;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,6DACb,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,4DAA4D,KAAK;AAGpE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,wBAAwB,MAKb;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,qEACD,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,oBAAoB,MAKT;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,iEACD,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAkB,MAKP;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,+DACD,KAAK,eAAe,KAAK;AAAA;AAAA;AAM3B,UAAM,KAAK,IACR,mEAAmE,KAAK;AAG3E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,MAKO;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAuC;AACzC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,mEAAmE,KAAK;AAG3E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0DAA0D,KAAK;AAGlE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0DAA0D,KAAK;AAGlE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,oEAAoE,KAAK;AAG5E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACh8BA,OAAOC,cAAY;AAiBZ,IAAM,SAAN,MAAa;AAAA,EAQlB,YAAY,MA0FT;AA7FH,0BAA0B;AAC1B,uBAAuB;AA6FrB,SAAK,KAAK,SAASA,SAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACnD,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,mCACb,KAAK,KAAK,aAAa,KAAK,sBACd,KAAK,KAAK,SAAS,KAAK,qBACtC,KAAK,KAAK,QAAQ,KAAK,gBACf,KAAK,KAAK,GAAG,KAAK,4BAC1B,KAAK,KAAK,eAAe,KAAK,6BACT,KAAK,KAAK,gBAAgB,KAAK,kBACpD,KAAK,KAAK,KAAK,KAAK,iBACX,KAAK,KAAK,IAAI,KAAK,qCAC5B,KAAK,KAAK,wBAAwB,KAAK,+BAEvC,KAAK,KAAK,kBAAkB,KAAK,wBACjB,KAAK,KAAK,WAAW,KAAK,wBAC1C,KAAK,KAAK,WAAW,KAAK,qBACb,KAAK,KAAK,QAAQ,KAAK,qBACpC,KAAK,KAAK,QAAQ,KAAK;AAAA;AAAA;AAKzB,UAAM,KAAK,IAAI,kBAAkB,KAAK;AAEtC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,sBAAsB,KAAK;AAE1C,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAGA,UAAM,KAAK,IAAI,qCACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,mCAAmC,KAAK;AAG3C,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAGA,UAAM,KAAK,IAAI,6CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,2CAA2C,KAAK;AAGnD,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,oDAAoD,KAAK;AAG5D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IAAI,wCAAwC,KAAK;AAG5D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,gBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8CAA8C,KAAK;AAGtD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAA8B;AAChC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0CAA0C,KAAK;AAGlD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,kBAAoC;AACtC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,gDAAgD,KAAK;AAGxD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,eAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,6CAA6C,KAAK;AAGrD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,qBAAyC;AAC3C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,mDAAmD,KAAK;AAG3D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC3E;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,+CAA+C,KAAK;AAGvD,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kDAAkD,KAAK;AAG1D,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACrfA,OAAOC,cAAY;AAaZ,IAAM,uBAAN,MAA2B;AAAA,EAQhC,YAAY,MAoET;AAvEH,0BAA0B;AAC1B,uBAAuB;AAuErB,SAAK,KAAK,uBAAuBA,SAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACjE,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,gDACb,KAAK,KAAK,YAAY,KAAK,qBACd,KAAK,KAAK,QAAQ,KAAK,2BACpC,KAAK,KAAK,cAAc,KAAK,qBAChB,KAAK,KAAK,QAAQ,KAAK,yBACpC,KAAK,KAAK,YAAY,KAAK,yBACV,KAAK,KAAK,YAAY,KAAK,yBAC5C,KAAK,KAAK,YAAY,KAAK,4BACP,KAAK,KAAK,MAAM,KAAK,cACzC,KAAK,KAAK,MAAM,MAAM,+BAEtB,KAAK,KAAK,QAAQ,KAAK,2BACJ,KAAK,KAAK,cAAc,KAAK;AAAA;AAAA;AAIlD,UAAM,KAAK,IACR,gCAAgC,KAAK;AAExC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,oCAAoC,KAAK;AAExD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,+DAA+D,KAAK;AAGvE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAKG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,GAAG,KAAK;AAAA;AAAA;AAMf,UAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,iEACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,gFAAgF,KAAK;AAGxF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,MAKI;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,gDACb,KAAK,GAAG,KAAK;AAAA;AAAA;AAMf,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,MAUG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,GAAG,KAAK,4BACO,KAAK,MAAM,KAAK,cACpC,KAAK,MAAM,MAAM;AAAA;AAAA;AAMnB,UAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAA8B;AAChC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kEAAkE,KAAK;AAG1E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wEAAwE,KAAK;AAGhF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAqC;AACvC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8EAA8E,KAAK;AAGtF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACxhBA,OAAOC,cAAY;AAeZ,IAAM,qBAAN,MAAyB;AAAA,EAQ9B,YAAY,MA+FT;AAlGH,0BAA0B;AAC1B,uBAAuB;AAkGrB,SAAK,KAAK,qBAAqBA,SAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAC/D,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,8CACb,KAAK,KAAK,YAAY,KAAK,2BAE3B,KAAK,KAAK,cAAc,KAAK,2BAE7B,KAAK,KAAK,cAAc,KAAK,2BACV,KAAK,KAAK,cAAc,KAAK,qBAChD,KAAK,KAAK,QAAQ,KAAK,oBACX,KAAK,KAAK,OAAO,KAAK,uBAClC,KAAK,KAAK,UAAU,KAAK,0BACP,KAAK,KAAK,aAAa,KAAK,wBAC9C,KAAK,KAAK,WAAW,KAAK,4BACN,KAAK,KAAK,eAAe,KAAK,qBAClD,KAAK,KAAK,QAAQ,KAAK,oBACX,KAAK,KAAK,OAAO,KAAK,4BAClC,KAAK,KAAK,eAAe,KAAK,qBACjB,KAAK,KAAK,QAAQ,KAAK,sBACpC,KAAK,KAAK,SAAS,KAAK;AAAA;AAAA;AAK1B,UAAM,KAAK,IACR,8BAA8B,KAAK;AAEtC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,kCAAkC,KAAK;AAEtD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAGA,UAAM,KAAK,IAAI,iDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAUG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,yDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,mEAAmE,KAAK;AAG3E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,+DACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,4EAA4E,KAAK;AAGpF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,mBAAyC;AAC3C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,gEAAgE,KAAK;AAGxE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0EAA0E,KAAK;AAGlF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;;;ACvbA,OAAOC,cAAY;AAiBZ,IAAM,uBAAN,MAA2B;AAAA,EAQhC,YAAY,MA+CT;AAlDH,0BAA0B;AAC1B,uBAAuB;AAkDrB,SAAK,KAAK,uBAAuBA,SAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AACjE,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,gDACb,KAAK,KAAK,YAAY,KAAK,yBACV,KAAK,KAAK,YAAY,KAAK,yBAC5C,KAAK,KAAK,YAAY,KAAK,yBAE3B,KAAK,KAAK,YAAY,KAAK,4BACP,KAAK,KAAK,MAAM,KAAK,cACzC,KAAK,KAAK,MAAM,MAAM,+BAEtB,KAAK,KAAK,QAAQ,KAAK,2BACJ,KAAK,KAAK,cAAc,KAAK;AAAA;AAAA;AAIlD,UAAM,KAAK,IACR,gCAAgC,KAAK;AAExC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,oCAAoC,KAAK;AAExD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,0BAA6B,KAAK,GAAG,KAAK;AAAA;AAAA;AAKhE,UAAM,KAAK,IACR,+DAA+D,KAAK;AAGvE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,MAKG;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,kDACb,KAAK,GAAG,KAAK;AAAA;AAAA;AAMf,UAAM,KAAK,IACR,uEAAuE,KAAK;AAG/E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,qBAAqB,MAKV;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,iEACD,KAAK,SAAS,KAAK;AAAA;AAAA;AAMrB,UAAM,KAAK,IACR,gFAAgF,KAAK;AAGxF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,MAKI;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,gDACb,KAAK,GAAG,KAAK;AAAA;AAAA;AAMf,UAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,MAUG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,oDACb,KAAK,GAAG,KAAK,4BACO,KAAK,MAAM,KAAK,cACpC,KAAK,MAAM,MAAM;AAAA;AAAA;AAMnB,UAAM,KAAK,IACR,yEAAyE,KAAK;AAGjF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAA8B;AAChC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,kEAAkE,KAAK;AAG1E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAiC;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,qEAAqE,KAAK;AAG7E,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wEAAwE,KAAK;AAGhF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAqC;AACvC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2EAA2E,KAAK;AAGnF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8EAA8E,KAAK;AAGtF,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}