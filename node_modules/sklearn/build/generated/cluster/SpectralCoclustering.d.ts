import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Spectral Co-Clustering algorithm (Dhillon, 2001).

  Clusters rows and columns of an array `X` to solve the relaxed normalized cut of the bipartite graph created from `X` as follows: the edge between row vertex `i` and column vertex `j` has weight `X\[i, j\]`.

  The resulting bicluster structure is block-diagonal, since each row and each column belongs to exactly one bicluster.

  Supports sparse matrices, as long as they are nonnegative.

  Read more in the [User Guide](../biclustering.html#spectral-coclustering).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralCoclustering.html)
 */
export declare class SpectralCoclustering {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          The number of biclusters to find.
    
          @defaultValue `3`
         */
        n_clusters?: number;
        /**
          Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, use [`sklearn.utils.extmath.randomized\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd "sklearn.utils.extmath.randomized_svd"), which may be faster for large matrices. If ‘arpack’, use [`scipy.sparse.linalg.svds`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.svds.html#scipy.sparse.linalg.svds "(in SciPy v1.11.3)"), which is more accurate, but possibly slower in some cases.
    
          @defaultValue `'randomized'`
         */
        svd_method?: 'randomized' | 'arpack';
        /**
          Number of vectors to use in calculating the SVD. Corresponds to `ncv` when `svd\_method=arpack` and `n\_oversamples` when `svd\_method` is ‘randomized\`.
         */
        n_svd_vecs?: number;
        /**
          Whether to use mini-batch k-means, which is faster but may get different results.
    
          @defaultValue `false`
         */
        mini_batch?: boolean;
        /**
          Method for initialization of k-means algorithm; defaults to ‘k-means++’.
    
          @defaultValue `'k-means++'`
         */
        init?: NDArray[];
        /**
          Number of random initializations that are tried with the k-means algorithm.
    
          If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen.
    
          @defaultValue `10`
         */
        n_init?: number;
        /**
          Used for randomizing the singular value decomposition and the k-means initialization. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Create a biclustering for X.
     */
    fit(opts: {
        /**
          Training data.
         */
        X?: ArrayLike[];
        /**
          Not used, present for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Row and column indices of the `i`’th bicluster.
  
      Only works if `rows\_` and `columns\_` attributes exist.
     */
    get_indices(opts: {
        /**
          The index of the cluster.
         */
        i?: number;
    }): Promise<NDArray>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Shape of the `i`’th bicluster.
     */
    get_shape(opts: {
        /**
          The index of the cluster.
         */
        i?: number;
    }): Promise<number>;
    /**
      Return the submatrix corresponding to bicluster `i`.
     */
    get_submatrix(opts: {
        /**
          The index of the cluster.
         */
        i?: number;
        /**
          The data.
         */
        data?: ArrayLike[];
    }): Promise<NDArray[]>;
    /**
      Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
     */
    get rows_(): Promise<ArrayLike[]>;
    /**
      Results of the clustering, like `rows`.
     */
    get columns_(): Promise<ArrayLike[]>;
    /**
      The bicluster label of each row.
     */
    get row_labels_(): Promise<ArrayLike>;
    /**
      The bicluster label of each column.
     */
    get column_labels_(): Promise<ArrayLike>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=SpectralCoclustering.d.ts.map