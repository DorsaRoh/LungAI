// src/generated/calibration/CalibratedClassifierCV.ts
import crypto from "node:crypto";
var CalibratedClassifierCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CalibratedClassifierCV${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "CalibratedClassifierCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.calibration import CalibratedClassifierCV
try: bridgeCalibratedClassifierCV
except NameError: bridgeCalibratedClassifierCV = {}
`;
    await this._py.ex`ctor_CalibratedClassifierCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'ensemble': ${this.opts["ensemble"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_CalibratedClassifierCV = {k: v for k, v in ctor_CalibratedClassifierCV.items() if v is not None}`;
    await this._py.ex`bridgeCalibratedClassifierCV[${this.id}] = CalibratedClassifierCV(**ctor_CalibratedClassifierCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCalibratedClassifierCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the calibrated model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibratedClassifierCV must call init() before fit()");
    }
    await this._py.ex`pms_CalibratedClassifierCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_CalibratedClassifierCV_fit = {k: v for k, v in pms_CalibratedClassifierCV_fit.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_fit = bridgeCalibratedClassifierCV[${this.id}].fit(**pms_CalibratedClassifierCV_fit)`;
    return this._py`res_CalibratedClassifierCV_fit.tolist() if hasattr(res_CalibratedClassifierCV_fit, 'tolist') else res_CalibratedClassifierCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CalibratedClassifierCV_get_metadata_routing = {k: v for k, v in pms_CalibratedClassifierCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_get_metadata_routing = bridgeCalibratedClassifierCV[${this.id}].get_metadata_routing(**pms_CalibratedClassifierCV_get_metadata_routing)`;
    return this._py`res_CalibratedClassifierCV_get_metadata_routing.tolist() if hasattr(res_CalibratedClassifierCV_get_metadata_routing, 'tolist') else res_CalibratedClassifierCV_get_metadata_routing`;
  }
  /**
      Predict the target of new samples.
  
      The predicted class is the class that has the highest probability, and can thus be different from the prediction of the uncalibrated classifier.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before predict()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CalibratedClassifierCV_predict = {k: v for k, v in pms_CalibratedClassifierCV_predict.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_predict = bridgeCalibratedClassifierCV[${this.id}].predict(**pms_CalibratedClassifierCV_predict)`;
    return this._py`res_CalibratedClassifierCV_predict.tolist() if hasattr(res_CalibratedClassifierCV_predict, 'tolist') else res_CalibratedClassifierCV_predict`;
  }
  /**
      Calibrated probabilities of classification.
  
      This function returns calibrated probabilities of classification according to each class on an array of test vectors X.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CalibratedClassifierCV_predict_proba = {k: v for k, v in pms_CalibratedClassifierCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_predict_proba = bridgeCalibratedClassifierCV[${this.id}].predict_proba(**pms_CalibratedClassifierCV_predict_proba)`;
    return this._py`res_CalibratedClassifierCV_predict_proba.tolist() if hasattr(res_CalibratedClassifierCV_predict_proba, 'tolist') else res_CalibratedClassifierCV_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibratedClassifierCV must call init() before score()");
    }
    await this._py.ex`pms_CalibratedClassifierCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CalibratedClassifierCV_score = {k: v for k, v in pms_CalibratedClassifierCV_score.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_score = bridgeCalibratedClassifierCV[${this.id}].score(**pms_CalibratedClassifierCV_score)`;
    return this._py`res_CalibratedClassifierCV_score.tolist() if hasattr(res_CalibratedClassifierCV_score, 'tolist') else res_CalibratedClassifierCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CalibratedClassifierCV_set_fit_request = {k: v for k, v in pms_CalibratedClassifierCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_set_fit_request = bridgeCalibratedClassifierCV[${this.id}].set_fit_request(**pms_CalibratedClassifierCV_set_fit_request)`;
    return this._py`res_CalibratedClassifierCV_set_fit_request.tolist() if hasattr(res_CalibratedClassifierCV_set_fit_request, 'tolist') else res_CalibratedClassifierCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CalibratedClassifierCV_set_score_request = {k: v for k, v in pms_CalibratedClassifierCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_set_score_request = bridgeCalibratedClassifierCV[${this.id}].set_score_request(**pms_CalibratedClassifierCV_set_score_request)`;
    return this._py`res_CalibratedClassifierCV_set_score_request.tolist() if hasattr(res_CalibratedClassifierCV_set_score_request, 'tolist') else res_CalibratedClassifierCV_set_score_request`;
  }
  /**
    The class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_classes_ = bridgeCalibratedClassifierCV[${this.id}].classes_`;
      return this._py`attr_CalibratedClassifierCV_classes_.tolist() if hasattr(attr_CalibratedClassifierCV_classes_, 'tolist') else attr_CalibratedClassifierCV_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_n_features_in_ = bridgeCalibratedClassifierCV[${this.id}].n_features_in_`;
      return this._py`attr_CalibratedClassifierCV_n_features_in_.tolist() if hasattr(attr_CalibratedClassifierCV_n_features_in_, 'tolist') else attr_CalibratedClassifierCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_feature_names_in_ = bridgeCalibratedClassifierCV[${this.id}].feature_names_in_`;
      return this._py`attr_CalibratedClassifierCV_feature_names_in_.tolist() if hasattr(attr_CalibratedClassifierCV_feature_names_in_, 'tolist') else attr_CalibratedClassifierCV_feature_names_in_`;
    })();
  }
  /**
    The list of classifier and calibrator pairs.
   */
  get calibrated_classifiers_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing calibrated_classifiers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_calibrated_classifiers_ = bridgeCalibratedClassifierCV[${this.id}].calibrated_classifiers_`;
      return this._py`attr_CalibratedClassifierCV_calibrated_classifiers_.tolist() if hasattr(attr_CalibratedClassifierCV_calibrated_classifiers_, 'tolist') else attr_CalibratedClassifierCV_calibrated_classifiers_`;
    })();
  }
};

// src/generated/calibration/CalibrationDisplay.ts
import crypto2 from "node:crypto";
var CalibrationDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CalibrationDisplay${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "CalibrationDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.calibration import CalibrationDisplay
try: bridgeCalibrationDisplay
except NameError: bridgeCalibrationDisplay = {}
`;
    await this._py.ex`ctor_CalibrationDisplay = {'prob_true': np.array(${this.opts["prob_true"] ?? void 0}) if ${this.opts["prob_true"] !== void 0} else None, 'prob_pred': np.array(${this.opts["prob_pred"] ?? void 0}) if ${this.opts["prob_pred"] !== void 0} else None, 'y_prob': np.array(${this.opts["y_prob"] ?? void 0}) if ${this.opts["y_prob"] !== void 0} else None, 'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}}

ctor_CalibrationDisplay = {k: v for k, v in ctor_CalibrationDisplay.items() if v is not None}`;
    await this._py.ex`bridgeCalibrationDisplay[${this.id}] = CalibrationDisplay(**ctor_CalibrationDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCalibrationDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot calibration curve using a binary classifier and data.
  
      A calibration curve, also known as a reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.8.1)").
  
      Read more about calibration in the [User Guide](../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](../../visualizations.html#visualizations).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_CalibrationDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'n_bins': ${opts["n_bins"] ?? void 0}, 'strategy': ${opts["strategy"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_from_estimator = {k: v for k, v in pms_CalibrationDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_from_estimator = bridgeCalibrationDisplay[${this.id}].from_estimator(**pms_CalibrationDisplay_from_estimator)`;
    return this._py`res_CalibrationDisplay_from_estimator.tolist() if hasattr(res_CalibrationDisplay_from_estimator, 'tolist') else res_CalibrationDisplay_from_estimator`;
  }
  /**
      Plot calibration curve using true labels and predicted probabilities.
  
      Calibration curve, also known as reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.8.1)").
  
      Read more about calibration in the [User Guide](../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](../../visualizations.html#visualizations).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_CalibrationDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_prob': np.array(${opts["y_prob"] ?? void 0}) if ${opts["y_prob"] !== void 0} else None, 'n_bins': ${opts["n_bins"] ?? void 0}, 'strategy': ${opts["strategy"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_from_predictions = {k: v for k, v in pms_CalibrationDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_from_predictions = bridgeCalibrationDisplay[${this.id}].from_predictions(**pms_CalibrationDisplay_from_predictions)`;
    return this._py`res_CalibrationDisplay_from_predictions.tolist() if hasattr(res_CalibrationDisplay_from_predictions, 'tolist') else res_CalibrationDisplay_from_predictions`;
  }
  /**
      Plot visualization.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.8.1)").
     */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibrationDisplay must call init() before plot()");
    }
    await this._py.ex`pms_CalibrationDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_plot = {k: v for k, v in pms_CalibrationDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_plot = bridgeCalibrationDisplay[${this.id}].plot(**pms_CalibrationDisplay_plot)`;
    return this._py`res_CalibrationDisplay_plot.tolist() if hasattr(res_CalibrationDisplay_plot, 'tolist') else res_CalibrationDisplay_plot`;
  }
  /**
    Calibration curve.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing line_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_line_ = bridgeCalibrationDisplay[${this.id}].line_`;
      return this._py`attr_CalibrationDisplay_line_.tolist() if hasattr(attr_CalibrationDisplay_line_, 'tolist') else attr_CalibrationDisplay_line_`;
    })();
  }
  /**
    Axes with calibration curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_ax_ = bridgeCalibrationDisplay[${this.id}].ax_`;
      return this._py`attr_CalibrationDisplay_ax_.tolist() if hasattr(attr_CalibrationDisplay_ax_, 'tolist') else attr_CalibrationDisplay_ax_`;
    })();
  }
  /**
    Figure containing the curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_figure_ = bridgeCalibrationDisplay[${this.id}].figure_`;
      return this._py`attr_CalibrationDisplay_figure_.tolist() if hasattr(attr_CalibrationDisplay_figure_, 'tolist') else attr_CalibrationDisplay_figure_`;
    })();
  }
};

// src/generated/cluster/AffinityPropagation.ts
import crypto3 from "node:crypto";
var AffinityPropagation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AffinityPropagation${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AffinityPropagation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AffinityPropagation
try: bridgeAffinityPropagation
except NameError: bridgeAffinityPropagation = {}
`;
    await this._py.ex`ctor_AffinityPropagation = {'damping': ${this.opts["damping"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'convergence_iter': ${this.opts["convergence_iter"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'preference': np.array(${this.opts["preference"] ?? void 0}) if ${this.opts["preference"] !== void 0} else None, 'affinity': ${this.opts["affinity"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_AffinityPropagation = {k: v for k, v in ctor_AffinityPropagation.items() if v is not None}`;
    await this._py.ex`bridgeAffinityPropagation[${this.id}] = AffinityPropagation(**ctor_AffinityPropagation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAffinityPropagation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before fit()");
    }
    await this._py.ex`pms_AffinityPropagation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit = {k: v for k, v in pms_AffinityPropagation_fit.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit = bridgeAffinityPropagation[${this.id}].fit(**pms_AffinityPropagation_fit)`;
    return this._py`res_AffinityPropagation_fit.tolist() if hasattr(res_AffinityPropagation_fit, 'tolist') else res_AffinityPropagation_fit`;
  }
  /**
    Fit clustering from features/affinity matrix; return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit_predict = {k: v for k, v in pms_AffinityPropagation_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit_predict = bridgeAffinityPropagation[${this.id}].fit_predict(**pms_AffinityPropagation_fit_predict)`;
    return this._py`res_AffinityPropagation_fit_predict.tolist() if hasattr(res_AffinityPropagation_fit_predict, 'tolist') else res_AffinityPropagation_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AffinityPropagation_get_metadata_routing = {k: v for k, v in pms_AffinityPropagation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_get_metadata_routing = bridgeAffinityPropagation[${this.id}].get_metadata_routing(**pms_AffinityPropagation_get_metadata_routing)`;
    return this._py`res_AffinityPropagation_get_metadata_routing.tolist() if hasattr(res_AffinityPropagation_get_metadata_routing, 'tolist') else res_AffinityPropagation_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before predict()");
    }
    await this._py.ex`pms_AffinityPropagation_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AffinityPropagation_predict = {k: v for k, v in pms_AffinityPropagation_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_predict = bridgeAffinityPropagation[${this.id}].predict(**pms_AffinityPropagation_predict)`;
    return this._py`res_AffinityPropagation_predict.tolist() if hasattr(res_AffinityPropagation_predict, 'tolist') else res_AffinityPropagation_predict`;
  }
  /**
    Indices of cluster centers.
   */
  get cluster_centers_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_indices_ = bridgeAffinityPropagation[${this.id}].cluster_centers_indices_`;
      return this._py`attr_AffinityPropagation_cluster_centers_indices_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_indices_, 'tolist') else attr_AffinityPropagation_cluster_centers_indices_`;
    })();
  }
  /**
    Cluster centers (if affinity != `precomputed`).
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_ = bridgeAffinityPropagation[${this.id}].cluster_centers_`;
      return this._py`attr_AffinityPropagation_cluster_centers_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_, 'tolist') else attr_AffinityPropagation_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_labels_ = bridgeAffinityPropagation[${this.id}].labels_`;
      return this._py`attr_AffinityPropagation_labels_.tolist() if hasattr(attr_AffinityPropagation_labels_, 'tolist') else attr_AffinityPropagation_labels_`;
    })();
  }
  /**
    Stores the affinity matrix used in `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_affinity_matrix_ = bridgeAffinityPropagation[${this.id}].affinity_matrix_`;
      return this._py`attr_AffinityPropagation_affinity_matrix_.tolist() if hasattr(attr_AffinityPropagation_affinity_matrix_, 'tolist') else attr_AffinityPropagation_affinity_matrix_`;
    })();
  }
  /**
    Number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_iter_ = bridgeAffinityPropagation[${this.id}].n_iter_`;
      return this._py`attr_AffinityPropagation_n_iter_.tolist() if hasattr(attr_AffinityPropagation_n_iter_, 'tolist') else attr_AffinityPropagation_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_features_in_ = bridgeAffinityPropagation[${this.id}].n_features_in_`;
      return this._py`attr_AffinityPropagation_n_features_in_.tolist() if hasattr(attr_AffinityPropagation_n_features_in_, 'tolist') else attr_AffinityPropagation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_feature_names_in_ = bridgeAffinityPropagation[${this.id}].feature_names_in_`;
      return this._py`attr_AffinityPropagation_feature_names_in_.tolist() if hasattr(attr_AffinityPropagation_feature_names_in_, 'tolist') else attr_AffinityPropagation_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/AgglomerativeClustering.ts
import crypto4 from "node:crypto";
var AgglomerativeClustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AgglomerativeClustering${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AgglomerativeClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AgglomerativeClustering
try: bridgeAgglomerativeClustering
except NameError: bridgeAgglomerativeClustering = {}
`;
    await this._py.ex`ctor_AgglomerativeClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_AgglomerativeClustering = {k: v for k, v in ctor_AgglomerativeClustering.items() if v is not None}`;
    await this._py.ex`bridgeAgglomerativeClustering[${this.id}] = AgglomerativeClustering(**ctor_AgglomerativeClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAgglomerativeClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AgglomerativeClustering must call init() before fit()");
    }
    await this._py.ex`pms_AgglomerativeClustering_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit = {k: v for k, v in pms_AgglomerativeClustering_fit.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit = bridgeAgglomerativeClustering[${this.id}].fit(**pms_AgglomerativeClustering_fit)`;
    return this._py`res_AgglomerativeClustering_fit.tolist() if hasattr(res_AgglomerativeClustering_fit, 'tolist') else res_AgglomerativeClustering_fit`;
  }
  /**
      Fit and return the result of each sampleâ€™s clustering assignment.
  
      In addition to fitting, this method also return the result of the clustering assignment for each sample in the training set.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit_predict = {k: v for k, v in pms_AgglomerativeClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit_predict = bridgeAgglomerativeClustering[${this.id}].fit_predict(**pms_AgglomerativeClustering_fit_predict)`;
    return this._py`res_AgglomerativeClustering_fit_predict.tolist() if hasattr(res_AgglomerativeClustering_fit_predict, 'tolist') else res_AgglomerativeClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AgglomerativeClustering_get_metadata_routing = {k: v for k, v in pms_AgglomerativeClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_get_metadata_routing = bridgeAgglomerativeClustering[${this.id}].get_metadata_routing(**pms_AgglomerativeClustering_get_metadata_routing)`;
    return this._py`res_AgglomerativeClustering_get_metadata_routing.tolist() if hasattr(res_AgglomerativeClustering_get_metadata_routing, 'tolist') else res_AgglomerativeClustering_get_metadata_routing`;
  }
  /**
    The number of clusters found by the algorithm. If `distance\_threshold=None`, it will be equal to the given `n\_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_clusters_ = bridgeAgglomerativeClustering[${this.id}].n_clusters_`;
      return this._py`attr_AgglomerativeClustering_n_clusters_.tolist() if hasattr(attr_AgglomerativeClustering_n_clusters_, 'tolist') else attr_AgglomerativeClustering_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_labels_ = bridgeAgglomerativeClustering[${this.id}].labels_`;
      return this._py`attr_AgglomerativeClustering_labels_.tolist() if hasattr(attr_AgglomerativeClustering_labels_, 'tolist') else attr_AgglomerativeClustering_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_leaves_ = bridgeAgglomerativeClustering[${this.id}].n_leaves_`;
      return this._py`attr_AgglomerativeClustering_n_leaves_.tolist() if hasattr(attr_AgglomerativeClustering_n_leaves_, 'tolist') else attr_AgglomerativeClustering_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_connected_components_ = bridgeAgglomerativeClustering[${this.id}].n_connected_components_`;
      return this._py`attr_AgglomerativeClustering_n_connected_components_.tolist() if hasattr(attr_AgglomerativeClustering_n_connected_components_, 'tolist') else attr_AgglomerativeClustering_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_features_in_ = bridgeAgglomerativeClustering[${this.id}].n_features_in_`;
      return this._py`attr_AgglomerativeClustering_n_features_in_.tolist() if hasattr(attr_AgglomerativeClustering_n_features_in_, 'tolist') else attr_AgglomerativeClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_feature_names_in_ = bridgeAgglomerativeClustering[${this.id}].feature_names_in_`;
      return this._py`attr_AgglomerativeClustering_feature_names_in_.tolist() if hasattr(attr_AgglomerativeClustering_feature_names_in_, 'tolist') else attr_AgglomerativeClustering_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n\_samples` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\_samples` is a non-leaf node and has children `children\_\[i \- n\_samples\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n\_samples + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_children_ = bridgeAgglomerativeClustering[${this.id}].children_`;
      return this._py`attr_AgglomerativeClustering_children_.tolist() if hasattr(attr_AgglomerativeClustering_children_, 'tolist') else attr_AgglomerativeClustering_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children\_`. Only computed if `distance\_threshold` is used or `compute\_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_distances_ = bridgeAgglomerativeClustering[${this.id}].distances_`;
      return this._py`attr_AgglomerativeClustering_distances_.tolist() if hasattr(attr_AgglomerativeClustering_distances_, 'tolist') else attr_AgglomerativeClustering_distances_`;
    })();
  }
};

// src/generated/cluster/Birch.ts
import crypto5 from "node:crypto";
var Birch = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Birch${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Birch.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import Birch
try: bridgeBirch
except NameError: bridgeBirch = {}
`;
    await this._py.ex`ctor_Birch = {'threshold': ${this.opts["threshold"] ?? void 0}, 'branching_factor': ${this.opts["branching_factor"] ?? void 0}, 'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Birch = {k: v for k, v in ctor_Birch.items() if v is not None}`;
    await this._py.ex`bridgeBirch[${this.id}] = Birch(**ctor_Birch)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBirch[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a CF Tree for the input data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit()");
    }
    await this._py.ex`pms_Birch_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_fit = {k: v for k, v in pms_Birch_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_fit = bridgeBirch[${this.id}].fit(**pms_Birch_fit)`;
    return this._py`res_Birch_fit.tolist() if hasattr(res_Birch_fit, 'tolist') else res_Birch_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_predict()");
    }
    await this._py.ex`pms_Birch_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_fit_predict = {k: v for k, v in pms_Birch_fit_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_predict = bridgeBirch[${this.id}].fit_predict(**pms_Birch_fit_predict)`;
    return this._py`res_Birch_fit_predict.tolist() if hasattr(res_Birch_fit_predict, 'tolist') else res_Birch_fit_predict`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_transform()");
    }
    await this._py.ex`pms_Birch_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Birch_fit_transform = {k: v for k, v in pms_Birch_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_transform = bridgeBirch[${this.id}].fit_transform(**pms_Birch_fit_transform)`;
    return this._py`res_Birch_fit_transform.tolist() if hasattr(res_Birch_fit_transform, 'tolist') else res_Birch_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_Birch_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Birch_get_feature_names_out = {k: v for k, v in pms_Birch_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Birch_get_feature_names_out = bridgeBirch[${this.id}].get_feature_names_out(**pms_Birch_get_feature_names_out)`;
    return this._py`res_Birch_get_feature_names_out.tolist() if hasattr(res_Birch_get_feature_names_out, 'tolist') else res_Birch_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Birch_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Birch_get_metadata_routing = {k: v for k, v in pms_Birch_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Birch_get_metadata_routing = bridgeBirch[${this.id}].get_metadata_routing(**pms_Birch_get_metadata_routing)`;
    return this._py`res_Birch_get_metadata_routing.tolist() if hasattr(res_Birch_get_metadata_routing, 'tolist') else res_Birch_get_metadata_routing`;
  }
  /**
    Online learning. Prevents rebuilding of CFTree from scratch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before partial_fit()");
    }
    await this._py.ex`pms_Birch_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_partial_fit = {k: v for k, v in pms_Birch_partial_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_partial_fit = bridgeBirch[${this.id}].partial_fit(**pms_Birch_partial_fit)`;
    return this._py`res_Birch_partial_fit.tolist() if hasattr(res_Birch_partial_fit, 'tolist') else res_Birch_partial_fit`;
  }
  /**
      Predict data using the `centroids\_` of subclusters.
  
      Avoid computation of the row norms of X.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before predict()");
    }
    await this._py.ex`pms_Birch_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_predict = {k: v for k, v in pms_Birch_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_predict = bridgeBirch[${this.id}].predict(**pms_Birch_predict)`;
    return this._py`res_Birch_predict.tolist() if hasattr(res_Birch_predict, 'tolist') else res_Birch_predict`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before set_output()");
    }
    await this._py.ex`pms_Birch_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Birch_set_output = {k: v for k, v in pms_Birch_set_output.items() if v is not None}`;
    await this._py.ex`res_Birch_set_output = bridgeBirch[${this.id}].set_output(**pms_Birch_set_output)`;
    return this._py`res_Birch_set_output.tolist() if hasattr(res_Birch_set_output, 'tolist') else res_Birch_set_output`;
  }
  /**
      Transform X into subcluster centroids dimension.
  
      Each dimension represents the distance from the sample point to each cluster centroid.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before transform()");
    }
    await this._py.ex`pms_Birch_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_transform = {k: v for k, v in pms_Birch_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_transform = bridgeBirch[${this.id}].transform(**pms_Birch_transform)`;
    return this._py`res_Birch_transform.tolist() if hasattr(res_Birch_transform, 'tolist') else res_Birch_transform`;
  }
  /**
    Root of the CFTree.
   */
  get root_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing root_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_root_ = bridgeBirch[${this.id}].root_`;
      return this._py`attr_Birch_root_.tolist() if hasattr(attr_Birch_root_, 'tolist') else attr_Birch_root_`;
    })();
  }
  /**
    Start pointer to all the leaves.
   */
  get dummy_leaf_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing dummy_leaf_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_dummy_leaf_ = bridgeBirch[${this.id}].dummy_leaf_`;
      return this._py`attr_Birch_dummy_leaf_.tolist() if hasattr(attr_Birch_dummy_leaf_, 'tolist') else attr_Birch_dummy_leaf_`;
    })();
  }
  /**
    Centroids of all subclusters read directly from the leaves.
   */
  get subcluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_centers_ = bridgeBirch[${this.id}].subcluster_centers_`;
      return this._py`attr_Birch_subcluster_centers_.tolist() if hasattr(attr_Birch_subcluster_centers_, 'tolist') else attr_Birch_subcluster_centers_`;
    })();
  }
  /**
    Labels assigned to the centroids of the subclusters after they are clustered globally.
   */
  get subcluster_labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_labels_ = bridgeBirch[${this.id}].subcluster_labels_`;
      return this._py`attr_Birch_subcluster_labels_.tolist() if hasattr(attr_Birch_subcluster_labels_, 'tolist') else attr_Birch_subcluster_labels_`;
    })();
  }
  /**
    Array of labels assigned to the input data. if partial\_fit is used instead of fit, they are assigned to the last batch of data.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_labels_ = bridgeBirch[${this.id}].labels_`;
      return this._py`attr_Birch_labels_.tolist() if hasattr(attr_Birch_labels_, 'tolist') else attr_Birch_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_n_features_in_ = bridgeBirch[${this.id}].n_features_in_`;
      return this._py`attr_Birch_n_features_in_.tolist() if hasattr(attr_Birch_n_features_in_, 'tolist') else attr_Birch_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_feature_names_in_ = bridgeBirch[${this.id}].feature_names_in_`;
      return this._py`attr_Birch_feature_names_in_.tolist() if hasattr(attr_Birch_feature_names_in_, 'tolist') else attr_Birch_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/BisectingKMeans.ts
import crypto6 from "node:crypto";
var BisectingKMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BisectingKMeans${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BisectingKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import BisectingKMeans
try: bridgeBisectingKMeans
except NameError: bridgeBisectingKMeans = {}
`;
    await this._py.ex`ctor_BisectingKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'bisecting_strategy': ${this.opts["bisecting_strategy"] ?? void 0}}

ctor_BisectingKMeans = {k: v for k, v in ctor_BisectingKMeans.items() if v is not None}`;
    await this._py.ex`bridgeBisectingKMeans[${this.id}] = BisectingKMeans(**ctor_BisectingKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBisectingKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute bisecting k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit()");
    }
    await this._py.ex`pms_BisectingKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit = {k: v for k, v in pms_BisectingKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit = bridgeBisectingKMeans[${this.id}].fit(**pms_BisectingKMeans_fit)`;
    return this._py`res_BisectingKMeans_fit.tolist() if hasattr(res_BisectingKMeans_fit, 'tolist') else res_BisectingKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_predict = {k: v for k, v in pms_BisectingKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_predict = bridgeBisectingKMeans[${this.id}].fit_predict(**pms_BisectingKMeans_fit_predict)`;
    return this._py`res_BisectingKMeans_fit_predict.tolist() if hasattr(res_BisectingKMeans_fit_predict, 'tolist') else res_BisectingKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_transform = {k: v for k, v in pms_BisectingKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_transform = bridgeBisectingKMeans[${this.id}].fit_transform(**pms_BisectingKMeans_fit_transform)`;
    return this._py`res_BisectingKMeans_fit_transform.tolist() if hasattr(res_BisectingKMeans_fit_transform, 'tolist') else res_BisectingKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_BisectingKMeans_get_feature_names_out = {k: v for k, v in pms_BisectingKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_feature_names_out = bridgeBisectingKMeans[${this.id}].get_feature_names_out(**pms_BisectingKMeans_get_feature_names_out)`;
    return this._py`res_BisectingKMeans_get_feature_names_out.tolist() if hasattr(res_BisectingKMeans_get_feature_names_out, 'tolist') else res_BisectingKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BisectingKMeans_get_metadata_routing = {k: v for k, v in pms_BisectingKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_metadata_routing = bridgeBisectingKMeans[${this.id}].get_metadata_routing(**pms_BisectingKMeans_get_metadata_routing)`;
    return this._py`res_BisectingKMeans_get_metadata_routing.tolist() if hasattr(res_BisectingKMeans_get_metadata_routing, 'tolist') else res_BisectingKMeans_get_metadata_routing`;
  }
  /**
      Predict which cluster each sample in X belongs to.
  
      Prediction is made by going down the hierarchical tree in searching of closest leaf cluster.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before predict()");
    }
    await this._py.ex`pms_BisectingKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_predict = {k: v for k, v in pms_BisectingKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_predict = bridgeBisectingKMeans[${this.id}].predict(**pms_BisectingKMeans_predict)`;
    return this._py`res_BisectingKMeans_predict.tolist() if hasattr(res_BisectingKMeans_predict, 'tolist') else res_BisectingKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before score()");
    }
    await this._py.ex`pms_BisectingKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_score = {k: v for k, v in pms_BisectingKMeans_score.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_score = bridgeBisectingKMeans[${this.id}].score(**pms_BisectingKMeans_score)`;
    return this._py`res_BisectingKMeans_score.tolist() if hasattr(res_BisectingKMeans_score, 'tolist') else res_BisectingKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_fit_request = {k: v for k, v in pms_BisectingKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_fit_request = bridgeBisectingKMeans[${this.id}].set_fit_request(**pms_BisectingKMeans_set_fit_request)`;
    return this._py`res_BisectingKMeans_set_fit_request.tolist() if hasattr(res_BisectingKMeans_set_fit_request, 'tolist') else res_BisectingKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_BisectingKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_BisectingKMeans_set_output = {k: v for k, v in pms_BisectingKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_output = bridgeBisectingKMeans[${this.id}].set_output(**pms_BisectingKMeans_set_output)`;
    return this._py`res_BisectingKMeans_set_output.tolist() if hasattr(res_BisectingKMeans_set_output, 'tolist') else res_BisectingKMeans_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_predict_request = {k: v for k, v in pms_BisectingKMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_predict_request = bridgeBisectingKMeans[${this.id}].set_predict_request(**pms_BisectingKMeans_set_predict_request)`;
    return this._py`res_BisectingKMeans_set_predict_request.tolist() if hasattr(res_BisectingKMeans_set_predict_request, 'tolist') else res_BisectingKMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_score_request = {k: v for k, v in pms_BisectingKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_score_request = bridgeBisectingKMeans[${this.id}].set_score_request(**pms_BisectingKMeans_set_score_request)`;
    return this._py`res_BisectingKMeans_set_score_request.tolist() if hasattr(res_BisectingKMeans_set_score_request, 'tolist') else res_BisectingKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before transform()");
    }
    await this._py.ex`pms_BisectingKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_transform = {k: v for k, v in pms_BisectingKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_transform = bridgeBisectingKMeans[${this.id}].transform(**pms_BisectingKMeans_transform)`;
    return this._py`res_BisectingKMeans_transform.tolist() if hasattr(res_BisectingKMeans_transform, 'tolist') else res_BisectingKMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\_iter`), these will not be consistent with `labels\_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_cluster_centers_ = bridgeBisectingKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_BisectingKMeans_cluster_centers_.tolist() if hasattr(attr_BisectingKMeans_cluster_centers_, 'tolist') else attr_BisectingKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_labels_ = bridgeBisectingKMeans[${this.id}].labels_`;
      return this._py`attr_BisectingKMeans_labels_.tolist() if hasattr(attr_BisectingKMeans_labels_, 'tolist') else attr_BisectingKMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_inertia_ = bridgeBisectingKMeans[${this.id}].inertia_`;
      return this._py`attr_BisectingKMeans_inertia_.tolist() if hasattr(attr_BisectingKMeans_inertia_, 'tolist') else attr_BisectingKMeans_inertia_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_n_features_in_ = bridgeBisectingKMeans[${this.id}].n_features_in_`;
      return this._py`attr_BisectingKMeans_n_features_in_.tolist() if hasattr(attr_BisectingKMeans_n_features_in_, 'tolist') else attr_BisectingKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_feature_names_in_ = bridgeBisectingKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_BisectingKMeans_feature_names_in_.tolist() if hasattr(attr_BisectingKMeans_feature_names_in_, 'tolist') else attr_BisectingKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/DBSCAN.ts
import crypto7 from "node:crypto";
var DBSCAN = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DBSCAN${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import DBSCAN
try: bridgeDBSCAN
except NameError: bridgeDBSCAN = {}
`;
    await this._py.ex`ctor_DBSCAN = {'eps': ${this.opts["eps"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_DBSCAN = {k: v for k, v in ctor_DBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeDBSCAN[${this.id}] = DBSCAN(**ctor_DBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform DBSCAN clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_DBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit = {k: v for k, v in pms_DBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit = bridgeDBSCAN[${this.id}].fit(**pms_DBSCAN_fit)`;
    return this._py`res_DBSCAN_fit.tolist() if hasattr(res_DBSCAN_fit, 'tolist') else res_DBSCAN_fit`;
  }
  /**
    Compute clusters from a data or distance matrix and predict labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_DBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit_predict = {k: v for k, v in pms_DBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit_predict = bridgeDBSCAN[${this.id}].fit_predict(**pms_DBSCAN_fit_predict)`;
    return this._py`res_DBSCAN_fit_predict.tolist() if hasattr(res_DBSCAN_fit_predict, 'tolist') else res_DBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_DBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DBSCAN_get_metadata_routing = {k: v for k, v in pms_DBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_get_metadata_routing = bridgeDBSCAN[${this.id}].get_metadata_routing(**pms_DBSCAN_get_metadata_routing)`;
    return this._py`res_DBSCAN_get_metadata_routing.tolist() if hasattr(res_DBSCAN_get_metadata_routing, 'tolist') else res_DBSCAN_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before set_fit_request()");
    }
    await this._py.ex`pms_DBSCAN_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DBSCAN_set_fit_request = {k: v for k, v in pms_DBSCAN_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_set_fit_request = bridgeDBSCAN[${this.id}].set_fit_request(**pms_DBSCAN_set_fit_request)`;
    return this._py`res_DBSCAN_set_fit_request.tolist() if hasattr(res_DBSCAN_set_fit_request, 'tolist') else res_DBSCAN_set_fit_request`;
  }
  /**
    Indices of core samples.
   */
  get core_sample_indices_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing core_sample_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_core_sample_indices_ = bridgeDBSCAN[${this.id}].core_sample_indices_`;
      return this._py`attr_DBSCAN_core_sample_indices_.tolist() if hasattr(attr_DBSCAN_core_sample_indices_, 'tolist') else attr_DBSCAN_core_sample_indices_`;
    })();
  }
  /**
    Copy of each core sample found by training.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_components_ = bridgeDBSCAN[${this.id}].components_`;
      return this._py`attr_DBSCAN_components_.tolist() if hasattr(attr_DBSCAN_components_, 'tolist') else attr_DBSCAN_components_`;
    })();
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples are given the label -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_labels_ = bridgeDBSCAN[${this.id}].labels_`;
      return this._py`attr_DBSCAN_labels_.tolist() if hasattr(attr_DBSCAN_labels_, 'tolist') else attr_DBSCAN_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_n_features_in_ = bridgeDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_DBSCAN_n_features_in_.tolist() if hasattr(attr_DBSCAN_n_features_in_, 'tolist') else attr_DBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_feature_names_in_ = bridgeDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_DBSCAN_feature_names_in_.tolist() if hasattr(attr_DBSCAN_feature_names_in_, 'tolist') else attr_DBSCAN_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/FeatureAgglomeration.ts
import crypto8 from "node:crypto";
var FeatureAgglomeration = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FeatureAgglomeration${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "FeatureAgglomeration.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import FeatureAgglomeration
try: bridgeFeatureAgglomeration
except NameError: bridgeFeatureAgglomeration = {}
`;
    await this._py.ex`ctor_FeatureAgglomeration = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'pooling_func': ${this.opts["pooling_func"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_FeatureAgglomeration = {k: v for k, v in ctor_FeatureAgglomeration.items() if v is not None}`;
    await this._py.ex`bridgeFeatureAgglomeration[${this.id}] = FeatureAgglomeration(**ctor_FeatureAgglomeration)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFeatureAgglomeration[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering on the data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FeatureAgglomeration must call init() before fit()");
    }
    await this._py.ex`pms_FeatureAgglomeration_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FeatureAgglomeration_fit = {k: v for k, v in pms_FeatureAgglomeration_fit.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit = bridgeFeatureAgglomeration[${this.id}].fit(**pms_FeatureAgglomeration_fit)`;
    return this._py`res_FeatureAgglomeration_fit.tolist() if hasattr(res_FeatureAgglomeration_fit, 'tolist') else res_FeatureAgglomeration_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureAgglomeration_fit_transform = {k: v for k, v in pms_FeatureAgglomeration_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit_transform = bridgeFeatureAgglomeration[${this.id}].fit_transform(**pms_FeatureAgglomeration_fit_transform)`;
    return this._py`res_FeatureAgglomeration_fit_transform.tolist() if hasattr(res_FeatureAgglomeration_fit_transform, 'tolist') else res_FeatureAgglomeration_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FeatureAgglomeration_get_feature_names_out = {k: v for k, v in pms_FeatureAgglomeration_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_feature_names_out = bridgeFeatureAgglomeration[${this.id}].get_feature_names_out(**pms_FeatureAgglomeration_get_feature_names_out)`;
    return this._py`res_FeatureAgglomeration_get_feature_names_out.tolist() if hasattr(res_FeatureAgglomeration_get_feature_names_out, 'tolist') else res_FeatureAgglomeration_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FeatureAgglomeration_get_metadata_routing = {k: v for k, v in pms_FeatureAgglomeration_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_metadata_routing = bridgeFeatureAgglomeration[${this.id}].get_metadata_routing(**pms_FeatureAgglomeration_get_metadata_routing)`;
    return this._py`res_FeatureAgglomeration_get_metadata_routing.tolist() if hasattr(res_FeatureAgglomeration_get_metadata_routing, 'tolist') else res_FeatureAgglomeration_get_metadata_routing`;
  }
  /**
    Inverse the transformation and return a vector of size `n\_features`.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'Xred': ${opts["Xred"] ?? void 0}}

pms_FeatureAgglomeration_inverse_transform = {k: v for k, v in pms_FeatureAgglomeration_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_inverse_transform = bridgeFeatureAgglomeration[${this.id}].inverse_transform(**pms_FeatureAgglomeration_inverse_transform)`;
    return this._py`res_FeatureAgglomeration_inverse_transform.tolist() if hasattr(res_FeatureAgglomeration_inverse_transform, 'tolist') else res_FeatureAgglomeration_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before set_output()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FeatureAgglomeration_set_output = {k: v for k, v in pms_FeatureAgglomeration_set_output.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_set_output = bridgeFeatureAgglomeration[${this.id}].set_output(**pms_FeatureAgglomeration_set_output)`;
    return this._py`res_FeatureAgglomeration_set_output.tolist() if hasattr(res_FeatureAgglomeration_set_output, 'tolist') else res_FeatureAgglomeration_set_output`;
  }
  /**
    Transform a new matrix using the built clustering.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FeatureAgglomeration_transform = {k: v for k, v in pms_FeatureAgglomeration_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_transform = bridgeFeatureAgglomeration[${this.id}].transform(**pms_FeatureAgglomeration_transform)`;
    return this._py`res_FeatureAgglomeration_transform.tolist() if hasattr(res_FeatureAgglomeration_transform, 'tolist') else res_FeatureAgglomeration_transform`;
  }
  /**
    The number of clusters found by the algorithm. If `distance\_threshold=None`, it will be equal to the given `n\_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_clusters_ = bridgeFeatureAgglomeration[${this.id}].n_clusters_`;
      return this._py`attr_FeatureAgglomeration_n_clusters_.tolist() if hasattr(attr_FeatureAgglomeration_n_clusters_, 'tolist') else attr_FeatureAgglomeration_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each feature.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_labels_ = bridgeFeatureAgglomeration[${this.id}].labels_`;
      return this._py`attr_FeatureAgglomeration_labels_.tolist() if hasattr(attr_FeatureAgglomeration_labels_, 'tolist') else attr_FeatureAgglomeration_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_leaves_ = bridgeFeatureAgglomeration[${this.id}].n_leaves_`;
      return this._py`attr_FeatureAgglomeration_n_leaves_.tolist() if hasattr(attr_FeatureAgglomeration_n_leaves_, 'tolist') else attr_FeatureAgglomeration_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_connected_components_ = bridgeFeatureAgglomeration[${this.id}].n_connected_components_`;
      return this._py`attr_FeatureAgglomeration_n_connected_components_.tolist() if hasattr(attr_FeatureAgglomeration_n_connected_components_, 'tolist') else attr_FeatureAgglomeration_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_features_in_ = bridgeFeatureAgglomeration[${this.id}].n_features_in_`;
      return this._py`attr_FeatureAgglomeration_n_features_in_.tolist() if hasattr(attr_FeatureAgglomeration_n_features_in_, 'tolist') else attr_FeatureAgglomeration_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_feature_names_in_ = bridgeFeatureAgglomeration[${this.id}].feature_names_in_`;
      return this._py`attr_FeatureAgglomeration_feature_names_in_.tolist() if hasattr(attr_FeatureAgglomeration_feature_names_in_, 'tolist') else attr_FeatureAgglomeration_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n\_features` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n\_features` is a non-leaf node and has children `children\_\[i \- n\_features\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n\_features + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_children_ = bridgeFeatureAgglomeration[${this.id}].children_`;
      return this._py`attr_FeatureAgglomeration_children_.tolist() if hasattr(attr_FeatureAgglomeration_children_, 'tolist') else attr_FeatureAgglomeration_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children\_`. Only computed if `distance\_threshold` is used or `compute\_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_distances_ = bridgeFeatureAgglomeration[${this.id}].distances_`;
      return this._py`attr_FeatureAgglomeration_distances_.tolist() if hasattr(attr_FeatureAgglomeration_distances_, 'tolist') else attr_FeatureAgglomeration_distances_`;
    })();
  }
};

// src/generated/cluster/HDBSCAN.ts
import crypto9 from "node:crypto";
var HDBSCAN = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HDBSCAN${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HDBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import HDBSCAN
try: bridgeHDBSCAN
except NameError: bridgeHDBSCAN = {}
`;
    await this._py.ex`ctor_HDBSCAN = {'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'cluster_selection_epsilon': ${this.opts["cluster_selection_epsilon"] ?? void 0}, 'max_cluster_size': ${this.opts["max_cluster_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'cluster_selection_method': ${this.opts["cluster_selection_method"] ?? void 0}, 'allow_single_cluster': ${this.opts["allow_single_cluster"] ?? void 0}, 'store_centers': ${this.opts["store_centers"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_HDBSCAN = {k: v for k, v in ctor_HDBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeHDBSCAN[${this.id}] = HDBSCAN(**ctor_HDBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return clustering given by DBSCAN without border points.
  
      Return clustering that would be equivalent to running DBSCAN\* for a particular cut\_distance (or epsilon) DBSCAN\* can be thought of as DBSCAN without the border points. As such these results may differ slightly from `cluster.DBSCAN` due to the difference in implementation over the non-core points.
  
      This can also be thought of as a flat clustering derived from constant height cut through the single linkage tree.
  
      This represents the result of selecting a cut value for robust single linkage clustering. The `min\_cluster\_size` allows the flat clustering to declare noise points (and cluster smaller than `min\_cluster\_size`).
     */
  async dbscan_clustering(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before dbscan_clustering()");
    }
    await this._py.ex`pms_HDBSCAN_dbscan_clustering = {'cut_distance': ${opts["cut_distance"] ?? void 0}, 'min_cluster_size': ${opts["min_cluster_size"] ?? void 0}}

pms_HDBSCAN_dbscan_clustering = {k: v for k, v in pms_HDBSCAN_dbscan_clustering.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_dbscan_clustering = bridgeHDBSCAN[${this.id}].dbscan_clustering(**pms_HDBSCAN_dbscan_clustering)`;
    return this._py`res_HDBSCAN_dbscan_clustering.tolist() if hasattr(res_HDBSCAN_dbscan_clustering, 'tolist') else res_HDBSCAN_dbscan_clustering`;
  }
  /**
    Find clusters based on hierarchical density-based clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_HDBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit = {k: v for k, v in pms_HDBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit = bridgeHDBSCAN[${this.id}].fit(**pms_HDBSCAN_fit)`;
    return this._py`res_HDBSCAN_fit.tolist() if hasattr(res_HDBSCAN_fit, 'tolist') else res_HDBSCAN_fit`;
  }
  /**
    Cluster X and return the associated cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_HDBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit_predict = {k: v for k, v in pms_HDBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit_predict = bridgeHDBSCAN[${this.id}].fit_predict(**pms_HDBSCAN_fit_predict)`;
    return this._py`res_HDBSCAN_fit_predict.tolist() if hasattr(res_HDBSCAN_fit_predict, 'tolist') else res_HDBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_HDBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HDBSCAN_get_metadata_routing = {k: v for k, v in pms_HDBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_get_metadata_routing = bridgeHDBSCAN[${this.id}].get_metadata_routing(**pms_HDBSCAN_get_metadata_routing)`;
    return this._py`res_HDBSCAN_get_metadata_routing.tolist() if hasattr(res_HDBSCAN_get_metadata_routing, 'tolist') else res_HDBSCAN_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to [fit](../../glossary.html#term-fit). Outliers are labeled as follows:
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_labels_ = bridgeHDBSCAN[${this.id}].labels_`;
      return this._py`attr_HDBSCAN_labels_.tolist() if hasattr(attr_HDBSCAN_labels_, 'tolist') else attr_HDBSCAN_labels_`;
    })();
  }
  /**
    The strength with which each sample is a member of its assigned cluster.
   */
  get probabilities_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing probabilities_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_probabilities_ = bridgeHDBSCAN[${this.id}].probabilities_`;
      return this._py`attr_HDBSCAN_probabilities_.tolist() if hasattr(attr_HDBSCAN_probabilities_, 'tolist') else attr_HDBSCAN_probabilities_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_n_features_in_ = bridgeHDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_HDBSCAN_n_features_in_.tolist() if hasattr(attr_HDBSCAN_n_features_in_, 'tolist') else attr_HDBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_feature_names_in_ = bridgeHDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_HDBSCAN_feature_names_in_.tolist() if hasattr(attr_HDBSCAN_feature_names_in_, 'tolist') else attr_HDBSCAN_feature_names_in_`;
    })();
  }
  /**
      A collection containing the centroid of each cluster calculated under the standard euclidean metric. The centroids may fall â€œoutsideâ€ their respective clusters if the clusters themselves are non-convex.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing centroids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_centroids_ = bridgeHDBSCAN[${this.id}].centroids_`;
      return this._py`attr_HDBSCAN_centroids_.tolist() if hasattr(attr_HDBSCAN_centroids_, 'tolist') else attr_HDBSCAN_centroids_`;
    })();
  }
  /**
      A collection containing the medoid of each cluster calculated under the whichever metric was passed to the `metric` parameter. The medoids are points in the original cluster which minimize the average distance to all other points in that cluster under the chosen metric. These can be thought of as the result of projecting the `metric`\-based centroid back onto the cluster.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get medoids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing medoids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_medoids_ = bridgeHDBSCAN[${this.id}].medoids_`;
      return this._py`attr_HDBSCAN_medoids_.tolist() if hasattr(attr_HDBSCAN_medoids_, 'tolist') else attr_HDBSCAN_medoids_`;
    })();
  }
};

// src/generated/cluster/KMeans.ts
import crypto10 from "node:crypto";
var KMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KMeans${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import KMeans
try: bridgeKMeans
except NameError: bridgeKMeans = {}
`;
    await this._py.ex`ctor_KMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}}

ctor_KMeans = {k: v for k, v in ctor_KMeans.items() if v is not None}`;
    await this._py.ex`bridgeKMeans[${this.id}] = KMeans(**ctor_KMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit()");
    }
    await this._py.ex`pms_KMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit = {k: v for k, v in pms_KMeans_fit.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit = bridgeKMeans[${this.id}].fit(**pms_KMeans_fit)`;
    return this._py`res_KMeans_fit.tolist() if hasattr(res_KMeans_fit, 'tolist') else res_KMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_KMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_predict = {k: v for k, v in pms_KMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_predict = bridgeKMeans[${this.id}].fit_predict(**pms_KMeans_fit_predict)`;
    return this._py`res_KMeans_fit_predict.tolist() if hasattr(res_KMeans_fit_predict, 'tolist') else res_KMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_KMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_transform = {k: v for k, v in pms_KMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_transform = bridgeKMeans[${this.id}].fit_transform(**pms_KMeans_fit_transform)`;
    return this._py`res_KMeans_fit_transform.tolist() if hasattr(res_KMeans_fit_transform, 'tolist') else res_KMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_KMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KMeans_get_feature_names_out = {k: v for k, v in pms_KMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_feature_names_out = bridgeKMeans[${this.id}].get_feature_names_out(**pms_KMeans_get_feature_names_out)`;
    return this._py`res_KMeans_get_feature_names_out.tolist() if hasattr(res_KMeans_get_feature_names_out, 'tolist') else res_KMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_KMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KMeans_get_metadata_routing = {k: v for k, v in pms_KMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_metadata_routing = bridgeKMeans[${this.id}].get_metadata_routing(**pms_KMeans_get_metadata_routing)`;
    return this._py`res_KMeans_get_metadata_routing.tolist() if hasattr(res_KMeans_get_metadata_routing, 'tolist') else res_KMeans_get_metadata_routing`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before predict()");
    }
    await this._py.ex`pms_KMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_predict = {k: v for k, v in pms_KMeans_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_predict = bridgeKMeans[${this.id}].predict(**pms_KMeans_predict)`;
    return this._py`res_KMeans_predict.tolist() if hasattr(res_KMeans_predict, 'tolist') else res_KMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before score()");
    }
    await this._py.ex`pms_KMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_score = {k: v for k, v in pms_KMeans_score.items() if v is not None}`;
    await this._py.ex`res_KMeans_score = bridgeKMeans[${this.id}].score(**pms_KMeans_score)`;
    return this._py`res_KMeans_score.tolist() if hasattr(res_KMeans_score, 'tolist') else res_KMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_fit_request = {k: v for k, v in pms_KMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_fit_request = bridgeKMeans[${this.id}].set_fit_request(**pms_KMeans_set_fit_request)`;
    return this._py`res_KMeans_set_fit_request.tolist() if hasattr(res_KMeans_set_fit_request, 'tolist') else res_KMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_output()");
    }
    await this._py.ex`pms_KMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KMeans_set_output = {k: v for k, v in pms_KMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_output = bridgeKMeans[${this.id}].set_output(**pms_KMeans_set_output)`;
    return this._py`res_KMeans_set_output.tolist() if hasattr(res_KMeans_set_output, 'tolist') else res_KMeans_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_predict_request()");
    }
    await this._py.ex`pms_KMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_predict_request = {k: v for k, v in pms_KMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_predict_request = bridgeKMeans[${this.id}].set_predict_request(**pms_KMeans_set_predict_request)`;
    return this._py`res_KMeans_set_predict_request.tolist() if hasattr(res_KMeans_set_predict_request, 'tolist') else res_KMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_score_request()");
    }
    await this._py.ex`pms_KMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_score_request = {k: v for k, v in pms_KMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_score_request = bridgeKMeans[${this.id}].set_score_request(**pms_KMeans_set_score_request)`;
    return this._py`res_KMeans_set_score_request.tolist() if hasattr(res_KMeans_set_score_request, 'tolist') else res_KMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before transform()");
    }
    await this._py.ex`pms_KMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KMeans_transform = {k: v for k, v in pms_KMeans_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_transform = bridgeKMeans[${this.id}].transform(**pms_KMeans_transform)`;
    return this._py`res_KMeans_transform.tolist() if hasattr(res_KMeans_transform, 'tolist') else res_KMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max\_iter`), these will not be consistent with `labels\_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_cluster_centers_ = bridgeKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_KMeans_cluster_centers_.tolist() if hasattr(attr_KMeans_cluster_centers_, 'tolist') else attr_KMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_labels_ = bridgeKMeans[${this.id}].labels_`;
      return this._py`attr_KMeans_labels_.tolist() if hasattr(attr_KMeans_labels_, 'tolist') else attr_KMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing inertia_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_inertia_ = bridgeKMeans[${this.id}].inertia_`;
      return this._py`attr_KMeans_inertia_.tolist() if hasattr(attr_KMeans_inertia_, 'tolist') else attr_KMeans_inertia_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_iter_ = bridgeKMeans[${this.id}].n_iter_`;
      return this._py`attr_KMeans_n_iter_.tolist() if hasattr(attr_KMeans_n_iter_, 'tolist') else attr_KMeans_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_features_in_ = bridgeKMeans[${this.id}].n_features_in_`;
      return this._py`attr_KMeans_n_features_in_.tolist() if hasattr(attr_KMeans_n_features_in_, 'tolist') else attr_KMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_feature_names_in_ = bridgeKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_KMeans_feature_names_in_.tolist() if hasattr(attr_KMeans_feature_names_in_, 'tolist') else attr_KMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MeanShift.ts
import crypto11 from "node:crypto";
var MeanShift = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MeanShift${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MeanShift.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MeanShift
try: bridgeMeanShift
except NameError: bridgeMeanShift = {}
`;
    await this._py.ex`ctor_MeanShift = {'bandwidth': ${this.opts["bandwidth"] ?? void 0}, 'seeds': np.array(${this.opts["seeds"] ?? void 0}) if ${this.opts["seeds"] !== void 0} else None, 'bin_seeding': ${this.opts["bin_seeding"] ?? void 0}, 'min_bin_freq': ${this.opts["min_bin_freq"] ?? void 0}, 'cluster_all': ${this.opts["cluster_all"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_MeanShift = {k: v for k, v in ctor_MeanShift.items() if v is not None}`;
    await this._py.ex`bridgeMeanShift[${this.id}] = MeanShift(**ctor_MeanShift)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMeanShift[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit()");
    }
    await this._py.ex`pms_MeanShift_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MeanShift_fit = {k: v for k, v in pms_MeanShift_fit.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit = bridgeMeanShift[${this.id}].fit(**pms_MeanShift_fit)`;
    return this._py`res_MeanShift_fit.tolist() if hasattr(res_MeanShift_fit, 'tolist') else res_MeanShift_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit_predict()");
    }
    await this._py.ex`pms_MeanShift_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MeanShift_fit_predict = {k: v for k, v in pms_MeanShift_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit_predict = bridgeMeanShift[${this.id}].fit_predict(**pms_MeanShift_fit_predict)`;
    return this._py`res_MeanShift_fit_predict.tolist() if hasattr(res_MeanShift_fit_predict, 'tolist') else res_MeanShift_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MeanShift_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MeanShift_get_metadata_routing = {k: v for k, v in pms_MeanShift_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MeanShift_get_metadata_routing = bridgeMeanShift[${this.id}].get_metadata_routing(**pms_MeanShift_get_metadata_routing)`;
    return this._py`res_MeanShift_get_metadata_routing.tolist() if hasattr(res_MeanShift_get_metadata_routing, 'tolist') else res_MeanShift_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before predict()");
    }
    await this._py.ex`pms_MeanShift_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MeanShift_predict = {k: v for k, v in pms_MeanShift_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_predict = bridgeMeanShift[${this.id}].predict(**pms_MeanShift_predict)`;
    return this._py`res_MeanShift_predict.tolist() if hasattr(res_MeanShift_predict, 'tolist') else res_MeanShift_predict`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_cluster_centers_ = bridgeMeanShift[${this.id}].cluster_centers_`;
      return this._py`attr_MeanShift_cluster_centers_.tolist() if hasattr(attr_MeanShift_cluster_centers_, 'tolist') else attr_MeanShift_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_labels_ = bridgeMeanShift[${this.id}].labels_`;
      return this._py`attr_MeanShift_labels_.tolist() if hasattr(attr_MeanShift_labels_, 'tolist') else attr_MeanShift_labels_`;
    })();
  }
  /**
    Maximum number of iterations performed on each seed.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_iter_ = bridgeMeanShift[${this.id}].n_iter_`;
      return this._py`attr_MeanShift_n_iter_.tolist() if hasattr(attr_MeanShift_n_iter_, 'tolist') else attr_MeanShift_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_features_in_ = bridgeMeanShift[${this.id}].n_features_in_`;
      return this._py`attr_MeanShift_n_features_in_.tolist() if hasattr(attr_MeanShift_n_features_in_, 'tolist') else attr_MeanShift_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_feature_names_in_ = bridgeMeanShift[${this.id}].feature_names_in_`;
      return this._py`attr_MeanShift_feature_names_in_.tolist() if hasattr(attr_MeanShift_feature_names_in_, 'tolist') else attr_MeanShift_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MiniBatchKMeans.ts
import crypto12 from "node:crypto";
var MiniBatchKMeans = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchKMeans${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MiniBatchKMeans
try: bridgeMiniBatchKMeans
except NameError: bridgeMiniBatchKMeans = {}
`;
    await this._py.ex`ctor_MiniBatchKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'init_size': ${this.opts["init_size"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'reassignment_ratio': ${this.opts["reassignment_ratio"] ?? void 0}}

ctor_MiniBatchKMeans = {k: v for k, v in ctor_MiniBatchKMeans.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchKMeans[${this.id}] = MiniBatchKMeans(**ctor_MiniBatchKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the centroids on X by chunking it into mini-batches.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit = {k: v for k, v in pms_MiniBatchKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit = bridgeMiniBatchKMeans[${this.id}].fit(**pms_MiniBatchKMeans_fit)`;
    return this._py`res_MiniBatchKMeans_fit.tolist() if hasattr(res_MiniBatchKMeans_fit, 'tolist') else res_MiniBatchKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_predict = {k: v for k, v in pms_MiniBatchKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_predict = bridgeMiniBatchKMeans[${this.id}].fit_predict(**pms_MiniBatchKMeans_fit_predict)`;
    return this._py`res_MiniBatchKMeans_fit_predict.tolist() if hasattr(res_MiniBatchKMeans_fit_predict, 'tolist') else res_MiniBatchKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_transform = {k: v for k, v in pms_MiniBatchKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_transform = bridgeMiniBatchKMeans[${this.id}].fit_transform(**pms_MiniBatchKMeans_fit_transform)`;
    return this._py`res_MiniBatchKMeans_fit_transform.tolist() if hasattr(res_MiniBatchKMeans_fit_transform, 'tolist') else res_MiniBatchKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchKMeans_get_feature_names_out = {k: v for k, v in pms_MiniBatchKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_feature_names_out = bridgeMiniBatchKMeans[${this.id}].get_feature_names_out(**pms_MiniBatchKMeans_get_feature_names_out)`;
    return this._py`res_MiniBatchKMeans_get_feature_names_out.tolist() if hasattr(res_MiniBatchKMeans_get_feature_names_out, 'tolist') else res_MiniBatchKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchKMeans_get_metadata_routing = {k: v for k, v in pms_MiniBatchKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_metadata_routing = bridgeMiniBatchKMeans[${this.id}].get_metadata_routing(**pms_MiniBatchKMeans_get_metadata_routing)`;
    return this._py`res_MiniBatchKMeans_get_metadata_routing.tolist() if hasattr(res_MiniBatchKMeans_get_metadata_routing, 'tolist') else res_MiniBatchKMeans_get_metadata_routing`;
  }
  /**
    Update k means estimate on a single mini-batch X.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_partial_fit = {k: v for k, v in pms_MiniBatchKMeans_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_partial_fit = bridgeMiniBatchKMeans[${this.id}].partial_fit(**pms_MiniBatchKMeans_partial_fit)`;
    return this._py`res_MiniBatchKMeans_partial_fit.tolist() if hasattr(res_MiniBatchKMeans_partial_fit, 'tolist') else res_MiniBatchKMeans_partial_fit`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster\_centers\_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_predict = {k: v for k, v in pms_MiniBatchKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_predict = bridgeMiniBatchKMeans[${this.id}].predict(**pms_MiniBatchKMeans_predict)`;
    return this._py`res_MiniBatchKMeans_predict.tolist() if hasattr(res_MiniBatchKMeans_predict, 'tolist') else res_MiniBatchKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before score()");
    }
    await this._py.ex`pms_MiniBatchKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_score = {k: v for k, v in pms_MiniBatchKMeans_score.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_score = bridgeMiniBatchKMeans[${this.id}].score(**pms_MiniBatchKMeans_score)`;
    return this._py`res_MiniBatchKMeans_score.tolist() if hasattr(res_MiniBatchKMeans_score, 'tolist') else res_MiniBatchKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_fit_request = bridgeMiniBatchKMeans[${this.id}].set_fit_request(**pms_MiniBatchKMeans_set_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_fit_request, 'tolist') else res_MiniBatchKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchKMeans_set_output = {k: v for k, v in pms_MiniBatchKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_output = bridgeMiniBatchKMeans[${this.id}].set_output(**pms_MiniBatchKMeans_set_output)`;
    return this._py`res_MiniBatchKMeans_set_output.tolist() if hasattr(res_MiniBatchKMeans_set_output, 'tolist') else res_MiniBatchKMeans_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_partial_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_partial_fit_request = bridgeMiniBatchKMeans[${this.id}].set_partial_fit_request(**pms_MiniBatchKMeans_set_partial_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_partial_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_partial_fit_request, 'tolist') else res_MiniBatchKMeans_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_predict_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_predict_request = {k: v for k, v in pms_MiniBatchKMeans_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_predict_request = bridgeMiniBatchKMeans[${this.id}].set_predict_request(**pms_MiniBatchKMeans_set_predict_request)`;
    return this._py`res_MiniBatchKMeans_set_predict_request.tolist() if hasattr(res_MiniBatchKMeans_set_predict_request, 'tolist') else res_MiniBatchKMeans_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_score_request = {k: v for k, v in pms_MiniBatchKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_score_request = bridgeMiniBatchKMeans[${this.id}].set_score_request(**pms_MiniBatchKMeans_set_score_request)`;
    return this._py`res_MiniBatchKMeans_set_score_request.tolist() if hasattr(res_MiniBatchKMeans_set_score_request, 'tolist') else res_MiniBatchKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchKMeans_transform = {k: v for k, v in pms_MiniBatchKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_transform = bridgeMiniBatchKMeans[${this.id}].transform(**pms_MiniBatchKMeans_transform)`;
    return this._py`res_MiniBatchKMeans_transform.tolist() if hasattr(res_MiniBatchKMeans_transform, 'tolist') else res_MiniBatchKMeans_transform`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_cluster_centers_ = bridgeMiniBatchKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_MiniBatchKMeans_cluster_centers_.tolist() if hasattr(attr_MiniBatchKMeans_cluster_centers_, 'tolist') else attr_MiniBatchKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point (if compute\_labels is set to `true`).
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_labels_ = bridgeMiniBatchKMeans[${this.id}].labels_`;
      return this._py`attr_MiniBatchKMeans_labels_.tolist() if hasattr(attr_MiniBatchKMeans_labels_, 'tolist') else attr_MiniBatchKMeans_labels_`;
    })();
  }
  /**
    The value of the inertia criterion associated with the chosen partition if compute\_labels is set to `true`. If compute\_labels is set to `false`, itâ€™s an approximation of the inertia based on an exponentially weighted average of the batch inertiae. The inertia is defined as the sum of square distances of samples to their cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_inertia_ = bridgeMiniBatchKMeans[${this.id}].inertia_`;
      return this._py`attr_MiniBatchKMeans_inertia_.tolist() if hasattr(attr_MiniBatchKMeans_inertia_, 'tolist') else attr_MiniBatchKMeans_inertia_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_iter_ = bridgeMiniBatchKMeans[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchKMeans_n_iter_.tolist() if hasattr(attr_MiniBatchKMeans_n_iter_, 'tolist') else attr_MiniBatchKMeans_n_iter_`;
    })();
  }
  /**
    Number of minibatches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_steps_ = bridgeMiniBatchKMeans[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchKMeans_n_steps_.tolist() if hasattr(attr_MiniBatchKMeans_n_steps_, 'tolist') else attr_MiniBatchKMeans_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_features_in_ = bridgeMiniBatchKMeans[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchKMeans_n_features_in_.tolist() if hasattr(attr_MiniBatchKMeans_n_features_in_, 'tolist') else attr_MiniBatchKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_feature_names_in_ = bridgeMiniBatchKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchKMeans_feature_names_in_.tolist() if hasattr(attr_MiniBatchKMeans_feature_names_in_, 'tolist') else attr_MiniBatchKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/OPTICS.ts
import crypto13 from "node:crypto";
var OPTICS = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OPTICS${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OPTICS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import OPTICS
try: bridgeOPTICS
except NameError: bridgeOPTICS = {}
`;
    await this._py.ex`ctor_OPTICS = {'min_samples': ${this.opts["min_samples"] ?? void 0}, 'max_eps': ${this.opts["max_eps"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'cluster_method': ${this.opts["cluster_method"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'xi': ${this.opts["xi"] ?? void 0}, 'predecessor_correction': ${this.opts["predecessor_correction"] ?? void 0}, 'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OPTICS = {k: v for k, v in ctor_OPTICS.items() if v is not None}`;
    await this._py.ex`bridgeOPTICS[${this.id}] = OPTICS(**ctor_OPTICS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOPTICS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Perform OPTICS clustering.
  
      Extracts an ordered list of points and reachability distances, and performs initial clustering using `max\_eps` distance specified at OPTICS object instantiation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit()");
    }
    await this._py.ex`pms_OPTICS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OPTICS_fit = {k: v for k, v in pms_OPTICS_fit.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit = bridgeOPTICS[${this.id}].fit(**pms_OPTICS_fit)`;
    return this._py`res_OPTICS_fit.tolist() if hasattr(res_OPTICS_fit, 'tolist') else res_OPTICS_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit_predict()");
    }
    await this._py.ex`pms_OPTICS_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OPTICS_fit_predict = {k: v for k, v in pms_OPTICS_fit_predict.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit_predict = bridgeOPTICS[${this.id}].fit_predict(**pms_OPTICS_fit_predict)`;
    return this._py`res_OPTICS_fit_predict.tolist() if hasattr(res_OPTICS_fit_predict, 'tolist') else res_OPTICS_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_OPTICS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OPTICS_get_metadata_routing = {k: v for k, v in pms_OPTICS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OPTICS_get_metadata_routing = bridgeOPTICS[${this.id}].get_metadata_routing(**pms_OPTICS_get_metadata_routing)`;
    return this._py`res_OPTICS_get_metadata_routing.tolist() if hasattr(res_OPTICS_get_metadata_routing, 'tolist') else res_OPTICS_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples and points which are not included in a leaf cluster of `cluster\_hierarchy\_` are labeled as -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_labels_ = bridgeOPTICS[${this.id}].labels_`;
      return this._py`attr_OPTICS_labels_.tolist() if hasattr(attr_OPTICS_labels_, 'tolist') else attr_OPTICS_labels_`;
    })();
  }
  /**
    Reachability distances per sample, indexed by object order. Use `clust.reachability\_\[clust.ordering\_\]` to access in cluster order.
   */
  get reachability_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing reachability_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_reachability_ = bridgeOPTICS[${this.id}].reachability_`;
      return this._py`attr_OPTICS_reachability_.tolist() if hasattr(attr_OPTICS_reachability_, 'tolist') else attr_OPTICS_reachability_`;
    })();
  }
  /**
    The cluster ordered list of sample indices.
   */
  get ordering_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing ordering_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_ordering_ = bridgeOPTICS[${this.id}].ordering_`;
      return this._py`attr_OPTICS_ordering_.tolist() if hasattr(attr_OPTICS_ordering_, 'tolist') else attr_OPTICS_ordering_`;
    })();
  }
  /**
    Distance at which each sample becomes a core point, indexed by object order. Points which will never be core have a distance of inf. Use `clust.core\_distances\_\[clust.ordering\_\]` to access in cluster order.
   */
  get core_distances_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing core_distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_core_distances_ = bridgeOPTICS[${this.id}].core_distances_`;
      return this._py`attr_OPTICS_core_distances_.tolist() if hasattr(attr_OPTICS_core_distances_, 'tolist') else attr_OPTICS_core_distances_`;
    })();
  }
  /**
    Point that a sample was reached from, indexed by object order. Seed points have a predecessor of -1.
   */
  get predecessor_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing predecessor_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_predecessor_ = bridgeOPTICS[${this.id}].predecessor_`;
      return this._py`attr_OPTICS_predecessor_.tolist() if hasattr(attr_OPTICS_predecessor_, 'tolist') else attr_OPTICS_predecessor_`;
    })();
  }
  /**
    The list of clusters in the form of `\[start, end\]` in each row, with all indices inclusive. The clusters are ordered according to `(end, \-start)` (ascending) so that larger clusters encompassing smaller clusters come after those smaller ones. Since `labels\_` does not reflect the hierarchy, usually `len(cluster\_hierarchy\_) > np.unique(optics.labels\_)`. Please also note that these indices are of the `ordering\_`, i.e. `X\[ordering\_\]\[start:end + 1\]` form a cluster. Only available when `cluster\_method='xi'`.
   */
  get cluster_hierarchy_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing cluster_hierarchy_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_cluster_hierarchy_ = bridgeOPTICS[${this.id}].cluster_hierarchy_`;
      return this._py`attr_OPTICS_cluster_hierarchy_.tolist() if hasattr(attr_OPTICS_cluster_hierarchy_, 'tolist') else attr_OPTICS_cluster_hierarchy_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_n_features_in_ = bridgeOPTICS[${this.id}].n_features_in_`;
      return this._py`attr_OPTICS_n_features_in_.tolist() if hasattr(attr_OPTICS_n_features_in_, 'tolist') else attr_OPTICS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_feature_names_in_ = bridgeOPTICS[${this.id}].feature_names_in_`;
      return this._py`attr_OPTICS_feature_names_in_.tolist() if hasattr(attr_OPTICS_feature_names_in_, 'tolist') else attr_OPTICS_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralBiclustering.ts
import crypto14 from "node:crypto";
var SpectralBiclustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralBiclustering${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralBiclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralBiclustering
try: bridgeSpectralBiclustering
except NameError: bridgeSpectralBiclustering = {}
`;
    await this._py.ex`ctor_SpectralBiclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'n_best': ${this.opts["n_best"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralBiclustering = {k: v for k, v in ctor_SpectralBiclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralBiclustering[${this.id}] = SpectralBiclustering(**ctor_SpectralBiclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralBiclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralBiclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralBiclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralBiclustering_fit = {k: v for k, v in pms_SpectralBiclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_fit = bridgeSpectralBiclustering[${this.id}].fit(**pms_SpectralBiclustering_fit)`;
    return this._py`res_SpectralBiclustering_fit.tolist() if hasattr(res_SpectralBiclustering_fit, 'tolist') else res_SpectralBiclustering_fit`;
  }
  /**
      Row and column indices of the `i`â€™th bicluster.
  
      Only works if `rows\_` and `columns\_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_indices = {k: v for k, v in pms_SpectralBiclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_indices = bridgeSpectralBiclustering[${this.id}].get_indices(**pms_SpectralBiclustering_get_indices)`;
    return this._py`res_SpectralBiclustering_get_indices.tolist() if hasattr(res_SpectralBiclustering_get_indices, 'tolist') else res_SpectralBiclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralBiclustering_get_metadata_routing = {k: v for k, v in pms_SpectralBiclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_metadata_routing = bridgeSpectralBiclustering[${this.id}].get_metadata_routing(**pms_SpectralBiclustering_get_metadata_routing)`;
    return this._py`res_SpectralBiclustering_get_metadata_routing.tolist() if hasattr(res_SpectralBiclustering_get_metadata_routing, 'tolist') else res_SpectralBiclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`â€™th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_shape = {k: v for k, v in pms_SpectralBiclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_shape = bridgeSpectralBiclustering[${this.id}].get_shape(**pms_SpectralBiclustering_get_shape)`;
    return this._py`res_SpectralBiclustering_get_shape.tolist() if hasattr(res_SpectralBiclustering_get_shape, 'tolist') else res_SpectralBiclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralBiclustering_get_submatrix = {k: v for k, v in pms_SpectralBiclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_submatrix = bridgeSpectralBiclustering[${this.id}].get_submatrix(**pms_SpectralBiclustering_get_submatrix)`;
    return this._py`res_SpectralBiclustering_get_submatrix.tolist() if hasattr(res_SpectralBiclustering_get_submatrix, 'tolist') else res_SpectralBiclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_rows_ = bridgeSpectralBiclustering[${this.id}].rows_`;
      return this._py`attr_SpectralBiclustering_rows_.tolist() if hasattr(attr_SpectralBiclustering_rows_, 'tolist') else attr_SpectralBiclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_columns_ = bridgeSpectralBiclustering[${this.id}].columns_`;
      return this._py`attr_SpectralBiclustering_columns_.tolist() if hasattr(attr_SpectralBiclustering_columns_, 'tolist') else attr_SpectralBiclustering_columns_`;
    })();
  }
  /**
    Row partition labels.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_row_labels_ = bridgeSpectralBiclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralBiclustering_row_labels_.tolist() if hasattr(attr_SpectralBiclustering_row_labels_, 'tolist') else attr_SpectralBiclustering_row_labels_`;
    })();
  }
  /**
    Column partition labels.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_column_labels_ = bridgeSpectralBiclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralBiclustering_column_labels_.tolist() if hasattr(attr_SpectralBiclustering_column_labels_, 'tolist') else attr_SpectralBiclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_n_features_in_ = bridgeSpectralBiclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralBiclustering_n_features_in_.tolist() if hasattr(attr_SpectralBiclustering_n_features_in_, 'tolist') else attr_SpectralBiclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_feature_names_in_ = bridgeSpectralBiclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralBiclustering_feature_names_in_.tolist() if hasattr(attr_SpectralBiclustering_feature_names_in_, 'tolist') else attr_SpectralBiclustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralClustering.ts
import crypto15 from "node:crypto";
var SpectralClustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralClustering${crypto15.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralClustering
try: bridgeSpectralClustering
except NameError: bridgeSpectralClustering = {}
`;
    await this._py.ex`ctor_SpectralClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'eigen_tol': ${this.opts["eigen_tol"] ?? void 0}, 'assign_labels': ${this.opts["assign_labels"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_SpectralClustering = {k: v for k, v in ctor_SpectralClustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralClustering[${this.id}] = SpectralClustering(**ctor_SpectralClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform spectral clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralClustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralClustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit = {k: v for k, v in pms_SpectralClustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit = bridgeSpectralClustering[${this.id}].fit(**pms_SpectralClustering_fit)`;
    return this._py`res_SpectralClustering_fit.tolist() if hasattr(res_SpectralClustering_fit, 'tolist') else res_SpectralClustering_fit`;
  }
  /**
    Perform spectral clustering on `X` and return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_SpectralClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit_predict = {k: v for k, v in pms_SpectralClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit_predict = bridgeSpectralClustering[${this.id}].fit_predict(**pms_SpectralClustering_fit_predict)`;
    return this._py`res_SpectralClustering_fit_predict.tolist() if hasattr(res_SpectralClustering_fit_predict, 'tolist') else res_SpectralClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralClustering_get_metadata_routing = {k: v for k, v in pms_SpectralClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_get_metadata_routing = bridgeSpectralClustering[${this.id}].get_metadata_routing(**pms_SpectralClustering_get_metadata_routing)`;
    return this._py`res_SpectralClustering_get_metadata_routing.tolist() if hasattr(res_SpectralClustering_get_metadata_routing, 'tolist') else res_SpectralClustering_get_metadata_routing`;
  }
  /**
    Affinity matrix used for clustering. Available only after calling `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_affinity_matrix_ = bridgeSpectralClustering[${this.id}].affinity_matrix_`;
      return this._py`attr_SpectralClustering_affinity_matrix_.tolist() if hasattr(attr_SpectralClustering_affinity_matrix_, 'tolist') else attr_SpectralClustering_affinity_matrix_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_labels_ = bridgeSpectralClustering[${this.id}].labels_`;
      return this._py`attr_SpectralClustering_labels_.tolist() if hasattr(attr_SpectralClustering_labels_, 'tolist') else attr_SpectralClustering_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_n_features_in_ = bridgeSpectralClustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralClustering_n_features_in_.tolist() if hasattr(attr_SpectralClustering_n_features_in_, 'tolist') else attr_SpectralClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_feature_names_in_ = bridgeSpectralClustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralClustering_feature_names_in_.tolist() if hasattr(attr_SpectralClustering_feature_names_in_, 'tolist') else attr_SpectralClustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralCoclustering.ts
import crypto16 from "node:crypto";
var SpectralCoclustering = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralCoclustering${crypto16.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralCoclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralCoclustering
try: bridgeSpectralCoclustering
except NameError: bridgeSpectralCoclustering = {}
`;
    await this._py.ex`ctor_SpectralCoclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralCoclustering = {k: v for k, v in ctor_SpectralCoclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralCoclustering[${this.id}] = SpectralCoclustering(**ctor_SpectralCoclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralCoclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralCoclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralCoclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralCoclustering_fit = {k: v for k, v in pms_SpectralCoclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_fit = bridgeSpectralCoclustering[${this.id}].fit(**pms_SpectralCoclustering_fit)`;
    return this._py`res_SpectralCoclustering_fit.tolist() if hasattr(res_SpectralCoclustering_fit, 'tolist') else res_SpectralCoclustering_fit`;
  }
  /**
      Row and column indices of the `i`â€™th bicluster.
  
      Only works if `rows\_` and `columns\_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_indices = {k: v for k, v in pms_SpectralCoclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_indices = bridgeSpectralCoclustering[${this.id}].get_indices(**pms_SpectralCoclustering_get_indices)`;
    return this._py`res_SpectralCoclustering_get_indices.tolist() if hasattr(res_SpectralCoclustering_get_indices, 'tolist') else res_SpectralCoclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralCoclustering_get_metadata_routing = {k: v for k, v in pms_SpectralCoclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_metadata_routing = bridgeSpectralCoclustering[${this.id}].get_metadata_routing(**pms_SpectralCoclustering_get_metadata_routing)`;
    return this._py`res_SpectralCoclustering_get_metadata_routing.tolist() if hasattr(res_SpectralCoclustering_get_metadata_routing, 'tolist') else res_SpectralCoclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`â€™th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_shape = {k: v for k, v in pms_SpectralCoclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_shape = bridgeSpectralCoclustering[${this.id}].get_shape(**pms_SpectralCoclustering_get_shape)`;
    return this._py`res_SpectralCoclustering_get_shape.tolist() if hasattr(res_SpectralCoclustering_get_shape, 'tolist') else res_SpectralCoclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralCoclustering_get_submatrix = {k: v for k, v in pms_SpectralCoclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_submatrix = bridgeSpectralCoclustering[${this.id}].get_submatrix(**pms_SpectralCoclustering_get_submatrix)`;
    return this._py`res_SpectralCoclustering_get_submatrix.tolist() if hasattr(res_SpectralCoclustering_get_submatrix, 'tolist') else res_SpectralCoclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_rows_ = bridgeSpectralCoclustering[${this.id}].rows_`;
      return this._py`attr_SpectralCoclustering_rows_.tolist() if hasattr(attr_SpectralCoclustering_rows_, 'tolist') else attr_SpectralCoclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_columns_ = bridgeSpectralCoclustering[${this.id}].columns_`;
      return this._py`attr_SpectralCoclustering_columns_.tolist() if hasattr(attr_SpectralCoclustering_columns_, 'tolist') else attr_SpectralCoclustering_columns_`;
    })();
  }
  /**
    The bicluster label of each row.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_row_labels_ = bridgeSpectralCoclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralCoclustering_row_labels_.tolist() if hasattr(attr_SpectralCoclustering_row_labels_, 'tolist') else attr_SpectralCoclustering_row_labels_`;
    })();
  }
  /**
    The bicluster label of each column.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_column_labels_ = bridgeSpectralCoclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralCoclustering_column_labels_.tolist() if hasattr(attr_SpectralCoclustering_column_labels_, 'tolist') else attr_SpectralCoclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_n_features_in_ = bridgeSpectralCoclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralCoclustering_n_features_in_.tolist() if hasattr(attr_SpectralCoclustering_n_features_in_, 'tolist') else attr_SpectralCoclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_feature_names_in_ = bridgeSpectralCoclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralCoclustering_feature_names_in_.tolist() if hasattr(attr_SpectralCoclustering_feature_names_in_, 'tolist') else attr_SpectralCoclustering_feature_names_in_`;
    })();
  }
};

// src/generated/compose/ColumnTransformer.ts
import crypto17 from "node:crypto";
var ColumnTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ColumnTransformer${crypto17.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ColumnTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.compose import ColumnTransformer
try: bridgeColumnTransformer
except NameError: bridgeColumnTransformer = {}
`;
    await this._py.ex`ctor_ColumnTransformer = {'transformers': ${this.opts["transformers"] ?? void 0}, 'remainder': ${this.opts["remainder"] ?? void 0}, 'sparse_threshold': ${this.opts["sparse_threshold"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'transformer_weights': ${this.opts["transformer_weights"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_feature_names_out': ${this.opts["verbose_feature_names_out"] ?? void 0}}

ctor_ColumnTransformer = {k: v for k, v in ctor_ColumnTransformer.items() if v is not None}`;
    await this._py.ex`bridgeColumnTransformer[${this.id}] = ColumnTransformer(**ctor_ColumnTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeColumnTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit all transformers using X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before fit()");
    }
    await this._py.ex`pms_ColumnTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_ColumnTransformer_fit = {k: v for k, v in pms_ColumnTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_fit = bridgeColumnTransformer[${this.id}].fit(**pms_ColumnTransformer_fit)`;
    return this._py`res_ColumnTransformer_fit.tolist() if hasattr(res_ColumnTransformer_fit, 'tolist') else res_ColumnTransformer_fit`;
  }
  /**
    Fit all transformers, transform the data and concatenate results.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_ColumnTransformer_fit_transform = {k: v for k, v in pms_ColumnTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_fit_transform = bridgeColumnTransformer[${this.id}].fit_transform(**pms_ColumnTransformer_fit_transform)`;
    return this._py`res_ColumnTransformer_fit_transform.tolist() if hasattr(res_ColumnTransformer_fit_transform, 'tolist') else res_ColumnTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_ColumnTransformer_get_feature_names_out = {k: v for k, v in pms_ColumnTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_get_feature_names_out = bridgeColumnTransformer[${this.id}].get_feature_names_out(**pms_ColumnTransformer_get_feature_names_out)`;
    return this._py`res_ColumnTransformer_get_feature_names_out.tolist() if hasattr(res_ColumnTransformer_get_feature_names_out, 'tolist') else res_ColumnTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ColumnTransformer_get_metadata_routing = {k: v for k, v in pms_ColumnTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_get_metadata_routing = bridgeColumnTransformer[${this.id}].get_metadata_routing(**pms_ColumnTransformer_get_metadata_routing)`;
    return this._py`res_ColumnTransformer_get_metadata_routing.tolist() if hasattr(res_ColumnTransformer_get_metadata_routing, 'tolist') else res_ColumnTransformer_get_metadata_routing`;
  }
  /**
      Set the output container when `"transform"` and `"fit\_transform"` are called.
  
      Calling `set\_output` will set the output of all estimators in `transformers` and `transformers\_`.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_ColumnTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_ColumnTransformer_set_output = {k: v for k, v in pms_ColumnTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_set_output = bridgeColumnTransformer[${this.id}].set_output(**pms_ColumnTransformer_set_output)`;
    return this._py`res_ColumnTransformer_set_output.tolist() if hasattr(res_ColumnTransformer_set_output, 'tolist') else res_ColumnTransformer_set_output`;
  }
  /**
    Transform X separately by each transformer, concatenate results.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before transform()");
    }
    await this._py.ex`pms_ColumnTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ColumnTransformer_transform = {k: v for k, v in pms_ColumnTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_transform = bridgeColumnTransformer[${this.id}].transform(**pms_ColumnTransformer_transform)`;
    return this._py`res_ColumnTransformer_transform.tolist() if hasattr(res_ColumnTransformer_transform, 'tolist') else res_ColumnTransformer_transform`;
  }
  /**
    The collection of fitted transformers as tuples of (name, fitted\_transformer, column). `fitted\_transformer` can be an estimator, â€˜dropâ€™, or â€˜passthroughâ€™. In case there were no columns selected, this will be the unfitted transformer. If there are remaining columns, the final element is a tuple of the form: (â€˜remainderâ€™, transformer, remaining\_columns) corresponding to the `remainder` parameter. If there are remaining columns, then `len(transformers\_)==len(transformers)+1`, otherwise `len(transformers\_)==len(transformers)`.
   */
  get transformers_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing transformers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_transformers_ = bridgeColumnTransformer[${this.id}].transformers_`;
      return this._py`attr_ColumnTransformer_transformers_.tolist() if hasattr(attr_ColumnTransformer_transformers_, 'tolist') else attr_ColumnTransformer_transformers_`;
    })();
  }
  /**
    Boolean flag indicating whether the output of `transform` is a sparse matrix or a dense numpy array, which depends on the output of the individual transformers and the `sparse\_threshold` keyword.
   */
  get sparse_output_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing sparse_output_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_sparse_output_ = bridgeColumnTransformer[${this.id}].sparse_output_`;
      return this._py`attr_ColumnTransformer_sparse_output_.tolist() if hasattr(attr_ColumnTransformer_sparse_output_, 'tolist') else attr_ColumnTransformer_sparse_output_`;
    })();
  }
  /**
    A dictionary from each transformer name to a slice, where the slice corresponds to indices in the transformed output. This is useful to inspect which transformer is responsible for which transformed feature(s).
   */
  get output_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing output_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_output_indices_ = bridgeColumnTransformer[${this.id}].output_indices_`;
      return this._py`attr_ColumnTransformer_output_indices_.tolist() if hasattr(attr_ColumnTransformer_output_indices_, 'tolist') else attr_ColumnTransformer_output_indices_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying transformers expose such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_n_features_in_ = bridgeColumnTransformer[${this.id}].n_features_in_`;
      return this._py`attr_ColumnTransformer_n_features_in_.tolist() if hasattr(attr_ColumnTransformer_n_features_in_, 'tolist') else attr_ColumnTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_feature_names_in_ = bridgeColumnTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_ColumnTransformer_feature_names_in_.tolist() if hasattr(attr_ColumnTransformer_feature_names_in_, 'tolist') else attr_ColumnTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/compose/TransformedTargetRegressor.ts
import crypto18 from "node:crypto";
var TransformedTargetRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TransformedTargetRegressor${crypto18.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "TransformedTargetRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.compose import TransformedTargetRegressor
try: bridgeTransformedTargetRegressor
except NameError: bridgeTransformedTargetRegressor = {}
`;
    await this._py.ex`ctor_TransformedTargetRegressor = {'regressor': ${this.opts["regressor"] ?? void 0}, 'transformer': ${this.opts["transformer"] ?? void 0}, 'func': ${this.opts["func"] ?? void 0}, 'inverse_func': ${this.opts["inverse_func"] ?? void 0}, 'check_inverse': ${this.opts["check_inverse"] ?? void 0}}

ctor_TransformedTargetRegressor = {k: v for k, v in ctor_TransformedTargetRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTransformedTargetRegressor[${this.id}] = TransformedTargetRegressor(**ctor_TransformedTargetRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTransformedTargetRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before fit()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_TransformedTargetRegressor_fit = {k: v for k, v in pms_TransformedTargetRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_fit = bridgeTransformedTargetRegressor[${this.id}].fit(**pms_TransformedTargetRegressor_fit)`;
    return this._py`res_TransformedTargetRegressor_fit.tolist() if hasattr(res_TransformedTargetRegressor_fit, 'tolist') else res_TransformedTargetRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TransformedTargetRegressor_get_metadata_routing = {k: v for k, v in pms_TransformedTargetRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_get_metadata_routing = bridgeTransformedTargetRegressor[${this.id}].get_metadata_routing(**pms_TransformedTargetRegressor_get_metadata_routing)`;
    return this._py`res_TransformedTargetRegressor_get_metadata_routing.tolist() if hasattr(res_TransformedTargetRegressor_get_metadata_routing, 'tolist') else res_TransformedTargetRegressor_get_metadata_routing`;
  }
  /**
      Predict using the base regressor, applying inverse.
  
      The regressor is used to predict and the `inverse\_func` or `inverse\_transform` is applied before returning the prediction.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'predict_params': ${opts["predict_params"] ?? void 0}}

pms_TransformedTargetRegressor_predict = {k: v for k, v in pms_TransformedTargetRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_predict = bridgeTransformedTargetRegressor[${this.id}].predict(**pms_TransformedTargetRegressor_predict)`;
    return this._py`res_TransformedTargetRegressor_predict.tolist() if hasattr(res_TransformedTargetRegressor_predict, 'tolist') else res_TransformedTargetRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TransformedTargetRegressor_score = {k: v for k, v in pms_TransformedTargetRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_score = bridgeTransformedTargetRegressor[${this.id}].score(**pms_TransformedTargetRegressor_score)`;
    return this._py`res_TransformedTargetRegressor_score.tolist() if hasattr(res_TransformedTargetRegressor_score, 'tolist') else res_TransformedTargetRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TransformedTargetRegressor_set_score_request = {k: v for k, v in pms_TransformedTargetRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_set_score_request = bridgeTransformedTargetRegressor[${this.id}].set_score_request(**pms_TransformedTargetRegressor_set_score_request)`;
    return this._py`res_TransformedTargetRegressor_set_score_request.tolist() if hasattr(res_TransformedTargetRegressor_set_score_request, 'tolist') else res_TransformedTargetRegressor_set_score_request`;
  }
  /**
    Fitted regressor.
   */
  get regressor_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing regressor_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_regressor_ = bridgeTransformedTargetRegressor[${this.id}].regressor_`;
      return this._py`attr_TransformedTargetRegressor_regressor_.tolist() if hasattr(attr_TransformedTargetRegressor_regressor_, 'tolist') else attr_TransformedTargetRegressor_regressor_`;
    })();
  }
  /**
    Transformer used in [`fit`](#sklearn.compose.TransformedTargetRegressor.fit "sklearn.compose.TransformedTargetRegressor.fit") and [`predict`](#sklearn.compose.TransformedTargetRegressor.predict "sklearn.compose.TransformedTargetRegressor.predict").
   */
  get transformer_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing transformer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_transformer_ = bridgeTransformedTargetRegressor[${this.id}].transformer_`;
      return this._py`attr_TransformedTargetRegressor_transformer_.tolist() if hasattr(attr_TransformedTargetRegressor_transformer_, 'tolist') else attr_TransformedTargetRegressor_transformer_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_feature_names_in_ = bridgeTransformedTargetRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TransformedTargetRegressor_feature_names_in_.tolist() if hasattr(attr_TransformedTargetRegressor_feature_names_in_, 'tolist') else attr_TransformedTargetRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/EllipticEnvelope.ts
import crypto19 from "node:crypto";
var EllipticEnvelope = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `EllipticEnvelope${crypto19.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("EllipticEnvelope.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import EllipticEnvelope
try: bridgeEllipticEnvelope
except NameError: bridgeEllipticEnvelope = {}
`;
    await this._py.ex`ctor_EllipticEnvelope = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'support_fraction': ${this.opts["support_fraction"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_EllipticEnvelope = {k: v for k, v in ctor_EllipticEnvelope.items() if v is not None}`;
    await this._py.ex`bridgeEllipticEnvelope[${this.id}] = EllipticEnvelope(**ctor_EllipticEnvelope)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeEllipticEnvelope[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply a correction to raw Minimum Covariance Determinant estimates.
  
      Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [\[RVD\]](#rbb2ba44703ed-rvd).
     */
  async correct_covariance(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before correct_covariance()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_correct_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_EllipticEnvelope_correct_covariance = {k: v for k, v in pms_EllipticEnvelope_correct_covariance.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_correct_covariance = bridgeEllipticEnvelope[${this.id}].correct_covariance(**pms_EllipticEnvelope_correct_covariance)`;
    return this._py`res_EllipticEnvelope_correct_covariance.tolist() if hasattr(res_EllipticEnvelope_correct_covariance, 'tolist') else res_EllipticEnvelope_correct_covariance`;
  }
  /**
    Compute the decision function of the given observations.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_decision_function = {k: v for k, v in pms_EllipticEnvelope_decision_function.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_decision_function = bridgeEllipticEnvelope[${this.id}].decision_function(**pms_EllipticEnvelope_decision_function)`;
    return this._py`res_EllipticEnvelope_decision_function.tolist() if hasattr(res_EllipticEnvelope_decision_function, 'tolist') else res_EllipticEnvelope_decision_function`;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before error_norm()");
    }
    await this._py.ex`pms_EllipticEnvelope_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_EllipticEnvelope_error_norm = {k: v for k, v in pms_EllipticEnvelope_error_norm.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_error_norm = bridgeEllipticEnvelope[${this.id}].error_norm(**pms_EllipticEnvelope_error_norm)`;
    return this._py`res_EllipticEnvelope_error_norm.tolist() if hasattr(res_EllipticEnvelope_error_norm, 'tolist') else res_EllipticEnvelope_error_norm`;
  }
  /**
    Fit the EllipticEnvelope model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before fit()");
    }
    await this._py.ex`pms_EllipticEnvelope_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EllipticEnvelope_fit = {k: v for k, v in pms_EllipticEnvelope_fit.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_fit = bridgeEllipticEnvelope[${this.id}].fit(**pms_EllipticEnvelope_fit)`;
    return this._py`res_EllipticEnvelope_fit.tolist() if hasattr(res_EllipticEnvelope_fit, 'tolist') else res_EllipticEnvelope_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before fit_predict()");
    }
    await this._py.ex`pms_EllipticEnvelope_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EllipticEnvelope_fit_predict = {k: v for k, v in pms_EllipticEnvelope_fit_predict.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_fit_predict = bridgeEllipticEnvelope[${this.id}].fit_predict(**pms_EllipticEnvelope_fit_predict)`;
    return this._py`res_EllipticEnvelope_fit_predict.tolist() if hasattr(res_EllipticEnvelope_fit_predict, 'tolist') else res_EllipticEnvelope_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_EllipticEnvelope_get_metadata_routing = {k: v for k, v in pms_EllipticEnvelope_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_get_metadata_routing = bridgeEllipticEnvelope[${this.id}].get_metadata_routing(**pms_EllipticEnvelope_get_metadata_routing)`;
    return this._py`res_EllipticEnvelope_get_metadata_routing.tolist() if hasattr(res_EllipticEnvelope_get_metadata_routing, 'tolist') else res_EllipticEnvelope_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_EllipticEnvelope_get_precision = {k: v for k, v in pms_EllipticEnvelope_get_precision.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_get_precision = bridgeEllipticEnvelope[${this.id}].get_precision(**pms_EllipticEnvelope_get_precision)`;
    return this._py`res_EllipticEnvelope_get_precision.tolist() if hasattr(res_EllipticEnvelope_get_precision, 'tolist') else res_EllipticEnvelope_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before mahalanobis()");
    }
    await this._py.ex`pms_EllipticEnvelope_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_mahalanobis = {k: v for k, v in pms_EllipticEnvelope_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_mahalanobis = bridgeEllipticEnvelope[${this.id}].mahalanobis(**pms_EllipticEnvelope_mahalanobis)`;
    return this._py`res_EllipticEnvelope_mahalanobis.tolist() if hasattr(res_EllipticEnvelope_mahalanobis, 'tolist') else res_EllipticEnvelope_mahalanobis`;
  }
  /**
    Predict labels (1 inlier, -1 outlier) of X according to fitted model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before predict()");
    }
    await this._py.ex`pms_EllipticEnvelope_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_predict = {k: v for k, v in pms_EllipticEnvelope_predict.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_predict = bridgeEllipticEnvelope[${this.id}].predict(**pms_EllipticEnvelope_predict)`;
    return this._py`res_EllipticEnvelope_predict.tolist() if hasattr(res_EllipticEnvelope_predict, 'tolist') else res_EllipticEnvelope_predict`;
  }
  /**
      Re-weight raw Minimum Covariance Determinant estimates.
  
      Re-weight observations using Rousseeuwâ€™s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [\[RVDriessen\]](#rd2c89e63f1c9-rvdriessen).
     */
  async reweight_covariance(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before reweight_covariance()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_reweight_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_EllipticEnvelope_reweight_covariance = {k: v for k, v in pms_EllipticEnvelope_reweight_covariance.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_reweight_covariance = bridgeEllipticEnvelope[${this.id}].reweight_covariance(**pms_EllipticEnvelope_reweight_covariance)`;
    return this._py`res_EllipticEnvelope_reweight_covariance.tolist() if hasattr(res_EllipticEnvelope_reweight_covariance, 'tolist') else res_EllipticEnvelope_reweight_covariance`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before score()");
    }
    await this._py.ex`pms_EllipticEnvelope_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_EllipticEnvelope_score = {k: v for k, v in pms_EllipticEnvelope_score.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_score = bridgeEllipticEnvelope[${this.id}].score(**pms_EllipticEnvelope_score)`;
    return this._py`res_EllipticEnvelope_score.tolist() if hasattr(res_EllipticEnvelope_score, 'tolist') else res_EllipticEnvelope_score`;
  }
  /**
    Compute the negative Mahalanobis distances.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_score_samples = {k: v for k, v in pms_EllipticEnvelope_score_samples.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_score_samples = bridgeEllipticEnvelope[${this.id}].score_samples(**pms_EllipticEnvelope_score_samples)`;
    return this._py`res_EllipticEnvelope_score_samples.tolist() if hasattr(res_EllipticEnvelope_score_samples, 'tolist') else res_EllipticEnvelope_score_samples`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_EllipticEnvelope_set_score_request = {k: v for k, v in pms_EllipticEnvelope_set_score_request.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_set_score_request = bridgeEllipticEnvelope[${this.id}].set_score_request(**pms_EllipticEnvelope_set_score_request)`;
    return this._py`res_EllipticEnvelope_set_score_request.tolist() if hasattr(res_EllipticEnvelope_set_score_request, 'tolist') else res_EllipticEnvelope_set_score_request`;
  }
  /**
    Estimated robust location.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_location_ = bridgeEllipticEnvelope[${this.id}].location_`;
      return this._py`attr_EllipticEnvelope_location_.tolist() if hasattr(attr_EllipticEnvelope_location_, 'tolist') else attr_EllipticEnvelope_location_`;
    })();
  }
  /**
    Estimated robust covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_covariance_ = bridgeEllipticEnvelope[${this.id}].covariance_`;
      return this._py`attr_EllipticEnvelope_covariance_.tolist() if hasattr(attr_EllipticEnvelope_covariance_, 'tolist') else attr_EllipticEnvelope_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_precision_ = bridgeEllipticEnvelope[${this.id}].precision_`;
      return this._py`attr_EllipticEnvelope_precision_.tolist() if hasattr(attr_EllipticEnvelope_precision_, 'tolist') else attr_EllipticEnvelope_precision_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the robust estimates of location and shape.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_support_ = bridgeEllipticEnvelope[${this.id}].support_`;
      return this._py`attr_EllipticEnvelope_support_.tolist() if hasattr(attr_EllipticEnvelope_support_, 'tolist') else attr_EllipticEnvelope_support_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: `decision\_function \= score\_samples \- offset\_`. The offset depends on the contamination parameter and is defined in such a way we obtain the expected number of outliers (samples with decision function < 0) in training.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_offset_ = bridgeEllipticEnvelope[${this.id}].offset_`;
      return this._py`attr_EllipticEnvelope_offset_.tolist() if hasattr(attr_EllipticEnvelope_offset_, 'tolist') else attr_EllipticEnvelope_offset_`;
    })();
  }
  /**
    The raw robust estimated location before correction and re-weighting.
   */
  get raw_location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_location_ = bridgeEllipticEnvelope[${this.id}].raw_location_`;
      return this._py`attr_EllipticEnvelope_raw_location_.tolist() if hasattr(attr_EllipticEnvelope_raw_location_, 'tolist') else attr_EllipticEnvelope_raw_location_`;
    })();
  }
  /**
    The raw robust estimated covariance before correction and re-weighting.
   */
  get raw_covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_covariance_ = bridgeEllipticEnvelope[${this.id}].raw_covariance_`;
      return this._py`attr_EllipticEnvelope_raw_covariance_.tolist() if hasattr(attr_EllipticEnvelope_raw_covariance_, 'tolist') else attr_EllipticEnvelope_raw_covariance_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.
   */
  get raw_support_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_support_ = bridgeEllipticEnvelope[${this.id}].raw_support_`;
      return this._py`attr_EllipticEnvelope_raw_support_.tolist() if hasattr(attr_EllipticEnvelope_raw_support_, 'tolist') else attr_EllipticEnvelope_raw_support_`;
    })();
  }
  /**
    Mahalanobis distances of the training set (on which [`fit`](#sklearn.covariance.EllipticEnvelope.fit "sklearn.covariance.EllipticEnvelope.fit") is called) observations.
   */
  get dist_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing dist_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_dist_ = bridgeEllipticEnvelope[${this.id}].dist_`;
      return this._py`attr_EllipticEnvelope_dist_.tolist() if hasattr(attr_EllipticEnvelope_dist_, 'tolist') else attr_EllipticEnvelope_dist_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_n_features_in_ = bridgeEllipticEnvelope[${this.id}].n_features_in_`;
      return this._py`attr_EllipticEnvelope_n_features_in_.tolist() if hasattr(attr_EllipticEnvelope_n_features_in_, 'tolist') else attr_EllipticEnvelope_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_feature_names_in_ = bridgeEllipticEnvelope[${this.id}].feature_names_in_`;
      return this._py`attr_EllipticEnvelope_feature_names_in_.tolist() if hasattr(attr_EllipticEnvelope_feature_names_in_, 'tolist') else attr_EllipticEnvelope_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/EmpiricalCovariance.ts
import crypto20 from "node:crypto";
var EmpiricalCovariance = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `EmpiricalCovariance${crypto20.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "EmpiricalCovariance.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import EmpiricalCovariance
try: bridgeEmpiricalCovariance
except NameError: bridgeEmpiricalCovariance = {}
`;
    await this._py.ex`ctor_EmpiricalCovariance = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_EmpiricalCovariance = {k: v for k, v in ctor_EmpiricalCovariance.items() if v is not None}`;
    await this._py.ex`bridgeEmpiricalCovariance[${this.id}] = EmpiricalCovariance(**ctor_EmpiricalCovariance)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeEmpiricalCovariance[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before error_norm()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_EmpiricalCovariance_error_norm = {k: v for k, v in pms_EmpiricalCovariance_error_norm.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_error_norm = bridgeEmpiricalCovariance[${this.id}].error_norm(**pms_EmpiricalCovariance_error_norm)`;
    return this._py`res_EmpiricalCovariance_error_norm.tolist() if hasattr(res_EmpiricalCovariance_error_norm, 'tolist') else res_EmpiricalCovariance_error_norm`;
  }
  /**
    Fit the maximum likelihood covariance estimator to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EmpiricalCovariance must call init() before fit()");
    }
    await this._py.ex`pms_EmpiricalCovariance_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EmpiricalCovariance_fit = {k: v for k, v in pms_EmpiricalCovariance_fit.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_fit = bridgeEmpiricalCovariance[${this.id}].fit(**pms_EmpiricalCovariance_fit)`;
    return this._py`res_EmpiricalCovariance_fit.tolist() if hasattr(res_EmpiricalCovariance_fit, 'tolist') else res_EmpiricalCovariance_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_EmpiricalCovariance_get_metadata_routing = {k: v for k, v in pms_EmpiricalCovariance_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_get_metadata_routing = bridgeEmpiricalCovariance[${this.id}].get_metadata_routing(**pms_EmpiricalCovariance_get_metadata_routing)`;
    return this._py`res_EmpiricalCovariance_get_metadata_routing.tolist() if hasattr(res_EmpiricalCovariance_get_metadata_routing, 'tolist') else res_EmpiricalCovariance_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_EmpiricalCovariance_get_precision = {k: v for k, v in pms_EmpiricalCovariance_get_precision.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_get_precision = bridgeEmpiricalCovariance[${this.id}].get_precision(**pms_EmpiricalCovariance_get_precision)`;
    return this._py`res_EmpiricalCovariance_get_precision.tolist() if hasattr(res_EmpiricalCovariance_get_precision, 'tolist') else res_EmpiricalCovariance_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before mahalanobis()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EmpiricalCovariance_mahalanobis = {k: v for k, v in pms_EmpiricalCovariance_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_mahalanobis = bridgeEmpiricalCovariance[${this.id}].mahalanobis(**pms_EmpiricalCovariance_mahalanobis)`;
    return this._py`res_EmpiricalCovariance_mahalanobis.tolist() if hasattr(res_EmpiricalCovariance_mahalanobis, 'tolist') else res_EmpiricalCovariance_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EmpiricalCovariance must call init() before score()");
    }
    await this._py.ex`pms_EmpiricalCovariance_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EmpiricalCovariance_score = {k: v for k, v in pms_EmpiricalCovariance_score.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_score = bridgeEmpiricalCovariance[${this.id}].score(**pms_EmpiricalCovariance_score)`;
    return this._py`res_EmpiricalCovariance_score.tolist() if hasattr(res_EmpiricalCovariance_score, 'tolist') else res_EmpiricalCovariance_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_EmpiricalCovariance_set_score_request = {k: v for k, v in pms_EmpiricalCovariance_set_score_request.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_set_score_request = bridgeEmpiricalCovariance[${this.id}].set_score_request(**pms_EmpiricalCovariance_set_score_request)`;
    return this._py`res_EmpiricalCovariance_set_score_request.tolist() if hasattr(res_EmpiricalCovariance_set_score_request, 'tolist') else res_EmpiricalCovariance_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_location_ = bridgeEmpiricalCovariance[${this.id}].location_`;
      return this._py`attr_EmpiricalCovariance_location_.tolist() if hasattr(attr_EmpiricalCovariance_location_, 'tolist') else attr_EmpiricalCovariance_location_`;
    })();
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_covariance_ = bridgeEmpiricalCovariance[${this.id}].covariance_`;
      return this._py`attr_EmpiricalCovariance_covariance_.tolist() if hasattr(attr_EmpiricalCovariance_covariance_, 'tolist') else attr_EmpiricalCovariance_covariance_`;
    })();
  }
  /**
    Estimated pseudo-inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_precision_ = bridgeEmpiricalCovariance[${this.id}].precision_`;
      return this._py`attr_EmpiricalCovariance_precision_.tolist() if hasattr(attr_EmpiricalCovariance_precision_, 'tolist') else attr_EmpiricalCovariance_precision_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_n_features_in_ = bridgeEmpiricalCovariance[${this.id}].n_features_in_`;
      return this._py`attr_EmpiricalCovariance_n_features_in_.tolist() if hasattr(attr_EmpiricalCovariance_n_features_in_, 'tolist') else attr_EmpiricalCovariance_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_feature_names_in_ = bridgeEmpiricalCovariance[${this.id}].feature_names_in_`;
      return this._py`attr_EmpiricalCovariance_feature_names_in_.tolist() if hasattr(attr_EmpiricalCovariance_feature_names_in_, 'tolist') else attr_EmpiricalCovariance_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/GraphicalLasso.ts
import crypto21 from "node:crypto";
var GraphicalLasso = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GraphicalLasso${crypto21.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GraphicalLasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import GraphicalLasso
try: bridgeGraphicalLasso
except NameError: bridgeGraphicalLasso = {}
`;
    await this._py.ex`ctor_GraphicalLasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'covariance': ${this.opts["covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'enet_tol': ${this.opts["enet_tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_GraphicalLasso = {k: v for k, v in ctor_GraphicalLasso.items() if v is not None}`;
    await this._py.ex`bridgeGraphicalLasso[${this.id}] = GraphicalLasso(**ctor_GraphicalLasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGraphicalLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before error_norm()");
    }
    await this._py.ex`pms_GraphicalLasso_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_GraphicalLasso_error_norm = {k: v for k, v in pms_GraphicalLasso_error_norm.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_error_norm = bridgeGraphicalLasso[${this.id}].error_norm(**pms_GraphicalLasso_error_norm)`;
    return this._py`res_GraphicalLasso_error_norm.tolist() if hasattr(res_GraphicalLasso_error_norm, 'tolist') else res_GraphicalLasso_error_norm`;
  }
  /**
    Fit the GraphicalLasso model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before fit()");
    }
    await this._py.ex`pms_GraphicalLasso_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLasso_fit = {k: v for k, v in pms_GraphicalLasso_fit.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_fit = bridgeGraphicalLasso[${this.id}].fit(**pms_GraphicalLasso_fit)`;
    return this._py`res_GraphicalLasso_fit.tolist() if hasattr(res_GraphicalLasso_fit, 'tolist') else res_GraphicalLasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GraphicalLasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GraphicalLasso_get_metadata_routing = {k: v for k, v in pms_GraphicalLasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_get_metadata_routing = bridgeGraphicalLasso[${this.id}].get_metadata_routing(**pms_GraphicalLasso_get_metadata_routing)`;
    return this._py`res_GraphicalLasso_get_metadata_routing.tolist() if hasattr(res_GraphicalLasso_get_metadata_routing, 'tolist') else res_GraphicalLasso_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before get_precision()");
    }
    await this._py.ex`pms_GraphicalLasso_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_GraphicalLasso_get_precision = {k: v for k, v in pms_GraphicalLasso_get_precision.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_get_precision = bridgeGraphicalLasso[${this.id}].get_precision(**pms_GraphicalLasso_get_precision)`;
    return this._py`res_GraphicalLasso_get_precision.tolist() if hasattr(res_GraphicalLasso_get_precision, 'tolist') else res_GraphicalLasso_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before mahalanobis()");
    }
    await this._py.ex`pms_GraphicalLasso_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GraphicalLasso_mahalanobis = {k: v for k, v in pms_GraphicalLasso_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_mahalanobis = bridgeGraphicalLasso[${this.id}].mahalanobis(**pms_GraphicalLasso_mahalanobis)`;
    return this._py`res_GraphicalLasso_mahalanobis.tolist() if hasattr(res_GraphicalLasso_mahalanobis, 'tolist') else res_GraphicalLasso_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before score()");
    }
    await this._py.ex`pms_GraphicalLasso_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLasso_score = {k: v for k, v in pms_GraphicalLasso_score.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_score = bridgeGraphicalLasso[${this.id}].score(**pms_GraphicalLasso_score)`;
    return this._py`res_GraphicalLasso_score.tolist() if hasattr(res_GraphicalLasso_score, 'tolist') else res_GraphicalLasso_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GraphicalLasso_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_GraphicalLasso_set_score_request = {k: v for k, v in pms_GraphicalLasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_set_score_request = bridgeGraphicalLasso[${this.id}].set_score_request(**pms_GraphicalLasso_set_score_request)`;
    return this._py`res_GraphicalLasso_set_score_request.tolist() if hasattr(res_GraphicalLasso_set_score_request, 'tolist') else res_GraphicalLasso_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_location_ = bridgeGraphicalLasso[${this.id}].location_`;
      return this._py`attr_GraphicalLasso_location_.tolist() if hasattr(attr_GraphicalLasso_location_, 'tolist') else attr_GraphicalLasso_location_`;
    })();
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_covariance_ = bridgeGraphicalLasso[${this.id}].covariance_`;
      return this._py`attr_GraphicalLasso_covariance_.tolist() if hasattr(attr_GraphicalLasso_covariance_, 'tolist') else attr_GraphicalLasso_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix.
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_precision_ = bridgeGraphicalLasso[${this.id}].precision_`;
      return this._py`attr_GraphicalLasso_precision_.tolist() if hasattr(attr_GraphicalLasso_precision_, 'tolist') else attr_GraphicalLasso_precision_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_n_iter_ = bridgeGraphicalLasso[${this.id}].n_iter_`;
      return this._py`attr_GraphicalLasso_n_iter_.tolist() if hasattr(attr_GraphicalLasso_n_iter_, 'tolist') else attr_GraphicalLasso_n_iter_`;
    })();
  }
  /**
    The list of values of the objective function and the dual gap at each iteration. Returned only if return\_costs is `true`.
   */
  get costs_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before accessing costs_");
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_costs_ = bridgeGraphicalLasso[${this.id}].costs_`;
      return this._py`attr_GraphicalLasso_costs_.tolist() if hasattr(attr_GraphicalLasso_costs_, 'tolist') else attr_GraphicalLasso_costs_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_n_features_in_ = bridgeGraphicalLasso[${this.id}].n_features_in_`;
      return this._py`attr_GraphicalLasso_n_features_in_.tolist() if hasattr(attr_GraphicalLasso_n_features_in_, 'tolist') else attr_GraphicalLasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_feature_names_in_ = bridgeGraphicalLasso[${this.id}].feature_names_in_`;
      return this._py`attr_GraphicalLasso_feature_names_in_.tolist() if hasattr(attr_GraphicalLasso_feature_names_in_, 'tolist') else attr_GraphicalLasso_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/GraphicalLassoCV.ts
import crypto22 from "node:crypto";
var GraphicalLassoCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GraphicalLassoCV${crypto22.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GraphicalLassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import GraphicalLassoCV
try: bridgeGraphicalLassoCV
except NameError: bridgeGraphicalLassoCV = {}
`;
    await this._py.ex`ctor_GraphicalLassoCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'n_refinements': ${this.opts["n_refinements"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'enet_tol': ${this.opts["enet_tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_GraphicalLassoCV = {k: v for k, v in ctor_GraphicalLassoCV.items() if v is not None}`;
    await this._py.ex`bridgeGraphicalLassoCV[${this.id}] = GraphicalLassoCV(**ctor_GraphicalLassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGraphicalLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before error_norm()");
    }
    await this._py.ex`pms_GraphicalLassoCV_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_GraphicalLassoCV_error_norm = {k: v for k, v in pms_GraphicalLassoCV_error_norm.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_error_norm = bridgeGraphicalLassoCV[${this.id}].error_norm(**pms_GraphicalLassoCV_error_norm)`;
    return this._py`res_GraphicalLassoCV_error_norm.tolist() if hasattr(res_GraphicalLassoCV_error_norm, 'tolist') else res_GraphicalLassoCV_error_norm`;
  }
  /**
    Fit the GraphicalLasso covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before fit()");
    }
    await this._py.ex`pms_GraphicalLassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLassoCV_fit = {k: v for k, v in pms_GraphicalLassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_fit = bridgeGraphicalLassoCV[${this.id}].fit(**pms_GraphicalLassoCV_fit)`;
    return this._py`res_GraphicalLassoCV_fit.tolist() if hasattr(res_GraphicalLassoCV_fit, 'tolist') else res_GraphicalLassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GraphicalLassoCV_get_metadata_routing = {k: v for k, v in pms_GraphicalLassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_get_metadata_routing = bridgeGraphicalLassoCV[${this.id}].get_metadata_routing(**pms_GraphicalLassoCV_get_metadata_routing)`;
    return this._py`res_GraphicalLassoCV_get_metadata_routing.tolist() if hasattr(res_GraphicalLassoCV_get_metadata_routing, 'tolist') else res_GraphicalLassoCV_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_GraphicalLassoCV_get_precision = {k: v for k, v in pms_GraphicalLassoCV_get_precision.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_get_precision = bridgeGraphicalLassoCV[${this.id}].get_precision(**pms_GraphicalLassoCV_get_precision)`;
    return this._py`res_GraphicalLassoCV_get_precision.tolist() if hasattr(res_GraphicalLassoCV_get_precision, 'tolist') else res_GraphicalLassoCV_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before mahalanobis()");
    }
    await this._py.ex`pms_GraphicalLassoCV_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GraphicalLassoCV_mahalanobis = {k: v for k, v in pms_GraphicalLassoCV_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_mahalanobis = bridgeGraphicalLassoCV[${this.id}].mahalanobis(**pms_GraphicalLassoCV_mahalanobis)`;
    return this._py`res_GraphicalLassoCV_mahalanobis.tolist() if hasattr(res_GraphicalLassoCV_mahalanobis, 'tolist') else res_GraphicalLassoCV_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before score()");
    }
    await this._py.ex`pms_GraphicalLassoCV_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLassoCV_score = {k: v for k, v in pms_GraphicalLassoCV_score.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_score = bridgeGraphicalLassoCV[${this.id}].score(**pms_GraphicalLassoCV_score)`;
    return this._py`res_GraphicalLassoCV_score.tolist() if hasattr(res_GraphicalLassoCV_score, 'tolist') else res_GraphicalLassoCV_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_GraphicalLassoCV_set_score_request = {k: v for k, v in pms_GraphicalLassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_set_score_request = bridgeGraphicalLassoCV[${this.id}].set_score_request(**pms_GraphicalLassoCV_set_score_request)`;
    return this._py`res_GraphicalLassoCV_set_score_request.tolist() if hasattr(res_GraphicalLassoCV_set_score_request, 'tolist') else res_GraphicalLassoCV_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_location_ = bridgeGraphicalLassoCV[${this.id}].location_`;
      return this._py`attr_GraphicalLassoCV_location_.tolist() if hasattr(attr_GraphicalLassoCV_location_, 'tolist') else attr_GraphicalLassoCV_location_`;
    })();
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_covariance_ = bridgeGraphicalLassoCV[${this.id}].covariance_`;
      return this._py`attr_GraphicalLassoCV_covariance_.tolist() if hasattr(attr_GraphicalLassoCV_covariance_, 'tolist') else attr_GraphicalLassoCV_covariance_`;
    })();
  }
  /**
    Estimated precision matrix (inverse covariance).
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_precision_ = bridgeGraphicalLassoCV[${this.id}].precision_`;
      return this._py`attr_GraphicalLassoCV_precision_.tolist() if hasattr(attr_GraphicalLassoCV_precision_, 'tolist') else attr_GraphicalLassoCV_precision_`;
    })();
  }
  /**
    The list of values of the objective function and the dual gap at each iteration. Returned only if return\_costs is `true`.
   */
  get costs_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing costs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_costs_ = bridgeGraphicalLassoCV[${this.id}].costs_`;
      return this._py`attr_GraphicalLassoCV_costs_.tolist() if hasattr(attr_GraphicalLassoCV_costs_, 'tolist') else attr_GraphicalLassoCV_costs_`;
    })();
  }
  /**
    Penalization parameter selected.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_alpha_ = bridgeGraphicalLassoCV[${this.id}].alpha_`;
      return this._py`attr_GraphicalLassoCV_alpha_.tolist() if hasattr(attr_GraphicalLassoCV_alpha_, 'tolist') else attr_GraphicalLassoCV_alpha_`;
    })();
  }
  /**
    A dict with keys:
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_cv_results_ = bridgeGraphicalLassoCV[${this.id}].cv_results_`;
      return this._py`attr_GraphicalLassoCV_cv_results_.tolist() if hasattr(attr_GraphicalLassoCV_cv_results_, 'tolist') else attr_GraphicalLassoCV_cv_results_`;
    })();
  }
  /**
    Number of iterations run for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_n_iter_ = bridgeGraphicalLassoCV[${this.id}].n_iter_`;
      return this._py`attr_GraphicalLassoCV_n_iter_.tolist() if hasattr(attr_GraphicalLassoCV_n_iter_, 'tolist') else attr_GraphicalLassoCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_n_features_in_ = bridgeGraphicalLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_GraphicalLassoCV_n_features_in_.tolist() if hasattr(attr_GraphicalLassoCV_n_features_in_, 'tolist') else attr_GraphicalLassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_feature_names_in_ = bridgeGraphicalLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_GraphicalLassoCV_feature_names_in_.tolist() if hasattr(attr_GraphicalLassoCV_feature_names_in_, 'tolist') else attr_GraphicalLassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/LedoitWolf.ts
import crypto23 from "node:crypto";
var LedoitWolf = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LedoitWolf${crypto23.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LedoitWolf.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import LedoitWolf
try: bridgeLedoitWolf
except NameError: bridgeLedoitWolf = {}
`;
    await this._py.ex`ctor_LedoitWolf = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'block_size': ${this.opts["block_size"] ?? void 0}}

ctor_LedoitWolf = {k: v for k, v in ctor_LedoitWolf.items() if v is not None}`;
    await this._py.ex`bridgeLedoitWolf[${this.id}] = LedoitWolf(**ctor_LedoitWolf)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLedoitWolf[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before error_norm()");
    }
    await this._py.ex`pms_LedoitWolf_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_LedoitWolf_error_norm = {k: v for k, v in pms_LedoitWolf_error_norm.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_error_norm = bridgeLedoitWolf[${this.id}].error_norm(**pms_LedoitWolf_error_norm)`;
    return this._py`res_LedoitWolf_error_norm.tolist() if hasattr(res_LedoitWolf_error_norm, 'tolist') else res_LedoitWolf_error_norm`;
  }
  /**
    Fit the Ledoit-Wolf shrunk covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before fit()");
    }
    await this._py.ex`pms_LedoitWolf_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LedoitWolf_fit = {k: v for k, v in pms_LedoitWolf_fit.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_fit = bridgeLedoitWolf[${this.id}].fit(**pms_LedoitWolf_fit)`;
    return this._py`res_LedoitWolf_fit.tolist() if hasattr(res_LedoitWolf_fit, 'tolist') else res_LedoitWolf_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LedoitWolf_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LedoitWolf_get_metadata_routing = {k: v for k, v in pms_LedoitWolf_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_get_metadata_routing = bridgeLedoitWolf[${this.id}].get_metadata_routing(**pms_LedoitWolf_get_metadata_routing)`;
    return this._py`res_LedoitWolf_get_metadata_routing.tolist() if hasattr(res_LedoitWolf_get_metadata_routing, 'tolist') else res_LedoitWolf_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before get_precision()");
    }
    await this._py.ex`pms_LedoitWolf_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_LedoitWolf_get_precision = {k: v for k, v in pms_LedoitWolf_get_precision.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_get_precision = bridgeLedoitWolf[${this.id}].get_precision(**pms_LedoitWolf_get_precision)`;
    return this._py`res_LedoitWolf_get_precision.tolist() if hasattr(res_LedoitWolf_get_precision, 'tolist') else res_LedoitWolf_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before mahalanobis()");
    }
    await this._py.ex`pms_LedoitWolf_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LedoitWolf_mahalanobis = {k: v for k, v in pms_LedoitWolf_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_mahalanobis = bridgeLedoitWolf[${this.id}].mahalanobis(**pms_LedoitWolf_mahalanobis)`;
    return this._py`res_LedoitWolf_mahalanobis.tolist() if hasattr(res_LedoitWolf_mahalanobis, 'tolist') else res_LedoitWolf_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before score()");
    }
    await this._py.ex`pms_LedoitWolf_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LedoitWolf_score = {k: v for k, v in pms_LedoitWolf_score.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_score = bridgeLedoitWolf[${this.id}].score(**pms_LedoitWolf_score)`;
    return this._py`res_LedoitWolf_score.tolist() if hasattr(res_LedoitWolf_score, 'tolist') else res_LedoitWolf_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before set_score_request()");
    }
    await this._py.ex`pms_LedoitWolf_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_LedoitWolf_set_score_request = {k: v for k, v in pms_LedoitWolf_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_set_score_request = bridgeLedoitWolf[${this.id}].set_score_request(**pms_LedoitWolf_set_score_request)`;
    return this._py`res_LedoitWolf_set_score_request.tolist() if hasattr(res_LedoitWolf_set_score_request, 'tolist') else res_LedoitWolf_set_score_request`;
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_covariance_ = bridgeLedoitWolf[${this.id}].covariance_`;
      return this._py`attr_LedoitWolf_covariance_.tolist() if hasattr(attr_LedoitWolf_covariance_, 'tolist') else attr_LedoitWolf_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_location_ = bridgeLedoitWolf[${this.id}].location_`;
      return this._py`attr_LedoitWolf_location_.tolist() if hasattr(attr_LedoitWolf_location_, 'tolist') else attr_LedoitWolf_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_precision_ = bridgeLedoitWolf[${this.id}].precision_`;
      return this._py`attr_LedoitWolf_precision_.tolist() if hasattr(attr_LedoitWolf_precision_, 'tolist') else attr_LedoitWolf_precision_`;
    })();
  }
  /**
    Coefficient in the convex combination used for the computation of the shrunk estimate. Range is \[0, 1\].
   */
  get shrinkage_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing shrinkage_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_shrinkage_ = bridgeLedoitWolf[${this.id}].shrinkage_`;
      return this._py`attr_LedoitWolf_shrinkage_.tolist() if hasattr(attr_LedoitWolf_shrinkage_, 'tolist') else attr_LedoitWolf_shrinkage_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_n_features_in_ = bridgeLedoitWolf[${this.id}].n_features_in_`;
      return this._py`attr_LedoitWolf_n_features_in_.tolist() if hasattr(attr_LedoitWolf_n_features_in_, 'tolist') else attr_LedoitWolf_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_feature_names_in_ = bridgeLedoitWolf[${this.id}].feature_names_in_`;
      return this._py`attr_LedoitWolf_feature_names_in_.tolist() if hasattr(attr_LedoitWolf_feature_names_in_, 'tolist') else attr_LedoitWolf_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/MinCovDet.ts
import crypto24 from "node:crypto";
var MinCovDet = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MinCovDet${crypto24.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MinCovDet.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import MinCovDet
try: bridgeMinCovDet
except NameError: bridgeMinCovDet = {}
`;
    await this._py.ex`ctor_MinCovDet = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'support_fraction': ${this.opts["support_fraction"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_MinCovDet = {k: v for k, v in ctor_MinCovDet.items() if v is not None}`;
    await this._py.ex`bridgeMinCovDet[${this.id}] = MinCovDet(**ctor_MinCovDet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMinCovDet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply a correction to raw Minimum Covariance Determinant estimates.
  
      Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [\[RVD\]](#r491365aeaa84-rvd).
     */
  async correct_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before correct_covariance()");
    }
    await this._py.ex`pms_MinCovDet_correct_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_MinCovDet_correct_covariance = {k: v for k, v in pms_MinCovDet_correct_covariance.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_correct_covariance = bridgeMinCovDet[${this.id}].correct_covariance(**pms_MinCovDet_correct_covariance)`;
    return this._py`res_MinCovDet_correct_covariance.tolist() if hasattr(res_MinCovDet_correct_covariance, 'tolist') else res_MinCovDet_correct_covariance`;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before error_norm()");
    }
    await this._py.ex`pms_MinCovDet_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_MinCovDet_error_norm = {k: v for k, v in pms_MinCovDet_error_norm.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_error_norm = bridgeMinCovDet[${this.id}].error_norm(**pms_MinCovDet_error_norm)`;
    return this._py`res_MinCovDet_error_norm.tolist() if hasattr(res_MinCovDet_error_norm, 'tolist') else res_MinCovDet_error_norm`;
  }
  /**
    Fit a Minimum Covariance Determinant with the FastMCD algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before fit()");
    }
    await this._py.ex`pms_MinCovDet_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinCovDet_fit = {k: v for k, v in pms_MinCovDet_fit.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_fit = bridgeMinCovDet[${this.id}].fit(**pms_MinCovDet_fit)`;
    return this._py`res_MinCovDet_fit.tolist() if hasattr(res_MinCovDet_fit, 'tolist') else res_MinCovDet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MinCovDet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MinCovDet_get_metadata_routing = {k: v for k, v in pms_MinCovDet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_get_metadata_routing = bridgeMinCovDet[${this.id}].get_metadata_routing(**pms_MinCovDet_get_metadata_routing)`;
    return this._py`res_MinCovDet_get_metadata_routing.tolist() if hasattr(res_MinCovDet_get_metadata_routing, 'tolist') else res_MinCovDet_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before get_precision()");
    }
    await this._py.ex`pms_MinCovDet_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_MinCovDet_get_precision = {k: v for k, v in pms_MinCovDet_get_precision.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_get_precision = bridgeMinCovDet[${this.id}].get_precision(**pms_MinCovDet_get_precision)`;
    return this._py`res_MinCovDet_get_precision.tolist() if hasattr(res_MinCovDet_get_precision, 'tolist') else res_MinCovDet_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before mahalanobis()");
    }
    await this._py.ex`pms_MinCovDet_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinCovDet_mahalanobis = {k: v for k, v in pms_MinCovDet_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_mahalanobis = bridgeMinCovDet[${this.id}].mahalanobis(**pms_MinCovDet_mahalanobis)`;
    return this._py`res_MinCovDet_mahalanobis.tolist() if hasattr(res_MinCovDet_mahalanobis, 'tolist') else res_MinCovDet_mahalanobis`;
  }
  /**
      Re-weight raw Minimum Covariance Determinant estimates.
  
      Re-weight observations using Rousseeuwâ€™s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [\[RVDriessen\]](#r9465bad4668c-rvdriessen).
     */
  async reweight_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before reweight_covariance()");
    }
    await this._py.ex`pms_MinCovDet_reweight_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_MinCovDet_reweight_covariance = {k: v for k, v in pms_MinCovDet_reweight_covariance.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_reweight_covariance = bridgeMinCovDet[${this.id}].reweight_covariance(**pms_MinCovDet_reweight_covariance)`;
    return this._py`res_MinCovDet_reweight_covariance.tolist() if hasattr(res_MinCovDet_reweight_covariance, 'tolist') else res_MinCovDet_reweight_covariance`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before score()");
    }
    await this._py.ex`pms_MinCovDet_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinCovDet_score = {k: v for k, v in pms_MinCovDet_score.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_score = bridgeMinCovDet[${this.id}].score(**pms_MinCovDet_score)`;
    return this._py`res_MinCovDet_score.tolist() if hasattr(res_MinCovDet_score, 'tolist') else res_MinCovDet_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before set_score_request()");
    }
    await this._py.ex`pms_MinCovDet_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_MinCovDet_set_score_request = {k: v for k, v in pms_MinCovDet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_set_score_request = bridgeMinCovDet[${this.id}].set_score_request(**pms_MinCovDet_set_score_request)`;
    return this._py`res_MinCovDet_set_score_request.tolist() if hasattr(res_MinCovDet_set_score_request, 'tolist') else res_MinCovDet_set_score_request`;
  }
  /**
    The raw robust estimated location before correction and re-weighting.
   */
  get raw_location_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_location_ = bridgeMinCovDet[${this.id}].raw_location_`;
      return this._py`attr_MinCovDet_raw_location_.tolist() if hasattr(attr_MinCovDet_raw_location_, 'tolist') else attr_MinCovDet_raw_location_`;
    })();
  }
  /**
    The raw robust estimated covariance before correction and re-weighting.
   */
  get raw_covariance_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_covariance_ = bridgeMinCovDet[${this.id}].raw_covariance_`;
      return this._py`attr_MinCovDet_raw_covariance_.tolist() if hasattr(attr_MinCovDet_raw_covariance_, 'tolist') else attr_MinCovDet_raw_covariance_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.
   */
  get raw_support_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_support_ = bridgeMinCovDet[${this.id}].raw_support_`;
      return this._py`attr_MinCovDet_raw_support_.tolist() if hasattr(attr_MinCovDet_raw_support_, 'tolist') else attr_MinCovDet_raw_support_`;
    })();
  }
  /**
    Estimated robust location.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_location_ = bridgeMinCovDet[${this.id}].location_`;
      return this._py`attr_MinCovDet_location_.tolist() if hasattr(attr_MinCovDet_location_, 'tolist') else attr_MinCovDet_location_`;
    })();
  }
  /**
    Estimated robust covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing covariance_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_covariance_ = bridgeMinCovDet[${this.id}].covariance_`;
      return this._py`attr_MinCovDet_covariance_.tolist() if hasattr(attr_MinCovDet_covariance_, 'tolist') else attr_MinCovDet_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_precision_ = bridgeMinCovDet[${this.id}].precision_`;
      return this._py`attr_MinCovDet_precision_.tolist() if hasattr(attr_MinCovDet_precision_, 'tolist') else attr_MinCovDet_precision_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the robust estimates of location and shape.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_support_ = bridgeMinCovDet[${this.id}].support_`;
      return this._py`attr_MinCovDet_support_.tolist() if hasattr(attr_MinCovDet_support_, 'tolist') else attr_MinCovDet_support_`;
    })();
  }
  /**
    Mahalanobis distances of the training set (on which [`fit`](#sklearn.covariance.MinCovDet.fit "sklearn.covariance.MinCovDet.fit") is called) observations.
   */
  get dist_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing dist_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_dist_ = bridgeMinCovDet[${this.id}].dist_`;
      return this._py`attr_MinCovDet_dist_.tolist() if hasattr(attr_MinCovDet_dist_, 'tolist') else attr_MinCovDet_dist_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_n_features_in_ = bridgeMinCovDet[${this.id}].n_features_in_`;
      return this._py`attr_MinCovDet_n_features_in_.tolist() if hasattr(attr_MinCovDet_n_features_in_, 'tolist') else attr_MinCovDet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_feature_names_in_ = bridgeMinCovDet[${this.id}].feature_names_in_`;
      return this._py`attr_MinCovDet_feature_names_in_.tolist() if hasattr(attr_MinCovDet_feature_names_in_, 'tolist') else attr_MinCovDet_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/OAS.ts
import crypto25 from "node:crypto";
var OAS = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OAS${crypto25.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OAS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import OAS
try: bridgeOAS
except NameError: bridgeOAS = {}
`;
    await this._py.ex`ctor_OAS = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_OAS = {k: v for k, v in ctor_OAS.items() if v is not None}`;
    await this._py.ex`bridgeOAS[${this.id}] = OAS(**ctor_OAS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOAS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before error_norm()");
    }
    await this._py.ex`pms_OAS_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_OAS_error_norm = {k: v for k, v in pms_OAS_error_norm.items() if v is not None}`;
    await this._py.ex`res_OAS_error_norm = bridgeOAS[${this.id}].error_norm(**pms_OAS_error_norm)`;
    return this._py`res_OAS_error_norm.tolist() if hasattr(res_OAS_error_norm, 'tolist') else res_OAS_error_norm`;
  }
  /**
    Fit the Oracle Approximating Shrinkage covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before fit()");
    }
    await this._py.ex`pms_OAS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OAS_fit = {k: v for k, v in pms_OAS_fit.items() if v is not None}`;
    await this._py.ex`res_OAS_fit = bridgeOAS[${this.id}].fit(**pms_OAS_fit)`;
    return this._py`res_OAS_fit.tolist() if hasattr(res_OAS_fit, 'tolist') else res_OAS_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_OAS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OAS_get_metadata_routing = {k: v for k, v in pms_OAS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OAS_get_metadata_routing = bridgeOAS[${this.id}].get_metadata_routing(**pms_OAS_get_metadata_routing)`;
    return this._py`res_OAS_get_metadata_routing.tolist() if hasattr(res_OAS_get_metadata_routing, 'tolist') else res_OAS_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before get_precision()");
    }
    await this._py.ex`pms_OAS_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_OAS_get_precision = {k: v for k, v in pms_OAS_get_precision.items() if v is not None}`;
    await this._py.ex`res_OAS_get_precision = bridgeOAS[${this.id}].get_precision(**pms_OAS_get_precision)`;
    return this._py`res_OAS_get_precision.tolist() if hasattr(res_OAS_get_precision, 'tolist') else res_OAS_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before mahalanobis()");
    }
    await this._py.ex`pms_OAS_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OAS_mahalanobis = {k: v for k, v in pms_OAS_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_OAS_mahalanobis = bridgeOAS[${this.id}].mahalanobis(**pms_OAS_mahalanobis)`;
    return this._py`res_OAS_mahalanobis.tolist() if hasattr(res_OAS_mahalanobis, 'tolist') else res_OAS_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before score()");
    }
    await this._py.ex`pms_OAS_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OAS_score = {k: v for k, v in pms_OAS_score.items() if v is not None}`;
    await this._py.ex`res_OAS_score = bridgeOAS[${this.id}].score(**pms_OAS_score)`;
    return this._py`res_OAS_score.tolist() if hasattr(res_OAS_score, 'tolist') else res_OAS_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before set_score_request()");
    }
    await this._py.ex`pms_OAS_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_OAS_set_score_request = {k: v for k, v in pms_OAS_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OAS_set_score_request = bridgeOAS[${this.id}].set_score_request(**pms_OAS_set_score_request)`;
    return this._py`res_OAS_set_score_request.tolist() if hasattr(res_OAS_set_score_request, 'tolist') else res_OAS_set_score_request`;
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing covariance_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_covariance_ = bridgeOAS[${this.id}].covariance_`;
      return this._py`attr_OAS_covariance_.tolist() if hasattr(attr_OAS_covariance_, 'tolist') else attr_OAS_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_location_ = bridgeOAS[${this.id}].location_`;
      return this._py`attr_OAS_location_.tolist() if hasattr(attr_OAS_location_, 'tolist') else attr_OAS_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_precision_ = bridgeOAS[${this.id}].precision_`;
      return this._py`attr_OAS_precision_.tolist() if hasattr(attr_OAS_precision_, 'tolist') else attr_OAS_precision_`;
    })();
  }
  /**
    coefficient in the convex combination used for the computation of the shrunk estimate. Range is \[0, 1\].
   */
  get shrinkage_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing shrinkage_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_shrinkage_ = bridgeOAS[${this.id}].shrinkage_`;
      return this._py`attr_OAS_shrinkage_.tolist() if hasattr(attr_OAS_shrinkage_, 'tolist') else attr_OAS_shrinkage_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_n_features_in_ = bridgeOAS[${this.id}].n_features_in_`;
      return this._py`attr_OAS_n_features_in_.tolist() if hasattr(attr_OAS_n_features_in_, 'tolist') else attr_OAS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_feature_names_in_ = bridgeOAS[${this.id}].feature_names_in_`;
      return this._py`attr_OAS_feature_names_in_.tolist() if hasattr(attr_OAS_feature_names_in_, 'tolist') else attr_OAS_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/ShrunkCovariance.ts
import crypto26 from "node:crypto";
var ShrunkCovariance = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ShrunkCovariance${crypto26.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ShrunkCovariance.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import ShrunkCovariance
try: bridgeShrunkCovariance
except NameError: bridgeShrunkCovariance = {}
`;
    await this._py.ex`ctor_ShrunkCovariance = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'shrinkage': ${this.opts["shrinkage"] ?? void 0}}

ctor_ShrunkCovariance = {k: v for k, v in ctor_ShrunkCovariance.items() if v is not None}`;
    await this._py.ex`bridgeShrunkCovariance[${this.id}] = ShrunkCovariance(**ctor_ShrunkCovariance)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeShrunkCovariance[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before error_norm()");
    }
    await this._py.ex`pms_ShrunkCovariance_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_ShrunkCovariance_error_norm = {k: v for k, v in pms_ShrunkCovariance_error_norm.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_error_norm = bridgeShrunkCovariance[${this.id}].error_norm(**pms_ShrunkCovariance_error_norm)`;
    return this._py`res_ShrunkCovariance_error_norm.tolist() if hasattr(res_ShrunkCovariance_error_norm, 'tolist') else res_ShrunkCovariance_error_norm`;
  }
  /**
    Fit the shrunk covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before fit()");
    }
    await this._py.ex`pms_ShrunkCovariance_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_ShrunkCovariance_fit = {k: v for k, v in pms_ShrunkCovariance_fit.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_fit = bridgeShrunkCovariance[${this.id}].fit(**pms_ShrunkCovariance_fit)`;
    return this._py`res_ShrunkCovariance_fit.tolist() if hasattr(res_ShrunkCovariance_fit, 'tolist') else res_ShrunkCovariance_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ShrunkCovariance_get_metadata_routing = {k: v for k, v in pms_ShrunkCovariance_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_get_metadata_routing = bridgeShrunkCovariance[${this.id}].get_metadata_routing(**pms_ShrunkCovariance_get_metadata_routing)`;
    return this._py`res_ShrunkCovariance_get_metadata_routing.tolist() if hasattr(res_ShrunkCovariance_get_metadata_routing, 'tolist') else res_ShrunkCovariance_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_ShrunkCovariance_get_precision = {k: v for k, v in pms_ShrunkCovariance_get_precision.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_get_precision = bridgeShrunkCovariance[${this.id}].get_precision(**pms_ShrunkCovariance_get_precision)`;
    return this._py`res_ShrunkCovariance_get_precision.tolist() if hasattr(res_ShrunkCovariance_get_precision, 'tolist') else res_ShrunkCovariance_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before mahalanobis()");
    }
    await this._py.ex`pms_ShrunkCovariance_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ShrunkCovariance_mahalanobis = {k: v for k, v in pms_ShrunkCovariance_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_mahalanobis = bridgeShrunkCovariance[${this.id}].mahalanobis(**pms_ShrunkCovariance_mahalanobis)`;
    return this._py`res_ShrunkCovariance_mahalanobis.tolist() if hasattr(res_ShrunkCovariance_mahalanobis, 'tolist') else res_ShrunkCovariance_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X\_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location\_` and `self.covariance\_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before score()");
    }
    await this._py.ex`pms_ShrunkCovariance_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_ShrunkCovariance_score = {k: v for k, v in pms_ShrunkCovariance_score.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_score = bridgeShrunkCovariance[${this.id}].score(**pms_ShrunkCovariance_score)`;
    return this._py`res_ShrunkCovariance_score.tolist() if hasattr(res_ShrunkCovariance_score, 'tolist') else res_ShrunkCovariance_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_ShrunkCovariance_set_score_request = {k: v for k, v in pms_ShrunkCovariance_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_set_score_request = bridgeShrunkCovariance[${this.id}].set_score_request(**pms_ShrunkCovariance_set_score_request)`;
    return this._py`res_ShrunkCovariance_set_score_request.tolist() if hasattr(res_ShrunkCovariance_set_score_request, 'tolist') else res_ShrunkCovariance_set_score_request`;
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_covariance_ = bridgeShrunkCovariance[${this.id}].covariance_`;
      return this._py`attr_ShrunkCovariance_covariance_.tolist() if hasattr(attr_ShrunkCovariance_covariance_, 'tolist') else attr_ShrunkCovariance_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_location_ = bridgeShrunkCovariance[${this.id}].location_`;
      return this._py`attr_ShrunkCovariance_location_.tolist() if hasattr(attr_ShrunkCovariance_location_, 'tolist') else attr_ShrunkCovariance_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store\_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_precision_ = bridgeShrunkCovariance[${this.id}].precision_`;
      return this._py`attr_ShrunkCovariance_precision_.tolist() if hasattr(attr_ShrunkCovariance_precision_, 'tolist') else attr_ShrunkCovariance_precision_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_n_features_in_ = bridgeShrunkCovariance[${this.id}].n_features_in_`;
      return this._py`attr_ShrunkCovariance_n_features_in_.tolist() if hasattr(attr_ShrunkCovariance_n_features_in_, 'tolist') else attr_ShrunkCovariance_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_feature_names_in_ = bridgeShrunkCovariance[${this.id}].feature_names_in_`;
      return this._py`attr_ShrunkCovariance_feature_names_in_.tolist() if hasattr(attr_ShrunkCovariance_feature_names_in_, 'tolist') else attr_ShrunkCovariance_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/CCA.ts
import crypto27 from "node:crypto";
var CCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CCA${crypto27.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import CCA
try: bridgeCCA
except NameError: bridgeCCA = {}
`;
    await this._py.ex`ctor_CCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_CCA = {k: v for k, v in ctor_CCA.items() if v is not None}`;
    await this._py.ex`bridgeCCA[${this.id}] = CCA(**ctor_CCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before fit()");
    }
    await this._py.ex`pms_CCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_CCA_fit = {k: v for k, v in pms_CCA_fit.items() if v is not None}`;
    await this._py.ex`res_CCA_fit = bridgeCCA[${this.id}].fit(**pms_CCA_fit)`;
    return this._py`res_CCA_fit.tolist() if hasattr(res_CCA_fit, 'tolist') else res_CCA_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_CCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_CCA_fit_transform = {k: v for k, v in pms_CCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_fit_transform = bridgeCCA[${this.id}].fit_transform(**pms_CCA_fit_transform)`;
    return this._py`res_CCA_fit_transform.tolist() if hasattr(res_CCA_fit_transform, 'tolist') else res_CCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_CCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_CCA_get_feature_names_out = {k: v for k, v in pms_CCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_CCA_get_feature_names_out = bridgeCCA[${this.id}].get_feature_names_out(**pms_CCA_get_feature_names_out)`;
    return this._py`res_CCA_get_feature_names_out.tolist() if hasattr(res_CCA_get_feature_names_out, 'tolist') else res_CCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_CCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CCA_get_metadata_routing = {k: v for k, v in pms_CCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CCA_get_metadata_routing = bridgeCCA[${this.id}].get_metadata_routing(**pms_CCA_get_metadata_routing)`;
    return this._py`res_CCA_get_metadata_routing.tolist() if hasattr(res_CCA_get_metadata_routing, 'tolist') else res_CCA_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_CCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_CCA_inverse_transform = {k: v for k, v in pms_CCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_inverse_transform = bridgeCCA[${this.id}].inverse_transform(**pms_CCA_inverse_transform)`;
    return this._py`res_CCA_inverse_transform.tolist() if hasattr(res_CCA_inverse_transform, 'tolist') else res_CCA_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before predict()");
    }
    await this._py.ex`pms_CCA_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_CCA_predict = {k: v for k, v in pms_CCA_predict.items() if v is not None}`;
    await this._py.ex`res_CCA_predict = bridgeCCA[${this.id}].predict(**pms_CCA_predict)`;
    return this._py`res_CCA_predict.tolist() if hasattr(res_CCA_predict, 'tolist') else res_CCA_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before score()");
    }
    await this._py.ex`pms_CCA_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CCA_score = {k: v for k, v in pms_CCA_score.items() if v is not None}`;
    await this._py.ex`res_CCA_score = bridgeCCA[${this.id}].score(**pms_CCA_score)`;
    return this._py`res_CCA_score.tolist() if hasattr(res_CCA_score, 'tolist') else res_CCA_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_output()");
    }
    await this._py.ex`pms_CCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_CCA_set_output = {k: v for k, v in pms_CCA_set_output.items() if v is not None}`;
    await this._py.ex`res_CCA_set_output = bridgeCCA[${this.id}].set_output(**pms_CCA_set_output)`;
    return this._py`res_CCA_set_output.tolist() if hasattr(res_CCA_set_output, 'tolist') else res_CCA_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_predict_request()");
    }
    await this._py.ex`pms_CCA_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_CCA_set_predict_request = {k: v for k, v in pms_CCA_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_predict_request = bridgeCCA[${this.id}].set_predict_request(**pms_CCA_set_predict_request)`;
    return this._py`res_CCA_set_predict_request.tolist() if hasattr(res_CCA_set_predict_request, 'tolist') else res_CCA_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_score_request()");
    }
    await this._py.ex`pms_CCA_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CCA_set_score_request = {k: v for k, v in pms_CCA_set_score_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_score_request = bridgeCCA[${this.id}].set_score_request(**pms_CCA_set_score_request)`;
    return this._py`res_CCA_set_score_request.tolist() if hasattr(res_CCA_set_score_request, 'tolist') else res_CCA_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_transform_request()");
    }
    await this._py.ex`pms_CCA_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_CCA_set_transform_request = {k: v for k, v in pms_CCA_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_transform_request = bridgeCCA[${this.id}].set_transform_request(**pms_CCA_set_transform_request)`;
    return this._py`res_CCA_set_transform_request.tolist() if hasattr(res_CCA_set_transform_request, 'tolist') else res_CCA_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before transform()");
    }
    await this._py.ex`pms_CCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_CCA_transform = {k: v for k, v in pms_CCA_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_transform = bridgeCCA[${this.id}].transform(**pms_CCA_transform)`;
    return this._py`res_CCA_transform.tolist() if hasattr(res_CCA_transform, 'tolist') else res_CCA_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_weights_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_weights_ = bridgeCCA[${this.id}].x_weights_`;
      return this._py`attr_CCA_x_weights_.tolist() if hasattr(attr_CCA_x_weights_, 'tolist') else attr_CCA_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_weights_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_weights_ = bridgeCCA[${this.id}].y_weights_`;
      return this._py`attr_CCA_y_weights_.tolist() if hasattr(attr_CCA_y_weights_, 'tolist') else attr_CCA_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_loadings_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_loadings_ = bridgeCCA[${this.id}].x_loadings_`;
      return this._py`attr_CCA_x_loadings_.tolist() if hasattr(attr_CCA_x_loadings_, 'tolist') else attr_CCA_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_loadings_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_loadings_ = bridgeCCA[${this.id}].y_loadings_`;
      return this._py`attr_CCA_y_loadings_.tolist() if hasattr(attr_CCA_y_loadings_, 'tolist') else attr_CCA_y_loadings_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_rotations_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_rotations_ = bridgeCCA[${this.id}].x_rotations_`;
      return this._py`attr_CCA_x_rotations_.tolist() if hasattr(attr_CCA_x_rotations_, 'tolist') else attr_CCA_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_rotations_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_rotations_ = bridgeCCA[${this.id}].y_rotations_`;
      return this._py`attr_CCA_y_rotations_.tolist() if hasattr(attr_CCA_y_rotations_, 'tolist') else attr_CCA_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_coef_ = bridgeCCA[${this.id}].coef_`;
      return this._py`attr_CCA_coef_.tolist() if hasattr(attr_CCA_coef_, 'tolist') else attr_CCA_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_intercept_ = bridgeCCA[${this.id}].intercept_`;
      return this._py`attr_CCA_intercept_.tolist() if hasattr(attr_CCA_intercept_, 'tolist') else attr_CCA_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_n_iter_ = bridgeCCA[${this.id}].n_iter_`;
      return this._py`attr_CCA_n_iter_.tolist() if hasattr(attr_CCA_n_iter_, 'tolist') else attr_CCA_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_n_features_in_ = bridgeCCA[${this.id}].n_features_in_`;
      return this._py`attr_CCA_n_features_in_.tolist() if hasattr(attr_CCA_n_features_in_, 'tolist') else attr_CCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_feature_names_in_ = bridgeCCA[${this.id}].feature_names_in_`;
      return this._py`attr_CCA_feature_names_in_.tolist() if hasattr(attr_CCA_feature_names_in_, 'tolist') else attr_CCA_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSCanonical.ts
import crypto28 from "node:crypto";
var PLSCanonical = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PLSCanonical${crypto28.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSCanonical.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSCanonical
try: bridgePLSCanonical
except NameError: bridgePLSCanonical = {}
`;
    await this._py.ex`ctor_PLSCanonical = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSCanonical = {k: v for k, v in ctor_PLSCanonical.items() if v is not None}`;
    await this._py.ex`bridgePLSCanonical[${this.id}] = PLSCanonical(**ctor_PLSCanonical)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSCanonical[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before fit()");
    }
    await this._py.ex`pms_PLSCanonical_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSCanonical_fit = {k: v for k, v in pms_PLSCanonical_fit.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_fit = bridgePLSCanonical[${this.id}].fit(**pms_PLSCanonical_fit)`;
    return this._py`res_PLSCanonical_fit.tolist() if hasattr(res_PLSCanonical_fit, 'tolist') else res_PLSCanonical_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSCanonical_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSCanonical_fit_transform = {k: v for k, v in pms_PLSCanonical_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_fit_transform = bridgePLSCanonical[${this.id}].fit_transform(**pms_PLSCanonical_fit_transform)`;
    return this._py`res_PLSCanonical_fit_transform.tolist() if hasattr(res_PLSCanonical_fit_transform, 'tolist') else res_PLSCanonical_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PLSCanonical_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSCanonical_get_feature_names_out = {k: v for k, v in pms_PLSCanonical_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_get_feature_names_out = bridgePLSCanonical[${this.id}].get_feature_names_out(**pms_PLSCanonical_get_feature_names_out)`;
    return this._py`res_PLSCanonical_get_feature_names_out.tolist() if hasattr(res_PLSCanonical_get_feature_names_out, 'tolist') else res_PLSCanonical_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PLSCanonical_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSCanonical_get_metadata_routing = {k: v for k, v in pms_PLSCanonical_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_get_metadata_routing = bridgePLSCanonical[${this.id}].get_metadata_routing(**pms_PLSCanonical_get_metadata_routing)`;
    return this._py`res_PLSCanonical_get_metadata_routing.tolist() if hasattr(res_PLSCanonical_get_metadata_routing, 'tolist') else res_PLSCanonical_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PLSCanonical_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSCanonical_inverse_transform = {k: v for k, v in pms_PLSCanonical_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_inverse_transform = bridgePLSCanonical[${this.id}].inverse_transform(**pms_PLSCanonical_inverse_transform)`;
    return this._py`res_PLSCanonical_inverse_transform.tolist() if hasattr(res_PLSCanonical_inverse_transform, 'tolist') else res_PLSCanonical_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before predict()");
    }
    await this._py.ex`pms_PLSCanonical_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_predict = {k: v for k, v in pms_PLSCanonical_predict.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_predict = bridgePLSCanonical[${this.id}].predict(**pms_PLSCanonical_predict)`;
    return this._py`res_PLSCanonical_predict.tolist() if hasattr(res_PLSCanonical_predict, 'tolist') else res_PLSCanonical_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before score()");
    }
    await this._py.ex`pms_PLSCanonical_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PLSCanonical_score = {k: v for k, v in pms_PLSCanonical_score.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_score = bridgePLSCanonical[${this.id}].score(**pms_PLSCanonical_score)`;
    return this._py`res_PLSCanonical_score.tolist() if hasattr(res_PLSCanonical_score, 'tolist') else res_PLSCanonical_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before set_output()");
    }
    await this._py.ex`pms_PLSCanonical_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSCanonical_set_output = {k: v for k, v in pms_PLSCanonical_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_output = bridgePLSCanonical[${this.id}].set_output(**pms_PLSCanonical_set_output)`;
    return this._py`res_PLSCanonical_set_output.tolist() if hasattr(res_PLSCanonical_set_output, 'tolist') else res_PLSCanonical_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_set_predict_request = {k: v for k, v in pms_PLSCanonical_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_predict_request = bridgePLSCanonical[${this.id}].set_predict_request(**pms_PLSCanonical_set_predict_request)`;
    return this._py`res_PLSCanonical_set_predict_request.tolist() if hasattr(res_PLSCanonical_set_predict_request, 'tolist') else res_PLSCanonical_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PLSCanonical_set_score_request = {k: v for k, v in pms_PLSCanonical_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_score_request = bridgePLSCanonical[${this.id}].set_score_request(**pms_PLSCanonical_set_score_request)`;
    return this._py`res_PLSCanonical_set_score_request.tolist() if hasattr(res_PLSCanonical_set_score_request, 'tolist') else res_PLSCanonical_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_set_transform_request = {k: v for k, v in pms_PLSCanonical_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_transform_request = bridgePLSCanonical[${this.id}].set_transform_request(**pms_PLSCanonical_set_transform_request)`;
    return this._py`res_PLSCanonical_set_transform_request.tolist() if hasattr(res_PLSCanonical_set_transform_request, 'tolist') else res_PLSCanonical_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before transform()");
    }
    await this._py.ex`pms_PLSCanonical_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_transform = {k: v for k, v in pms_PLSCanonical_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_transform = bridgePLSCanonical[${this.id}].transform(**pms_PLSCanonical_transform)`;
    return this._py`res_PLSCanonical_transform.tolist() if hasattr(res_PLSCanonical_transform, 'tolist') else res_PLSCanonical_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_weights_ = bridgePLSCanonical[${this.id}].x_weights_`;
      return this._py`attr_PLSCanonical_x_weights_.tolist() if hasattr(attr_PLSCanonical_x_weights_, 'tolist') else attr_PLSCanonical_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_weights_ = bridgePLSCanonical[${this.id}].y_weights_`;
      return this._py`attr_PLSCanonical_y_weights_.tolist() if hasattr(attr_PLSCanonical_y_weights_, 'tolist') else attr_PLSCanonical_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_loadings_ = bridgePLSCanonical[${this.id}].x_loadings_`;
      return this._py`attr_PLSCanonical_x_loadings_.tolist() if hasattr(attr_PLSCanonical_x_loadings_, 'tolist') else attr_PLSCanonical_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_loadings_ = bridgePLSCanonical[${this.id}].y_loadings_`;
      return this._py`attr_PLSCanonical_y_loadings_.tolist() if hasattr(attr_PLSCanonical_y_loadings_, 'tolist') else attr_PLSCanonical_y_loadings_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_rotations_ = bridgePLSCanonical[${this.id}].x_rotations_`;
      return this._py`attr_PLSCanonical_x_rotations_.tolist() if hasattr(attr_PLSCanonical_x_rotations_, 'tolist') else attr_PLSCanonical_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_rotations_ = bridgePLSCanonical[${this.id}].y_rotations_`;
      return this._py`attr_PLSCanonical_y_rotations_.tolist() if hasattr(attr_PLSCanonical_y_rotations_, 'tolist') else attr_PLSCanonical_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_coef_ = bridgePLSCanonical[${this.id}].coef_`;
      return this._py`attr_PLSCanonical_coef_.tolist() if hasattr(attr_PLSCanonical_coef_, 'tolist') else attr_PLSCanonical_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_intercept_ = bridgePLSCanonical[${this.id}].intercept_`;
      return this._py`attr_PLSCanonical_intercept_.tolist() if hasattr(attr_PLSCanonical_intercept_, 'tolist') else attr_PLSCanonical_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component. Empty if `algorithm='svd'`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_n_iter_ = bridgePLSCanonical[${this.id}].n_iter_`;
      return this._py`attr_PLSCanonical_n_iter_.tolist() if hasattr(attr_PLSCanonical_n_iter_, 'tolist') else attr_PLSCanonical_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_n_features_in_ = bridgePLSCanonical[${this.id}].n_features_in_`;
      return this._py`attr_PLSCanonical_n_features_in_.tolist() if hasattr(attr_PLSCanonical_n_features_in_, 'tolist') else attr_PLSCanonical_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_feature_names_in_ = bridgePLSCanonical[${this.id}].feature_names_in_`;
      return this._py`attr_PLSCanonical_feature_names_in_.tolist() if hasattr(attr_PLSCanonical_feature_names_in_, 'tolist') else attr_PLSCanonical_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSRegression.ts
import crypto29 from "node:crypto";
var PLSRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PLSRegression${crypto29.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSRegression
try: bridgePLSRegression
except NameError: bridgePLSRegression = {}
`;
    await this._py.ex`ctor_PLSRegression = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSRegression = {k: v for k, v in ctor_PLSRegression.items() if v is not None}`;
    await this._py.ex`bridgePLSRegression[${this.id}] = PLSRegression(**ctor_PLSRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before fit()");
    }
    await this._py.ex`pms_PLSRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSRegression_fit = {k: v for k, v in pms_PLSRegression_fit.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_fit = bridgePLSRegression[${this.id}].fit(**pms_PLSRegression_fit)`;
    return this._py`res_PLSRegression_fit.tolist() if hasattr(res_PLSRegression_fit, 'tolist') else res_PLSRegression_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSRegression_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSRegression_fit_transform = {k: v for k, v in pms_PLSRegression_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_fit_transform = bridgePLSRegression[${this.id}].fit_transform(**pms_PLSRegression_fit_transform)`;
    return this._py`res_PLSRegression_fit_transform.tolist() if hasattr(res_PLSRegression_fit_transform, 'tolist') else res_PLSRegression_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PLSRegression_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSRegression_get_feature_names_out = {k: v for k, v in pms_PLSRegression_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_get_feature_names_out = bridgePLSRegression[${this.id}].get_feature_names_out(**pms_PLSRegression_get_feature_names_out)`;
    return this._py`res_PLSRegression_get_feature_names_out.tolist() if hasattr(res_PLSRegression_get_feature_names_out, 'tolist') else res_PLSRegression_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PLSRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSRegression_get_metadata_routing = {k: v for k, v in pms_PLSRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_get_metadata_routing = bridgePLSRegression[${this.id}].get_metadata_routing(**pms_PLSRegression_get_metadata_routing)`;
    return this._py`res_PLSRegression_get_metadata_routing.tolist() if hasattr(res_PLSRegression_get_metadata_routing, 'tolist') else res_PLSRegression_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PLSRegression_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSRegression_inverse_transform = {k: v for k, v in pms_PLSRegression_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_inverse_transform = bridgePLSRegression[${this.id}].inverse_transform(**pms_PLSRegression_inverse_transform)`;
    return this._py`res_PLSRegression_inverse_transform.tolist() if hasattr(res_PLSRegression_inverse_transform, 'tolist') else res_PLSRegression_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before predict()");
    }
    await this._py.ex`pms_PLSRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_predict = {k: v for k, v in pms_PLSRegression_predict.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_predict = bridgePLSRegression[${this.id}].predict(**pms_PLSRegression_predict)`;
    return this._py`res_PLSRegression_predict.tolist() if hasattr(res_PLSRegression_predict, 'tolist') else res_PLSRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before score()");
    }
    await this._py.ex`pms_PLSRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PLSRegression_score = {k: v for k, v in pms_PLSRegression_score.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_score = bridgePLSRegression[${this.id}].score(**pms_PLSRegression_score)`;
    return this._py`res_PLSRegression_score.tolist() if hasattr(res_PLSRegression_score, 'tolist') else res_PLSRegression_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before set_output()");
    }
    await this._py.ex`pms_PLSRegression_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSRegression_set_output = {k: v for k, v in pms_PLSRegression_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_output = bridgePLSRegression[${this.id}].set_output(**pms_PLSRegression_set_output)`;
    return this._py`res_PLSRegression_set_output.tolist() if hasattr(res_PLSRegression_set_output, 'tolist') else res_PLSRegression_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_set_predict_request = {k: v for k, v in pms_PLSRegression_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_predict_request = bridgePLSRegression[${this.id}].set_predict_request(**pms_PLSRegression_set_predict_request)`;
    return this._py`res_PLSRegression_set_predict_request.tolist() if hasattr(res_PLSRegression_set_predict_request, 'tolist') else res_PLSRegression_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PLSRegression_set_score_request = {k: v for k, v in pms_PLSRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_score_request = bridgePLSRegression[${this.id}].set_score_request(**pms_PLSRegression_set_score_request)`;
    return this._py`res_PLSRegression_set_score_request.tolist() if hasattr(res_PLSRegression_set_score_request, 'tolist') else res_PLSRegression_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_set_transform_request = {k: v for k, v in pms_PLSRegression_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_transform_request = bridgePLSRegression[${this.id}].set_transform_request(**pms_PLSRegression_set_transform_request)`;
    return this._py`res_PLSRegression_set_transform_request.tolist() if hasattr(res_PLSRegression_set_transform_request, 'tolist') else res_PLSRegression_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before transform()");
    }
    await this._py.ex`pms_PLSRegression_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_transform = {k: v for k, v in pms_PLSRegression_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_transform = bridgePLSRegression[${this.id}].transform(**pms_PLSRegression_transform)`;
    return this._py`res_PLSRegression_transform.tolist() if hasattr(res_PLSRegression_transform, 'tolist') else res_PLSRegression_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_weights_ = bridgePLSRegression[${this.id}].x_weights_`;
      return this._py`attr_PLSRegression_x_weights_.tolist() if hasattr(attr_PLSRegression_x_weights_, 'tolist') else attr_PLSRegression_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_weights_ = bridgePLSRegression[${this.id}].y_weights_`;
      return this._py`attr_PLSRegression_y_weights_.tolist() if hasattr(attr_PLSRegression_y_weights_, 'tolist') else attr_PLSRegression_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_loadings_ = bridgePLSRegression[${this.id}].x_loadings_`;
      return this._py`attr_PLSRegression_x_loadings_.tolist() if hasattr(attr_PLSRegression_x_loadings_, 'tolist') else attr_PLSRegression_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_loadings_ = bridgePLSRegression[${this.id}].y_loadings_`;
      return this._py`attr_PLSRegression_y_loadings_.tolist() if hasattr(attr_PLSRegression_y_loadings_, 'tolist') else attr_PLSRegression_y_loadings_`;
    })();
  }
  /**
    The transformed training samples.
   */
  get x_scores_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_scores_ = bridgePLSRegression[${this.id}].x_scores_`;
      return this._py`attr_PLSRegression_x_scores_.tolist() if hasattr(attr_PLSRegression_x_scores_, 'tolist') else attr_PLSRegression_x_scores_`;
    })();
  }
  /**
    The transformed training targets.
   */
  get y_scores_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_scores_ = bridgePLSRegression[${this.id}].y_scores_`;
      return this._py`attr_PLSRegression_y_scores_.tolist() if hasattr(attr_PLSRegression_y_scores_, 'tolist') else attr_PLSRegression_y_scores_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_rotations_ = bridgePLSRegression[${this.id}].x_rotations_`;
      return this._py`attr_PLSRegression_x_rotations_.tolist() if hasattr(attr_PLSRegression_x_rotations_, 'tolist') else attr_PLSRegression_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_rotations_ = bridgePLSRegression[${this.id}].y_rotations_`;
      return this._py`attr_PLSRegression_y_rotations_.tolist() if hasattr(attr_PLSRegression_y_rotations_, 'tolist') else attr_PLSRegression_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_coef_ = bridgePLSRegression[${this.id}].coef_`;
      return this._py`attr_PLSRegression_coef_.tolist() if hasattr(attr_PLSRegression_coef_, 'tolist') else attr_PLSRegression_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef\_.T + intercept\_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_intercept_ = bridgePLSRegression[${this.id}].intercept_`;
      return this._py`attr_PLSRegression_intercept_.tolist() if hasattr(attr_PLSRegression_intercept_, 'tolist') else attr_PLSRegression_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_n_iter_ = bridgePLSRegression[${this.id}].n_iter_`;
      return this._py`attr_PLSRegression_n_iter_.tolist() if hasattr(attr_PLSRegression_n_iter_, 'tolist') else attr_PLSRegression_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_n_features_in_ = bridgePLSRegression[${this.id}].n_features_in_`;
      return this._py`attr_PLSRegression_n_features_in_.tolist() if hasattr(attr_PLSRegression_n_features_in_, 'tolist') else attr_PLSRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_feature_names_in_ = bridgePLSRegression[${this.id}].feature_names_in_`;
      return this._py`attr_PLSRegression_feature_names_in_.tolist() if hasattr(attr_PLSRegression_feature_names_in_, 'tolist') else attr_PLSRegression_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSSVD.ts
import crypto30 from "node:crypto";
var PLSSVD = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PLSSVD${crypto30.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSSVD.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSSVD
try: bridgePLSSVD
except NameError: bridgePLSSVD = {}
`;
    await this._py.ex`ctor_PLSSVD = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSSVD = {k: v for k, v in ctor_PLSSVD.items() if v is not None}`;
    await this._py.ex`bridgePLSSVD[${this.id}] = PLSSVD(**ctor_PLSSVD)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSSVD[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before fit()");
    }
    await this._py.ex`pms_PLSSVD_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSSVD_fit = {k: v for k, v in pms_PLSSVD_fit.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_fit = bridgePLSSVD[${this.id}].fit(**pms_PLSSVD_fit)`;
    return this._py`res_PLSSVD_fit.tolist() if hasattr(res_PLSSVD_fit, 'tolist') else res_PLSSVD_fit`;
  }
  /**
    Learn and apply the dimensionality reduction.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSSVD_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSSVD_fit_transform = {k: v for k, v in pms_PLSSVD_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_fit_transform = bridgePLSSVD[${this.id}].fit_transform(**pms_PLSSVD_fit_transform)`;
    return this._py`res_PLSSVD_fit_transform.tolist() if hasattr(res_PLSSVD_fit_transform, 'tolist') else res_PLSSVD_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_PLSSVD_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSSVD_get_feature_names_out = {k: v for k, v in pms_PLSSVD_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_get_feature_names_out = bridgePLSSVD[${this.id}].get_feature_names_out(**pms_PLSSVD_get_feature_names_out)`;
    return this._py`res_PLSSVD_get_feature_names_out.tolist() if hasattr(res_PLSSVD_get_feature_names_out, 'tolist') else res_PLSSVD_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_PLSSVD_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSSVD_get_metadata_routing = {k: v for k, v in pms_PLSSVD_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_get_metadata_routing = bridgePLSSVD[${this.id}].get_metadata_routing(**pms_PLSSVD_get_metadata_routing)`;
    return this._py`res_PLSSVD_get_metadata_routing.tolist() if hasattr(res_PLSSVD_get_metadata_routing, 'tolist') else res_PLSSVD_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before set_output()");
    }
    await this._py.ex`pms_PLSSVD_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSSVD_set_output = {k: v for k, v in pms_PLSSVD_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_set_output = bridgePLSSVD[${this.id}].set_output(**pms_PLSSVD_set_output)`;
    return this._py`res_PLSSVD_set_output.tolist() if hasattr(res_PLSSVD_set_output, 'tolist') else res_PLSSVD_set_output`;
  }
  /**
    Apply the dimensionality reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before transform()");
    }
    await this._py.ex`pms_PLSSVD_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSSVD_transform = {k: v for k, v in pms_PLSSVD_transform.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_transform = bridgePLSSVD[${this.id}].transform(**pms_PLSSVD_transform)`;
    return this._py`res_PLSSVD_transform.tolist() if hasattr(res_PLSSVD_transform, 'tolist') else res_PLSSVD_transform`;
  }
  /**
    The left singular vectors of the SVD of the cross-covariance matrix. Used to project `X` in [`transform`](#sklearn.cross_decomposition.PLSSVD.transform "sklearn.cross_decomposition.PLSSVD.transform").
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing x_weights_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_x_weights_ = bridgePLSSVD[${this.id}].x_weights_`;
      return this._py`attr_PLSSVD_x_weights_.tolist() if hasattr(attr_PLSSVD_x_weights_, 'tolist') else attr_PLSSVD_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the SVD of the cross-covariance matrix. Used to project `X` in [`transform`](#sklearn.cross_decomposition.PLSSVD.transform "sklearn.cross_decomposition.PLSSVD.transform").
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing y_weights_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_y_weights_ = bridgePLSSVD[${this.id}].y_weights_`;
      return this._py`attr_PLSSVD_y_weights_.tolist() if hasattr(attr_PLSSVD_y_weights_, 'tolist') else attr_PLSSVD_y_weights_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_n_features_in_ = bridgePLSSVD[${this.id}].n_features_in_`;
      return this._py`attr_PLSSVD_n_features_in_.tolist() if hasattr(attr_PLSSVD_n_features_in_, 'tolist') else attr_PLSSVD_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSSVD must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_feature_names_in_ = bridgePLSSVD[${this.id}].feature_names_in_`;
      return this._py`attr_PLSSVD_feature_names_in_.tolist() if hasattr(attr_PLSSVD_feature_names_in_, 'tolist') else attr_PLSSVD_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/DictionaryLearning.ts
import crypto31 from "node:crypto";
var DictionaryLearning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DictionaryLearning${crypto31.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import DictionaryLearning
try: bridgeDictionaryLearning
except NameError: bridgeDictionaryLearning = {}
`;
    await this._py.ex`ctor_DictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'code_init': np.array(${this.opts["code_init"] ?? void 0}) if ${this.opts["code_init"] !== void 0} else None, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'callback': ${this.opts["callback"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_DictionaryLearning = {k: v for k, v in ctor_DictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeDictionaryLearning[${this.id}] = DictionaryLearning(**ctor_DictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before fit()");
    }
    await this._py.ex`pms_DictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit = {k: v for k, v in pms_DictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit = bridgeDictionaryLearning[${this.id}].fit(**pms_DictionaryLearning_fit)`;
    return this._py`res_DictionaryLearning_fit.tolist() if hasattr(res_DictionaryLearning_fit, 'tolist') else res_DictionaryLearning_fit`;
  }
  /**
    Fit the model from data in X and return the transformed data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit_transform = {k: v for k, v in pms_DictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit_transform = bridgeDictionaryLearning[${this.id}].fit_transform(**pms_DictionaryLearning_fit_transform)`;
    return this._py`res_DictionaryLearning_fit_transform.tolist() if hasattr(res_DictionaryLearning_fit_transform, 'tolist') else res_DictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_DictionaryLearning_get_feature_names_out = {k: v for k, v in pms_DictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_feature_names_out = bridgeDictionaryLearning[${this.id}].get_feature_names_out(**pms_DictionaryLearning_get_feature_names_out)`;
    return this._py`res_DictionaryLearning_get_feature_names_out.tolist() if hasattr(res_DictionaryLearning_get_feature_names_out, 'tolist') else res_DictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DictionaryLearning_get_metadata_routing = {k: v for k, v in pms_DictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_metadata_routing = bridgeDictionaryLearning[${this.id}].get_metadata_routing(**pms_DictionaryLearning_get_metadata_routing)`;
    return this._py`res_DictionaryLearning_get_metadata_routing.tolist() if hasattr(res_DictionaryLearning_get_metadata_routing, 'tolist') else res_DictionaryLearning_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before set_output()");
    }
    await this._py.ex`pms_DictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_DictionaryLearning_set_output = {k: v for k, v in pms_DictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_set_output = bridgeDictionaryLearning[${this.id}].set_output(**pms_DictionaryLearning_set_output)`;
    return this._py`res_DictionaryLearning_set_output.tolist() if hasattr(res_DictionaryLearning_set_output, 'tolist') else res_DictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before transform()");
    }
    await this._py.ex`pms_DictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DictionaryLearning_transform = {k: v for k, v in pms_DictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_transform = bridgeDictionaryLearning[${this.id}].transform(**pms_DictionaryLearning_transform)`;
    return this._py`res_DictionaryLearning_transform.tolist() if hasattr(res_DictionaryLearning_transform, 'tolist') else res_DictionaryLearning_transform`;
  }
  /**
    dictionary atoms extracted from the data
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_components_ = bridgeDictionaryLearning[${this.id}].components_`;
      return this._py`attr_DictionaryLearning_components_.tolist() if hasattr(attr_DictionaryLearning_components_, 'tolist') else attr_DictionaryLearning_components_`;
    })();
  }
  /**
    vector of errors at each iteration
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing error_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_error_ = bridgeDictionaryLearning[${this.id}].error_`;
      return this._py`attr_DictionaryLearning_error_.tolist() if hasattr(attr_DictionaryLearning_error_, 'tolist') else attr_DictionaryLearning_error_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_features_in_ = bridgeDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_DictionaryLearning_n_features_in_.tolist() if hasattr(attr_DictionaryLearning_n_features_in_, 'tolist') else attr_DictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_feature_names_in_ = bridgeDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_DictionaryLearning_feature_names_in_.tolist() if hasattr(attr_DictionaryLearning_feature_names_in_, 'tolist') else attr_DictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_iter_ = bridgeDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_DictionaryLearning_n_iter_.tolist() if hasattr(attr_DictionaryLearning_n_iter_, 'tolist') else attr_DictionaryLearning_n_iter_`;
    })();
  }
};

// src/generated/decomposition/FactorAnalysis.ts
import crypto32 from "node:crypto";
var FactorAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FactorAnalysis${crypto32.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FactorAnalysis.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FactorAnalysis
try: bridgeFactorAnalysis
except NameError: bridgeFactorAnalysis = {}
`;
    await this._py.ex`ctor_FactorAnalysis = {'n_components': ${this.opts["n_components"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'noise_variance_init': np.array(${this.opts["noise_variance_init"] ?? void 0}) if ${this.opts["noise_variance_init"] !== void 0} else None, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'rotation': ${this.opts["rotation"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FactorAnalysis = {k: v for k, v in ctor_FactorAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeFactorAnalysis[${this.id}] = FactorAnalysis(**ctor_FactorAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFactorAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the FactorAnalysis model to X using SVD based approach.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit()");
    }
    await this._py.ex`pms_FactorAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_fit = {k: v for k, v in pms_FactorAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit = bridgeFactorAnalysis[${this.id}].fit(**pms_FactorAnalysis_fit)`;
    return this._py`res_FactorAnalysis_fit.tolist() if hasattr(res_FactorAnalysis_fit, 'tolist') else res_FactorAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit_transform()");
    }
    await this._py.ex`pms_FactorAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FactorAnalysis_fit_transform = {k: v for k, v in pms_FactorAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit_transform = bridgeFactorAnalysis[${this.id}].fit_transform(**pms_FactorAnalysis_fit_transform)`;
    return this._py`res_FactorAnalysis_fit_transform.tolist() if hasattr(res_FactorAnalysis_fit_transform, 'tolist') else res_FactorAnalysis_fit_transform`;
  }
  /**
      Compute data covariance with the FactorAnalysis model.
  
      `cov \= components\_.T \* components\_ + diag(noise\_variance)`
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_covariance()");
    }
    await this._py.ex`pms_FactorAnalysis_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_FactorAnalysis_get_covariance = {k: v for k, v in pms_FactorAnalysis_get_covariance.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_covariance = bridgeFactorAnalysis[${this.id}].get_covariance(**pms_FactorAnalysis_get_covariance)`;
    return this._py`res_FactorAnalysis_get_covariance.tolist() if hasattr(res_FactorAnalysis_get_covariance, 'tolist') else res_FactorAnalysis_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FactorAnalysis_get_feature_names_out = {k: v for k, v in pms_FactorAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_feature_names_out = bridgeFactorAnalysis[${this.id}].get_feature_names_out(**pms_FactorAnalysis_get_feature_names_out)`;
    return this._py`res_FactorAnalysis_get_feature_names_out.tolist() if hasattr(res_FactorAnalysis_get_feature_names_out, 'tolist') else res_FactorAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FactorAnalysis_get_metadata_routing = {k: v for k, v in pms_FactorAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_metadata_routing = bridgeFactorAnalysis[${this.id}].get_metadata_routing(**pms_FactorAnalysis_get_metadata_routing)`;
    return this._py`res_FactorAnalysis_get_metadata_routing.tolist() if hasattr(res_FactorAnalysis_get_metadata_routing, 'tolist') else res_FactorAnalysis_get_metadata_routing`;
  }
  /**
    Compute data precision matrix with the FactorAnalysis model.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_precision()");
    }
    await this._py.ex`pms_FactorAnalysis_get_precision = {'precision': np.array(${opts["precision"] ?? void 0}) if ${opts["precision"] !== void 0} else None}

pms_FactorAnalysis_get_precision = {k: v for k, v in pms_FactorAnalysis_get_precision.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_precision = bridgeFactorAnalysis[${this.id}].get_precision(**pms_FactorAnalysis_get_precision)`;
    return this._py`res_FactorAnalysis_get_precision.tolist() if hasattr(res_FactorAnalysis_get_precision, 'tolist') else res_FactorAnalysis_get_precision`;
  }
  /**
    Compute the average log-likelihood of the samples.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score()");
    }
    await this._py.ex`pms_FactorAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_score = {k: v for k, v in pms_FactorAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score = bridgeFactorAnalysis[${this.id}].score(**pms_FactorAnalysis_score)`;
    return this._py`res_FactorAnalysis_score.tolist() if hasattr(res_FactorAnalysis_score, 'tolist') else res_FactorAnalysis_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score_samples()");
    }
    await this._py.ex`pms_FactorAnalysis_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_score_samples = {k: v for k, v in pms_FactorAnalysis_score_samples.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score_samples = bridgeFactorAnalysis[${this.id}].score_samples(**pms_FactorAnalysis_score_samples)`;
    return this._py`res_FactorAnalysis_score_samples.tolist() if hasattr(res_FactorAnalysis_score_samples, 'tolist') else res_FactorAnalysis_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before set_output()");
    }
    await this._py.ex`pms_FactorAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FactorAnalysis_set_output = {k: v for k, v in pms_FactorAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_set_output = bridgeFactorAnalysis[${this.id}].set_output(**pms_FactorAnalysis_set_output)`;
    return this._py`res_FactorAnalysis_set_output.tolist() if hasattr(res_FactorAnalysis_set_output, 'tolist') else res_FactorAnalysis_set_output`;
  }
  /**
      Apply dimensionality reduction to X using the model.
  
      Compute the expected mean of the latent variables. See Barber, 21.2.33 (or Bishop, 12.66).
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before transform()");
    }
    await this._py.ex`pms_FactorAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_transform = {k: v for k, v in pms_FactorAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_transform = bridgeFactorAnalysis[${this.id}].transform(**pms_FactorAnalysis_transform)`;
    return this._py`res_FactorAnalysis_transform.tolist() if hasattr(res_FactorAnalysis_transform, 'tolist') else res_FactorAnalysis_transform`;
  }
  /**
    Components with maximum variance.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_components_ = bridgeFactorAnalysis[${this.id}].components_`;
      return this._py`attr_FactorAnalysis_components_.tolist() if hasattr(attr_FactorAnalysis_components_, 'tolist') else attr_FactorAnalysis_components_`;
    })();
  }
  /**
    The log likelihood at each iteration.
   */
  get loglike_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing loglike_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_loglike_ = bridgeFactorAnalysis[${this.id}].loglike_`;
      return this._py`attr_FactorAnalysis_loglike_.tolist() if hasattr(attr_FactorAnalysis_loglike_, 'tolist') else attr_FactorAnalysis_loglike_`;
    })();
  }
  /**
    The estimated noise variance for each feature.
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_noise_variance_ = bridgeFactorAnalysis[${this.id}].noise_variance_`;
      return this._py`attr_FactorAnalysis_noise_variance_.tolist() if hasattr(attr_FactorAnalysis_noise_variance_, 'tolist') else attr_FactorAnalysis_noise_variance_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_iter_ = bridgeFactorAnalysis[${this.id}].n_iter_`;
      return this._py`attr_FactorAnalysis_n_iter_.tolist() if hasattr(attr_FactorAnalysis_n_iter_, 'tolist') else attr_FactorAnalysis_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_mean_ = bridgeFactorAnalysis[${this.id}].mean_`;
      return this._py`attr_FactorAnalysis_mean_.tolist() if hasattr(attr_FactorAnalysis_mean_, 'tolist') else attr_FactorAnalysis_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_features_in_ = bridgeFactorAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_FactorAnalysis_n_features_in_.tolist() if hasattr(attr_FactorAnalysis_n_features_in_, 'tolist') else attr_FactorAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_feature_names_in_ = bridgeFactorAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_FactorAnalysis_feature_names_in_.tolist() if hasattr(attr_FactorAnalysis_feature_names_in_, 'tolist') else attr_FactorAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/FastICA.ts
import crypto33 from "node:crypto";
var FastICA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FastICA${crypto33.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FastICA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FastICA
try: bridgeFastICA
except NameError: bridgeFastICA = {}
`;
    await this._py.ex`ctor_FastICA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'fun': ${this.opts["fun"] ?? void 0}, 'fun_args': ${this.opts["fun_args"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'w_init': np.array(${this.opts["w_init"] ?? void 0}) if ${this.opts["w_init"] !== void 0} else None, 'whiten_solver': ${this.opts["whiten_solver"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FastICA = {k: v for k, v in ctor_FastICA.items() if v is not None}`;
    await this._py.ex`bridgeFastICA[${this.id}] = FastICA(**ctor_FastICA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFastICA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit()");
    }
    await this._py.ex`pms_FastICA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit = {k: v for k, v in pms_FastICA_fit.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit = bridgeFastICA[${this.id}].fit(**pms_FastICA_fit)`;
    return this._py`res_FastICA_fit.tolist() if hasattr(res_FastICA_fit, 'tolist') else res_FastICA_fit`;
  }
  /**
    Fit the model and recover the sources from X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit_transform()");
    }
    await this._py.ex`pms_FastICA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit_transform = {k: v for k, v in pms_FastICA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit_transform = bridgeFastICA[${this.id}].fit_transform(**pms_FastICA_fit_transform)`;
    return this._py`res_FastICA_fit_transform.tolist() if hasattr(res_FastICA_fit_transform, 'tolist') else res_FastICA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_FastICA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FastICA_get_feature_names_out = {k: v for k, v in pms_FastICA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_feature_names_out = bridgeFastICA[${this.id}].get_feature_names_out(**pms_FastICA_get_feature_names_out)`;
    return this._py`res_FastICA_get_feature_names_out.tolist() if hasattr(res_FastICA_get_feature_names_out, 'tolist') else res_FastICA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_FastICA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FastICA_get_metadata_routing = {k: v for k, v in pms_FastICA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_metadata_routing = bridgeFastICA[${this.id}].get_metadata_routing(**pms_FastICA_get_metadata_routing)`;
    return this._py`res_FastICA_get_metadata_routing.tolist() if hasattr(res_FastICA_get_metadata_routing, 'tolist') else res_FastICA_get_metadata_routing`;
  }
  /**
    Transform the sources back to the mixed data (apply mixing matrix).
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_FastICA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_inverse_transform = {k: v for k, v in pms_FastICA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_inverse_transform = bridgeFastICA[${this.id}].inverse_transform(**pms_FastICA_inverse_transform)`;
    return this._py`res_FastICA_inverse_transform.tolist() if hasattr(res_FastICA_inverse_transform, 'tolist') else res_FastICA_inverse_transform`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_FastICA_set_inverse_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_inverse_transform_request = {k: v for k, v in pms_FastICA_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_inverse_transform_request = bridgeFastICA[${this.id}].set_inverse_transform_request(**pms_FastICA_set_inverse_transform_request)`;
    return this._py`res_FastICA_set_inverse_transform_request.tolist() if hasattr(res_FastICA_set_inverse_transform_request, 'tolist') else res_FastICA_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_output()");
    }
    await this._py.ex`pms_FastICA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FastICA_set_output = {k: v for k, v in pms_FastICA_set_output.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_output = bridgeFastICA[${this.id}].set_output(**pms_FastICA_set_output)`;
    return this._py`res_FastICA_set_output.tolist() if hasattr(res_FastICA_set_output, 'tolist') else res_FastICA_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_transform_request()");
    }
    await this._py.ex`pms_FastICA_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_transform_request = {k: v for k, v in pms_FastICA_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_transform_request = bridgeFastICA[${this.id}].set_transform_request(**pms_FastICA_set_transform_request)`;
    return this._py`res_FastICA_set_transform_request.tolist() if hasattr(res_FastICA_set_transform_request, 'tolist') else res_FastICA_set_transform_request`;
  }
  /**
    Recover the sources from X (apply the unmixing matrix).
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before transform()");
    }
    await this._py.ex`pms_FastICA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_transform = {k: v for k, v in pms_FastICA_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_transform = bridgeFastICA[${this.id}].transform(**pms_FastICA_transform)`;
    return this._py`res_FastICA_transform.tolist() if hasattr(res_FastICA_transform, 'tolist') else res_FastICA_transform`;
  }
  /**
    The linear operator to apply to the data to get the independent sources. This is equal to the unmixing matrix when `whiten` is `false`, and equal to `np.dot(unmixing\_matrix, self.whitening\_)` when `whiten` is `true`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_components_ = bridgeFastICA[${this.id}].components_`;
      return this._py`attr_FastICA_components_.tolist() if hasattr(attr_FastICA_components_, 'tolist') else attr_FastICA_components_`;
    })();
  }
  /**
    The pseudo-inverse of `components\_`. It is the linear operator that maps independent sources to the data.
   */
  get mixing_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mixing_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mixing_ = bridgeFastICA[${this.id}].mixing_`;
      return this._py`attr_FastICA_mixing_.tolist() if hasattr(attr_FastICA_mixing_, 'tolist') else attr_FastICA_mixing_`;
    })();
  }
  /**
    The mean over features. Only set if `self.whiten` is `true`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mean_ = bridgeFastICA[${this.id}].mean_`;
      return this._py`attr_FastICA_mean_.tolist() if hasattr(attr_FastICA_mean_, 'tolist') else attr_FastICA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_features_in_ = bridgeFastICA[${this.id}].n_features_in_`;
      return this._py`attr_FastICA_n_features_in_.tolist() if hasattr(attr_FastICA_n_features_in_, 'tolist') else attr_FastICA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_feature_names_in_ = bridgeFastICA[${this.id}].feature_names_in_`;
      return this._py`attr_FastICA_feature_names_in_.tolist() if hasattr(attr_FastICA_feature_names_in_, 'tolist') else attr_FastICA_feature_names_in_`;
    })();
  }
  /**
    If the algorithm is â€œdeflationâ€, n\_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_iter_ = bridgeFastICA[${this.id}].n_iter_`;
      return this._py`attr_FastICA_n_iter_.tolist() if hasattr(attr_FastICA_n_iter_, 'tolist') else attr_FastICA_n_iter_`;
    })();
  }
  /**
    Only set if whiten is â€˜`true`â€™. This is the pre-whitening matrix that projects data onto the first `n\_components` principal components.
   */
  get whitening_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing whitening_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_whitening_ = bridgeFastICA[${this.id}].whitening_`;
      return this._py`attr_FastICA_whitening_.tolist() if hasattr(attr_FastICA_whitening_, 'tolist') else attr_FastICA_whitening_`;
    })();
  }
};

// src/generated/decomposition/IncrementalPCA.ts
import crypto34 from "node:crypto";
var IncrementalPCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `IncrementalPCA${crypto34.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IncrementalPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import IncrementalPCA
try: bridgeIncrementalPCA
except NameError: bridgeIncrementalPCA = {}
`;
    await this._py.ex`ctor_IncrementalPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}}

ctor_IncrementalPCA = {k: v for k, v in ctor_IncrementalPCA.items() if v is not None}`;
    await this._py.ex`bridgeIncrementalPCA[${this.id}] = IncrementalPCA(**ctor_IncrementalPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIncrementalPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X, using minibatches of size batch\_size.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit()");
    }
    await this._py.ex`pms_IncrementalPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_IncrementalPCA_fit = {k: v for k, v in pms_IncrementalPCA_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit = bridgeIncrementalPCA[${this.id}].fit(**pms_IncrementalPCA_fit)`;
    return this._py`res_IncrementalPCA_fit.tolist() if hasattr(res_IncrementalPCA_fit, 'tolist') else res_IncrementalPCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_IncrementalPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_IncrementalPCA_fit_transform = {k: v for k, v in pms_IncrementalPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit_transform = bridgeIncrementalPCA[${this.id}].fit_transform(**pms_IncrementalPCA_fit_transform)`;
    return this._py`res_IncrementalPCA_fit_transform.tolist() if hasattr(res_IncrementalPCA_fit_transform, 'tolist') else res_IncrementalPCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components\_.T \* S\*\*2 \* components\_ + sigma2 \* eye(n\_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_IncrementalPCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_IncrementalPCA_get_covariance = {k: v for k, v in pms_IncrementalPCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_covariance = bridgeIncrementalPCA[${this.id}].get_covariance(**pms_IncrementalPCA_get_covariance)`;
    return this._py`res_IncrementalPCA_get_covariance.tolist() if hasattr(res_IncrementalPCA_get_covariance, 'tolist') else res_IncrementalPCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_IncrementalPCA_get_feature_names_out = {k: v for k, v in pms_IncrementalPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_feature_names_out = bridgeIncrementalPCA[${this.id}].get_feature_names_out(**pms_IncrementalPCA_get_feature_names_out)`;
    return this._py`res_IncrementalPCA_get_feature_names_out.tolist() if hasattr(res_IncrementalPCA_get_feature_names_out, 'tolist') else res_IncrementalPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IncrementalPCA_get_metadata_routing = {k: v for k, v in pms_IncrementalPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_metadata_routing = bridgeIncrementalPCA[${this.id}].get_metadata_routing(**pms_IncrementalPCA_get_metadata_routing)`;
    return this._py`res_IncrementalPCA_get_metadata_routing.tolist() if hasattr(res_IncrementalPCA_get_metadata_routing, 'tolist') else res_IncrementalPCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_precision()");
    }
    await this._py.ex`pms_IncrementalPCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_IncrementalPCA_get_precision = {k: v for k, v in pms_IncrementalPCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_precision = bridgeIncrementalPCA[${this.id}].get_precision(**pms_IncrementalPCA_get_precision)`;
    return this._py`res_IncrementalPCA_get_precision.tolist() if hasattr(res_IncrementalPCA_get_precision, 'tolist') else res_IncrementalPCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X\_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_inverse_transform = {k: v for k, v in pms_IncrementalPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_inverse_transform = bridgeIncrementalPCA[${this.id}].inverse_transform(**pms_IncrementalPCA_inverse_transform)`;
    return this._py`res_IncrementalPCA_inverse_transform.tolist() if hasattr(res_IncrementalPCA_inverse_transform, 'tolist') else res_IncrementalPCA_inverse_transform`;
  }
  /**
    Incremental fit with X. All of X is processed as a single batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before partial_fit()");
    }
    await this._py.ex`pms_IncrementalPCA_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_partial_fit = {k: v for k, v in pms_IncrementalPCA_partial_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_partial_fit = bridgeIncrementalPCA[${this.id}].partial_fit(**pms_IncrementalPCA_partial_fit)`;
    return this._py`res_IncrementalPCA_partial_fit.tolist() if hasattr(res_IncrementalPCA_partial_fit, 'tolist') else res_IncrementalPCA_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before set_output()");
    }
    await this._py.ex`pms_IncrementalPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_IncrementalPCA_set_output = {k: v for k, v in pms_IncrementalPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_output = bridgeIncrementalPCA[${this.id}].set_output(**pms_IncrementalPCA_set_output)`;
    return this._py`res_IncrementalPCA_set_output.tolist() if hasattr(res_IncrementalPCA_set_output, 'tolist') else res_IncrementalPCA_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_set_partial_fit_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_set_partial_fit_request = {k: v for k, v in pms_IncrementalPCA_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_partial_fit_request = bridgeIncrementalPCA[${this.id}].set_partial_fit_request(**pms_IncrementalPCA_set_partial_fit_request)`;
    return this._py`res_IncrementalPCA_set_partial_fit_request.tolist() if hasattr(res_IncrementalPCA_set_partial_fit_request, 'tolist') else res_IncrementalPCA_set_partial_fit_request`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set, using minibatches of size batch\_size if X is sparse.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before transform()");
    }
    await this._py.ex`pms_IncrementalPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_transform = {k: v for k, v in pms_IncrementalPCA_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_transform = bridgeIncrementalPCA[${this.id}].transform(**pms_IncrementalPCA_transform)`;
    return this._py`res_IncrementalPCA_transform.tolist() if hasattr(res_IncrementalPCA_transform, 'tolist') else res_IncrementalPCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\_variance\_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_components_ = bridgeIncrementalPCA[${this.id}].components_`;
      return this._py`attr_IncrementalPCA_components_.tolist() if hasattr(attr_IncrementalPCA_components_, 'tolist') else attr_IncrementalPCA_components_`;
    })();
  }
  /**
    Variance explained by each of the selected components.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ = bridgeIncrementalPCA[${this.id}].explained_variance_`;
      return this._py`attr_IncrementalPCA_explained_variance_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_, 'tolist') else attr_IncrementalPCA_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ratio_ = bridgeIncrementalPCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_IncrementalPCA_explained_variance_ratio_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_ratio_, 'tolist') else attr_IncrementalPCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_singular_values_ = bridgeIncrementalPCA[${this.id}].singular_values_`;
      return this._py`attr_IncrementalPCA_singular_values_.tolist() if hasattr(attr_IncrementalPCA_singular_values_, 'tolist') else attr_IncrementalPCA_singular_values_`;
    })();
  }
  /**
    Per-feature empirical mean, aggregate over calls to `partial\_fit`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_mean_ = bridgeIncrementalPCA[${this.id}].mean_`;
      return this._py`attr_IncrementalPCA_mean_.tolist() if hasattr(attr_IncrementalPCA_mean_, 'tolist') else attr_IncrementalPCA_mean_`;
    })();
  }
  /**
    Per-feature empirical variance, aggregate over calls to `partial\_fit`.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_var_ = bridgeIncrementalPCA[${this.id}].var_`;
      return this._py`attr_IncrementalPCA_var_.tolist() if hasattr(attr_IncrementalPCA_var_, 'tolist') else attr_IncrementalPCA_var_`;
    })();
  }
  /**
    The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See â€œPattern Recognition and Machine Learningâ€ by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf).
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_noise_variance_ = bridgeIncrementalPCA[${this.id}].noise_variance_`;
      return this._py`attr_IncrementalPCA_noise_variance_.tolist() if hasattr(attr_IncrementalPCA_noise_variance_, 'tolist') else attr_IncrementalPCA_noise_variance_`;
    })();
  }
  /**
    The estimated number of components. Relevant when `n\_components=None`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_components_ = bridgeIncrementalPCA[${this.id}].n_components_`;
      return this._py`attr_IncrementalPCA_n_components_.tolist() if hasattr(attr_IncrementalPCA_n_components_, 'tolist') else attr_IncrementalPCA_n_components_`;
    })();
  }
  /**
    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_samples_seen_ = bridgeIncrementalPCA[${this.id}].n_samples_seen_`;
      return this._py`attr_IncrementalPCA_n_samples_seen_.tolist() if hasattr(attr_IncrementalPCA_n_samples_seen_, 'tolist') else attr_IncrementalPCA_n_samples_seen_`;
    })();
  }
  /**
    Inferred batch size from `batch\_size`.
   */
  get batch_size_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing batch_size_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_batch_size_ = bridgeIncrementalPCA[${this.id}].batch_size_`;
      return this._py`attr_IncrementalPCA_batch_size_.tolist() if hasattr(attr_IncrementalPCA_batch_size_, 'tolist') else attr_IncrementalPCA_batch_size_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_features_in_ = bridgeIncrementalPCA[${this.id}].n_features_in_`;
      return this._py`attr_IncrementalPCA_n_features_in_.tolist() if hasattr(attr_IncrementalPCA_n_features_in_, 'tolist') else attr_IncrementalPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_feature_names_in_ = bridgeIncrementalPCA[${this.id}].feature_names_in_`;
      return this._py`attr_IncrementalPCA_feature_names_in_.tolist() if hasattr(attr_IncrementalPCA_feature_names_in_, 'tolist') else attr_IncrementalPCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/KernelPCA.ts
import crypto35 from "node:crypto";
var KernelPCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelPCA${crypto35.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import KernelPCA
try: bridgeKernelPCA
except NameError: bridgeKernelPCA = {}
`;
    await this._py.ex`ctor_KernelPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_inverse_transform': ${this.opts["fit_inverse_transform"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'remove_zero_eig': ${this.opts["remove_zero_eig"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KernelPCA = {k: v for k, v in ctor_KernelPCA.items() if v is not None}`;
    await this._py.ex`bridgeKernelPCA[${this.id}] = KernelPCA(**ctor_KernelPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit()");
    }
    await this._py.ex`pms_KernelPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelPCA_fit = {k: v for k, v in pms_KernelPCA_fit.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit = bridgeKernelPCA[${this.id}].fit(**pms_KernelPCA_fit)`;
    return this._py`res_KernelPCA_fit.tolist() if hasattr(res_KernelPCA_fit, 'tolist') else res_KernelPCA_fit`;
  }
  /**
    Fit the model from data in X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_KernelPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_KernelPCA_fit_transform = {k: v for k, v in pms_KernelPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit_transform = bridgeKernelPCA[${this.id}].fit_transform(**pms_KernelPCA_fit_transform)`;
    return this._py`res_KernelPCA_fit_transform.tolist() if hasattr(res_KernelPCA_fit_transform, 'tolist') else res_KernelPCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KernelPCA_get_feature_names_out = {k: v for k, v in pms_KernelPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_feature_names_out = bridgeKernelPCA[${this.id}].get_feature_names_out(**pms_KernelPCA_get_feature_names_out)`;
    return this._py`res_KernelPCA_get_feature_names_out.tolist() if hasattr(res_KernelPCA_get_feature_names_out, 'tolist') else res_KernelPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelPCA_get_metadata_routing = {k: v for k, v in pms_KernelPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_metadata_routing = bridgeKernelPCA[${this.id}].get_metadata_routing(**pms_KernelPCA_get_metadata_routing)`;
    return this._py`res_KernelPCA_get_metadata_routing.tolist() if hasattr(res_KernelPCA_get_metadata_routing, 'tolist') else res_KernelPCA_get_metadata_routing`;
  }
  /**
      Transform X back to original space.
  
      `inverse\_transform` approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_KernelPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_inverse_transform = {k: v for k, v in pms_KernelPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_inverse_transform = bridgeKernelPCA[${this.id}].inverse_transform(**pms_KernelPCA_inverse_transform)`;
    return this._py`res_KernelPCA_inverse_transform.tolist() if hasattr(res_KernelPCA_inverse_transform, 'tolist') else res_KernelPCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before set_output()");
    }
    await this._py.ex`pms_KernelPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KernelPCA_set_output = {k: v for k, v in pms_KernelPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_set_output = bridgeKernelPCA[${this.id}].set_output(**pms_KernelPCA_set_output)`;
    return this._py`res_KernelPCA_set_output.tolist() if hasattr(res_KernelPCA_set_output, 'tolist') else res_KernelPCA_set_output`;
  }
  /**
    Transform X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before transform()");
    }
    await this._py.ex`pms_KernelPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_transform = {k: v for k, v in pms_KernelPCA_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_transform = bridgeKernelPCA[${this.id}].transform(**pms_KernelPCA_transform)`;
    return this._py`res_KernelPCA_transform.tolist() if hasattr(res_KernelPCA_transform, 'tolist') else res_KernelPCA_transform`;
  }
  /**
    Eigenvalues of the centered kernel matrix in decreasing order. If `n\_components` and `remove\_zero\_eig` are not set, then all values are stored.
   */
  get eigenvalues_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvalues_ = bridgeKernelPCA[${this.id}].eigenvalues_`;
      return this._py`attr_KernelPCA_eigenvalues_.tolist() if hasattr(attr_KernelPCA_eigenvalues_, 'tolist') else attr_KernelPCA_eigenvalues_`;
    })();
  }
  /**
    Eigenvectors of the centered kernel matrix. If `n\_components` and `remove\_zero\_eig` are not set, then all components are stored.
   */
  get eigenvectors_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvectors_ = bridgeKernelPCA[${this.id}].eigenvectors_`;
      return this._py`attr_KernelPCA_eigenvectors_.tolist() if hasattr(attr_KernelPCA_eigenvectors_, 'tolist') else attr_KernelPCA_eigenvectors_`;
    })();
  }
  /**
    Inverse transform matrix. Only available when `fit\_inverse\_transform` is `true`.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_dual_coef_ = bridgeKernelPCA[${this.id}].dual_coef_`;
      return this._py`attr_KernelPCA_dual_coef_.tolist() if hasattr(attr_KernelPCA_dual_coef_, 'tolist') else attr_KernelPCA_dual_coef_`;
    })();
  }
  /**
    Projection of the fitted data on the kernel principal components. Only available when `fit\_inverse\_transform` is `true`.
   */
  get X_transformed_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing X_transformed_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_transformed_fit_ = bridgeKernelPCA[${this.id}].X_transformed_fit_`;
      return this._py`attr_KernelPCA_X_transformed_fit_.tolist() if hasattr(attr_KernelPCA_X_transformed_fit_, 'tolist') else attr_KernelPCA_X_transformed_fit_`;
    })();
  }
  /**
    The data used to fit the model. If `copy\_X=False`, then `X\_fit\_` is a reference. This attribute is used for the calls to transform.
   */
  get X_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing X_fit_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_fit_ = bridgeKernelPCA[${this.id}].X_fit_`;
      return this._py`attr_KernelPCA_X_fit_.tolist() if hasattr(attr_KernelPCA_X_fit_, 'tolist') else attr_KernelPCA_X_fit_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_n_features_in_ = bridgeKernelPCA[${this.id}].n_features_in_`;
      return this._py`attr_KernelPCA_n_features_in_.tolist() if hasattr(attr_KernelPCA_n_features_in_, 'tolist') else attr_KernelPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_feature_names_in_ = bridgeKernelPCA[${this.id}].feature_names_in_`;
      return this._py`attr_KernelPCA_feature_names_in_.tolist() if hasattr(attr_KernelPCA_feature_names_in_, 'tolist') else attr_KernelPCA_feature_names_in_`;
    })();
  }
  /**
    Kernel coefficient for rbf, poly and sigmoid kernels. When `gamma` is explicitly provided, this is just the same as `gamma`. When `gamma` is `undefined`, this is the actual value of kernel coefficient.
   */
  get gamma_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing gamma_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_gamma_ = bridgeKernelPCA[${this.id}].gamma_`;
      return this._py`attr_KernelPCA_gamma_.tolist() if hasattr(attr_KernelPCA_gamma_, 'tolist') else attr_KernelPCA_gamma_`;
    })();
  }
};

// src/generated/decomposition/LatentDirichletAllocation.ts
import crypto36 from "node:crypto";
var LatentDirichletAllocation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LatentDirichletAllocation${crypto36.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LatentDirichletAllocation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import LatentDirichletAllocation
try: bridgeLatentDirichletAllocation
except NameError: bridgeLatentDirichletAllocation = {}
`;
    await this._py.ex`ctor_LatentDirichletAllocation = {'n_components': ${this.opts["n_components"] ?? void 0}, 'doc_topic_prior': ${this.opts["doc_topic_prior"] ?? void 0}, 'topic_word_prior': ${this.opts["topic_word_prior"] ?? void 0}, 'learning_method': ${this.opts["learning_method"] ?? void 0}, 'learning_decay': ${this.opts["learning_decay"] ?? void 0}, 'learning_offset': ${this.opts["learning_offset"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'evaluate_every': ${this.opts["evaluate_every"] ?? void 0}, 'total_samples': ${this.opts["total_samples"] ?? void 0}, 'perp_tol': ${this.opts["perp_tol"] ?? void 0}, 'mean_change_tol': ${this.opts["mean_change_tol"] ?? void 0}, 'max_doc_update_iter': ${this.opts["max_doc_update_iter"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_LatentDirichletAllocation = {k: v for k, v in ctor_LatentDirichletAllocation.items() if v is not None}`;
    await this._py.ex`bridgeLatentDirichletAllocation[${this.id}] = LatentDirichletAllocation(**ctor_LatentDirichletAllocation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLatentDirichletAllocation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Learn model for the data X with variational Bayes method.
  
      When `learning\_method` is â€˜onlineâ€™, use mini-batch update. Otherwise, use batch update.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LatentDirichletAllocation must call init() before fit()");
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_fit = {k: v for k, v in pms_LatentDirichletAllocation_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit = bridgeLatentDirichletAllocation[${this.id}].fit(**pms_LatentDirichletAllocation_fit)`;
    return this._py`res_LatentDirichletAllocation_fit.tolist() if hasattr(res_LatentDirichletAllocation_fit, 'tolist') else res_LatentDirichletAllocation_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_LatentDirichletAllocation_fit_transform = {k: v for k, v in pms_LatentDirichletAllocation_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit_transform = bridgeLatentDirichletAllocation[${this.id}].fit_transform(**pms_LatentDirichletAllocation_fit_transform)`;
    return this._py`res_LatentDirichletAllocation_fit_transform.tolist() if hasattr(res_LatentDirichletAllocation_fit_transform, 'tolist') else res_LatentDirichletAllocation_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LatentDirichletAllocation_get_feature_names_out = {k: v for k, v in pms_LatentDirichletAllocation_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_feature_names_out = bridgeLatentDirichletAllocation[${this.id}].get_feature_names_out(**pms_LatentDirichletAllocation_get_feature_names_out)`;
    return this._py`res_LatentDirichletAllocation_get_feature_names_out.tolist() if hasattr(res_LatentDirichletAllocation_get_feature_names_out, 'tolist') else res_LatentDirichletAllocation_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LatentDirichletAllocation_get_metadata_routing = {k: v for k, v in pms_LatentDirichletAllocation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_metadata_routing = bridgeLatentDirichletAllocation[${this.id}].get_metadata_routing(**pms_LatentDirichletAllocation_get_metadata_routing)`;
    return this._py`res_LatentDirichletAllocation_get_metadata_routing.tolist() if hasattr(res_LatentDirichletAllocation_get_metadata_routing, 'tolist') else res_LatentDirichletAllocation_get_metadata_routing`;
  }
  /**
    Online VB with Mini-Batch update.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_partial_fit = {k: v for k, v in pms_LatentDirichletAllocation_partial_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_partial_fit = bridgeLatentDirichletAllocation[${this.id}].partial_fit(**pms_LatentDirichletAllocation_partial_fit)`;
    return this._py`res_LatentDirichletAllocation_partial_fit.tolist() if hasattr(res_LatentDirichletAllocation_partial_fit, 'tolist') else res_LatentDirichletAllocation_partial_fit`;
  }
  /**
      Calculate approximate perplexity for data X.
  
      Perplexity is defined as exp(-1. \* log-likelihood per word)
     */
  async perplexity(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before perplexity()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_perplexity = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sub_sampling': ${opts["sub_sampling"] ?? void 0}}

pms_LatentDirichletAllocation_perplexity = {k: v for k, v in pms_LatentDirichletAllocation_perplexity.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_perplexity = bridgeLatentDirichletAllocation[${this.id}].perplexity(**pms_LatentDirichletAllocation_perplexity)`;
    return this._py`res_LatentDirichletAllocation_perplexity.tolist() if hasattr(res_LatentDirichletAllocation_perplexity, 'tolist') else res_LatentDirichletAllocation_perplexity`;
  }
  /**
    Calculate approximate log-likelihood as score.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before score()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_score = {k: v for k, v in pms_LatentDirichletAllocation_score.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_score = bridgeLatentDirichletAllocation[${this.id}].score(**pms_LatentDirichletAllocation_score)`;
    return this._py`res_LatentDirichletAllocation_score.tolist() if hasattr(res_LatentDirichletAllocation_score, 'tolist') else res_LatentDirichletAllocation_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LatentDirichletAllocation_set_output = {k: v for k, v in pms_LatentDirichletAllocation_set_output.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_set_output = bridgeLatentDirichletAllocation[${this.id}].set_output(**pms_LatentDirichletAllocation_set_output)`;
    return this._py`res_LatentDirichletAllocation_set_output.tolist() if hasattr(res_LatentDirichletAllocation_set_output, 'tolist') else res_LatentDirichletAllocation_set_output`;
  }
  /**
    Transform data X according to the fitted model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LatentDirichletAllocation_transform = {k: v for k, v in pms_LatentDirichletAllocation_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_transform = bridgeLatentDirichletAllocation[${this.id}].transform(**pms_LatentDirichletAllocation_transform)`;
    return this._py`res_LatentDirichletAllocation_transform.tolist() if hasattr(res_LatentDirichletAllocation_transform, 'tolist') else res_LatentDirichletAllocation_transform`;
  }
  /**
    Variational parameters for topic word distribution. Since the complete conditional for topic word distribution is a Dirichlet, `components\_\[i, j\]` can be viewed as pseudocount that represents the number of times word `j` was assigned to topic `i`. It can also be viewed as distribution over the words for each topic after normalization: `model.components\_ / model.components\_.sum(axis=1)\[:, np.newaxis\]`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_components_ = bridgeLatentDirichletAllocation[${this.id}].components_`;
      return this._py`attr_LatentDirichletAllocation_components_.tolist() if hasattr(attr_LatentDirichletAllocation_components_, 'tolist') else attr_LatentDirichletAllocation_components_`;
    })();
  }
  /**
    Exponential value of expectation of log topic word distribution. In the literature, this is `exp(E\[log(beta)\])`.
   */
  get exp_dirichlet_component_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing exp_dirichlet_component_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_exp_dirichlet_component_ = bridgeLatentDirichletAllocation[${this.id}].exp_dirichlet_component_`;
      return this._py`attr_LatentDirichletAllocation_exp_dirichlet_component_.tolist() if hasattr(attr_LatentDirichletAllocation_exp_dirichlet_component_, 'tolist') else attr_LatentDirichletAllocation_exp_dirichlet_component_`;
    })();
  }
  /**
    Number of iterations of the EM step.
   */
  get n_batch_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_batch_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_batch_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_batch_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_batch_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_batch_iter_, 'tolist') else attr_LatentDirichletAllocation_n_batch_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_features_in_ = bridgeLatentDirichletAllocation[${this.id}].n_features_in_`;
      return this._py`attr_LatentDirichletAllocation_n_features_in_.tolist() if hasattr(attr_LatentDirichletAllocation_n_features_in_, 'tolist') else attr_LatentDirichletAllocation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_feature_names_in_ = bridgeLatentDirichletAllocation[${this.id}].feature_names_in_`;
      return this._py`attr_LatentDirichletAllocation_feature_names_in_.tolist() if hasattr(attr_LatentDirichletAllocation_feature_names_in_, 'tolist') else attr_LatentDirichletAllocation_feature_names_in_`;
    })();
  }
  /**
    Number of passes over the dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_iter_, 'tolist') else attr_LatentDirichletAllocation_n_iter_`;
    })();
  }
  /**
    Final perplexity score on training set.
   */
  get bound_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_bound_ = bridgeLatentDirichletAllocation[${this.id}].bound_`;
      return this._py`attr_LatentDirichletAllocation_bound_.tolist() if hasattr(attr_LatentDirichletAllocation_bound_, 'tolist') else attr_LatentDirichletAllocation_bound_`;
    })();
  }
  /**
    Prior of document topic distribution `theta`. If the value is `undefined`, it is `1 / n\_components`.
   */
  get doc_topic_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing doc_topic_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_doc_topic_prior_ = bridgeLatentDirichletAllocation[${this.id}].doc_topic_prior_`;
      return this._py`attr_LatentDirichletAllocation_doc_topic_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_doc_topic_prior_, 'tolist') else attr_LatentDirichletAllocation_doc_topic_prior_`;
    })();
  }
  /**
    RandomState instance that is generated either from a seed, the random number generator or by `np.random`.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_random_state_ = bridgeLatentDirichletAllocation[${this.id}].random_state_`;
      return this._py`attr_LatentDirichletAllocation_random_state_.tolist() if hasattr(attr_LatentDirichletAllocation_random_state_, 'tolist') else attr_LatentDirichletAllocation_random_state_`;
    })();
  }
  /**
    Prior of topic word distribution `beta`. If the value is `undefined`, it is `1 / n\_components`.
   */
  get topic_word_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing topic_word_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_topic_word_prior_ = bridgeLatentDirichletAllocation[${this.id}].topic_word_prior_`;
      return this._py`attr_LatentDirichletAllocation_topic_word_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_topic_word_prior_, 'tolist') else attr_LatentDirichletAllocation_topic_word_prior_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchDictionaryLearning.ts
import crypto37 from "node:crypto";
var MiniBatchDictionaryLearning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchDictionaryLearning${crypto37.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchDictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchDictionaryLearning
try: bridgeMiniBatchDictionaryLearning
except NameError: bridgeMiniBatchDictionaryLearning = {}
`;
    await this._py.ex`ctor_MiniBatchDictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchDictionaryLearning = {k: v for k, v in ctor_MiniBatchDictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchDictionaryLearning[${this.id}] = MiniBatchDictionaryLearning(**ctor_MiniBatchDictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit = bridgeMiniBatchDictionaryLearning[${this.id}].fit(**pms_MiniBatchDictionaryLearning_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit, 'tolist') else res_MiniBatchDictionaryLearning_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit_transform = bridgeMiniBatchDictionaryLearning[${this.id}].fit_transform(**pms_MiniBatchDictionaryLearning_fit_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_fit_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit_transform, 'tolist') else res_MiniBatchDictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_feature_names_out = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_feature_names_out = bridgeMiniBatchDictionaryLearning[${this.id}].get_feature_names_out(**pms_MiniBatchDictionaryLearning_get_feature_names_out)`;
    return this._py`res_MiniBatchDictionaryLearning_get_feature_names_out.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_feature_names_out, 'tolist') else res_MiniBatchDictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_metadata_routing = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_metadata_routing = bridgeMiniBatchDictionaryLearning[${this.id}].get_metadata_routing(**pms_MiniBatchDictionaryLearning_get_metadata_routing)`;
    return this._py`res_MiniBatchDictionaryLearning_get_metadata_routing.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_metadata_routing, 'tolist') else res_MiniBatchDictionaryLearning_get_metadata_routing`;
  }
  /**
    Update the model using the data in X as a mini-batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_partial_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_partial_fit = bridgeMiniBatchDictionaryLearning[${this.id}].partial_fit(**pms_MiniBatchDictionaryLearning_partial_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_partial_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_partial_fit, 'tolist') else res_MiniBatchDictionaryLearning_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before set_output()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchDictionaryLearning_set_output = {k: v for k, v in pms_MiniBatchDictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_set_output = bridgeMiniBatchDictionaryLearning[${this.id}].set_output(**pms_MiniBatchDictionaryLearning_set_output)`;
    return this._py`res_MiniBatchDictionaryLearning_set_output.tolist() if hasattr(res_MiniBatchDictionaryLearning_set_output, 'tolist') else res_MiniBatchDictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchDictionaryLearning_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_transform = bridgeMiniBatchDictionaryLearning[${this.id}].transform(**pms_MiniBatchDictionaryLearning_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_transform, 'tolist') else res_MiniBatchDictionaryLearning_transform`;
  }
  /**
    Components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_components_ = bridgeMiniBatchDictionaryLearning[${this.id}].components_`;
      return this._py`attr_MiniBatchDictionaryLearning_components_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_components_, 'tolist') else attr_MiniBatchDictionaryLearning_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_features_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_features_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_features_in_, 'tolist') else attr_MiniBatchDictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_feature_names_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_feature_names_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_feature_names_in_, 'tolist') else attr_MiniBatchDictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_iter_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_iter_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_iter_, 'tolist') else attr_MiniBatchDictionaryLearning_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_steps_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_steps_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_steps_, 'tolist') else attr_MiniBatchDictionaryLearning_n_steps_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchNMF.ts
import crypto38 from "node:crypto";
var MiniBatchNMF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchNMF${crypto38.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchNMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchNMF
try: bridgeMiniBatchNMF
except NameError: bridgeMiniBatchNMF = {}
`;
    await this._py.ex`ctor_MiniBatchNMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'forget_factor': ${this.opts["forget_factor"] ?? void 0}, 'fresh_restarts': ${this.opts["fresh_restarts"] ?? void 0}, 'fresh_restarts_max_iter': ${this.opts["fresh_restarts_max_iter"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_MiniBatchNMF = {k: v for k, v in ctor_MiniBatchNMF.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchNMF[${this.id}] = MiniBatchNMF(**ctor_MiniBatchNMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MiniBatchNMF_fit = {k: v for k, v in pms_MiniBatchNMF_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit = bridgeMiniBatchNMF[${this.id}].fit(**pms_MiniBatchNMF_fit)`;
    return this._py`res_MiniBatchNMF_fit.tolist() if hasattr(res_MiniBatchNMF_fit, 'tolist') else res_MiniBatchNMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_fit_transform = {k: v for k, v in pms_MiniBatchNMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit_transform = bridgeMiniBatchNMF[${this.id}].fit_transform(**pms_MiniBatchNMF_fit_transform)`;
    return this._py`res_MiniBatchNMF_fit_transform.tolist() if hasattr(res_MiniBatchNMF_fit_transform, 'tolist') else res_MiniBatchNMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchNMF_get_feature_names_out = {k: v for k, v in pms_MiniBatchNMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_feature_names_out = bridgeMiniBatchNMF[${this.id}].get_feature_names_out(**pms_MiniBatchNMF_get_feature_names_out)`;
    return this._py`res_MiniBatchNMF_get_feature_names_out.tolist() if hasattr(res_MiniBatchNMF_get_feature_names_out, 'tolist') else res_MiniBatchNMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchNMF_get_metadata_routing = {k: v for k, v in pms_MiniBatchNMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_metadata_routing = bridgeMiniBatchNMF[${this.id}].get_metadata_routing(**pms_MiniBatchNMF_get_metadata_routing)`;
    return this._py`res_MiniBatchNMF_get_metadata_routing.tolist() if hasattr(res_MiniBatchNMF_get_metadata_routing, 'tolist') else res_MiniBatchNMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'W': ${opts["W"] ?? void 0}}

pms_MiniBatchNMF_inverse_transform = {k: v for k, v in pms_MiniBatchNMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_inverse_transform = bridgeMiniBatchNMF[${this.id}].inverse_transform(**pms_MiniBatchNMF_inverse_transform)`;
    return this._py`res_MiniBatchNMF_inverse_transform.tolist() if hasattr(res_MiniBatchNMF_inverse_transform, 'tolist') else res_MiniBatchNMF_inverse_transform`;
  }
  /**
      Update the model using the data in `X` as a mini-batch.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once (see [Strategies to scale computationally: bigger data](../../computing/scaling_strategies.html#scaling-strategies)).
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_partial_fit = {k: v for k, v in pms_MiniBatchNMF_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_partial_fit = bridgeMiniBatchNMF[${this.id}].partial_fit(**pms_MiniBatchNMF_partial_fit)`;
    return this._py`res_MiniBatchNMF_partial_fit.tolist() if hasattr(res_MiniBatchNMF_partial_fit, 'tolist') else res_MiniBatchNMF_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchNMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchNMF_set_output = {k: v for k, v in pms_MiniBatchNMF_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_set_output = bridgeMiniBatchNMF[${this.id}].set_output(**pms_MiniBatchNMF_set_output)`;
    return this._py`res_MiniBatchNMF_set_output.tolist() if hasattr(res_MiniBatchNMF_set_output, 'tolist') else res_MiniBatchNMF_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_set_partial_fit_request = {'H': ${opts["H"] ?? void 0}, 'W': ${opts["W"] ?? void 0}}

pms_MiniBatchNMF_set_partial_fit_request = {k: v for k, v in pms_MiniBatchNMF_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_set_partial_fit_request = bridgeMiniBatchNMF[${this.id}].set_partial_fit_request(**pms_MiniBatchNMF_set_partial_fit_request)`;
    return this._py`res_MiniBatchNMF_set_partial_fit_request.tolist() if hasattr(res_MiniBatchNMF_set_partial_fit_request, 'tolist') else res_MiniBatchNMF_set_partial_fit_request`;
  }
  /**
    Transform the data X according to the fitted MiniBatchNMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchNMF_transform = {k: v for k, v in pms_MiniBatchNMF_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_transform = bridgeMiniBatchNMF[${this.id}].transform(**pms_MiniBatchNMF_transform)`;
    return this._py`res_MiniBatchNMF_transform.tolist() if hasattr(res_MiniBatchNMF_transform, 'tolist') else res_MiniBatchNMF_transform`;
  }
  /**
    Factorization matrix, sometimes called â€˜dictionaryâ€™.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_components_ = bridgeMiniBatchNMF[${this.id}].components_`;
      return this._py`attr_MiniBatchNMF_components_.tolist() if hasattr(attr_MiniBatchNMF_components_, 'tolist') else attr_MiniBatchNMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n\_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_components_ = bridgeMiniBatchNMF[${this.id}].n_components_`;
      return this._py`attr_MiniBatchNMF_n_components_.tolist() if hasattr(attr_MiniBatchNMF_n_components_, 'tolist') else attr_MiniBatchNMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_reconstruction_err_ = bridgeMiniBatchNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_MiniBatchNMF_reconstruction_err_.tolist() if hasattr(attr_MiniBatchNMF_reconstruction_err_, 'tolist') else attr_MiniBatchNMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of started iterations over the whole dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_iter_ = bridgeMiniBatchNMF[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchNMF_n_iter_.tolist() if hasattr(attr_MiniBatchNMF_n_iter_, 'tolist') else attr_MiniBatchNMF_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_steps_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_steps_ = bridgeMiniBatchNMF[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchNMF_n_steps_.tolist() if hasattr(attr_MiniBatchNMF_n_steps_, 'tolist') else attr_MiniBatchNMF_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_features_in_ = bridgeMiniBatchNMF[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchNMF_n_features_in_.tolist() if hasattr(attr_MiniBatchNMF_n_features_in_, 'tolist') else attr_MiniBatchNMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_feature_names_in_ = bridgeMiniBatchNMF[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchNMF_feature_names_in_.tolist() if hasattr(attr_MiniBatchNMF_feature_names_in_, 'tolist') else attr_MiniBatchNMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchSparsePCA.ts
import crypto39 from "node:crypto";
var MiniBatchSparsePCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MiniBatchSparsePCA${crypto39.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchSparsePCA.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchSparsePCA
try: bridgeMiniBatchSparsePCA
except NameError: bridgeMiniBatchSparsePCA = {}
`;
    await this._py.ex`ctor_MiniBatchSparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchSparsePCA = {k: v for k, v in ctor_MiniBatchSparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchSparsePCA[${this.id}] = MiniBatchSparsePCA(**ctor_MiniBatchSparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchSparsePCA_fit = {k: v for k, v in pms_MiniBatchSparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit = bridgeMiniBatchSparsePCA[${this.id}].fit(**pms_MiniBatchSparsePCA_fit)`;
    return this._py`res_MiniBatchSparsePCA_fit.tolist() if hasattr(res_MiniBatchSparsePCA_fit, 'tolist') else res_MiniBatchSparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchSparsePCA_fit_transform = {k: v for k, v in pms_MiniBatchSparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit_transform = bridgeMiniBatchSparsePCA[${this.id}].fit_transform(**pms_MiniBatchSparsePCA_fit_transform)`;
    return this._py`res_MiniBatchSparsePCA_fit_transform.tolist() if hasattr(res_MiniBatchSparsePCA_fit_transform, 'tolist') else res_MiniBatchSparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchSparsePCA_get_feature_names_out = {k: v for k, v in pms_MiniBatchSparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_feature_names_out = bridgeMiniBatchSparsePCA[${this.id}].get_feature_names_out(**pms_MiniBatchSparsePCA_get_feature_names_out)`;
    return this._py`res_MiniBatchSparsePCA_get_feature_names_out.tolist() if hasattr(res_MiniBatchSparsePCA_get_feature_names_out, 'tolist') else res_MiniBatchSparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchSparsePCA_get_metadata_routing = {k: v for k, v in pms_MiniBatchSparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_metadata_routing = bridgeMiniBatchSparsePCA[${this.id}].get_metadata_routing(**pms_MiniBatchSparsePCA_get_metadata_routing)`;
    return this._py`res_MiniBatchSparsePCA_get_metadata_routing.tolist() if hasattr(res_MiniBatchSparsePCA_get_metadata_routing, 'tolist') else res_MiniBatchSparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_inverse_transform = {k: v for k, v in pms_MiniBatchSparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_inverse_transform = bridgeMiniBatchSparsePCA[${this.id}].inverse_transform(**pms_MiniBatchSparsePCA_inverse_transform)`;
    return this._py`res_MiniBatchSparsePCA_inverse_transform.tolist() if hasattr(res_MiniBatchSparsePCA_inverse_transform, 'tolist') else res_MiniBatchSparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchSparsePCA_set_output = {k: v for k, v in pms_MiniBatchSparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_set_output = bridgeMiniBatchSparsePCA[${this.id}].set_output(**pms_MiniBatchSparsePCA_set_output)`;
    return this._py`res_MiniBatchSparsePCA_set_output.tolist() if hasattr(res_MiniBatchSparsePCA_set_output, 'tolist') else res_MiniBatchSparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_transform = {k: v for k, v in pms_MiniBatchSparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_transform = bridgeMiniBatchSparsePCA[${this.id}].transform(**pms_MiniBatchSparsePCA_transform)`;
    return this._py`res_MiniBatchSparsePCA_transform.tolist() if hasattr(res_MiniBatchSparsePCA_transform, 'tolist') else res_MiniBatchSparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_components_ = bridgeMiniBatchSparsePCA[${this.id}].components_`;
      return this._py`attr_MiniBatchSparsePCA_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_components_, 'tolist') else attr_MiniBatchSparsePCA_components_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_components_ = bridgeMiniBatchSparsePCA[${this.id}].n_components_`;
      return this._py`attr_MiniBatchSparsePCA_n_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_components_, 'tolist') else attr_MiniBatchSparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_iter_ = bridgeMiniBatchSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchSparsePCA_n_iter_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_iter_, 'tolist') else attr_MiniBatchSparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing mean_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_mean_ = bridgeMiniBatchSparsePCA[${this.id}].mean_`;
      return this._py`attr_MiniBatchSparsePCA_mean_.tolist() if hasattr(attr_MiniBatchSparsePCA_mean_, 'tolist') else attr_MiniBatchSparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_features_in_ = bridgeMiniBatchSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchSparsePCA_n_features_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_features_in_, 'tolist') else attr_MiniBatchSparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_feature_names_in_ = bridgeMiniBatchSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchSparsePCA_feature_names_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_feature_names_in_, 'tolist') else attr_MiniBatchSparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/NMF.ts
import crypto40 from "node:crypto";
var NMF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NMF${crypto40.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import NMF
try: bridgeNMF
except NameError: bridgeNMF = {}
`;
    await this._py.ex`ctor_NMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}}

ctor_NMF = {k: v for k, v in ctor_NMF.items() if v is not None}`;
    await this._py.ex`bridgeNMF[${this.id}] = NMF(**ctor_NMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit()");
    }
    await this._py.ex`pms_NMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_NMF_fit = {k: v for k, v in pms_NMF_fit.items() if v is not None}`;
    await this._py.ex`res_NMF_fit = bridgeNMF[${this.id}].fit(**pms_NMF_fit)`;
    return this._py`res_NMF_fit.tolist() if hasattr(res_NMF_fit, 'tolist') else res_NMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_NMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_NMF_fit_transform = {k: v for k, v in pms_NMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_fit_transform = bridgeNMF[${this.id}].fit_transform(**pms_NMF_fit_transform)`;
    return this._py`res_NMF_fit_transform.tolist() if hasattr(res_NMF_fit_transform, 'tolist') else res_NMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_NMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_NMF_get_feature_names_out = {k: v for k, v in pms_NMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_NMF_get_feature_names_out = bridgeNMF[${this.id}].get_feature_names_out(**pms_NMF_get_feature_names_out)`;
    return this._py`res_NMF_get_feature_names_out.tolist() if hasattr(res_NMF_get_feature_names_out, 'tolist') else res_NMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_NMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NMF_get_metadata_routing = {k: v for k, v in pms_NMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NMF_get_metadata_routing = bridgeNMF[${this.id}].get_metadata_routing(**pms_NMF_get_metadata_routing)`;
    return this._py`res_NMF_get_metadata_routing.tolist() if hasattr(res_NMF_get_metadata_routing, 'tolist') else res_NMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before inverse_transform()");
    }
    await this._py.ex`pms_NMF_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None, 'W': ${opts["W"] ?? void 0}}

pms_NMF_inverse_transform = {k: v for k, v in pms_NMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_inverse_transform = bridgeNMF[${this.id}].inverse_transform(**pms_NMF_inverse_transform)`;
    return this._py`res_NMF_inverse_transform.tolist() if hasattr(res_NMF_inverse_transform, 'tolist') else res_NMF_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before set_output()");
    }
    await this._py.ex`pms_NMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_NMF_set_output = {k: v for k, v in pms_NMF_set_output.items() if v is not None}`;
    await this._py.ex`res_NMF_set_output = bridgeNMF[${this.id}].set_output(**pms_NMF_set_output)`;
    return this._py`res_NMF_set_output.tolist() if hasattr(res_NMF_set_output, 'tolist') else res_NMF_set_output`;
  }
  /**
    Transform the data X according to the fitted NMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before transform()");
    }
    await this._py.ex`pms_NMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NMF_transform = {k: v for k, v in pms_NMF_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_transform = bridgeNMF[${this.id}].transform(**pms_NMF_transform)`;
    return this._py`res_NMF_transform.tolist() if hasattr(res_NMF_transform, 'tolist') else res_NMF_transform`;
  }
  /**
    Factorization matrix, sometimes called â€˜dictionaryâ€™.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_components_ = bridgeNMF[${this.id}].components_`;
      return this._py`attr_NMF_components_.tolist() if hasattr(attr_NMF_components_, 'tolist') else attr_NMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n\_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_components_ = bridgeNMF[${this.id}].n_components_`;
      return this._py`attr_NMF_n_components_.tolist() if hasattr(attr_NMF_n_components_, 'tolist') else attr_NMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NMF_reconstruction_err_ = bridgeNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_NMF_reconstruction_err_.tolist() if hasattr(attr_NMF_reconstruction_err_, 'tolist') else attr_NMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of iterations.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_iter_ = bridgeNMF[${this.id}].n_iter_`;
      return this._py`attr_NMF_n_iter_.tolist() if hasattr(attr_NMF_n_iter_, 'tolist') else attr_NMF_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_features_in_ = bridgeNMF[${this.id}].n_features_in_`;
      return this._py`attr_NMF_n_features_in_.tolist() if hasattr(attr_NMF_n_features_in_, 'tolist') else attr_NMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_feature_names_in_ = bridgeNMF[${this.id}].feature_names_in_`;
      return this._py`attr_NMF_feature_names_in_.tolist() if hasattr(attr_NMF_feature_names_in_, 'tolist') else attr_NMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/PCA.ts
import crypto41 from "node:crypto";
var PCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PCA${crypto41.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import PCA
try: bridgePCA
except NameError: bridgePCA = {}
`;
    await this._py.ex`ctor_PCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'svd_solver': ${this.opts["svd_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_PCA = {k: v for k, v in ctor_PCA.items() if v is not None}`;
    await this._py.ex`bridgePCA[${this.id}] = PCA(**ctor_PCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit()");
    }
    await this._py.ex`pms_PCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit = {k: v for k, v in pms_PCA_fit.items() if v is not None}`;
    await this._py.ex`res_PCA_fit = bridgePCA[${this.id}].fit(**pms_PCA_fit)`;
    return this._py`res_PCA_fit.tolist() if hasattr(res_PCA_fit, 'tolist') else res_PCA_fit`;
  }
  /**
    Fit the model with X and apply the dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_PCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit_transform = {k: v for k, v in pms_PCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_fit_transform = bridgePCA[${this.id}].fit_transform(**pms_PCA_fit_transform)`;
    return this._py`res_PCA_fit_transform.tolist() if hasattr(res_PCA_fit_transform, 'tolist') else res_PCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components\_.T \* S\*\*2 \* components\_ + sigma2 \* eye(n\_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_PCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_PCA_get_covariance = {k: v for k, v in pms_PCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_PCA_get_covariance = bridgePCA[${this.id}].get_covariance(**pms_PCA_get_covariance)`;
    return this._py`res_PCA_get_covariance.tolist() if hasattr(res_PCA_get_covariance, 'tolist') else res_PCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_PCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PCA_get_feature_names_out = {k: v for k, v in pms_PCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PCA_get_feature_names_out = bridgePCA[${this.id}].get_feature_names_out(**pms_PCA_get_feature_names_out)`;
    return this._py`res_PCA_get_feature_names_out.tolist() if hasattr(res_PCA_get_feature_names_out, 'tolist') else res_PCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_PCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PCA_get_metadata_routing = {k: v for k, v in pms_PCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PCA_get_metadata_routing = bridgePCA[${this.id}].get_metadata_routing(**pms_PCA_get_metadata_routing)`;
    return this._py`res_PCA_get_metadata_routing.tolist() if hasattr(res_PCA_get_metadata_routing, 'tolist') else res_PCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_precision()");
    }
    await this._py.ex`pms_PCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_PCA_get_precision = {k: v for k, v in pms_PCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_PCA_get_precision = bridgePCA[${this.id}].get_precision(**pms_PCA_get_precision)`;
    return this._py`res_PCA_get_precision.tolist() if hasattr(res_PCA_get_precision, 'tolist') else res_PCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X\_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_PCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_inverse_transform = {k: v for k, v in pms_PCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_inverse_transform = bridgePCA[${this.id}].inverse_transform(**pms_PCA_inverse_transform)`;
    return this._py`res_PCA_inverse_transform.tolist() if hasattr(res_PCA_inverse_transform, 'tolist') else res_PCA_inverse_transform`;
  }
  /**
      Return the average log-likelihood of all samples.
  
      See. â€œPattern Recognition and Machine Learningâ€ by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score()");
    }
    await this._py.ex`pms_PCA_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_score = {k: v for k, v in pms_PCA_score.items() if v is not None}`;
    await this._py.ex`res_PCA_score = bridgePCA[${this.id}].score(**pms_PCA_score)`;
    return this._py`res_PCA_score.tolist() if hasattr(res_PCA_score, 'tolist') else res_PCA_score`;
  }
  /**
      Return the log-likelihood of each sample.
  
      See. â€œPattern Recognition and Machine Learningâ€ by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score_samples()");
    }
    await this._py.ex`pms_PCA_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_score_samples = {k: v for k, v in pms_PCA_score_samples.items() if v is not None}`;
    await this._py.ex`res_PCA_score_samples = bridgePCA[${this.id}].score_samples(**pms_PCA_score_samples)`;
    return this._py`res_PCA_score_samples.tolist() if hasattr(res_PCA_score_samples, 'tolist') else res_PCA_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before set_output()");
    }
    await this._py.ex`pms_PCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PCA_set_output = {k: v for k, v in pms_PCA_set_output.items() if v is not None}`;
    await this._py.ex`res_PCA_set_output = bridgePCA[${this.id}].set_output(**pms_PCA_set_output)`;
    return this._py`res_PCA_set_output.tolist() if hasattr(res_PCA_set_output, 'tolist') else res_PCA_set_output`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before transform()");
    }
    await this._py.ex`pms_PCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_transform = {k: v for k, v in pms_PCA_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_transform = bridgePCA[${this.id}].transform(**pms_PCA_transform)`;
    return this._py`res_PCA_transform.tolist() if hasattr(res_PCA_transform, 'tolist') else res_PCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained\_variance\_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_components_ = bridgePCA[${this.id}].components_`;
      return this._py`attr_PCA_components_.tolist() if hasattr(attr_PCA_components_, 'tolist') else attr_PCA_components_`;
    })();
  }
  /**
      The amount of variance explained by each of the selected components. The variance estimation uses `n\_samples \- 1` degrees of freedom.
  
      Equal to n\_components largest eigenvalues of the covariance matrix of X.
     */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ = bridgePCA[${this.id}].explained_variance_`;
      return this._py`attr_PCA_explained_variance_.tolist() if hasattr(attr_PCA_explained_variance_, 'tolist') else attr_PCA_explained_variance_`;
    })();
  }
  /**
      Percentage of variance explained by each of the selected components.
  
      If `n\_components` is not set then all components are stored and the sum of the ratios is equal to 1.0.
     */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ratio_ = bridgePCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_PCA_explained_variance_ratio_.tolist() if hasattr(attr_PCA_explained_variance_ratio_, 'tolist') else attr_PCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing singular_values_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_singular_values_ = bridgePCA[${this.id}].singular_values_`;
      return this._py`attr_PCA_singular_values_.tolist() if hasattr(attr_PCA_singular_values_, 'tolist') else attr_PCA_singular_values_`;
    })();
  }
  /**
      Per-feature empirical mean, estimated from the training set.
  
      Equal to `X.mean(axis=0)`.
     */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_mean_ = bridgePCA[${this.id}].mean_`;
      return this._py`attr_PCA_mean_.tolist() if hasattr(attr_PCA_mean_, 'tolist') else attr_PCA_mean_`;
    })();
  }
  /**
    The estimated number of components. When n\_components is set to â€˜mleâ€™ or a number between 0 and 1 (with svd\_solver == â€˜fullâ€™) this number is estimated from input data. Otherwise it equals the parameter n\_components, or the lesser value of n\_features and n\_samples if n\_components is `undefined`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_components_ = bridgePCA[${this.id}].n_components_`;
      return this._py`attr_PCA_n_components_.tolist() if hasattr(attr_PCA_n_components_, 'tolist') else attr_PCA_n_components_`;
    })();
  }
  /**
    Number of features in the training data.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_features_ = bridgePCA[${this.id}].n_features_`;
      return this._py`attr_PCA_n_features_.tolist() if hasattr(attr_PCA_n_features_, 'tolist') else attr_PCA_n_features_`;
    })();
  }
  /**
    Number of samples in the training data.
   */
  get n_samples_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_samples_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_samples_ = bridgePCA[${this.id}].n_samples_`;
      return this._py`attr_PCA_n_samples_.tolist() if hasattr(attr_PCA_n_samples_, 'tolist') else attr_PCA_n_samples_`;
    })();
  }
  /**
      The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See â€œPattern Recognition and Machine Learningâ€ by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf). It is required to compute the estimated data covariance and score samples.
  
      Equal to the average of (min(n\_features, n\_samples) - n\_components) smallest eigenvalues of the covariance matrix of X.
     */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing noise_variance_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_noise_variance_ = bridgePCA[${this.id}].noise_variance_`;
      return this._py`attr_PCA_noise_variance_.tolist() if hasattr(attr_PCA_noise_variance_, 'tolist') else attr_PCA_noise_variance_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_features_in_ = bridgePCA[${this.id}].n_features_in_`;
      return this._py`attr_PCA_n_features_in_.tolist() if hasattr(attr_PCA_n_features_in_, 'tolist') else attr_PCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_feature_names_in_ = bridgePCA[${this.id}].feature_names_in_`;
      return this._py`attr_PCA_feature_names_in_.tolist() if hasattr(attr_PCA_feature_names_in_, 'tolist') else attr_PCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparseCoder.ts
import crypto42 from "node:crypto";
var SparseCoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SparseCoder${crypto42.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparseCoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparseCoder
try: bridgeSparseCoder
except NameError: bridgeSparseCoder = {}
`;
    await this._py.ex`ctor_SparseCoder = {'dictionary': np.array(${this.opts["dictionary"] ?? void 0}) if ${this.opts["dictionary"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_SparseCoder = {k: v for k, v in ctor_SparseCoder.items() if v is not None}`;
    await this._py.ex`bridgeSparseCoder[${this.id}] = SparseCoder(**ctor_SparseCoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparseCoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Do nothing and return the estimator unchanged.
  
      This method is just there to implement the usual API and hence work in pipelines.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit()");
    }
    await this._py.ex`pms_SparseCoder_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_fit = {k: v for k, v in pms_SparseCoder_fit.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit = bridgeSparseCoder[${this.id}].fit(**pms_SparseCoder_fit)`;
    return this._py`res_SparseCoder_fit.tolist() if hasattr(res_SparseCoder_fit, 'tolist') else res_SparseCoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparseCoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparseCoder_fit_transform = {k: v for k, v in pms_SparseCoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit_transform = bridgeSparseCoder[${this.id}].fit_transform(**pms_SparseCoder_fit_transform)`;
    return this._py`res_SparseCoder_fit_transform.tolist() if hasattr(res_SparseCoder_fit_transform, 'tolist') else res_SparseCoder_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparseCoder_get_feature_names_out = {k: v for k, v in pms_SparseCoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_feature_names_out = bridgeSparseCoder[${this.id}].get_feature_names_out(**pms_SparseCoder_get_feature_names_out)`;
    return this._py`res_SparseCoder_get_feature_names_out.tolist() if hasattr(res_SparseCoder_get_feature_names_out, 'tolist') else res_SparseCoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparseCoder_get_metadata_routing = {k: v for k, v in pms_SparseCoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_metadata_routing = bridgeSparseCoder[${this.id}].get_metadata_routing(**pms_SparseCoder_get_metadata_routing)`;
    return this._py`res_SparseCoder_get_metadata_routing.tolist() if hasattr(res_SparseCoder_get_metadata_routing, 'tolist') else res_SparseCoder_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before set_output()");
    }
    await this._py.ex`pms_SparseCoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparseCoder_set_output = {k: v for k, v in pms_SparseCoder_set_output.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_set_output = bridgeSparseCoder[${this.id}].set_output(**pms_SparseCoder_set_output)`;
    return this._py`res_SparseCoder_set_output.tolist() if hasattr(res_SparseCoder_set_output, 'tolist') else res_SparseCoder_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform\_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before transform()");
    }
    await this._py.ex`pms_SparseCoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_transform = {k: v for k, v in pms_SparseCoder_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_transform = bridgeSparseCoder[${this.id}].transform(**pms_SparseCoder_transform)`;
    return this._py`res_SparseCoder_transform.tolist() if hasattr(res_SparseCoder_transform, 'tolist') else res_SparseCoder_transform`;
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseCoder_feature_names_in_ = bridgeSparseCoder[${this.id}].feature_names_in_`;
      return this._py`attr_SparseCoder_feature_names_in_.tolist() if hasattr(attr_SparseCoder_feature_names_in_, 'tolist') else attr_SparseCoder_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparsePCA.ts
import crypto43 from "node:crypto";
var SparsePCA = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SparsePCA${crypto43.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparsePCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparsePCA
try: bridgeSparsePCA
except NameError: bridgeSparsePCA = {}
`;
    await this._py.ex`ctor_SparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'U_init': np.array(${this.opts["U_init"] ?? void 0}) if ${this.opts["U_init"] !== void 0} else None, 'V_init': np.array(${this.opts["V_init"] ?? void 0}) if ${this.opts["V_init"] !== void 0} else None, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SparsePCA = {k: v for k, v in ctor_SparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeSparsePCA[${this.id}] = SparsePCA(**ctor_SparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_SparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparsePCA_fit = {k: v for k, v in pms_SparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit = bridgeSparsePCA[${this.id}].fit(**pms_SparsePCA_fit)`;
    return this._py`res_SparsePCA_fit.tolist() if hasattr(res_SparsePCA_fit, 'tolist') else res_SparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparsePCA_fit_transform = {k: v for k, v in pms_SparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit_transform = bridgeSparsePCA[${this.id}].fit_transform(**pms_SparsePCA_fit_transform)`;
    return this._py`res_SparsePCA_fit_transform.tolist() if hasattr(res_SparsePCA_fit_transform, 'tolist') else res_SparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparsePCA_get_feature_names_out = {k: v for k, v in pms_SparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_feature_names_out = bridgeSparsePCA[${this.id}].get_feature_names_out(**pms_SparsePCA_get_feature_names_out)`;
    return this._py`res_SparsePCA_get_feature_names_out.tolist() if hasattr(res_SparsePCA_get_feature_names_out, 'tolist') else res_SparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparsePCA_get_metadata_routing = {k: v for k, v in pms_SparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_metadata_routing = bridgeSparsePCA[${this.id}].get_metadata_routing(**pms_SparsePCA_get_metadata_routing)`;
    return this._py`res_SparsePCA_get_metadata_routing.tolist() if hasattr(res_SparsePCA_get_metadata_routing, 'tolist') else res_SparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_inverse_transform = {k: v for k, v in pms_SparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_inverse_transform = bridgeSparsePCA[${this.id}].inverse_transform(**pms_SparsePCA_inverse_transform)`;
    return this._py`res_SparsePCA_inverse_transform.tolist() if hasattr(res_SparsePCA_inverse_transform, 'tolist') else res_SparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_SparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparsePCA_set_output = {k: v for k, v in pms_SparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_set_output = bridgeSparsePCA[${this.id}].set_output(**pms_SparsePCA_set_output)`;
    return this._py`res_SparsePCA_set_output.tolist() if hasattr(res_SparsePCA_set_output, 'tolist') else res_SparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge\_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_SparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_transform = {k: v for k, v in pms_SparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_transform = bridgeSparsePCA[${this.id}].transform(**pms_SparsePCA_transform)`;
    return this._py`res_SparsePCA_transform.tolist() if hasattr(res_SparsePCA_transform, 'tolist') else res_SparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_components_ = bridgeSparsePCA[${this.id}].components_`;
      return this._py`attr_SparsePCA_components_.tolist() if hasattr(attr_SparsePCA_components_, 'tolist') else attr_SparsePCA_components_`;
    })();
  }
  /**
    Vector of errors at each iteration.
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing error_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_error_ = bridgeSparsePCA[${this.id}].error_`;
      return this._py`attr_SparsePCA_error_.tolist() if hasattr(attr_SparsePCA_error_, 'tolist') else attr_SparsePCA_error_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_components_ = bridgeSparsePCA[${this.id}].n_components_`;
      return this._py`attr_SparsePCA_n_components_.tolist() if hasattr(attr_SparsePCA_n_components_, 'tolist') else attr_SparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_iter_ = bridgeSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_SparsePCA_n_iter_.tolist() if hasattr(attr_SparsePCA_n_iter_, 'tolist') else attr_SparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_mean_ = bridgeSparsePCA[${this.id}].mean_`;
      return this._py`attr_SparsePCA_mean_.tolist() if hasattr(attr_SparsePCA_mean_, 'tolist') else attr_SparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_features_in_ = bridgeSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_SparsePCA_n_features_in_.tolist() if hasattr(attr_SparsePCA_n_features_in_, 'tolist') else attr_SparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_feature_names_in_ = bridgeSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_SparsePCA_feature_names_in_.tolist() if hasattr(attr_SparsePCA_feature_names_in_, 'tolist') else attr_SparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/TruncatedSVD.ts
import crypto44 from "node:crypto";
var TruncatedSVD = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TruncatedSVD${crypto44.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TruncatedSVD.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import TruncatedSVD
try: bridgeTruncatedSVD
except NameError: bridgeTruncatedSVD = {}
`;
    await this._py.ex`ctor_TruncatedSVD = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_TruncatedSVD = {k: v for k, v in ctor_TruncatedSVD.items() if v is not None}`;
    await this._py.ex`bridgeTruncatedSVD[${this.id}] = TruncatedSVD(**ctor_TruncatedSVD)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTruncatedSVD[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model on training data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit()");
    }
    await this._py.ex`pms_TruncatedSVD_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit = {k: v for k, v in pms_TruncatedSVD_fit.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit = bridgeTruncatedSVD[${this.id}].fit(**pms_TruncatedSVD_fit)`;
    return this._py`res_TruncatedSVD_fit.tolist() if hasattr(res_TruncatedSVD_fit, 'tolist') else res_TruncatedSVD_fit`;
  }
  /**
    Fit model to X and perform dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit_transform()");
    }
    await this._py.ex`pms_TruncatedSVD_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit_transform = {k: v for k, v in pms_TruncatedSVD_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit_transform = bridgeTruncatedSVD[${this.id}].fit_transform(**pms_TruncatedSVD_fit_transform)`;
    return this._py`res_TruncatedSVD_fit_transform.tolist() if hasattr(res_TruncatedSVD_fit_transform, 'tolist') else res_TruncatedSVD_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TruncatedSVD_get_feature_names_out = {k: v for k, v in pms_TruncatedSVD_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_feature_names_out = bridgeTruncatedSVD[${this.id}].get_feature_names_out(**pms_TruncatedSVD_get_feature_names_out)`;
    return this._py`res_TruncatedSVD_get_feature_names_out.tolist() if hasattr(res_TruncatedSVD_get_feature_names_out, 'tolist') else res_TruncatedSVD_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TruncatedSVD_get_metadata_routing = {k: v for k, v in pms_TruncatedSVD_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_metadata_routing = bridgeTruncatedSVD[${this.id}].get_metadata_routing(**pms_TruncatedSVD_get_metadata_routing)`;
    return this._py`res_TruncatedSVD_get_metadata_routing.tolist() if hasattr(res_TruncatedSVD_get_metadata_routing, 'tolist') else res_TruncatedSVD_get_metadata_routing`;
  }
  /**
      Transform X back to its original space.
  
      Returns an array X\_original whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_inverse_transform = {k: v for k, v in pms_TruncatedSVD_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_inverse_transform = bridgeTruncatedSVD[${this.id}].inverse_transform(**pms_TruncatedSVD_inverse_transform)`;
    return this._py`res_TruncatedSVD_inverse_transform.tolist() if hasattr(res_TruncatedSVD_inverse_transform, 'tolist') else res_TruncatedSVD_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before set_output()");
    }
    await this._py.ex`pms_TruncatedSVD_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TruncatedSVD_set_output = {k: v for k, v in pms_TruncatedSVD_set_output.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_set_output = bridgeTruncatedSVD[${this.id}].set_output(**pms_TruncatedSVD_set_output)`;
    return this._py`res_TruncatedSVD_set_output.tolist() if hasattr(res_TruncatedSVD_set_output, 'tolist') else res_TruncatedSVD_set_output`;
  }
  /**
    Perform dimensionality reduction on X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before transform()");
    }
    await this._py.ex`pms_TruncatedSVD_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_transform = {k: v for k, v in pms_TruncatedSVD_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_transform = bridgeTruncatedSVD[${this.id}].transform(**pms_TruncatedSVD_transform)`;
    return this._py`res_TruncatedSVD_transform.tolist() if hasattr(res_TruncatedSVD_transform, 'tolist') else res_TruncatedSVD_transform`;
  }
  /**
    The right singular vectors of the input data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_components_ = bridgeTruncatedSVD[${this.id}].components_`;
      return this._py`attr_TruncatedSVD_components_.tolist() if hasattr(attr_TruncatedSVD_components_, 'tolist') else attr_TruncatedSVD_components_`;
    })();
  }
  /**
    The variance of the training samples transformed by a projection to each component.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ = bridgeTruncatedSVD[${this.id}].explained_variance_`;
      return this._py`attr_TruncatedSVD_explained_variance_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_, 'tolist') else attr_TruncatedSVD_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ratio_ = bridgeTruncatedSVD[${this.id}].explained_variance_ratio_`;
      return this._py`attr_TruncatedSVD_explained_variance_ratio_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_ratio_, 'tolist') else attr_TruncatedSVD_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n\_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_singular_values_ = bridgeTruncatedSVD[${this.id}].singular_values_`;
      return this._py`attr_TruncatedSVD_singular_values_.tolist() if hasattr(attr_TruncatedSVD_singular_values_, 'tolist') else attr_TruncatedSVD_singular_values_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_n_features_in_ = bridgeTruncatedSVD[${this.id}].n_features_in_`;
      return this._py`attr_TruncatedSVD_n_features_in_.tolist() if hasattr(attr_TruncatedSVD_n_features_in_, 'tolist') else attr_TruncatedSVD_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_feature_names_in_ = bridgeTruncatedSVD[${this.id}].feature_names_in_`;
      return this._py`attr_TruncatedSVD_feature_names_in_.tolist() if hasattr(attr_TruncatedSVD_feature_names_in_, 'tolist') else attr_TruncatedSVD_feature_names_in_`;
    })();
  }
};

// src/generated/discriminant_analysis/LinearDiscriminantAnalysis.ts
import crypto45 from "node:crypto";
var LinearDiscriminantAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearDiscriminantAnalysis${crypto45.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LinearDiscriminantAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
try: bridgeLinearDiscriminantAnalysis
except NameError: bridgeLinearDiscriminantAnalysis = {}
`;
    await this._py.ex`ctor_LinearDiscriminantAnalysis = {'solver': ${this.opts["solver"] ?? void 0}, 'shrinkage': ${this.opts["shrinkage"] ?? void 0}, 'priors': np.array(${this.opts["priors"] ?? void 0}) if ${this.opts["priors"] !== void 0} else None, 'n_components': ${this.opts["n_components"] ?? void 0}, 'store_covariance': ${this.opts["store_covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'covariance_estimator': ${this.opts["covariance_estimator"] ?? void 0}}

ctor_LinearDiscriminantAnalysis = {k: v for k, v in ctor_LinearDiscriminantAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeLinearDiscriminantAnalysis[${this.id}] = LinearDiscriminantAnalysis(**ctor_LinearDiscriminantAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearDiscriminantAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply decision function to an array of samples.
  
      The decision function is equal (up to a constant factor) to the log-posterior of the model, i.e. `log p(y \= k | x)`. In a binary classification setting this instead corresponds to the difference `log p(y \= 1 | x) \- log p(y \= 0 | x)`. See [Mathematical formulation of the LDA and QDA classifiers](../lda_qda.html#lda-qda-math).
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_decision_function = {k: v for k, v in pms_LinearDiscriminantAnalysis_decision_function.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_decision_function = bridgeLinearDiscriminantAnalysis[${this.id}].decision_function(**pms_LinearDiscriminantAnalysis_decision_function)`;
    return this._py`res_LinearDiscriminantAnalysis_decision_function.tolist() if hasattr(res_LinearDiscriminantAnalysis_decision_function, 'tolist') else res_LinearDiscriminantAnalysis_decision_function`;
  }
  /**
    Fit the Linear Discriminant Analysis model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_fit = {k: v for k, v in pms_LinearDiscriminantAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_fit = bridgeLinearDiscriminantAnalysis[${this.id}].fit(**pms_LinearDiscriminantAnalysis_fit)`;
    return this._py`res_LinearDiscriminantAnalysis_fit.tolist() if hasattr(res_LinearDiscriminantAnalysis_fit, 'tolist') else res_LinearDiscriminantAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_LinearDiscriminantAnalysis_fit_transform = {k: v for k, v in pms_LinearDiscriminantAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_fit_transform = bridgeLinearDiscriminantAnalysis[${this.id}].fit_transform(**pms_LinearDiscriminantAnalysis_fit_transform)`;
    return this._py`res_LinearDiscriminantAnalysis_fit_transform.tolist() if hasattr(res_LinearDiscriminantAnalysis_fit_transform, 'tolist') else res_LinearDiscriminantAnalysis_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LinearDiscriminantAnalysis_get_feature_names_out = {k: v for k, v in pms_LinearDiscriminantAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_get_feature_names_out = bridgeLinearDiscriminantAnalysis[${this.id}].get_feature_names_out(**pms_LinearDiscriminantAnalysis_get_feature_names_out)`;
    return this._py`res_LinearDiscriminantAnalysis_get_feature_names_out.tolist() if hasattr(res_LinearDiscriminantAnalysis_get_feature_names_out, 'tolist') else res_LinearDiscriminantAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearDiscriminantAnalysis_get_metadata_routing = {k: v for k, v in pms_LinearDiscriminantAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_get_metadata_routing = bridgeLinearDiscriminantAnalysis[${this.id}].get_metadata_routing(**pms_LinearDiscriminantAnalysis_get_metadata_routing)`;
    return this._py`res_LinearDiscriminantAnalysis_get_metadata_routing.tolist() if hasattr(res_LinearDiscriminantAnalysis_get_metadata_routing, 'tolist') else res_LinearDiscriminantAnalysis_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict = bridgeLinearDiscriminantAnalysis[${this.id}].predict(**pms_LinearDiscriminantAnalysis_predict)`;
    return this._py`res_LinearDiscriminantAnalysis_predict.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict, 'tolist') else res_LinearDiscriminantAnalysis_predict`;
  }
  /**
    Estimate log probability.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict_log_proba = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict_log_proba = bridgeLinearDiscriminantAnalysis[${this.id}].predict_log_proba(**pms_LinearDiscriminantAnalysis_predict_log_proba)`;
    return this._py`res_LinearDiscriminantAnalysis_predict_log_proba.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict_log_proba, 'tolist') else res_LinearDiscriminantAnalysis_predict_log_proba`;
  }
  /**
    Estimate probability.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict_proba = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict_proba = bridgeLinearDiscriminantAnalysis[${this.id}].predict_proba(**pms_LinearDiscriminantAnalysis_predict_proba)`;
    return this._py`res_LinearDiscriminantAnalysis_predict_proba.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict_proba, 'tolist') else res_LinearDiscriminantAnalysis_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before score()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_score = {k: v for k, v in pms_LinearDiscriminantAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_score = bridgeLinearDiscriminantAnalysis[${this.id}].score(**pms_LinearDiscriminantAnalysis_score)`;
    return this._py`res_LinearDiscriminantAnalysis_score.tolist() if hasattr(res_LinearDiscriminantAnalysis_score, 'tolist') else res_LinearDiscriminantAnalysis_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LinearDiscriminantAnalysis_set_output = {k: v for k, v in pms_LinearDiscriminantAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_set_output = bridgeLinearDiscriminantAnalysis[${this.id}].set_output(**pms_LinearDiscriminantAnalysis_set_output)`;
    return this._py`res_LinearDiscriminantAnalysis_set_output.tolist() if hasattr(res_LinearDiscriminantAnalysis_set_output, 'tolist') else res_LinearDiscriminantAnalysis_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearDiscriminantAnalysis_set_score_request = {k: v for k, v in pms_LinearDiscriminantAnalysis_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_set_score_request = bridgeLinearDiscriminantAnalysis[${this.id}].set_score_request(**pms_LinearDiscriminantAnalysis_set_score_request)`;
    return this._py`res_LinearDiscriminantAnalysis_set_score_request.tolist() if hasattr(res_LinearDiscriminantAnalysis_set_score_request, 'tolist') else res_LinearDiscriminantAnalysis_set_score_request`;
  }
  /**
    Project data to maximize class separation.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before transform()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_transform = {k: v for k, v in pms_LinearDiscriminantAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_transform = bridgeLinearDiscriminantAnalysis[${this.id}].transform(**pms_LinearDiscriminantAnalysis_transform)`;
    return this._py`res_LinearDiscriminantAnalysis_transform.tolist() if hasattr(res_LinearDiscriminantAnalysis_transform, 'tolist') else res_LinearDiscriminantAnalysis_transform`;
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_coef_ = bridgeLinearDiscriminantAnalysis[${this.id}].coef_`;
      return this._py`attr_LinearDiscriminantAnalysis_coef_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_coef_, 'tolist') else attr_LinearDiscriminantAnalysis_coef_`;
    })();
  }
  /**
    Intercept term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_intercept_ = bridgeLinearDiscriminantAnalysis[${this.id}].intercept_`;
      return this._py`attr_LinearDiscriminantAnalysis_intercept_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_intercept_, 'tolist') else attr_LinearDiscriminantAnalysis_intercept_`;
    })();
  }
  /**
    Weighted within-class covariance matrix. It corresponds to `sum\_k prior\_k \* C\_k` where `C\_k` is the covariance matrix of the samples in class `k`. The `C\_k` are estimated using the (potentially shrunk) biased estimator of covariance. If solver is â€˜svdâ€™, only exists when `store\_covariance` is `true`.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_covariance_ = bridgeLinearDiscriminantAnalysis[${this.id}].covariance_`;
      return this._py`attr_LinearDiscriminantAnalysis_covariance_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_covariance_, 'tolist') else attr_LinearDiscriminantAnalysis_covariance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components. If `n\_components` is not set then all components are stored and the sum of explained variances is equal to 1.0. Only available when eigen or svd solver is used.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_explained_variance_ratio_ = bridgeLinearDiscriminantAnalysis[${this.id}].explained_variance_ratio_`;
      return this._py`attr_LinearDiscriminantAnalysis_explained_variance_ratio_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_explained_variance_ratio_, 'tolist') else attr_LinearDiscriminantAnalysis_explained_variance_ratio_`;
    })();
  }
  /**
    Class-wise means.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_means_ = bridgeLinearDiscriminantAnalysis[${this.id}].means_`;
      return this._py`attr_LinearDiscriminantAnalysis_means_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_means_, 'tolist') else attr_LinearDiscriminantAnalysis_means_`;
    })();
  }
  /**
    Class priors (sum to 1).
   */
  get priors_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing priors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_priors_ = bridgeLinearDiscriminantAnalysis[${this.id}].priors_`;
      return this._py`attr_LinearDiscriminantAnalysis_priors_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_priors_, 'tolist') else attr_LinearDiscriminantAnalysis_priors_`;
    })();
  }
  /**
    Scaling of the features in the space spanned by the class centroids. Only available for â€˜svdâ€™ and â€˜eigenâ€™ solvers.
   */
  get scalings_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing scalings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_scalings_ = bridgeLinearDiscriminantAnalysis[${this.id}].scalings_`;
      return this._py`attr_LinearDiscriminantAnalysis_scalings_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_scalings_, 'tolist') else attr_LinearDiscriminantAnalysis_scalings_`;
    })();
  }
  /**
    Overall mean. Only present if solver is â€˜svdâ€™.
   */
  get xbar_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing xbar_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_xbar_ = bridgeLinearDiscriminantAnalysis[${this.id}].xbar_`;
      return this._py`attr_LinearDiscriminantAnalysis_xbar_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_xbar_, 'tolist') else attr_LinearDiscriminantAnalysis_xbar_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_classes_ = bridgeLinearDiscriminantAnalysis[${this.id}].classes_`;
      return this._py`attr_LinearDiscriminantAnalysis_classes_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_classes_, 'tolist') else attr_LinearDiscriminantAnalysis_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_n_features_in_ = bridgeLinearDiscriminantAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_LinearDiscriminantAnalysis_n_features_in_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_n_features_in_, 'tolist') else attr_LinearDiscriminantAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_feature_names_in_ = bridgeLinearDiscriminantAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_LinearDiscriminantAnalysis_feature_names_in_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_feature_names_in_, 'tolist') else attr_LinearDiscriminantAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/discriminant_analysis/QuadraticDiscriminantAnalysis.ts
import crypto46 from "node:crypto";
var QuadraticDiscriminantAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `QuadraticDiscriminantAnalysis${crypto46.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "QuadraticDiscriminantAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
try: bridgeQuadraticDiscriminantAnalysis
except NameError: bridgeQuadraticDiscriminantAnalysis = {}
`;
    await this._py.ex`ctor_QuadraticDiscriminantAnalysis = {'priors': np.array(${this.opts["priors"] ?? void 0}) if ${this.opts["priors"] !== void 0} else None, 'reg_param': ${this.opts["reg_param"] ?? void 0}, 'store_covariance': ${this.opts["store_covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_QuadraticDiscriminantAnalysis = {k: v for k, v in ctor_QuadraticDiscriminantAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeQuadraticDiscriminantAnalysis[${this.id}] = QuadraticDiscriminantAnalysis(**ctor_QuadraticDiscriminantAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuadraticDiscriminantAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply decision function to an array of samples.
  
      The decision function is equal (up to a constant factor) to the log-posterior of the model, i.e. `log p(y \= k | x)`. In a binary classification setting this instead corresponds to the difference `log p(y \= 1 | x) \- log p(y \= 0 | x)`. See [Mathematical formulation of the LDA and QDA classifiers](../lda_qda.html#lda-qda-math).
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_decision_function = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_decision_function.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_decision_function = bridgeQuadraticDiscriminantAnalysis[${this.id}].decision_function(**pms_QuadraticDiscriminantAnalysis_decision_function)`;
    return this._py`res_QuadraticDiscriminantAnalysis_decision_function.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_decision_function, 'tolist') else res_QuadraticDiscriminantAnalysis_decision_function`;
  }
  /**
    Fit the model according to the given training data and parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_fit = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_fit = bridgeQuadraticDiscriminantAnalysis[${this.id}].fit(**pms_QuadraticDiscriminantAnalysis_fit)`;
    return this._py`res_QuadraticDiscriminantAnalysis_fit.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_fit, 'tolist') else res_QuadraticDiscriminantAnalysis_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuadraticDiscriminantAnalysis_get_metadata_routing = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_get_metadata_routing = bridgeQuadraticDiscriminantAnalysis[${this.id}].get_metadata_routing(**pms_QuadraticDiscriminantAnalysis_get_metadata_routing)`;
    return this._py`res_QuadraticDiscriminantAnalysis_get_metadata_routing.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_get_metadata_routing, 'tolist') else res_QuadraticDiscriminantAnalysis_get_metadata_routing`;
  }
  /**
      Perform classification on an array of test vectors X.
  
      The predicted class C for each sample in X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict(**pms_QuadraticDiscriminantAnalysis_predict)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict, 'tolist') else res_QuadraticDiscriminantAnalysis_predict`;
  }
  /**
    Return log of posterior probabilities of classification.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict_log_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict_log_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_log_proba(**pms_QuadraticDiscriminantAnalysis_predict_log_proba)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict_log_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_log_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_log_proba`;
  }
  /**
    Return posterior probabilities of classification.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_proba.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_proba(**pms_QuadraticDiscriminantAnalysis_predict_proba)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before score()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_score = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_score = bridgeQuadraticDiscriminantAnalysis[${this.id}].score(**pms_QuadraticDiscriminantAnalysis_score)`;
    return this._py`res_QuadraticDiscriminantAnalysis_score.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_score, 'tolist') else res_QuadraticDiscriminantAnalysis_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuadraticDiscriminantAnalysis_set_score_request = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_set_score_request.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_set_score_request = bridgeQuadraticDiscriminantAnalysis[${this.id}].set_score_request(**pms_QuadraticDiscriminantAnalysis_set_score_request)`;
    return this._py`res_QuadraticDiscriminantAnalysis_set_score_request.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_set_score_request, 'tolist') else res_QuadraticDiscriminantAnalysis_set_score_request`;
  }
  /**
    For each class, gives the covariance matrix estimated using the samples of that class. The estimations are unbiased. Only present if `store\_covariance` is `true`.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_covariance_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].covariance_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_covariance_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_covariance_, 'tolist') else attr_QuadraticDiscriminantAnalysis_covariance_`;
    })();
  }
  /**
    Class-wise means.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_means_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].means_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_means_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_means_, 'tolist') else attr_QuadraticDiscriminantAnalysis_means_`;
    })();
  }
  /**
    Class priors (sum to 1).
   */
  get priors_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing priors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_priors_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].priors_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_priors_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_priors_, 'tolist') else attr_QuadraticDiscriminantAnalysis_priors_`;
    })();
  }
  /**
    For each class k an array of shape (n\_features, n\_k), where `n\_k \= min(n\_features, number of elements in class k)` It is the rotation of the Gaussian distribution, i.e. its principal axis. It corresponds to `V`, the matrix of eigenvectors coming from the SVD of `Xk \= U S Vt` where `Xk` is the centered matrix of samples from class k.
   */
  get rotations_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_rotations_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].rotations_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_rotations_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_rotations_, 'tolist') else attr_QuadraticDiscriminantAnalysis_rotations_`;
    })();
  }
  /**
    For each class, contains the scaling of the Gaussian distributions along its principal axes, i.e. the variance in the rotated coordinate system. It corresponds to `S^2 / (n\_samples \- 1)`, where `S` is the diagonal matrix of singular values from the SVD of `Xk`, where `Xk` is the centered matrix of samples from class k.
   */
  get scalings_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing scalings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_scalings_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].scalings_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_scalings_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_scalings_, 'tolist') else attr_QuadraticDiscriminantAnalysis_scalings_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_classes_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].classes_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_classes_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_classes_, 'tolist') else attr_QuadraticDiscriminantAnalysis_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_n_features_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_n_features_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_n_features_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_feature_names_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_feature_names_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_feature_names_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/dummy/DummyClassifier.ts
import crypto47 from "node:crypto";
var DummyClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DummyClassifier${crypto47.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DummyClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.dummy import DummyClassifier
try: bridgeDummyClassifier
except NameError: bridgeDummyClassifier = {}
`;
    await this._py.ex`ctor_DummyClassifier = {'strategy': ${this.opts["strategy"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'constant': np.array(${this.opts["constant"] ?? void 0}) if ${this.opts["constant"] !== void 0} else None}

ctor_DummyClassifier = {k: v for k, v in ctor_DummyClassifier.items() if v is not None}`;
    await this._py.ex`bridgeDummyClassifier[${this.id}] = DummyClassifier(**ctor_DummyClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDummyClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the baseline classifier.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before fit()");
    }
    await this._py.ex`pms_DummyClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyClassifier_fit = {k: v for k, v in pms_DummyClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_fit = bridgeDummyClassifier[${this.id}].fit(**pms_DummyClassifier_fit)`;
    return this._py`res_DummyClassifier_fit.tolist() if hasattr(res_DummyClassifier_fit, 'tolist') else res_DummyClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DummyClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DummyClassifier_get_metadata_routing = {k: v for k, v in pms_DummyClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_get_metadata_routing = bridgeDummyClassifier[${this.id}].get_metadata_routing(**pms_DummyClassifier_get_metadata_routing)`;
    return this._py`res_DummyClassifier_get_metadata_routing.tolist() if hasattr(res_DummyClassifier_get_metadata_routing, 'tolist') else res_DummyClassifier_get_metadata_routing`;
  }
  /**
    Perform classification on test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before predict()");
    }
    await this._py.ex`pms_DummyClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DummyClassifier_predict = {k: v for k, v in pms_DummyClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict = bridgeDummyClassifier[${this.id}].predict(**pms_DummyClassifier_predict)`;
    return this._py`res_DummyClassifier_predict.tolist() if hasattr(res_DummyClassifier_predict, 'tolist') else res_DummyClassifier_predict`;
  }
  /**
    Return log probability estimates for the test vectors X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_DummyClassifier_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_DummyClassifier_predict_log_proba = {k: v for k, v in pms_DummyClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict_log_proba = bridgeDummyClassifier[${this.id}].predict_log_proba(**pms_DummyClassifier_predict_log_proba)`;
    return this._py`res_DummyClassifier_predict_log_proba.tolist() if hasattr(res_DummyClassifier_predict_log_proba, 'tolist') else res_DummyClassifier_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vectors X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before predict_proba()");
    }
    await this._py.ex`pms_DummyClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DummyClassifier_predict_proba = {k: v for k, v in pms_DummyClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict_proba = bridgeDummyClassifier[${this.id}].predict_proba(**pms_DummyClassifier_predict_proba)`;
    return this._py`res_DummyClassifier_predict_proba.tolist() if hasattr(res_DummyClassifier_predict_proba, 'tolist') else res_DummyClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before score()");
    }
    await this._py.ex`pms_DummyClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyClassifier_score = {k: v for k, v in pms_DummyClassifier_score.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_score = bridgeDummyClassifier[${this.id}].score(**pms_DummyClassifier_score)`;
    return this._py`res_DummyClassifier_score.tolist() if hasattr(res_DummyClassifier_score, 'tolist') else res_DummyClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DummyClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyClassifier_set_fit_request = {k: v for k, v in pms_DummyClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_set_fit_request = bridgeDummyClassifier[${this.id}].set_fit_request(**pms_DummyClassifier_set_fit_request)`;
    return this._py`res_DummyClassifier_set_fit_request.tolist() if hasattr(res_DummyClassifier_set_fit_request, 'tolist') else res_DummyClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DummyClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyClassifier_set_score_request = {k: v for k, v in pms_DummyClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_set_score_request = bridgeDummyClassifier[${this.id}].set_score_request(**pms_DummyClassifier_set_score_request)`;
    return this._py`res_DummyClassifier_set_score_request.tolist() if hasattr(res_DummyClassifier_set_score_request, 'tolist') else res_DummyClassifier_set_score_request`;
  }
  /**
    Unique class labels observed in `y`. For multi-output classification problems, this attribute is a list of arrays as each output has an independent set of possible classes.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_classes_ = bridgeDummyClassifier[${this.id}].classes_`;
      return this._py`attr_DummyClassifier_classes_.tolist() if hasattr(attr_DummyClassifier_classes_, 'tolist') else attr_DummyClassifier_classes_`;
    })();
  }
  /**
    Number of label for each output.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_n_classes_ = bridgeDummyClassifier[${this.id}].n_classes_`;
      return this._py`attr_DummyClassifier_n_classes_.tolist() if hasattr(attr_DummyClassifier_n_classes_, 'tolist') else attr_DummyClassifier_n_classes_`;
    })();
  }
  /**
    Frequency of each class observed in `y`. For multioutput classification problems, this is computed independently for each output.
   */
  get class_prior_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing class_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_class_prior_ = bridgeDummyClassifier[${this.id}].class_prior_`;
      return this._py`attr_DummyClassifier_class_prior_.tolist() if hasattr(attr_DummyClassifier_class_prior_, 'tolist') else attr_DummyClassifier_class_prior_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_n_outputs_ = bridgeDummyClassifier[${this.id}].n_outputs_`;
      return this._py`attr_DummyClassifier_n_outputs_.tolist() if hasattr(attr_DummyClassifier_n_outputs_, 'tolist') else attr_DummyClassifier_n_outputs_`;
    })();
  }
  /**
    True if the array returned from predict is to be in sparse CSC format. Is automatically set to `true` if the input `y` is passed in sparse format.
   */
  get sparse_output_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing sparse_output_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_sparse_output_ = bridgeDummyClassifier[${this.id}].sparse_output_`;
      return this._py`attr_DummyClassifier_sparse_output_.tolist() if hasattr(attr_DummyClassifier_sparse_output_, 'tolist') else attr_DummyClassifier_sparse_output_`;
    })();
  }
};

// src/generated/dummy/DummyRegressor.ts
import crypto48 from "node:crypto";
var DummyRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DummyRegressor${crypto48.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DummyRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.dummy import DummyRegressor
try: bridgeDummyRegressor
except NameError: bridgeDummyRegressor = {}
`;
    await this._py.ex`ctor_DummyRegressor = {'strategy': ${this.opts["strategy"] ?? void 0}, 'constant': np.array(${this.opts["constant"] ?? void 0}) if ${this.opts["constant"] !== void 0} else None, 'quantile': ${this.opts["quantile"] ?? void 0}}

ctor_DummyRegressor = {k: v for k, v in ctor_DummyRegressor.items() if v is not None}`;
    await this._py.ex`bridgeDummyRegressor[${this.id}] = DummyRegressor(**ctor_DummyRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDummyRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the random regressor.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before fit()");
    }
    await this._py.ex`pms_DummyRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyRegressor_fit = {k: v for k, v in pms_DummyRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_fit = bridgeDummyRegressor[${this.id}].fit(**pms_DummyRegressor_fit)`;
    return this._py`res_DummyRegressor_fit.tolist() if hasattr(res_DummyRegressor_fit, 'tolist') else res_DummyRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DummyRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DummyRegressor_get_metadata_routing = {k: v for k, v in pms_DummyRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_get_metadata_routing = bridgeDummyRegressor[${this.id}].get_metadata_routing(**pms_DummyRegressor_get_metadata_routing)`;
    return this._py`res_DummyRegressor_get_metadata_routing.tolist() if hasattr(res_DummyRegressor_get_metadata_routing, 'tolist') else res_DummyRegressor_get_metadata_routing`;
  }
  /**
    Perform classification on test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before predict()");
    }
    await this._py.ex`pms_DummyRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_DummyRegressor_predict = {k: v for k, v in pms_DummyRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_predict = bridgeDummyRegressor[${this.id}].predict(**pms_DummyRegressor_predict)`;
    return this._py`res_DummyRegressor_predict.tolist() if hasattr(res_DummyRegressor_predict, 'tolist') else res_DummyRegressor_predict`;
  }
  /**
      Return the coefficient of determination R^2 of the prediction.
  
      The coefficient R^2 is defined as `(1 \- u/v)`, where `u` is the residual sum of squares `((y\_true \- y\_pred) \*\* 2).sum()` and `v` is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a R^2 score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before score()");
    }
    await this._py.ex`pms_DummyRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyRegressor_score = {k: v for k, v in pms_DummyRegressor_score.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_score = bridgeDummyRegressor[${this.id}].score(**pms_DummyRegressor_score)`;
    return this._py`res_DummyRegressor_score.tolist() if hasattr(res_DummyRegressor_score, 'tolist') else res_DummyRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyRegressor_set_fit_request = {k: v for k, v in pms_DummyRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_fit_request = bridgeDummyRegressor[${this.id}].set_fit_request(**pms_DummyRegressor_set_fit_request)`;
    return this._py`res_DummyRegressor_set_fit_request.tolist() if hasattr(res_DummyRegressor_set_fit_request, 'tolist') else res_DummyRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_DummyRegressor_set_predict_request = {k: v for k, v in pms_DummyRegressor_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_predict_request = bridgeDummyRegressor[${this.id}].set_predict_request(**pms_DummyRegressor_set_predict_request)`;
    return this._py`res_DummyRegressor_set_predict_request.tolist() if hasattr(res_DummyRegressor_set_predict_request, 'tolist') else res_DummyRegressor_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyRegressor_set_score_request = {k: v for k, v in pms_DummyRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_score_request = bridgeDummyRegressor[${this.id}].set_score_request(**pms_DummyRegressor_set_score_request)`;
    return this._py`res_DummyRegressor_set_score_request.tolist() if hasattr(res_DummyRegressor_set_score_request, 'tolist') else res_DummyRegressor_set_score_request`;
  }
  /**
    Mean or median or quantile of the training targets or constant value given by the user.
   */
  get constant_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing constant_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_constant_ = bridgeDummyRegressor[${this.id}].constant_`;
      return this._py`attr_DummyRegressor_constant_.tolist() if hasattr(attr_DummyRegressor_constant_, 'tolist') else attr_DummyRegressor_constant_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_n_outputs_ = bridgeDummyRegressor[${this.id}].n_outputs_`;
      return this._py`attr_DummyRegressor_n_outputs_.tolist() if hasattr(attr_DummyRegressor_n_outputs_, 'tolist') else attr_DummyRegressor_n_outputs_`;
    })();
  }
};

// src/generated/ensemble/AdaBoostClassifier.ts
import crypto49 from "node:crypto";
var AdaBoostClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AdaBoostClassifier${crypto49.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AdaBoostClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import AdaBoostClassifier
try: bridgeAdaBoostClassifier
except NameError: bridgeAdaBoostClassifier = {}
`;
    await this._py.ex`ctor_AdaBoostClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_AdaBoostClassifier = {k: v for k, v in ctor_AdaBoostClassifier.items() if v is not None}`;
    await this._py.ex`bridgeAdaBoostClassifier[${this.id}] = AdaBoostClassifier(**ctor_AdaBoostClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdaBoostClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_decision_function = {k: v for k, v in pms_AdaBoostClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_decision_function = bridgeAdaBoostClassifier[${this.id}].decision_function(**pms_AdaBoostClassifier_decision_function)`;
    return this._py`res_AdaBoostClassifier_decision_function.tolist() if hasattr(res_AdaBoostClassifier_decision_function, 'tolist') else res_AdaBoostClassifier_decision_function`;
  }
  /**
    Build a boosted classifier/regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before fit()");
    }
    await this._py.ex`pms_AdaBoostClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_fit = {k: v for k, v in pms_AdaBoostClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_fit = bridgeAdaBoostClassifier[${this.id}].fit(**pms_AdaBoostClassifier_fit)`;
    return this._py`res_AdaBoostClassifier_fit.tolist() if hasattr(res_AdaBoostClassifier_fit, 'tolist') else res_AdaBoostClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AdaBoostClassifier_get_metadata_routing = {k: v for k, v in pms_AdaBoostClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_get_metadata_routing = bridgeAdaBoostClassifier[${this.id}].get_metadata_routing(**pms_AdaBoostClassifier_get_metadata_routing)`;
    return this._py`res_AdaBoostClassifier_get_metadata_routing.tolist() if hasattr(res_AdaBoostClassifier_get_metadata_routing, 'tolist') else res_AdaBoostClassifier_get_metadata_routing`;
  }
  /**
      Predict classes for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before predict()");
    }
    await this._py.ex`pms_AdaBoostClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict = {k: v for k, v in pms_AdaBoostClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict = bridgeAdaBoostClassifier[${this.id}].predict(**pms_AdaBoostClassifier_predict)`;
    return this._py`res_AdaBoostClassifier_predict.tolist() if hasattr(res_AdaBoostClassifier_predict, 'tolist') else res_AdaBoostClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the weighted mean predicted class log-probabilities of the classifiers in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_log_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_log_proba = bridgeAdaBoostClassifier[${this.id}].predict_log_proba(**pms_AdaBoostClassifier_predict_log_proba)`;
    return this._py`res_AdaBoostClassifier_predict_log_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_log_proba, 'tolist') else res_AdaBoostClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_proba = bridgeAdaBoostClassifier[${this.id}].predict_proba(**pms_AdaBoostClassifier_predict_proba)`;
    return this._py`res_AdaBoostClassifier_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_proba, 'tolist') else res_AdaBoostClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before score()");
    }
    await this._py.ex`pms_AdaBoostClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_score = {k: v for k, v in pms_AdaBoostClassifier_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_score = bridgeAdaBoostClassifier[${this.id}].score(**pms_AdaBoostClassifier_score)`;
    return this._py`res_AdaBoostClassifier_score.tolist() if hasattr(res_AdaBoostClassifier_score, 'tolist') else res_AdaBoostClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostClassifier_set_fit_request = {k: v for k, v in pms_AdaBoostClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_set_fit_request = bridgeAdaBoostClassifier[${this.id}].set_fit_request(**pms_AdaBoostClassifier_set_fit_request)`;
    return this._py`res_AdaBoostClassifier_set_fit_request.tolist() if hasattr(res_AdaBoostClassifier_set_fit_request, 'tolist') else res_AdaBoostClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostClassifier_set_score_request = {k: v for k, v in pms_AdaBoostClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_set_score_request = bridgeAdaBoostClassifier[${this.id}].set_score_request(**pms_AdaBoostClassifier_set_score_request)`;
    return this._py`res_AdaBoostClassifier_set_score_request.tolist() if hasattr(res_AdaBoostClassifier_set_score_request, 'tolist') else res_AdaBoostClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each boosting iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each boosting iteration.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_decision_function = {k: v for k, v in pms_AdaBoostClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_decision_function = bridgeAdaBoostClassifier[${this.id}].staged_decision_function(**pms_AdaBoostClassifier_staged_decision_function)`;
    return this._py`res_AdaBoostClassifier_staged_decision_function.tolist() if hasattr(res_AdaBoostClassifier_staged_decision_function, 'tolist') else res_AdaBoostClassifier_staged_decision_function`;
  }
  /**
      Return staged predictions for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
  
      This generator method yields the ensemble prediction after each iteration of boosting and therefore allows monitoring, such as to determine the prediction on a test set after each boost.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict = {k: v for k, v in pms_AdaBoostClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict = bridgeAdaBoostClassifier[${this.id}].staged_predict(**pms_AdaBoostClassifier_staged_predict)`;
    return this._py`res_AdaBoostClassifier_staged_predict.tolist() if hasattr(res_AdaBoostClassifier_staged_predict, 'tolist') else res_AdaBoostClassifier_staged_predict`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
  
      This generator method yields the ensemble predicted class probabilities after each iteration of boosting and therefore allows monitoring, such as to determine the predicted class probabilities on a test set after each boost.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict_proba = bridgeAdaBoostClassifier[${this.id}].staged_predict_proba(**pms_AdaBoostClassifier_staged_predict_proba)`;
    return this._py`res_AdaBoostClassifier_staged_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_staged_predict_proba, 'tolist') else res_AdaBoostClassifier_staged_predict_proba`;
  }
  /**
      Return staged scores for X, y.
  
      This generator method yields the ensemble score after each iteration of boosting and therefore allows monitoring, such as to determine the score on a test set after each boost.
     */
  async staged_score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_score()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_staged_score = {k: v for k, v in pms_AdaBoostClassifier_staged_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_score = bridgeAdaBoostClassifier[${this.id}].staged_score(**pms_AdaBoostClassifier_staged_score)`;
    return this._py`res_AdaBoostClassifier_staged_score.tolist() if hasattr(res_AdaBoostClassifier_staged_score, 'tolist') else res_AdaBoostClassifier_staged_score`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_ = bridgeAdaBoostClassifier[${this.id}].estimator_`;
      return this._py`attr_AdaBoostClassifier_estimator_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_, 'tolist') else attr_AdaBoostClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimators_ = bridgeAdaBoostClassifier[${this.id}].estimators_`;
      return this._py`attr_AdaBoostClassifier_estimators_.tolist() if hasattr(attr_AdaBoostClassifier_estimators_, 'tolist') else attr_AdaBoostClassifier_estimators_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_classes_ = bridgeAdaBoostClassifier[${this.id}].classes_`;
      return this._py`attr_AdaBoostClassifier_classes_.tolist() if hasattr(attr_AdaBoostClassifier_classes_, 'tolist') else attr_AdaBoostClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_classes_ = bridgeAdaBoostClassifier[${this.id}].n_classes_`;
      return this._py`attr_AdaBoostClassifier_n_classes_.tolist() if hasattr(attr_AdaBoostClassifier_n_classes_, 'tolist') else attr_AdaBoostClassifier_n_classes_`;
    })();
  }
  /**
    Weights for each estimator in the boosted ensemble.
   */
  get estimator_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_weights_ = bridgeAdaBoostClassifier[${this.id}].estimator_weights_`;
      return this._py`attr_AdaBoostClassifier_estimator_weights_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_weights_, 'tolist') else attr_AdaBoostClassifier_estimator_weights_`;
    })();
  }
  /**
    Classification error for each estimator in the boosted ensemble.
   */
  get estimator_errors_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_errors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_errors_ = bridgeAdaBoostClassifier[${this.id}].estimator_errors_`;
      return this._py`attr_AdaBoostClassifier_estimator_errors_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_errors_, 'tolist') else attr_AdaBoostClassifier_estimator_errors_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_features_in_ = bridgeAdaBoostClassifier[${this.id}].n_features_in_`;
      return this._py`attr_AdaBoostClassifier_n_features_in_.tolist() if hasattr(attr_AdaBoostClassifier_n_features_in_, 'tolist') else attr_AdaBoostClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_feature_names_in_ = bridgeAdaBoostClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_AdaBoostClassifier_feature_names_in_.tolist() if hasattr(attr_AdaBoostClassifier_feature_names_in_, 'tolist') else attr_AdaBoostClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/AdaBoostRegressor.ts
import crypto50 from "node:crypto";
var AdaBoostRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AdaBoostRegressor${crypto50.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("AdaBoostRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import AdaBoostRegressor
try: bridgeAdaBoostRegressor
except NameError: bridgeAdaBoostRegressor = {}
`;
    await this._py.ex`ctor_AdaBoostRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_AdaBoostRegressor = {k: v for k, v in ctor_AdaBoostRegressor.items() if v is not None}`;
    await this._py.ex`bridgeAdaBoostRegressor[${this.id}] = AdaBoostRegressor(**ctor_AdaBoostRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdaBoostRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a boosted classifier/regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before fit()");
    }
    await this._py.ex`pms_AdaBoostRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_fit = {k: v for k, v in pms_AdaBoostRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_fit = bridgeAdaBoostRegressor[${this.id}].fit(**pms_AdaBoostRegressor_fit)`;
    return this._py`res_AdaBoostRegressor_fit.tolist() if hasattr(res_AdaBoostRegressor_fit, 'tolist') else res_AdaBoostRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AdaBoostRegressor_get_metadata_routing = {k: v for k, v in pms_AdaBoostRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_get_metadata_routing = bridgeAdaBoostRegressor[${this.id}].get_metadata_routing(**pms_AdaBoostRegressor_get_metadata_routing)`;
    return this._py`res_AdaBoostRegressor_get_metadata_routing.tolist() if hasattr(res_AdaBoostRegressor_get_metadata_routing, 'tolist') else res_AdaBoostRegressor_get_metadata_routing`;
  }
  /**
      Predict regression value for X.
  
      The predicted regression value of an input sample is computed as the weighted median prediction of the regressors in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before predict()");
    }
    await this._py.ex`pms_AdaBoostRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostRegressor_predict = {k: v for k, v in pms_AdaBoostRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_predict = bridgeAdaBoostRegressor[${this.id}].predict(**pms_AdaBoostRegressor_predict)`;
    return this._py`res_AdaBoostRegressor_predict.tolist() if hasattr(res_AdaBoostRegressor_predict, 'tolist') else res_AdaBoostRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before score()");
    }
    await this._py.ex`pms_AdaBoostRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_score = {k: v for k, v in pms_AdaBoostRegressor_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_score = bridgeAdaBoostRegressor[${this.id}].score(**pms_AdaBoostRegressor_score)`;
    return this._py`res_AdaBoostRegressor_score.tolist() if hasattr(res_AdaBoostRegressor_score, 'tolist') else res_AdaBoostRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostRegressor_set_fit_request = {k: v for k, v in pms_AdaBoostRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_set_fit_request = bridgeAdaBoostRegressor[${this.id}].set_fit_request(**pms_AdaBoostRegressor_set_fit_request)`;
    return this._py`res_AdaBoostRegressor_set_fit_request.tolist() if hasattr(res_AdaBoostRegressor_set_fit_request, 'tolist') else res_AdaBoostRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostRegressor_set_score_request = {k: v for k, v in pms_AdaBoostRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_set_score_request = bridgeAdaBoostRegressor[${this.id}].set_score_request(**pms_AdaBoostRegressor_set_score_request)`;
    return this._py`res_AdaBoostRegressor_set_score_request.tolist() if hasattr(res_AdaBoostRegressor_set_score_request, 'tolist') else res_AdaBoostRegressor_set_score_request`;
  }
  /**
      Return staged predictions for X.
  
      The predicted regression value of an input sample is computed as the weighted median prediction of the regressors in the ensemble.
  
      This generator method yields the ensemble prediction after each iteration of boosting and therefore allows monitoring, such as to determine the prediction on a test set after each boost.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostRegressor_staged_predict = {k: v for k, v in pms_AdaBoostRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_staged_predict = bridgeAdaBoostRegressor[${this.id}].staged_predict(**pms_AdaBoostRegressor_staged_predict)`;
    return this._py`res_AdaBoostRegressor_staged_predict.tolist() if hasattr(res_AdaBoostRegressor_staged_predict, 'tolist') else res_AdaBoostRegressor_staged_predict`;
  }
  /**
      Return staged scores for X, y.
  
      This generator method yields the ensemble score after each iteration of boosting and therefore allows monitoring, such as to determine the score on a test set after each boost.
     */
  async staged_score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before staged_score()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_staged_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_staged_score = {k: v for k, v in pms_AdaBoostRegressor_staged_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_staged_score = bridgeAdaBoostRegressor[${this.id}].staged_score(**pms_AdaBoostRegressor_staged_score)`;
    return this._py`res_AdaBoostRegressor_staged_score.tolist() if hasattr(res_AdaBoostRegressor_staged_score, 'tolist') else res_AdaBoostRegressor_staged_score`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_ = bridgeAdaBoostRegressor[${this.id}].estimator_`;
      return this._py`attr_AdaBoostRegressor_estimator_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_, 'tolist') else attr_AdaBoostRegressor_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimators_ = bridgeAdaBoostRegressor[${this.id}].estimators_`;
      return this._py`attr_AdaBoostRegressor_estimators_.tolist() if hasattr(attr_AdaBoostRegressor_estimators_, 'tolist') else attr_AdaBoostRegressor_estimators_`;
    })();
  }
  /**
    Weights for each estimator in the boosted ensemble.
   */
  get estimator_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_weights_ = bridgeAdaBoostRegressor[${this.id}].estimator_weights_`;
      return this._py`attr_AdaBoostRegressor_estimator_weights_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_weights_, 'tolist') else attr_AdaBoostRegressor_estimator_weights_`;
    })();
  }
  /**
    Regression error for each estimator in the boosted ensemble.
   */
  get estimator_errors_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_errors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_errors_ = bridgeAdaBoostRegressor[${this.id}].estimator_errors_`;
      return this._py`attr_AdaBoostRegressor_estimator_errors_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_errors_, 'tolist') else attr_AdaBoostRegressor_estimator_errors_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_n_features_in_ = bridgeAdaBoostRegressor[${this.id}].n_features_in_`;
      return this._py`attr_AdaBoostRegressor_n_features_in_.tolist() if hasattr(attr_AdaBoostRegressor_n_features_in_, 'tolist') else attr_AdaBoostRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_feature_names_in_ = bridgeAdaBoostRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_AdaBoostRegressor_feature_names_in_.tolist() if hasattr(attr_AdaBoostRegressor_feature_names_in_, 'tolist') else attr_AdaBoostRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/BaggingClassifier.ts
import crypto51 from "node:crypto";
var BaggingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BaggingClassifier${crypto51.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BaggingClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import BaggingClassifier
try: bridgeBaggingClassifier
except NameError: bridgeBaggingClassifier = {}
`;
    await this._py.ex`ctor_BaggingClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'bootstrap_features': ${this.opts["bootstrap_features"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_BaggingClassifier = {k: v for k, v in ctor_BaggingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeBaggingClassifier[${this.id}] = BaggingClassifier(**ctor_BaggingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBaggingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Average of the decision functions of the base classifiers.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_decision_function = {k: v for k, v in pms_BaggingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_decision_function = bridgeBaggingClassifier[${this.id}].decision_function(**pms_BaggingClassifier_decision_function)`;
    return this._py`res_BaggingClassifier_decision_function.tolist() if hasattr(res_BaggingClassifier_decision_function, 'tolist') else res_BaggingClassifier_decision_function`;
  }
  /**
    Build a Bagging ensemble of estimators from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_BaggingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingClassifier_fit = {k: v for k, v in pms_BaggingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_fit = bridgeBaggingClassifier[${this.id}].fit(**pms_BaggingClassifier_fit)`;
    return this._py`res_BaggingClassifier_fit.tolist() if hasattr(res_BaggingClassifier_fit, 'tolist') else res_BaggingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BaggingClassifier_get_metadata_routing = {k: v for k, v in pms_BaggingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_get_metadata_routing = bridgeBaggingClassifier[${this.id}].get_metadata_routing(**pms_BaggingClassifier_get_metadata_routing)`;
    return this._py`res_BaggingClassifier_get_metadata_routing.tolist() if hasattr(res_BaggingClassifier_get_metadata_routing, 'tolist') else res_BaggingClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is computed as the class with the highest mean predicted probability. If base estimators do not implement a `predict\_proba` method, then it resorts to voting.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before predict()");
    }
    await this._py.ex`pms_BaggingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict = {k: v for k, v in pms_BaggingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict = bridgeBaggingClassifier[${this.id}].predict(**pms_BaggingClassifier_predict)`;
    return this._py`res_BaggingClassifier_predict.tolist() if hasattr(res_BaggingClassifier_predict, 'tolist') else res_BaggingClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the base estimators in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_log_proba = {k: v for k, v in pms_BaggingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_log_proba = bridgeBaggingClassifier[${this.id}].predict_log_proba(**pms_BaggingClassifier_predict_log_proba)`;
    return this._py`res_BaggingClassifier_predict_log_proba.tolist() if hasattr(res_BaggingClassifier_predict_log_proba, 'tolist') else res_BaggingClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the mean predicted class probabilities of the base estimators in the ensemble. If base estimators do not implement a `predict\_proba` method, then it resorts to voting and the predicted class probabilities of an input sample represents the proportion of estimators predicting each class.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_proba = {k: v for k, v in pms_BaggingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_proba = bridgeBaggingClassifier[${this.id}].predict_proba(**pms_BaggingClassifier_predict_proba)`;
    return this._py`res_BaggingClassifier_predict_proba.tolist() if hasattr(res_BaggingClassifier_predict_proba, 'tolist') else res_BaggingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before score()");
    }
    await this._py.ex`pms_BaggingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingClassifier_score = {k: v for k, v in pms_BaggingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_score = bridgeBaggingClassifier[${this.id}].score(**pms_BaggingClassifier_score)`;
    return this._py`res_BaggingClassifier_score.tolist() if hasattr(res_BaggingClassifier_score, 'tolist') else res_BaggingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_fit_request = {k: v for k, v in pms_BaggingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_fit_request = bridgeBaggingClassifier[${this.id}].set_fit_request(**pms_BaggingClassifier_set_fit_request)`;
    return this._py`res_BaggingClassifier_set_fit_request.tolist() if hasattr(res_BaggingClassifier_set_fit_request, 'tolist') else res_BaggingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_score_request = {k: v for k, v in pms_BaggingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_score_request = bridgeBaggingClassifier[${this.id}].set_score_request(**pms_BaggingClassifier_set_score_request)`;
    return this._py`res_BaggingClassifier_set_score_request.tolist() if hasattr(res_BaggingClassifier_set_score_request, 'tolist') else res_BaggingClassifier_set_score_request`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimator_ = bridgeBaggingClassifier[${this.id}].estimator_`;
      return this._py`attr_BaggingClassifier_estimator_.tolist() if hasattr(attr_BaggingClassifier_estimator_, 'tolist') else attr_BaggingClassifier_estimator_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_features_in_ = bridgeBaggingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_BaggingClassifier_n_features_in_.tolist() if hasattr(attr_BaggingClassifier_n_features_in_, 'tolist') else attr_BaggingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_feature_names_in_ = bridgeBaggingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_BaggingClassifier_feature_names_in_.tolist() if hasattr(attr_BaggingClassifier_feature_names_in_, 'tolist') else attr_BaggingClassifier_feature_names_in_`;
    })();
  }
  /**
    The collection of fitted base estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_ = bridgeBaggingClassifier[${this.id}].estimators_`;
      return this._py`attr_BaggingClassifier_estimators_.tolist() if hasattr(attr_BaggingClassifier_estimators_, 'tolist') else attr_BaggingClassifier_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_features_ = bridgeBaggingClassifier[${this.id}].estimators_features_`;
      return this._py`attr_BaggingClassifier_estimators_features_.tolist() if hasattr(attr_BaggingClassifier_estimators_features_, 'tolist') else attr_BaggingClassifier_estimators_features_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_classes_ = bridgeBaggingClassifier[${this.id}].classes_`;
      return this._py`attr_BaggingClassifier_classes_.tolist() if hasattr(attr_BaggingClassifier_classes_, 'tolist') else attr_BaggingClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_classes_ = bridgeBaggingClassifier[${this.id}].n_classes_`;
      return this._py`attr_BaggingClassifier_n_classes_.tolist() if hasattr(attr_BaggingClassifier_n_classes_, 'tolist') else attr_BaggingClassifier_n_classes_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_score_ = bridgeBaggingClassifier[${this.id}].oob_score_`;
      return this._py`attr_BaggingClassifier_oob_score_.tolist() if hasattr(attr_BaggingClassifier_oob_score_, 'tolist') else attr_BaggingClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_decision\_function\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_decision_function_ = bridgeBaggingClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_BaggingClassifier_oob_decision_function_.tolist() if hasattr(attr_BaggingClassifier_oob_decision_function_, 'tolist') else attr_BaggingClassifier_oob_decision_function_`;
    })();
  }
};

// src/generated/ensemble/BaggingRegressor.ts
import crypto52 from "node:crypto";
var BaggingRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BaggingRegressor${crypto52.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BaggingRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import BaggingRegressor
try: bridgeBaggingRegressor
except NameError: bridgeBaggingRegressor = {}
`;
    await this._py.ex`ctor_BaggingRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'bootstrap_features': ${this.opts["bootstrap_features"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_BaggingRegressor = {k: v for k, v in ctor_BaggingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeBaggingRegressor[${this.id}] = BaggingRegressor(**ctor_BaggingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBaggingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a Bagging ensemble of estimators from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_BaggingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingRegressor_fit = {k: v for k, v in pms_BaggingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_fit = bridgeBaggingRegressor[${this.id}].fit(**pms_BaggingRegressor_fit)`;
    return this._py`res_BaggingRegressor_fit.tolist() if hasattr(res_BaggingRegressor_fit, 'tolist') else res_BaggingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BaggingRegressor_get_metadata_routing = {k: v for k, v in pms_BaggingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_get_metadata_routing = bridgeBaggingRegressor[${this.id}].get_metadata_routing(**pms_BaggingRegressor_get_metadata_routing)`;
    return this._py`res_BaggingRegressor_get_metadata_routing.tolist() if hasattr(res_BaggingRegressor_get_metadata_routing, 'tolist') else res_BaggingRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the estimators in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before predict()");
    }
    await this._py.ex`pms_BaggingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingRegressor_predict = {k: v for k, v in pms_BaggingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_predict = bridgeBaggingRegressor[${this.id}].predict(**pms_BaggingRegressor_predict)`;
    return this._py`res_BaggingRegressor_predict.tolist() if hasattr(res_BaggingRegressor_predict, 'tolist') else res_BaggingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before score()");
    }
    await this._py.ex`pms_BaggingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingRegressor_score = {k: v for k, v in pms_BaggingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_score = bridgeBaggingRegressor[${this.id}].score(**pms_BaggingRegressor_score)`;
    return this._py`res_BaggingRegressor_score.tolist() if hasattr(res_BaggingRegressor_score, 'tolist') else res_BaggingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingRegressor_set_fit_request = {k: v for k, v in pms_BaggingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_set_fit_request = bridgeBaggingRegressor[${this.id}].set_fit_request(**pms_BaggingRegressor_set_fit_request)`;
    return this._py`res_BaggingRegressor_set_fit_request.tolist() if hasattr(res_BaggingRegressor_set_fit_request, 'tolist') else res_BaggingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingRegressor_set_score_request = {k: v for k, v in pms_BaggingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_set_score_request = bridgeBaggingRegressor[${this.id}].set_score_request(**pms_BaggingRegressor_set_score_request)`;
    return this._py`res_BaggingRegressor_set_score_request.tolist() if hasattr(res_BaggingRegressor_set_score_request, 'tolist') else res_BaggingRegressor_set_score_request`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimator_ = bridgeBaggingRegressor[${this.id}].estimator_`;
      return this._py`attr_BaggingRegressor_estimator_.tolist() if hasattr(attr_BaggingRegressor_estimator_, 'tolist') else attr_BaggingRegressor_estimator_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_n_features_in_ = bridgeBaggingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_BaggingRegressor_n_features_in_.tolist() if hasattr(attr_BaggingRegressor_n_features_in_, 'tolist') else attr_BaggingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_feature_names_in_ = bridgeBaggingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_BaggingRegressor_feature_names_in_.tolist() if hasattr(attr_BaggingRegressor_feature_names_in_, 'tolist') else attr_BaggingRegressor_feature_names_in_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimators_ = bridgeBaggingRegressor[${this.id}].estimators_`;
      return this._py`attr_BaggingRegressor_estimators_.tolist() if hasattr(attr_BaggingRegressor_estimators_, 'tolist') else attr_BaggingRegressor_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimators_features_ = bridgeBaggingRegressor[${this.id}].estimators_features_`;
      return this._py`attr_BaggingRegressor_estimators_features_.tolist() if hasattr(attr_BaggingRegressor_estimators_features_, 'tolist') else attr_BaggingRegressor_estimators_features_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_oob_score_ = bridgeBaggingRegressor[${this.id}].oob_score_`;
      return this._py`attr_BaggingRegressor_oob_score_.tolist() if hasattr(attr_BaggingRegressor_oob_score_, 'tolist') else attr_BaggingRegressor_oob_score_`;
    })();
  }
  /**
    Prediction computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_prediction\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_prediction_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing oob_prediction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_oob_prediction_ = bridgeBaggingRegressor[${this.id}].oob_prediction_`;
      return this._py`attr_BaggingRegressor_oob_prediction_.tolist() if hasattr(attr_BaggingRegressor_oob_prediction_, 'tolist') else attr_BaggingRegressor_oob_prediction_`;
    })();
  }
};

// src/generated/ensemble/ExtraTreesClassifier.ts
import crypto53 from "node:crypto";
var ExtraTreesClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExtraTreesClassifier${crypto53.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreesClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import ExtraTreesClassifier
try: bridgeExtraTreesClassifier
except NameError: bridgeExtraTreesClassifier = {}
`;
    await this._py.ex`ctor_ExtraTreesClassifier = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}}

ctor_ExtraTreesClassifier = {k: v for k, v in ctor_ExtraTreesClassifier.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreesClassifier[${this.id}] = ExtraTreesClassifier(**ctor_ExtraTreesClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreesClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_apply = {k: v for k, v in pms_ExtraTreesClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_apply = bridgeExtraTreesClassifier[${this.id}].apply(**pms_ExtraTreesClassifier_apply)`;
    return this._py`res_ExtraTreesClassifier_apply.tolist() if hasattr(res_ExtraTreesClassifier_apply, 'tolist') else res_ExtraTreesClassifier_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_decision_path = {k: v for k, v in pms_ExtraTreesClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_decision_path = bridgeExtraTreesClassifier[${this.id}].decision_path(**pms_ExtraTreesClassifier_decision_path)`;
    return this._py`res_ExtraTreesClassifier_decision_path.tolist() if hasattr(res_ExtraTreesClassifier_decision_path, 'tolist') else res_ExtraTreesClassifier_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesClassifier_fit = {k: v for k, v in pms_ExtraTreesClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_fit = bridgeExtraTreesClassifier[${this.id}].fit(**pms_ExtraTreesClassifier_fit)`;
    return this._py`res_ExtraTreesClassifier_fit.tolist() if hasattr(res_ExtraTreesClassifier_fit, 'tolist') else res_ExtraTreesClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreesClassifier_get_metadata_routing = {k: v for k, v in pms_ExtraTreesClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_get_metadata_routing = bridgeExtraTreesClassifier[${this.id}].get_metadata_routing(**pms_ExtraTreesClassifier_get_metadata_routing)`;
    return this._py`res_ExtraTreesClassifier_get_metadata_routing.tolist() if hasattr(res_ExtraTreesClassifier_get_metadata_routing, 'tolist') else res_ExtraTreesClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates. That is, the predicted class is the one with highest mean probability estimate across the trees.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict = {k: v for k, v in pms_ExtraTreesClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict = bridgeExtraTreesClassifier[${this.id}].predict(**pms_ExtraTreesClassifier_predict)`;
    return this._py`res_ExtraTreesClassifier_predict.tolist() if hasattr(res_ExtraTreesClassifier_predict, 'tolist') else res_ExtraTreesClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the trees in the forest.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict_log_proba = {k: v for k, v in pms_ExtraTreesClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict_log_proba = bridgeExtraTreesClassifier[${this.id}].predict_log_proba(**pms_ExtraTreesClassifier_predict_log_proba)`;
    return this._py`res_ExtraTreesClassifier_predict_log_proba.tolist() if hasattr(res_ExtraTreesClassifier_predict_log_proba, 'tolist') else res_ExtraTreesClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample are computed as the mean predicted class probabilities of the trees in the forest. The class probability of a single tree is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict_proba = {k: v for k, v in pms_ExtraTreesClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict_proba = bridgeExtraTreesClassifier[${this.id}].predict_proba(**pms_ExtraTreesClassifier_predict_proba)`;
    return this._py`res_ExtraTreesClassifier_predict_proba.tolist() if hasattr(res_ExtraTreesClassifier_predict_proba, 'tolist') else res_ExtraTreesClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesClassifier_score = {k: v for k, v in pms_ExtraTreesClassifier_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_score = bridgeExtraTreesClassifier[${this.id}].score(**pms_ExtraTreesClassifier_score)`;
    return this._py`res_ExtraTreesClassifier_score.tolist() if hasattr(res_ExtraTreesClassifier_score, 'tolist') else res_ExtraTreesClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesClassifier_set_fit_request = {k: v for k, v in pms_ExtraTreesClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_set_fit_request = bridgeExtraTreesClassifier[${this.id}].set_fit_request(**pms_ExtraTreesClassifier_set_fit_request)`;
    return this._py`res_ExtraTreesClassifier_set_fit_request.tolist() if hasattr(res_ExtraTreesClassifier_set_fit_request, 'tolist') else res_ExtraTreesClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesClassifier_set_score_request = {k: v for k, v in pms_ExtraTreesClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_set_score_request = bridgeExtraTreesClassifier[${this.id}].set_score_request(**pms_ExtraTreesClassifier_set_score_request)`;
    return this._py`res_ExtraTreesClassifier_set_score_request.tolist() if hasattr(res_ExtraTreesClassifier_set_score_request, 'tolist') else res_ExtraTreesClassifier_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_estimator_ = bridgeExtraTreesClassifier[${this.id}].estimator_`;
      return this._py`attr_ExtraTreesClassifier_estimator_.tolist() if hasattr(attr_ExtraTreesClassifier_estimator_, 'tolist') else attr_ExtraTreesClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_estimators_ = bridgeExtraTreesClassifier[${this.id}].estimators_`;
      return this._py`attr_ExtraTreesClassifier_estimators_.tolist() if hasattr(attr_ExtraTreesClassifier_estimators_, 'tolist') else attr_ExtraTreesClassifier_estimators_`;
    })();
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_classes_ = bridgeExtraTreesClassifier[${this.id}].classes_`;
      return this._py`attr_ExtraTreesClassifier_classes_.tolist() if hasattr(attr_ExtraTreesClassifier_classes_, 'tolist') else attr_ExtraTreesClassifier_classes_`;
    })();
  }
  /**
    The number of classes (single output problem), or a list containing the number of classes for each output (multi-output problem).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_classes_ = bridgeExtraTreesClassifier[${this.id}].n_classes_`;
      return this._py`attr_ExtraTreesClassifier_n_classes_.tolist() if hasattr(attr_ExtraTreesClassifier_n_classes_, 'tolist') else attr_ExtraTreesClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_features_in_ = bridgeExtraTreesClassifier[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreesClassifier_n_features_in_.tolist() if hasattr(attr_ExtraTreesClassifier_n_features_in_, 'tolist') else attr_ExtraTreesClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_feature_names_in_ = bridgeExtraTreesClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreesClassifier_feature_names_in_.tolist() if hasattr(attr_ExtraTreesClassifier_feature_names_in_, 'tolist') else attr_ExtraTreesClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_outputs_ = bridgeExtraTreesClassifier[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreesClassifier_n_outputs_.tolist() if hasattr(attr_ExtraTreesClassifier_n_outputs_, 'tolist') else attr_ExtraTreesClassifier_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_oob_score_ = bridgeExtraTreesClassifier[${this.id}].oob_score_`;
      return this._py`attr_ExtraTreesClassifier_oob_score_.tolist() if hasattr(attr_ExtraTreesClassifier_oob_score_, 'tolist') else attr_ExtraTreesClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_decision\_function\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_oob_decision_function_ = bridgeExtraTreesClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_ExtraTreesClassifier_oob_decision_function_.tolist() if hasattr(attr_ExtraTreesClassifier_oob_decision_function_, 'tolist') else attr_ExtraTreesClassifier_oob_decision_function_`;
    })();
  }
};

// src/generated/ensemble/ExtraTreesRegressor.ts
import crypto54 from "node:crypto";
var ExtraTreesRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExtraTreesRegressor${crypto54.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreesRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import ExtraTreesRegressor
try: bridgeExtraTreesRegressor
except NameError: bridgeExtraTreesRegressor = {}
`;
    await this._py.ex`ctor_ExtraTreesRegressor = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}}

ctor_ExtraTreesRegressor = {k: v for k, v in ctor_ExtraTreesRegressor.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreesRegressor[${this.id}] = ExtraTreesRegressor(**ctor_ExtraTreesRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreesRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_apply = {k: v for k, v in pms_ExtraTreesRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_apply = bridgeExtraTreesRegressor[${this.id}].apply(**pms_ExtraTreesRegressor_apply)`;
    return this._py`res_ExtraTreesRegressor_apply.tolist() if hasattr(res_ExtraTreesRegressor_apply, 'tolist') else res_ExtraTreesRegressor_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_decision_path = {k: v for k, v in pms_ExtraTreesRegressor_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_decision_path = bridgeExtraTreesRegressor[${this.id}].decision_path(**pms_ExtraTreesRegressor_decision_path)`;
    return this._py`res_ExtraTreesRegressor_decision_path.tolist() if hasattr(res_ExtraTreesRegressor_decision_path, 'tolist') else res_ExtraTreesRegressor_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesRegressor_fit = {k: v for k, v in pms_ExtraTreesRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_fit = bridgeExtraTreesRegressor[${this.id}].fit(**pms_ExtraTreesRegressor_fit)`;
    return this._py`res_ExtraTreesRegressor_fit.tolist() if hasattr(res_ExtraTreesRegressor_fit, 'tolist') else res_ExtraTreesRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreesRegressor_get_metadata_routing = {k: v for k, v in pms_ExtraTreesRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_get_metadata_routing = bridgeExtraTreesRegressor[${this.id}].get_metadata_routing(**pms_ExtraTreesRegressor_get_metadata_routing)`;
    return this._py`res_ExtraTreesRegressor_get_metadata_routing.tolist() if hasattr(res_ExtraTreesRegressor_get_metadata_routing, 'tolist') else res_ExtraTreesRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the trees in the forest.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_predict = {k: v for k, v in pms_ExtraTreesRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_predict = bridgeExtraTreesRegressor[${this.id}].predict(**pms_ExtraTreesRegressor_predict)`;
    return this._py`res_ExtraTreesRegressor_predict.tolist() if hasattr(res_ExtraTreesRegressor_predict, 'tolist') else res_ExtraTreesRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesRegressor_score = {k: v for k, v in pms_ExtraTreesRegressor_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_score = bridgeExtraTreesRegressor[${this.id}].score(**pms_ExtraTreesRegressor_score)`;
    return this._py`res_ExtraTreesRegressor_score.tolist() if hasattr(res_ExtraTreesRegressor_score, 'tolist') else res_ExtraTreesRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesRegressor_set_fit_request = {k: v for k, v in pms_ExtraTreesRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_set_fit_request = bridgeExtraTreesRegressor[${this.id}].set_fit_request(**pms_ExtraTreesRegressor_set_fit_request)`;
    return this._py`res_ExtraTreesRegressor_set_fit_request.tolist() if hasattr(res_ExtraTreesRegressor_set_fit_request, 'tolist') else res_ExtraTreesRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesRegressor_set_score_request = {k: v for k, v in pms_ExtraTreesRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_set_score_request = bridgeExtraTreesRegressor[${this.id}].set_score_request(**pms_ExtraTreesRegressor_set_score_request)`;
    return this._py`res_ExtraTreesRegressor_set_score_request.tolist() if hasattr(res_ExtraTreesRegressor_set_score_request, 'tolist') else res_ExtraTreesRegressor_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_estimator_ = bridgeExtraTreesRegressor[${this.id}].estimator_`;
      return this._py`attr_ExtraTreesRegressor_estimator_.tolist() if hasattr(attr_ExtraTreesRegressor_estimator_, 'tolist') else attr_ExtraTreesRegressor_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_estimators_ = bridgeExtraTreesRegressor[${this.id}].estimators_`;
      return this._py`attr_ExtraTreesRegressor_estimators_.tolist() if hasattr(attr_ExtraTreesRegressor_estimators_, 'tolist') else attr_ExtraTreesRegressor_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_n_features_in_ = bridgeExtraTreesRegressor[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreesRegressor_n_features_in_.tolist() if hasattr(attr_ExtraTreesRegressor_n_features_in_, 'tolist') else attr_ExtraTreesRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_feature_names_in_ = bridgeExtraTreesRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreesRegressor_feature_names_in_.tolist() if hasattr(attr_ExtraTreesRegressor_feature_names_in_, 'tolist') else attr_ExtraTreesRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_n_outputs_ = bridgeExtraTreesRegressor[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreesRegressor_n_outputs_.tolist() if hasattr(attr_ExtraTreesRegressor_n_outputs_, 'tolist') else attr_ExtraTreesRegressor_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_oob_score_ = bridgeExtraTreesRegressor[${this.id}].oob_score_`;
      return this._py`attr_ExtraTreesRegressor_oob_score_.tolist() if hasattr(attr_ExtraTreesRegressor_oob_score_, 'tolist') else attr_ExtraTreesRegressor_oob_score_`;
    })();
  }
  /**
    Prediction computed with out-of-bag estimate on the training set. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_prediction_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing oob_prediction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_oob_prediction_ = bridgeExtraTreesRegressor[${this.id}].oob_prediction_`;
      return this._py`attr_ExtraTreesRegressor_oob_prediction_.tolist() if hasattr(attr_ExtraTreesRegressor_oob_prediction_, 'tolist') else attr_ExtraTreesRegressor_oob_prediction_`;
    })();
  }
};

// src/generated/ensemble/GradientBoostingClassifier.ts
import crypto55 from "node:crypto";
var GradientBoostingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GradientBoostingClassifier${crypto55.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GradientBoostingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import GradientBoostingClassifier
try: bridgeGradientBoostingClassifier
except NameError: bridgeGradientBoostingClassifier = {}
`;
    await this._py.ex`ctor_GradientBoostingClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_GradientBoostingClassifier = {k: v for k, v in ctor_GradientBoostingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeGradientBoostingClassifier[${this.id}] = GradientBoostingClassifier(**ctor_GradientBoostingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGradientBoostingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the ensemble to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before apply()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_apply = {k: v for k, v in pms_GradientBoostingClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_apply = bridgeGradientBoostingClassifier[${this.id}].apply(**pms_GradientBoostingClassifier_apply)`;
    return this._py`res_GradientBoostingClassifier_apply.tolist() if hasattr(res_GradientBoostingClassifier_apply, 'tolist') else res_GradientBoostingClassifier_apply`;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_decision_function = {k: v for k, v in pms_GradientBoostingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_decision_function = bridgeGradientBoostingClassifier[${this.id}].decision_function(**pms_GradientBoostingClassifier_decision_function)`;
    return this._py`res_GradientBoostingClassifier_decision_function.tolist() if hasattr(res_GradientBoostingClassifier_decision_function, 'tolist') else res_GradientBoostingClassifier_decision_function`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'monitor': ${opts["monitor"] ?? void 0}}

pms_GradientBoostingClassifier_fit = {k: v for k, v in pms_GradientBoostingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_fit = bridgeGradientBoostingClassifier[${this.id}].fit(**pms_GradientBoostingClassifier_fit)`;
    return this._py`res_GradientBoostingClassifier_fit.tolist() if hasattr(res_GradientBoostingClassifier_fit, 'tolist') else res_GradientBoostingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GradientBoostingClassifier_get_metadata_routing = {k: v for k, v in pms_GradientBoostingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_get_metadata_routing = bridgeGradientBoostingClassifier[${this.id}].get_metadata_routing(**pms_GradientBoostingClassifier_get_metadata_routing)`;
    return this._py`res_GradientBoostingClassifier_get_metadata_routing.tolist() if hasattr(res_GradientBoostingClassifier_get_metadata_routing, 'tolist') else res_GradientBoostingClassifier_get_metadata_routing`;
  }
  /**
    Predict class for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict = {k: v for k, v in pms_GradientBoostingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict = bridgeGradientBoostingClassifier[${this.id}].predict(**pms_GradientBoostingClassifier_predict)`;
    return this._py`res_GradientBoostingClassifier_predict.tolist() if hasattr(res_GradientBoostingClassifier_predict, 'tolist') else res_GradientBoostingClassifier_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict_log_proba = {k: v for k, v in pms_GradientBoostingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict_log_proba = bridgeGradientBoostingClassifier[${this.id}].predict_log_proba(**pms_GradientBoostingClassifier_predict_log_proba)`;
    return this._py`res_GradientBoostingClassifier_predict_log_proba.tolist() if hasattr(res_GradientBoostingClassifier_predict_log_proba, 'tolist') else res_GradientBoostingClassifier_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict_proba = {k: v for k, v in pms_GradientBoostingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict_proba = bridgeGradientBoostingClassifier[${this.id}].predict_proba(**pms_GradientBoostingClassifier_predict_proba)`;
    return this._py`res_GradientBoostingClassifier_predict_proba.tolist() if hasattr(res_GradientBoostingClassifier_predict_proba, 'tolist') else res_GradientBoostingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GradientBoostingClassifier_score = {k: v for k, v in pms_GradientBoostingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_score = bridgeGradientBoostingClassifier[${this.id}].score(**pms_GradientBoostingClassifier_score)`;
    return this._py`res_GradientBoostingClassifier_score.tolist() if hasattr(res_GradientBoostingClassifier_score, 'tolist') else res_GradientBoostingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_set_fit_request = {'monitor': ${opts["monitor"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingClassifier_set_fit_request = {k: v for k, v in pms_GradientBoostingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_set_fit_request = bridgeGradientBoostingClassifier[${this.id}].set_fit_request(**pms_GradientBoostingClassifier_set_fit_request)`;
    return this._py`res_GradientBoostingClassifier_set_fit_request.tolist() if hasattr(res_GradientBoostingClassifier_set_fit_request, 'tolist') else res_GradientBoostingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingClassifier_set_score_request = {k: v for k, v in pms_GradientBoostingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_set_score_request = bridgeGradientBoostingClassifier[${this.id}].set_score_request(**pms_GradientBoostingClassifier_set_score_request)`;
    return this._py`res_GradientBoostingClassifier_set_score_request.tolist() if hasattr(res_GradientBoostingClassifier_set_score_request, 'tolist') else res_GradientBoostingClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_decision_function = {k: v for k, v in pms_GradientBoostingClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_decision_function = bridgeGradientBoostingClassifier[${this.id}].staged_decision_function(**pms_GradientBoostingClassifier_staged_decision_function)`;
    return this._py`res_GradientBoostingClassifier_staged_decision_function.tolist() if hasattr(res_GradientBoostingClassifier_staged_decision_function, 'tolist') else res_GradientBoostingClassifier_staged_decision_function`;
  }
  /**
      Predict class at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_predict = {k: v for k, v in pms_GradientBoostingClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_predict = bridgeGradientBoostingClassifier[${this.id}].staged_predict(**pms_GradientBoostingClassifier_staged_predict)`;
    return this._py`res_GradientBoostingClassifier_staged_predict.tolist() if hasattr(res_GradientBoostingClassifier_staged_predict, 'tolist') else res_GradientBoostingClassifier_staged_predict`;
  }
  /**
      Predict class probabilities at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_predict_proba = {k: v for k, v in pms_GradientBoostingClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_predict_proba = bridgeGradientBoostingClassifier[${this.id}].staged_predict_proba(**pms_GradientBoostingClassifier_staged_predict_proba)`;
    return this._py`res_GradientBoostingClassifier_staged_predict_proba.tolist() if hasattr(res_GradientBoostingClassifier_staged_predict_proba, 'tolist') else res_GradientBoostingClassifier_staged_predict_proba`;
  }
  /**
    The number of estimators as selected by early stopping (if `n\_iter\_no\_change` is specified). Otherwise it is set to `n\_estimators`.
   */
  get n_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_estimators_ = bridgeGradientBoostingClassifier[${this.id}].n_estimators_`;
      return this._py`attr_GradientBoostingClassifier_n_estimators_.tolist() if hasattr(attr_GradientBoostingClassifier_n_estimators_, 'tolist') else attr_GradientBoostingClassifier_n_estimators_`;
    })();
  }
  /**
    The improvement in loss on the out-of-bag samples relative to the previous iteration. `oob\_improvement\_\[0\]` is the improvement in loss of the first stage over the `init` estimator. Only available if `subsample < 1.0`.
   */
  get oob_improvement_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_improvement_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_improvement_ = bridgeGradientBoostingClassifier[${this.id}].oob_improvement_`;
      return this._py`attr_GradientBoostingClassifier_oob_improvement_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_improvement_, 'tolist') else attr_GradientBoostingClassifier_oob_improvement_`;
    })();
  }
  /**
    The full history of the loss values on the out-of-bag samples. Only available if `subsample < 1.0`.
   */
  get oob_scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_scores_ = bridgeGradientBoostingClassifier[${this.id}].oob_scores_`;
      return this._py`attr_GradientBoostingClassifier_oob_scores_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_scores_, 'tolist') else attr_GradientBoostingClassifier_oob_scores_`;
    })();
  }
  /**
    The last value of the loss on the out-of-bag samples. It is the same as `oob\_scores\_\[-1\]`. Only available if `subsample < 1.0`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_score_ = bridgeGradientBoostingClassifier[${this.id}].oob_score_`;
      return this._py`attr_GradientBoostingClassifier_oob_score_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_score_, 'tolist') else attr_GradientBoostingClassifier_oob_score_`;
    })();
  }
  /**
    The i-th score `train\_score\_\[i\]` is the loss of the model at iteration `i` on the in-bag sample. If `subsample \== 1` this is the loss on the training data.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_train_score_ = bridgeGradientBoostingClassifier[${this.id}].train_score_`;
      return this._py`attr_GradientBoostingClassifier_train_score_.tolist() if hasattr(attr_GradientBoostingClassifier_train_score_, 'tolist') else attr_GradientBoostingClassifier_train_score_`;
    })();
  }
  /**
    The estimator that provides the initial predictions. Set via the `init` argument or `loss.init\_estimator`.
   */
  get init_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing init_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_init_ = bridgeGradientBoostingClassifier[${this.id}].init_`;
      return this._py`attr_GradientBoostingClassifier_init_.tolist() if hasattr(attr_GradientBoostingClassifier_init_, 'tolist') else attr_GradientBoostingClassifier_init_`;
    })();
  }
  /**
    The collection of fitted sub-estimators. `loss\_.K` is 1 for binary classification, otherwise n\_classes.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_estimators_ = bridgeGradientBoostingClassifier[${this.id}].estimators_`;
      return this._py`attr_GradientBoostingClassifier_estimators_.tolist() if hasattr(attr_GradientBoostingClassifier_estimators_, 'tolist') else attr_GradientBoostingClassifier_estimators_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_classes_ = bridgeGradientBoostingClassifier[${this.id}].classes_`;
      return this._py`attr_GradientBoostingClassifier_classes_.tolist() if hasattr(attr_GradientBoostingClassifier_classes_, 'tolist') else attr_GradientBoostingClassifier_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_features_in_ = bridgeGradientBoostingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_GradientBoostingClassifier_n_features_in_.tolist() if hasattr(attr_GradientBoostingClassifier_n_features_in_, 'tolist') else attr_GradientBoostingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_feature_names_in_ = bridgeGradientBoostingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_GradientBoostingClassifier_feature_names_in_.tolist() if hasattr(attr_GradientBoostingClassifier_feature_names_in_, 'tolist') else attr_GradientBoostingClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_classes_ = bridgeGradientBoostingClassifier[${this.id}].n_classes_`;
      return this._py`attr_GradientBoostingClassifier_n_classes_.tolist() if hasattr(attr_GradientBoostingClassifier_n_classes_, 'tolist') else attr_GradientBoostingClassifier_n_classes_`;
    })();
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_max_features_ = bridgeGradientBoostingClassifier[${this.id}].max_features_`;
      return this._py`attr_GradientBoostingClassifier_max_features_.tolist() if hasattr(attr_GradientBoostingClassifier_max_features_, 'tolist') else attr_GradientBoostingClassifier_max_features_`;
    })();
  }
};

// src/generated/ensemble/GradientBoostingRegressor.ts
import crypto56 from "node:crypto";
var GradientBoostingRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GradientBoostingRegressor${crypto56.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GradientBoostingRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor
try: bridgeGradientBoostingRegressor
except NameError: bridgeGradientBoostingRegressor = {}
`;
    await this._py.ex`ctor_GradientBoostingRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_GradientBoostingRegressor = {k: v for k, v in ctor_GradientBoostingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGradientBoostingRegressor[${this.id}] = GradientBoostingRegressor(**ctor_GradientBoostingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGradientBoostingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the ensemble to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before apply()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_apply = {k: v for k, v in pms_GradientBoostingRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_apply = bridgeGradientBoostingRegressor[${this.id}].apply(**pms_GradientBoostingRegressor_apply)`;
    return this._py`res_GradientBoostingRegressor_apply.tolist() if hasattr(res_GradientBoostingRegressor_apply, 'tolist') else res_GradientBoostingRegressor_apply`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GradientBoostingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GradientBoostingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'monitor': ${opts["monitor"] ?? void 0}}

pms_GradientBoostingRegressor_fit = {k: v for k, v in pms_GradientBoostingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_fit = bridgeGradientBoostingRegressor[${this.id}].fit(**pms_GradientBoostingRegressor_fit)`;
    return this._py`res_GradientBoostingRegressor_fit.tolist() if hasattr(res_GradientBoostingRegressor_fit, 'tolist') else res_GradientBoostingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GradientBoostingRegressor_get_metadata_routing = {k: v for k, v in pms_GradientBoostingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_get_metadata_routing = bridgeGradientBoostingRegressor[${this.id}].get_metadata_routing(**pms_GradientBoostingRegressor_get_metadata_routing)`;
    return this._py`res_GradientBoostingRegressor_get_metadata_routing.tolist() if hasattr(res_GradientBoostingRegressor_get_metadata_routing, 'tolist') else res_GradientBoostingRegressor_get_metadata_routing`;
  }
  /**
    Predict regression target for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_predict = {k: v for k, v in pms_GradientBoostingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_predict = bridgeGradientBoostingRegressor[${this.id}].predict(**pms_GradientBoostingRegressor_predict)`;
    return this._py`res_GradientBoostingRegressor_predict.tolist() if hasattr(res_GradientBoostingRegressor_predict, 'tolist') else res_GradientBoostingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GradientBoostingRegressor_score = {k: v for k, v in pms_GradientBoostingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_score = bridgeGradientBoostingRegressor[${this.id}].score(**pms_GradientBoostingRegressor_score)`;
    return this._py`res_GradientBoostingRegressor_score.tolist() if hasattr(res_GradientBoostingRegressor_score, 'tolist') else res_GradientBoostingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_set_fit_request = {'monitor': ${opts["monitor"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingRegressor_set_fit_request = {k: v for k, v in pms_GradientBoostingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_set_fit_request = bridgeGradientBoostingRegressor[${this.id}].set_fit_request(**pms_GradientBoostingRegressor_set_fit_request)`;
    return this._py`res_GradientBoostingRegressor_set_fit_request.tolist() if hasattr(res_GradientBoostingRegressor_set_fit_request, 'tolist') else res_GradientBoostingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingRegressor_set_score_request = {k: v for k, v in pms_GradientBoostingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_set_score_request = bridgeGradientBoostingRegressor[${this.id}].set_score_request(**pms_GradientBoostingRegressor_set_score_request)`;
    return this._py`res_GradientBoostingRegressor_set_score_request.tolist() if hasattr(res_GradientBoostingRegressor_set_score_request, 'tolist') else res_GradientBoostingRegressor_set_score_request`;
  }
  /**
      Predict regression target at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_staged_predict = {k: v for k, v in pms_GradientBoostingRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_staged_predict = bridgeGradientBoostingRegressor[${this.id}].staged_predict(**pms_GradientBoostingRegressor_staged_predict)`;
    return this._py`res_GradientBoostingRegressor_staged_predict.tolist() if hasattr(res_GradientBoostingRegressor_staged_predict, 'tolist') else res_GradientBoostingRegressor_staged_predict`;
  }
  /**
    The improvement in loss on the out-of-bag samples relative to the previous iteration. `oob\_improvement\_\[0\]` is the improvement in loss of the first stage over the `init` estimator. Only available if `subsample < 1.0`.
   */
  get oob_improvement_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_improvement_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_improvement_ = bridgeGradientBoostingRegressor[${this.id}].oob_improvement_`;
      return this._py`attr_GradientBoostingRegressor_oob_improvement_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_improvement_, 'tolist') else attr_GradientBoostingRegressor_oob_improvement_`;
    })();
  }
  /**
    The full history of the loss values on the out-of-bag samples. Only available if `subsample < 1.0`.
   */
  get oob_scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_scores_ = bridgeGradientBoostingRegressor[${this.id}].oob_scores_`;
      return this._py`attr_GradientBoostingRegressor_oob_scores_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_scores_, 'tolist') else attr_GradientBoostingRegressor_oob_scores_`;
    })();
  }
  /**
    The last value of the loss on the out-of-bag samples. It is the same as `oob\_scores\_\[-1\]`. Only available if `subsample < 1.0`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_score_ = bridgeGradientBoostingRegressor[${this.id}].oob_score_`;
      return this._py`attr_GradientBoostingRegressor_oob_score_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_score_, 'tolist') else attr_GradientBoostingRegressor_oob_score_`;
    })();
  }
  /**
    The i-th score `train\_score\_\[i\]` is the loss of the model at iteration `i` on the in-bag sample. If `subsample \== 1` this is the loss on the training data.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_train_score_ = bridgeGradientBoostingRegressor[${this.id}].train_score_`;
      return this._py`attr_GradientBoostingRegressor_train_score_.tolist() if hasattr(attr_GradientBoostingRegressor_train_score_, 'tolist') else attr_GradientBoostingRegressor_train_score_`;
    })();
  }
  /**
    The estimator that provides the initial predictions. Set via the `init` argument or `loss.init\_estimator`.
   */
  get init_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing init_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_init_ = bridgeGradientBoostingRegressor[${this.id}].init_`;
      return this._py`attr_GradientBoostingRegressor_init_.tolist() if hasattr(attr_GradientBoostingRegressor_init_, 'tolist') else attr_GradientBoostingRegressor_init_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_estimators_ = bridgeGradientBoostingRegressor[${this.id}].estimators_`;
      return this._py`attr_GradientBoostingRegressor_estimators_.tolist() if hasattr(attr_GradientBoostingRegressor_estimators_, 'tolist') else attr_GradientBoostingRegressor_estimators_`;
    })();
  }
  /**
    The number of estimators as selected by early stopping (if `n\_iter\_no\_change` is specified). Otherwise it is set to `n\_estimators`.
   */
  get n_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing n_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_n_estimators_ = bridgeGradientBoostingRegressor[${this.id}].n_estimators_`;
      return this._py`attr_GradientBoostingRegressor_n_estimators_.tolist() if hasattr(attr_GradientBoostingRegressor_n_estimators_, 'tolist') else attr_GradientBoostingRegressor_n_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_n_features_in_ = bridgeGradientBoostingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GradientBoostingRegressor_n_features_in_.tolist() if hasattr(attr_GradientBoostingRegressor_n_features_in_, 'tolist') else attr_GradientBoostingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_feature_names_in_ = bridgeGradientBoostingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GradientBoostingRegressor_feature_names_in_.tolist() if hasattr(attr_GradientBoostingRegressor_feature_names_in_, 'tolist') else attr_GradientBoostingRegressor_feature_names_in_`;
    })();
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_max_features_ = bridgeGradientBoostingRegressor[${this.id}].max_features_`;
      return this._py`attr_GradientBoostingRegressor_max_features_.tolist() if hasattr(attr_GradientBoostingRegressor_max_features_, 'tolist') else attr_GradientBoostingRegressor_max_features_`;
    })();
  }
};

// src/generated/ensemble/HistGradientBoostingClassifier.ts
import crypto57 from "node:crypto";
var HistGradientBoostingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HistGradientBoostingClassifier${crypto57.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HistGradientBoostingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import HistGradientBoostingClassifier
try: bridgeHistGradientBoostingClassifier
except NameError: bridgeHistGradientBoostingClassifier = {}
`;
    await this._py.ex`ctor_HistGradientBoostingClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'l2_regularization': ${this.opts["l2_regularization"] ?? void 0}, 'max_bins': ${this.opts["max_bins"] ?? void 0}, 'categorical_features': np.array(${this.opts["categorical_features"] ?? void 0}) if ${this.opts["categorical_features"] !== void 0} else None, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None, 'interaction_cst': ${this.opts["interaction_cst"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}}

ctor_HistGradientBoostingClassifier = {k: v for k, v in ctor_HistGradientBoostingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeHistGradientBoostingClassifier[${this.id}] = HistGradientBoostingClassifier(**ctor_HistGradientBoostingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHistGradientBoostingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_decision_function = {k: v for k, v in pms_HistGradientBoostingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_decision_function = bridgeHistGradientBoostingClassifier[${this.id}].decision_function(**pms_HistGradientBoostingClassifier_decision_function)`;
    return this._py`res_HistGradientBoostingClassifier_decision_function.tolist() if hasattr(res_HistGradientBoostingClassifier_decision_function, 'tolist') else res_HistGradientBoostingClassifier_decision_function`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingClassifier_fit = {k: v for k, v in pms_HistGradientBoostingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_fit = bridgeHistGradientBoostingClassifier[${this.id}].fit(**pms_HistGradientBoostingClassifier_fit)`;
    return this._py`res_HistGradientBoostingClassifier_fit.tolist() if hasattr(res_HistGradientBoostingClassifier_fit, 'tolist') else res_HistGradientBoostingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HistGradientBoostingClassifier_get_metadata_routing = {k: v for k, v in pms_HistGradientBoostingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_get_metadata_routing = bridgeHistGradientBoostingClassifier[${this.id}].get_metadata_routing(**pms_HistGradientBoostingClassifier_get_metadata_routing)`;
    return this._py`res_HistGradientBoostingClassifier_get_metadata_routing.tolist() if hasattr(res_HistGradientBoostingClassifier_get_metadata_routing, 'tolist') else res_HistGradientBoostingClassifier_get_metadata_routing`;
  }
  /**
    Predict classes for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_predict = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_predict = {k: v for k, v in pms_HistGradientBoostingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_predict = bridgeHistGradientBoostingClassifier[${this.id}].predict(**pms_HistGradientBoostingClassifier_predict)`;
    return this._py`res_HistGradientBoostingClassifier_predict.tolist() if hasattr(res_HistGradientBoostingClassifier_predict, 'tolist') else res_HistGradientBoostingClassifier_predict`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_predict_proba = {k: v for k, v in pms_HistGradientBoostingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_predict_proba = bridgeHistGradientBoostingClassifier[${this.id}].predict_proba(**pms_HistGradientBoostingClassifier_predict_proba)`;
    return this._py`res_HistGradientBoostingClassifier_predict_proba.tolist() if hasattr(res_HistGradientBoostingClassifier_predict_proba, 'tolist') else res_HistGradientBoostingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingClassifier_score = {k: v for k, v in pms_HistGradientBoostingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_score = bridgeHistGradientBoostingClassifier[${this.id}].score(**pms_HistGradientBoostingClassifier_score)`;
    return this._py`res_HistGradientBoostingClassifier_score.tolist() if hasattr(res_HistGradientBoostingClassifier_score, 'tolist') else res_HistGradientBoostingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingClassifier_set_fit_request = {k: v for k, v in pms_HistGradientBoostingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_set_fit_request = bridgeHistGradientBoostingClassifier[${this.id}].set_fit_request(**pms_HistGradientBoostingClassifier_set_fit_request)`;
    return this._py`res_HistGradientBoostingClassifier_set_fit_request.tolist() if hasattr(res_HistGradientBoostingClassifier_set_fit_request, 'tolist') else res_HistGradientBoostingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingClassifier_set_score_request = {k: v for k, v in pms_HistGradientBoostingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_set_score_request = bridgeHistGradientBoostingClassifier[${this.id}].set_score_request(**pms_HistGradientBoostingClassifier_set_score_request)`;
    return this._py`res_HistGradientBoostingClassifier_set_score_request.tolist() if hasattr(res_HistGradientBoostingClassifier_set_score_request, 'tolist') else res_HistGradientBoostingClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_decision_function = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_decision_function = bridgeHistGradientBoostingClassifier[${this.id}].staged_decision_function(**pms_HistGradientBoostingClassifier_staged_decision_function)`;
    return this._py`res_HistGradientBoostingClassifier_staged_decision_function.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_decision_function, 'tolist') else res_HistGradientBoostingClassifier_staged_decision_function`;
  }
  /**
      Predict classes at each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_predict = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_predict = bridgeHistGradientBoostingClassifier[${this.id}].staged_predict(**pms_HistGradientBoostingClassifier_staged_predict)`;
    return this._py`res_HistGradientBoostingClassifier_staged_predict.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_predict, 'tolist') else res_HistGradientBoostingClassifier_staged_predict`;
  }
  /**
      Predict class probabilities at each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_predict_proba = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_predict_proba = bridgeHistGradientBoostingClassifier[${this.id}].staged_predict_proba(**pms_HistGradientBoostingClassifier_staged_predict_proba)`;
    return this._py`res_HistGradientBoostingClassifier_staged_predict_proba.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_predict_proba, 'tolist') else res_HistGradientBoostingClassifier_staged_predict_proba`;
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_classes_ = bridgeHistGradientBoostingClassifier[${this.id}].classes_`;
      return this._py`attr_HistGradientBoostingClassifier_classes_.tolist() if hasattr(attr_HistGradientBoostingClassifier_classes_, 'tolist') else attr_HistGradientBoostingClassifier_classes_`;
    })();
  }
  /**
    Indicates whether early stopping is used during training.
   */
  get do_early_stopping_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing do_early_stopping_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_do_early_stopping_ = bridgeHistGradientBoostingClassifier[${this.id}].do_early_stopping_`;
      return this._py`attr_HistGradientBoostingClassifier_do_early_stopping_.tolist() if hasattr(attr_HistGradientBoostingClassifier_do_early_stopping_, 'tolist') else attr_HistGradientBoostingClassifier_do_early_stopping_`;
    })();
  }
  /**
    The number of tree that are built at each iteration. This is equal to 1 for binary classification, and to `n\_classes` for multiclass classification.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_n_trees_per_iteration_ = bridgeHistGradientBoostingClassifier[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_HistGradientBoostingClassifier_n_trees_per_iteration_.tolist() if hasattr(attr_HistGradientBoostingClassifier_n_trees_per_iteration_, 'tolist') else attr_HistGradientBoostingClassifier_n_trees_per_iteration_`;
    })();
  }
  /**
    The scores at each iteration on the training data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. If `scoring` is not â€˜lossâ€™, scores are computed on a subset of at most 10 000 samples. Empty if no early stopping.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_train_score_ = bridgeHistGradientBoostingClassifier[${this.id}].train_score_`;
      return this._py`attr_HistGradientBoostingClassifier_train_score_.tolist() if hasattr(attr_HistGradientBoostingClassifier_train_score_, 'tolist') else attr_HistGradientBoostingClassifier_train_score_`;
    })();
  }
  /**
    The scores at each iteration on the held-out validation data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. Empty if no early stopping or if `validation\_fraction` is `undefined`.
   */
  get validation_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_validation_score_ = bridgeHistGradientBoostingClassifier[${this.id}].validation_score_`;
      return this._py`attr_HistGradientBoostingClassifier_validation_score_.tolist() if hasattr(attr_HistGradientBoostingClassifier_validation_score_, 'tolist') else attr_HistGradientBoostingClassifier_validation_score_`;
    })();
  }
  /**
    Boolean mask for the categorical features. `undefined` if there are no categorical features.
   */
  get is_categorical_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing is_categorical_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_is_categorical_ = bridgeHistGradientBoostingClassifier[${this.id}].is_categorical_`;
      return this._py`attr_HistGradientBoostingClassifier_is_categorical_.tolist() if hasattr(attr_HistGradientBoostingClassifier_is_categorical_, 'tolist') else attr_HistGradientBoostingClassifier_is_categorical_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_n_features_in_ = bridgeHistGradientBoostingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_HistGradientBoostingClassifier_n_features_in_.tolist() if hasattr(attr_HistGradientBoostingClassifier_n_features_in_, 'tolist') else attr_HistGradientBoostingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_feature_names_in_ = bridgeHistGradientBoostingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_HistGradientBoostingClassifier_feature_names_in_.tolist() if hasattr(attr_HistGradientBoostingClassifier_feature_names_in_, 'tolist') else attr_HistGradientBoostingClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/HistGradientBoostingRegressor.ts
import crypto58 from "node:crypto";
var HistGradientBoostingRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HistGradientBoostingRegressor${crypto58.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HistGradientBoostingRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import HistGradientBoostingRegressor
try: bridgeHistGradientBoostingRegressor
except NameError: bridgeHistGradientBoostingRegressor = {}
`;
    await this._py.ex`ctor_HistGradientBoostingRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'quantile': ${this.opts["quantile"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'l2_regularization': ${this.opts["l2_regularization"] ?? void 0}, 'max_bins': ${this.opts["max_bins"] ?? void 0}, 'categorical_features': np.array(${this.opts["categorical_features"] ?? void 0}) if ${this.opts["categorical_features"] !== void 0} else None, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None, 'interaction_cst': ${this.opts["interaction_cst"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_HistGradientBoostingRegressor = {k: v for k, v in ctor_HistGradientBoostingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeHistGradientBoostingRegressor[${this.id}] = HistGradientBoostingRegressor(**ctor_HistGradientBoostingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHistGradientBoostingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before fit()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingRegressor_fit = {k: v for k, v in pms_HistGradientBoostingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_fit = bridgeHistGradientBoostingRegressor[${this.id}].fit(**pms_HistGradientBoostingRegressor_fit)`;
    return this._py`res_HistGradientBoostingRegressor_fit.tolist() if hasattr(res_HistGradientBoostingRegressor_fit, 'tolist') else res_HistGradientBoostingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HistGradientBoostingRegressor_get_metadata_routing = {k: v for k, v in pms_HistGradientBoostingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_get_metadata_routing = bridgeHistGradientBoostingRegressor[${this.id}].get_metadata_routing(**pms_HistGradientBoostingRegressor_get_metadata_routing)`;
    return this._py`res_HistGradientBoostingRegressor_get_metadata_routing.tolist() if hasattr(res_HistGradientBoostingRegressor_get_metadata_routing, 'tolist') else res_HistGradientBoostingRegressor_get_metadata_routing`;
  }
  /**
    Predict values for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingRegressor_predict = {k: v for k, v in pms_HistGradientBoostingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_predict = bridgeHistGradientBoostingRegressor[${this.id}].predict(**pms_HistGradientBoostingRegressor_predict)`;
    return this._py`res_HistGradientBoostingRegressor_predict.tolist() if hasattr(res_HistGradientBoostingRegressor_predict, 'tolist') else res_HistGradientBoostingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingRegressor_score = {k: v for k, v in pms_HistGradientBoostingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_score = bridgeHistGradientBoostingRegressor[${this.id}].score(**pms_HistGradientBoostingRegressor_score)`;
    return this._py`res_HistGradientBoostingRegressor_score.tolist() if hasattr(res_HistGradientBoostingRegressor_score, 'tolist') else res_HistGradientBoostingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingRegressor_set_fit_request = {k: v for k, v in pms_HistGradientBoostingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_set_fit_request = bridgeHistGradientBoostingRegressor[${this.id}].set_fit_request(**pms_HistGradientBoostingRegressor_set_fit_request)`;
    return this._py`res_HistGradientBoostingRegressor_set_fit_request.tolist() if hasattr(res_HistGradientBoostingRegressor_set_fit_request, 'tolist') else res_HistGradientBoostingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingRegressor_set_score_request = {k: v for k, v in pms_HistGradientBoostingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_set_score_request = bridgeHistGradientBoostingRegressor[${this.id}].set_score_request(**pms_HistGradientBoostingRegressor_set_score_request)`;
    return this._py`res_HistGradientBoostingRegressor_set_score_request.tolist() if hasattr(res_HistGradientBoostingRegressor_set_score_request, 'tolist') else res_HistGradientBoostingRegressor_set_score_request`;
  }
  /**
      Predict regression target for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingRegressor_staged_predict = {k: v for k, v in pms_HistGradientBoostingRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_staged_predict = bridgeHistGradientBoostingRegressor[${this.id}].staged_predict(**pms_HistGradientBoostingRegressor_staged_predict)`;
    return this._py`res_HistGradientBoostingRegressor_staged_predict.tolist() if hasattr(res_HistGradientBoostingRegressor_staged_predict, 'tolist') else res_HistGradientBoostingRegressor_staged_predict`;
  }
  /**
    Indicates whether early stopping is used during training.
   */
  get do_early_stopping_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing do_early_stopping_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_do_early_stopping_ = bridgeHistGradientBoostingRegressor[${this.id}].do_early_stopping_`;
      return this._py`attr_HistGradientBoostingRegressor_do_early_stopping_.tolist() if hasattr(attr_HistGradientBoostingRegressor_do_early_stopping_, 'tolist') else attr_HistGradientBoostingRegressor_do_early_stopping_`;
    })();
  }
  /**
    The number of tree that are built at each iteration. For regressors, this is always 1.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_n_trees_per_iteration_ = bridgeHistGradientBoostingRegressor[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_HistGradientBoostingRegressor_n_trees_per_iteration_.tolist() if hasattr(attr_HistGradientBoostingRegressor_n_trees_per_iteration_, 'tolist') else attr_HistGradientBoostingRegressor_n_trees_per_iteration_`;
    })();
  }
  /**
    The scores at each iteration on the training data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. If `scoring` is not â€˜lossâ€™, scores are computed on a subset of at most 10 000 samples. Empty if no early stopping.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_train_score_ = bridgeHistGradientBoostingRegressor[${this.id}].train_score_`;
      return this._py`attr_HistGradientBoostingRegressor_train_score_.tolist() if hasattr(attr_HistGradientBoostingRegressor_train_score_, 'tolist') else attr_HistGradientBoostingRegressor_train_score_`;
    })();
  }
  /**
    The scores at each iteration on the held-out validation data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. Empty if no early stopping or if `validation\_fraction` is `undefined`.
   */
  get validation_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_validation_score_ = bridgeHistGradientBoostingRegressor[${this.id}].validation_score_`;
      return this._py`attr_HistGradientBoostingRegressor_validation_score_.tolist() if hasattr(attr_HistGradientBoostingRegressor_validation_score_, 'tolist') else attr_HistGradientBoostingRegressor_validation_score_`;
    })();
  }
  /**
    Boolean mask for the categorical features. `undefined` if there are no categorical features.
   */
  get is_categorical_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing is_categorical_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_is_categorical_ = bridgeHistGradientBoostingRegressor[${this.id}].is_categorical_`;
      return this._py`attr_HistGradientBoostingRegressor_is_categorical_.tolist() if hasattr(attr_HistGradientBoostingRegressor_is_categorical_, 'tolist') else attr_HistGradientBoostingRegressor_is_categorical_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_n_features_in_ = bridgeHistGradientBoostingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_HistGradientBoostingRegressor_n_features_in_.tolist() if hasattr(attr_HistGradientBoostingRegressor_n_features_in_, 'tolist') else attr_HistGradientBoostingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_feature_names_in_ = bridgeHistGradientBoostingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_HistGradientBoostingRegressor_feature_names_in_.tolist() if hasattr(attr_HistGradientBoostingRegressor_feature_names_in_, 'tolist') else attr_HistGradientBoostingRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/IsolationForest.ts
import crypto59 from "node:crypto";
var IsolationForest = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `IsolationForest${crypto59.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IsolationForest.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import IsolationForest
try: bridgeIsolationForest
except NameError: bridgeIsolationForest = {}
`;
    await this._py.ex`ctor_IsolationForest = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}}

ctor_IsolationForest = {k: v for k, v in ctor_IsolationForest.items() if v is not None}`;
    await this._py.ex`bridgeIsolationForest[${this.id}] = IsolationForest(**ctor_IsolationForest)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIsolationForest[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Average anomaly score of X of the base classifiers.
  
      The anomaly score of an input sample is computed as the mean anomaly score of the trees in the forest.
  
      The measure of normality of an observation given a tree is the depth of the leaf containing this observation, which is equivalent to the number of splittings required to isolate this point. In case of several observations n\_left in the leaf, the average path length of a n\_left samples isolation tree is added.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_IsolationForest_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_decision_function = {k: v for k, v in pms_IsolationForest_decision_function.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_decision_function = bridgeIsolationForest[${this.id}].decision_function(**pms_IsolationForest_decision_function)`;
    return this._py`res_IsolationForest_decision_function.tolist() if hasattr(res_IsolationForest_decision_function, 'tolist') else res_IsolationForest_decision_function`;
  }
  /**
    Fit estimator.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before fit()");
    }
    await this._py.ex`pms_IsolationForest_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_IsolationForest_fit = {k: v for k, v in pms_IsolationForest_fit.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_fit = bridgeIsolationForest[${this.id}].fit(**pms_IsolationForest_fit)`;
    return this._py`res_IsolationForest_fit.tolist() if hasattr(res_IsolationForest_fit, 'tolist') else res_IsolationForest_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before fit_predict()");
    }
    await this._py.ex`pms_IsolationForest_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_IsolationForest_fit_predict = {k: v for k, v in pms_IsolationForest_fit_predict.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_fit_predict = bridgeIsolationForest[${this.id}].fit_predict(**pms_IsolationForest_fit_predict)`;
    return this._py`res_IsolationForest_fit_predict.tolist() if hasattr(res_IsolationForest_fit_predict, 'tolist') else res_IsolationForest_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IsolationForest_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IsolationForest_get_metadata_routing = {k: v for k, v in pms_IsolationForest_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_get_metadata_routing = bridgeIsolationForest[${this.id}].get_metadata_routing(**pms_IsolationForest_get_metadata_routing)`;
    return this._py`res_IsolationForest_get_metadata_routing.tolist() if hasattr(res_IsolationForest_get_metadata_routing, 'tolist') else res_IsolationForest_get_metadata_routing`;
  }
  /**
    Predict if a particular sample is an outlier or not.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before predict()");
    }
    await this._py.ex`pms_IsolationForest_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_predict = {k: v for k, v in pms_IsolationForest_predict.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_predict = bridgeIsolationForest[${this.id}].predict(**pms_IsolationForest_predict)`;
    return this._py`res_IsolationForest_predict.tolist() if hasattr(res_IsolationForest_predict, 'tolist') else res_IsolationForest_predict`;
  }
  /**
      Opposite of the anomaly score defined in the original paper.
  
      The anomaly score of an input sample is computed as the mean anomaly score of the trees in the forest.
  
      The measure of normality of an observation given a tree is the depth of the leaf containing this observation, which is equivalent to the number of splittings required to isolate this point. In case of several observations n\_left in the leaf, the average path length of a n\_left samples isolation tree is added.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before score_samples()");
    }
    await this._py.ex`pms_IsolationForest_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_score_samples = {k: v for k, v in pms_IsolationForest_score_samples.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_score_samples = bridgeIsolationForest[${this.id}].score_samples(**pms_IsolationForest_score_samples)`;
    return this._py`res_IsolationForest_score_samples.tolist() if hasattr(res_IsolationForest_score_samples, 'tolist') else res_IsolationForest_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_IsolationForest_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_IsolationForest_set_fit_request = {k: v for k, v in pms_IsolationForest_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_set_fit_request = bridgeIsolationForest[${this.id}].set_fit_request(**pms_IsolationForest_set_fit_request)`;
    return this._py`res_IsolationForest_set_fit_request.tolist() if hasattr(res_IsolationForest_set_fit_request, 'tolist') else res_IsolationForest_set_fit_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimator_ = bridgeIsolationForest[${this.id}].estimator_`;
      return this._py`attr_IsolationForest_estimator_.tolist() if hasattr(attr_IsolationForest_estimator_, 'tolist') else attr_IsolationForest_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimators_ = bridgeIsolationForest[${this.id}].estimators_`;
      return this._py`attr_IsolationForest_estimators_.tolist() if hasattr(attr_IsolationForest_estimators_, 'tolist') else attr_IsolationForest_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimators_features_ = bridgeIsolationForest[${this.id}].estimators_features_`;
      return this._py`attr_IsolationForest_estimators_features_.tolist() if hasattr(attr_IsolationForest_estimators_features_, 'tolist') else attr_IsolationForest_estimators_features_`;
    })();
  }
  /**
    The actual number of samples.
   */
  get max_samples_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing max_samples_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_max_samples_ = bridgeIsolationForest[${this.id}].max_samples_`;
      return this._py`attr_IsolationForest_max_samples_.tolist() if hasattr(attr_IsolationForest_max_samples_, 'tolist') else attr_IsolationForest_max_samples_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: `decision\_function \= score\_samples \- offset\_`. `offset\_` is defined as follows. When the contamination parameter is set to â€œautoâ€, the offset is equal to -0.5 as the scores of inliers are close to 0 and the scores of outliers are close to -1. When a contamination parameter different than â€œautoâ€ is provided, the offset is defined in such a way we obtain the expected number of outliers (samples with decision function < 0) in training.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_offset_ = bridgeIsolationForest[${this.id}].offset_`;
      return this._py`attr_IsolationForest_offset_.tolist() if hasattr(attr_IsolationForest_offset_, 'tolist') else attr_IsolationForest_offset_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_n_features_in_ = bridgeIsolationForest[${this.id}].n_features_in_`;
      return this._py`attr_IsolationForest_n_features_in_.tolist() if hasattr(attr_IsolationForest_n_features_in_, 'tolist') else attr_IsolationForest_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_feature_names_in_ = bridgeIsolationForest[${this.id}].feature_names_in_`;
      return this._py`attr_IsolationForest_feature_names_in_.tolist() if hasattr(attr_IsolationForest_feature_names_in_, 'tolist') else attr_IsolationForest_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/RandomForestClassifier.ts
import crypto60 from "node:crypto";
var RandomForestClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RandomForestClassifier${crypto60.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RandomForestClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import RandomForestClassifier
try: bridgeRandomForestClassifier
except NameError: bridgeRandomForestClassifier = {}
`;
    await this._py.ex`ctor_RandomForestClassifier = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}}

ctor_RandomForestClassifier = {k: v for k, v in ctor_RandomForestClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRandomForestClassifier[${this.id}] = RandomForestClassifier(**ctor_RandomForestClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRandomForestClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before apply()");
    }
    await this._py.ex`pms_RandomForestClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_apply = {k: v for k, v in pms_RandomForestClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_apply = bridgeRandomForestClassifier[${this.id}].apply(**pms_RandomForestClassifier_apply)`;
    return this._py`res_RandomForestClassifier_apply.tolist() if hasattr(res_RandomForestClassifier_apply, 'tolist') else res_RandomForestClassifier_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_decision_path = {k: v for k, v in pms_RandomForestClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_decision_path = bridgeRandomForestClassifier[${this.id}].decision_path(**pms_RandomForestClassifier_decision_path)`;
    return this._py`res_RandomForestClassifier_decision_path.tolist() if hasattr(res_RandomForestClassifier_decision_path, 'tolist') else res_RandomForestClassifier_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RandomForestClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestClassifier_fit = {k: v for k, v in pms_RandomForestClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_fit = bridgeRandomForestClassifier[${this.id}].fit(**pms_RandomForestClassifier_fit)`;
    return this._py`res_RandomForestClassifier_fit.tolist() if hasattr(res_RandomForestClassifier_fit, 'tolist') else res_RandomForestClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RandomForestClassifier_get_metadata_routing = {k: v for k, v in pms_RandomForestClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_get_metadata_routing = bridgeRandomForestClassifier[${this.id}].get_metadata_routing(**pms_RandomForestClassifier_get_metadata_routing)`;
    return this._py`res_RandomForestClassifier_get_metadata_routing.tolist() if hasattr(res_RandomForestClassifier_get_metadata_routing, 'tolist') else res_RandomForestClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates. That is, the predicted class is the one with highest mean probability estimate across the trees.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict = {k: v for k, v in pms_RandomForestClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict = bridgeRandomForestClassifier[${this.id}].predict(**pms_RandomForestClassifier_predict)`;
    return this._py`res_RandomForestClassifier_predict.tolist() if hasattr(res_RandomForestClassifier_predict, 'tolist') else res_RandomForestClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the trees in the forest.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict_log_proba = {k: v for k, v in pms_RandomForestClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict_log_proba = bridgeRandomForestClassifier[${this.id}].predict_log_proba(**pms_RandomForestClassifier_predict_log_proba)`;
    return this._py`res_RandomForestClassifier_predict_log_proba.tolist() if hasattr(res_RandomForestClassifier_predict_log_proba, 'tolist') else res_RandomForestClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample are computed as the mean predicted class probabilities of the trees in the forest. The class probability of a single tree is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict_proba = {k: v for k, v in pms_RandomForestClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict_proba = bridgeRandomForestClassifier[${this.id}].predict_proba(**pms_RandomForestClassifier_predict_proba)`;
    return this._py`res_RandomForestClassifier_predict_proba.tolist() if hasattr(res_RandomForestClassifier_predict_proba, 'tolist') else res_RandomForestClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before score()");
    }
    await this._py.ex`pms_RandomForestClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestClassifier_score = {k: v for k, v in pms_RandomForestClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_score = bridgeRandomForestClassifier[${this.id}].score(**pms_RandomForestClassifier_score)`;
    return this._py`res_RandomForestClassifier_score.tolist() if hasattr(res_RandomForestClassifier_score, 'tolist') else res_RandomForestClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RandomForestClassifier_set_fit_request = {k: v for k, v in pms_RandomForestClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_set_fit_request = bridgeRandomForestClassifier[${this.id}].set_fit_request(**pms_RandomForestClassifier_set_fit_request)`;
    return this._py`res_RandomForestClassifier_set_fit_request.tolist() if hasattr(res_RandomForestClassifier_set_fit_request, 'tolist') else res_RandomForestClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RandomForestClassifier_set_score_request = {k: v for k, v in pms_RandomForestClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_set_score_request = bridgeRandomForestClassifier[${this.id}].set_score_request(**pms_RandomForestClassifier_set_score_request)`;
    return this._py`res_RandomForestClassifier_set_score_request.tolist() if hasattr(res_RandomForestClassifier_set_score_request, 'tolist') else res_RandomForestClassifier_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_estimator_ = bridgeRandomForestClassifier[${this.id}].estimator_`;
      return this._py`attr_RandomForestClassifier_estimator_.tolist() if hasattr(attr_RandomForestClassifier_estimator_, 'tolist') else attr_RandomForestClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_estimators_ = bridgeRandomForestClassifier[${this.id}].estimators_`;
      return this._py`attr_RandomForestClassifier_estimators_.tolist() if hasattr(attr_RandomForestClassifier_estimators_, 'tolist') else attr_RandomForestClassifier_estimators_`;
    })();
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_classes_ = bridgeRandomForestClassifier[${this.id}].classes_`;
      return this._py`attr_RandomForestClassifier_classes_.tolist() if hasattr(attr_RandomForestClassifier_classes_, 'tolist') else attr_RandomForestClassifier_classes_`;
    })();
  }
  /**
    The number of classes (single output problem), or a list containing the number of classes for each output (multi-output problem).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_classes_ = bridgeRandomForestClassifier[${this.id}].n_classes_`;
      return this._py`attr_RandomForestClassifier_n_classes_.tolist() if hasattr(attr_RandomForestClassifier_n_classes_, 'tolist') else attr_RandomForestClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_features_in_ = bridgeRandomForestClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RandomForestClassifier_n_features_in_.tolist() if hasattr(attr_RandomForestClassifier_n_features_in_, 'tolist') else attr_RandomForestClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_feature_names_in_ = bridgeRandomForestClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RandomForestClassifier_feature_names_in_.tolist() if hasattr(attr_RandomForestClassifier_feature_names_in_, 'tolist') else attr_RandomForestClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_outputs_ = bridgeRandomForestClassifier[${this.id}].n_outputs_`;
      return this._py`attr_RandomForestClassifier_n_outputs_.tolist() if hasattr(attr_RandomForestClassifier_n_outputs_, 'tolist') else attr_RandomForestClassifier_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_oob_score_ = bridgeRandomForestClassifier[${this.id}].oob_score_`;
      return this._py`attr_RandomForestClassifier_oob_score_.tolist() if hasattr(attr_RandomForestClassifier_oob_score_, 'tolist') else attr_RandomForestClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_decision\_function\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_oob_decision_function_ = bridgeRandomForestClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_RandomForestClassifier_oob_decision_function_.tolist() if hasattr(attr_RandomForestClassifier_oob_decision_function_, 'tolist') else attr_RandomForestClassifier_oob_decision_function_`;
    })();
  }
};

// src/generated/ensemble/RandomForestRegressor.ts
import crypto61 from "node:crypto";
var RandomForestRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RandomForestRegressor${crypto61.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RandomForestRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import RandomForestRegressor
try: bridgeRandomForestRegressor
except NameError: bridgeRandomForestRegressor = {}
`;
    await this._py.ex`ctor_RandomForestRegressor = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}}

ctor_RandomForestRegressor = {k: v for k, v in ctor_RandomForestRegressor.items() if v is not None}`;
    await this._py.ex`bridgeRandomForestRegressor[${this.id}] = RandomForestRegressor(**ctor_RandomForestRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRandomForestRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestRegressor must call init() before apply()");
    }
    await this._py.ex`pms_RandomForestRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestRegressor_apply = {k: v for k, v in pms_RandomForestRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_apply = bridgeRandomForestRegressor[${this.id}].apply(**pms_RandomForestRegressor_apply)`;
    return this._py`res_RandomForestRegressor_apply.tolist() if hasattr(res_RandomForestRegressor_apply, 'tolist') else res_RandomForestRegressor_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_RandomForestRegressor_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestRegressor_decision_path = {k: v for k, v in pms_RandomForestRegressor_decision_path.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_decision_path = bridgeRandomForestRegressor[${this.id}].decision_path(**pms_RandomForestRegressor_decision_path)`;
    return this._py`res_RandomForestRegressor_decision_path.tolist() if hasattr(res_RandomForestRegressor_decision_path, 'tolist') else res_RandomForestRegressor_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestRegressor must call init() before fit()");
    }
    await this._py.ex`pms_RandomForestRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestRegressor_fit = {k: v for k, v in pms_RandomForestRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_fit = bridgeRandomForestRegressor[${this.id}].fit(**pms_RandomForestRegressor_fit)`;
    return this._py`res_RandomForestRegressor_fit.tolist() if hasattr(res_RandomForestRegressor_fit, 'tolist') else res_RandomForestRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RandomForestRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RandomForestRegressor_get_metadata_routing = {k: v for k, v in pms_RandomForestRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_get_metadata_routing = bridgeRandomForestRegressor[${this.id}].get_metadata_routing(**pms_RandomForestRegressor_get_metadata_routing)`;
    return this._py`res_RandomForestRegressor_get_metadata_routing.tolist() if hasattr(res_RandomForestRegressor_get_metadata_routing, 'tolist') else res_RandomForestRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the trees in the forest.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestRegressor must call init() before predict()");
    }
    await this._py.ex`pms_RandomForestRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestRegressor_predict = {k: v for k, v in pms_RandomForestRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_predict = bridgeRandomForestRegressor[${this.id}].predict(**pms_RandomForestRegressor_predict)`;
    return this._py`res_RandomForestRegressor_predict.tolist() if hasattr(res_RandomForestRegressor_predict, 'tolist') else res_RandomForestRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestRegressor must call init() before score()");
    }
    await this._py.ex`pms_RandomForestRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestRegressor_score = {k: v for k, v in pms_RandomForestRegressor_score.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_score = bridgeRandomForestRegressor[${this.id}].score(**pms_RandomForestRegressor_score)`;
    return this._py`res_RandomForestRegressor_score.tolist() if hasattr(res_RandomForestRegressor_score, 'tolist') else res_RandomForestRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RandomForestRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RandomForestRegressor_set_fit_request = {k: v for k, v in pms_RandomForestRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_set_fit_request = bridgeRandomForestRegressor[${this.id}].set_fit_request(**pms_RandomForestRegressor_set_fit_request)`;
    return this._py`res_RandomForestRegressor_set_fit_request.tolist() if hasattr(res_RandomForestRegressor_set_fit_request, 'tolist') else res_RandomForestRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RandomForestRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RandomForestRegressor_set_score_request = {k: v for k, v in pms_RandomForestRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RandomForestRegressor_set_score_request = bridgeRandomForestRegressor[${this.id}].set_score_request(**pms_RandomForestRegressor_set_score_request)`;
    return this._py`res_RandomForestRegressor_set_score_request.tolist() if hasattr(res_RandomForestRegressor_set_score_request, 'tolist') else res_RandomForestRegressor_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_estimator_ = bridgeRandomForestRegressor[${this.id}].estimator_`;
      return this._py`attr_RandomForestRegressor_estimator_.tolist() if hasattr(attr_RandomForestRegressor_estimator_, 'tolist') else attr_RandomForestRegressor_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_estimators_ = bridgeRandomForestRegressor[${this.id}].estimators_`;
      return this._py`attr_RandomForestRegressor_estimators_.tolist() if hasattr(attr_RandomForestRegressor_estimators_, 'tolist') else attr_RandomForestRegressor_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_n_features_in_ = bridgeRandomForestRegressor[${this.id}].n_features_in_`;
      return this._py`attr_RandomForestRegressor_n_features_in_.tolist() if hasattr(attr_RandomForestRegressor_n_features_in_, 'tolist') else attr_RandomForestRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_feature_names_in_ = bridgeRandomForestRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_RandomForestRegressor_feature_names_in_.tolist() if hasattr(attr_RandomForestRegressor_feature_names_in_, 'tolist') else attr_RandomForestRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_n_outputs_ = bridgeRandomForestRegressor[${this.id}].n_outputs_`;
      return this._py`attr_RandomForestRegressor_n_outputs_.tolist() if hasattr(attr_RandomForestRegressor_n_outputs_, 'tolist') else attr_RandomForestRegressor_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_oob_score_ = bridgeRandomForestRegressor[${this.id}].oob_score_`;
      return this._py`attr_RandomForestRegressor_oob_score_.tolist() if hasattr(attr_RandomForestRegressor_oob_score_, 'tolist') else attr_RandomForestRegressor_oob_score_`;
    })();
  }
  /**
    Prediction computed with out-of-bag estimate on the training set. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_prediction_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestRegressor must call init() before accessing oob_prediction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestRegressor_oob_prediction_ = bridgeRandomForestRegressor[${this.id}].oob_prediction_`;
      return this._py`attr_RandomForestRegressor_oob_prediction_.tolist() if hasattr(attr_RandomForestRegressor_oob_prediction_, 'tolist') else attr_RandomForestRegressor_oob_prediction_`;
    })();
  }
};

// src/generated/ensemble/RandomTreesEmbedding.ts
import crypto62 from "node:crypto";
var RandomTreesEmbedding = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RandomTreesEmbedding${crypto62.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RandomTreesEmbedding.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import RandomTreesEmbedding
try: bridgeRandomTreesEmbedding
except NameError: bridgeRandomTreesEmbedding = {}
`;
    await this._py.ex`ctor_RandomTreesEmbedding = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}}

ctor_RandomTreesEmbedding = {k: v for k, v in ctor_RandomTreesEmbedding.items() if v is not None}`;
    await this._py.ex`bridgeRandomTreesEmbedding[${this.id}] = RandomTreesEmbedding(**ctor_RandomTreesEmbedding)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRandomTreesEmbedding[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomTreesEmbedding must call init() before apply()");
    }
    await this._py.ex`pms_RandomTreesEmbedding_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomTreesEmbedding_apply = {k: v for k, v in pms_RandomTreesEmbedding_apply.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_apply = bridgeRandomTreesEmbedding[${this.id}].apply(**pms_RandomTreesEmbedding_apply)`;
    return this._py`res_RandomTreesEmbedding_apply.tolist() if hasattr(res_RandomTreesEmbedding_apply, 'tolist') else res_RandomTreesEmbedding_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomTreesEmbedding_decision_path = {k: v for k, v in pms_RandomTreesEmbedding_decision_path.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_decision_path = bridgeRandomTreesEmbedding[${this.id}].decision_path(**pms_RandomTreesEmbedding_decision_path)`;
    return this._py`res_RandomTreesEmbedding_decision_path.tolist() if hasattr(res_RandomTreesEmbedding_decision_path, 'tolist') else res_RandomTreesEmbedding_decision_path`;
  }
  /**
    Fit estimator.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomTreesEmbedding must call init() before fit()");
    }
    await this._py.ex`pms_RandomTreesEmbedding_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomTreesEmbedding_fit = {k: v for k, v in pms_RandomTreesEmbedding_fit.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_fit = bridgeRandomTreesEmbedding[${this.id}].fit(**pms_RandomTreesEmbedding_fit)`;
    return this._py`res_RandomTreesEmbedding_fit.tolist() if hasattr(res_RandomTreesEmbedding_fit, 'tolist') else res_RandomTreesEmbedding_fit`;
  }
  /**
    Fit estimator and transform dataset.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomTreesEmbedding_fit_transform = {k: v for k, v in pms_RandomTreesEmbedding_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_fit_transform = bridgeRandomTreesEmbedding[${this.id}].fit_transform(**pms_RandomTreesEmbedding_fit_transform)`;
    return this._py`res_RandomTreesEmbedding_fit_transform.tolist() if hasattr(res_RandomTreesEmbedding_fit_transform, 'tolist') else res_RandomTreesEmbedding_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RandomTreesEmbedding_get_feature_names_out = {k: v for k, v in pms_RandomTreesEmbedding_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_get_feature_names_out = bridgeRandomTreesEmbedding[${this.id}].get_feature_names_out(**pms_RandomTreesEmbedding_get_feature_names_out)`;
    return this._py`res_RandomTreesEmbedding_get_feature_names_out.tolist() if hasattr(res_RandomTreesEmbedding_get_feature_names_out, 'tolist') else res_RandomTreesEmbedding_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RandomTreesEmbedding_get_metadata_routing = {k: v for k, v in pms_RandomTreesEmbedding_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_get_metadata_routing = bridgeRandomTreesEmbedding[${this.id}].get_metadata_routing(**pms_RandomTreesEmbedding_get_metadata_routing)`;
    return this._py`res_RandomTreesEmbedding_get_metadata_routing.tolist() if hasattr(res_RandomTreesEmbedding_get_metadata_routing, 'tolist') else res_RandomTreesEmbedding_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RandomTreesEmbedding_set_fit_request = {k: v for k, v in pms_RandomTreesEmbedding_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_set_fit_request = bridgeRandomTreesEmbedding[${this.id}].set_fit_request(**pms_RandomTreesEmbedding_set_fit_request)`;
    return this._py`res_RandomTreesEmbedding_set_fit_request.tolist() if hasattr(res_RandomTreesEmbedding_set_fit_request, 'tolist') else res_RandomTreesEmbedding_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before set_output()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RandomTreesEmbedding_set_output = {k: v for k, v in pms_RandomTreesEmbedding_set_output.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_set_output = bridgeRandomTreesEmbedding[${this.id}].set_output(**pms_RandomTreesEmbedding_set_output)`;
    return this._py`res_RandomTreesEmbedding_set_output.tolist() if hasattr(res_RandomTreesEmbedding_set_output, 'tolist') else res_RandomTreesEmbedding_set_output`;
  }
  /**
    Transform dataset.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before transform()"
      );
    }
    await this._py.ex`pms_RandomTreesEmbedding_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomTreesEmbedding_transform = {k: v for k, v in pms_RandomTreesEmbedding_transform.items() if v is not None}`;
    await this._py.ex`res_RandomTreesEmbedding_transform = bridgeRandomTreesEmbedding[${this.id}].transform(**pms_RandomTreesEmbedding_transform)`;
    return this._py`res_RandomTreesEmbedding_transform.tolist() if hasattr(res_RandomTreesEmbedding_transform, 'tolist') else res_RandomTreesEmbedding_transform`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_estimator_ = bridgeRandomTreesEmbedding[${this.id}].estimator_`;
      return this._py`attr_RandomTreesEmbedding_estimator_.tolist() if hasattr(attr_RandomTreesEmbedding_estimator_, 'tolist') else attr_RandomTreesEmbedding_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_estimators_ = bridgeRandomTreesEmbedding[${this.id}].estimators_`;
      return this._py`attr_RandomTreesEmbedding_estimators_.tolist() if hasattr(attr_RandomTreesEmbedding_estimators_, 'tolist') else attr_RandomTreesEmbedding_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_n_features_in_ = bridgeRandomTreesEmbedding[${this.id}].n_features_in_`;
      return this._py`attr_RandomTreesEmbedding_n_features_in_.tolist() if hasattr(attr_RandomTreesEmbedding_n_features_in_, 'tolist') else attr_RandomTreesEmbedding_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_feature_names_in_ = bridgeRandomTreesEmbedding[${this.id}].feature_names_in_`;
      return this._py`attr_RandomTreesEmbedding_feature_names_in_.tolist() if hasattr(attr_RandomTreesEmbedding_feature_names_in_, 'tolist') else attr_RandomTreesEmbedding_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_n_outputs_ = bridgeRandomTreesEmbedding[${this.id}].n_outputs_`;
      return this._py`attr_RandomTreesEmbedding_n_outputs_.tolist() if hasattr(attr_RandomTreesEmbedding_n_outputs_, 'tolist') else attr_RandomTreesEmbedding_n_outputs_`;
    })();
  }
  /**
    One-hot encoder used to create the sparse embedding.
   */
  get one_hot_encoder_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomTreesEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomTreesEmbedding must call init() before accessing one_hot_encoder_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomTreesEmbedding_one_hot_encoder_ = bridgeRandomTreesEmbedding[${this.id}].one_hot_encoder_`;
      return this._py`attr_RandomTreesEmbedding_one_hot_encoder_.tolist() if hasattr(attr_RandomTreesEmbedding_one_hot_encoder_, 'tolist') else attr_RandomTreesEmbedding_one_hot_encoder_`;
    })();
  }
};

// src/generated/ensemble/StackingClassifier.ts
import crypto63 from "node:crypto";
var StackingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StackingClassifier${crypto63.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "StackingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import StackingClassifier
try: bridgeStackingClassifier
except NameError: bridgeStackingClassifier = {}
`;
    await this._py.ex`ctor_StackingClassifier = {'estimators': ${this.opts["estimators"] ?? void 0}, 'final_estimator': ${this.opts["final_estimator"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'stack_method': ${this.opts["stack_method"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'passthrough': ${this.opts["passthrough"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_StackingClassifier = {k: v for k, v in ctor_StackingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeStackingClassifier[${this.id}] = StackingClassifier(**ctor_StackingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStackingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Decision function for samples in `X` using the final estimator.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_StackingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_StackingClassifier_decision_function = {k: v for k, v in pms_StackingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_decision_function = bridgeStackingClassifier[${this.id}].decision_function(**pms_StackingClassifier_decision_function)`;
    return this._py`res_StackingClassifier_decision_function.tolist() if hasattr(res_StackingClassifier_decision_function, 'tolist') else res_StackingClassifier_decision_function`;
  }
  /**
    Fit the estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_StackingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StackingClassifier_fit = {k: v for k, v in pms_StackingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_fit = bridgeStackingClassifier[${this.id}].fit(**pms_StackingClassifier_fit)`;
    return this._py`res_StackingClassifier_fit.tolist() if hasattr(res_StackingClassifier_fit, 'tolist') else res_StackingClassifier_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_StackingClassifier_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_StackingClassifier_fit_transform = {k: v for k, v in pms_StackingClassifier_fit_transform.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_fit_transform = bridgeStackingClassifier[${this.id}].fit_transform(**pms_StackingClassifier_fit_transform)`;
    return this._py`res_StackingClassifier_fit_transform.tolist() if hasattr(res_StackingClassifier_fit_transform, 'tolist') else res_StackingClassifier_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_StackingClassifier_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_StackingClassifier_get_feature_names_out = {k: v for k, v in pms_StackingClassifier_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_get_feature_names_out = bridgeStackingClassifier[${this.id}].get_feature_names_out(**pms_StackingClassifier_get_feature_names_out)`;
    return this._py`res_StackingClassifier_get_feature_names_out.tolist() if hasattr(res_StackingClassifier_get_feature_names_out, 'tolist') else res_StackingClassifier_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StackingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StackingClassifier_get_metadata_routing = {k: v for k, v in pms_StackingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_get_metadata_routing = bridgeStackingClassifier[${this.id}].get_metadata_routing(**pms_StackingClassifier_get_metadata_routing)`;
    return this._py`res_StackingClassifier_get_metadata_routing.tolist() if hasattr(res_StackingClassifier_get_metadata_routing, 'tolist') else res_StackingClassifier_get_metadata_routing`;
  }
  /**
    Predict target for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingClassifier must call init() before predict()");
    }
    await this._py.ex`pms_StackingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'predict_params': ${opts["predict_params"] ?? void 0}}

pms_StackingClassifier_predict = {k: v for k, v in pms_StackingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_predict = bridgeStackingClassifier[${this.id}].predict(**pms_StackingClassifier_predict)`;
    return this._py`res_StackingClassifier_predict.tolist() if hasattr(res_StackingClassifier_predict, 'tolist') else res_StackingClassifier_predict`;
  }
  /**
    Predict class probabilities for `X` using the final estimator.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_StackingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_StackingClassifier_predict_proba = {k: v for k, v in pms_StackingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_predict_proba = bridgeStackingClassifier[${this.id}].predict_proba(**pms_StackingClassifier_predict_proba)`;
    return this._py`res_StackingClassifier_predict_proba.tolist() if hasattr(res_StackingClassifier_predict_proba, 'tolist') else res_StackingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingClassifier must call init() before score()");
    }
    await this._py.ex`pms_StackingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StackingClassifier_score = {k: v for k, v in pms_StackingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_score = bridgeStackingClassifier[${this.id}].score(**pms_StackingClassifier_score)`;
    return this._py`res_StackingClassifier_score.tolist() if hasattr(res_StackingClassifier_score, 'tolist') else res_StackingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_StackingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StackingClassifier_set_fit_request = {k: v for k, v in pms_StackingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_set_fit_request = bridgeStackingClassifier[${this.id}].set_fit_request(**pms_StackingClassifier_set_fit_request)`;
    return this._py`res_StackingClassifier_set_fit_request.tolist() if hasattr(res_StackingClassifier_set_fit_request, 'tolist') else res_StackingClassifier_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingClassifier must call init() before set_output()");
    }
    await this._py.ex`pms_StackingClassifier_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_StackingClassifier_set_output = {k: v for k, v in pms_StackingClassifier_set_output.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_set_output = bridgeStackingClassifier[${this.id}].set_output(**pms_StackingClassifier_set_output)`;
    return this._py`res_StackingClassifier_set_output.tolist() if hasattr(res_StackingClassifier_set_output, 'tolist') else res_StackingClassifier_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_StackingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StackingClassifier_set_score_request = {k: v for k, v in pms_StackingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_set_score_request = bridgeStackingClassifier[${this.id}].set_score_request(**pms_StackingClassifier_set_score_request)`;
    return this._py`res_StackingClassifier_set_score_request.tolist() if hasattr(res_StackingClassifier_set_score_request, 'tolist') else res_StackingClassifier_set_score_request`;
  }
  /**
    Return class labels or probabilities for X for each estimator.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingClassifier must call init() before transform()");
    }
    await this._py.ex`pms_StackingClassifier_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_StackingClassifier_transform = {k: v for k, v in pms_StackingClassifier_transform.items() if v is not None}`;
    await this._py.ex`res_StackingClassifier_transform = bridgeStackingClassifier[${this.id}].transform(**pms_StackingClassifier_transform)`;
    return this._py`res_StackingClassifier_transform.tolist() if hasattr(res_StackingClassifier_transform, 'tolist') else res_StackingClassifier_transform`;
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_classes_ = bridgeStackingClassifier[${this.id}].classes_`;
      return this._py`attr_StackingClassifier_classes_.tolist() if hasattr(attr_StackingClassifier_classes_, 'tolist') else attr_StackingClassifier_classes_`;
    })();
  }
  /**
    The elements of the `estimators` parameter, having been fitted on the training data. If an estimator has been set to `'drop'`, it will not appear in `estimators\_`. When `cv="prefit"`, `estimators\_` is set to `estimators` and is not fitted again.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_estimators_ = bridgeStackingClassifier[${this.id}].estimators_`;
      return this._py`attr_StackingClassifier_estimators_.tolist() if hasattr(attr_StackingClassifier_estimators_, 'tolist') else attr_StackingClassifier_estimators_`;
    })();
  }
  /**
    Attribute to access any fitted sub-estimators by name.
   */
  get named_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing named_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_named_estimators_ = bridgeStackingClassifier[${this.id}].named_estimators_`;
      return this._py`attr_StackingClassifier_named_estimators_.tolist() if hasattr(attr_StackingClassifier_named_estimators_, 'tolist') else attr_StackingClassifier_named_estimators_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_feature_names_in_ = bridgeStackingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_StackingClassifier_feature_names_in_.tolist() if hasattr(attr_StackingClassifier_feature_names_in_, 'tolist') else attr_StackingClassifier_feature_names_in_`;
    })();
  }
  /**
    The classifier which predicts given the output of `estimators\_`.
   */
  get final_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing final_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_final_estimator_ = bridgeStackingClassifier[${this.id}].final_estimator_`;
      return this._py`attr_StackingClassifier_final_estimator_.tolist() if hasattr(attr_StackingClassifier_final_estimator_, 'tolist') else attr_StackingClassifier_final_estimator_`;
    })();
  }
  /**
    The method used by each base estimator.
   */
  get stack_method_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingClassifier must call init() before accessing stack_method_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingClassifier_stack_method_ = bridgeStackingClassifier[${this.id}].stack_method_`;
      return this._py`attr_StackingClassifier_stack_method_.tolist() if hasattr(attr_StackingClassifier_stack_method_, 'tolist') else attr_StackingClassifier_stack_method_`;
    })();
  }
};

// src/generated/ensemble/StackingRegressor.ts
import crypto64 from "node:crypto";
var StackingRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StackingRegressor${crypto64.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("StackingRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import StackingRegressor
try: bridgeStackingRegressor
except NameError: bridgeStackingRegressor = {}
`;
    await this._py.ex`ctor_StackingRegressor = {'estimators': ${this.opts["estimators"] ?? void 0}, 'final_estimator': ${this.opts["final_estimator"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'passthrough': ${this.opts["passthrough"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_StackingRegressor = {k: v for k, v in ctor_StackingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeStackingRegressor[${this.id}] = StackingRegressor(**ctor_StackingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStackingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_StackingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StackingRegressor_fit = {k: v for k, v in pms_StackingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_fit = bridgeStackingRegressor[${this.id}].fit(**pms_StackingRegressor_fit)`;
    return this._py`res_StackingRegressor_fit.tolist() if hasattr(res_StackingRegressor_fit, 'tolist') else res_StackingRegressor_fit`;
  }
  /**
    Fit the estimators and return the predictions for X for each estimator.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_StackingRegressor_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StackingRegressor_fit_transform = {k: v for k, v in pms_StackingRegressor_fit_transform.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_fit_transform = bridgeStackingRegressor[${this.id}].fit_transform(**pms_StackingRegressor_fit_transform)`;
    return this._py`res_StackingRegressor_fit_transform.tolist() if hasattr(res_StackingRegressor_fit_transform, 'tolist') else res_StackingRegressor_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_StackingRegressor_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_StackingRegressor_get_feature_names_out = {k: v for k, v in pms_StackingRegressor_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_get_feature_names_out = bridgeStackingRegressor[${this.id}].get_feature_names_out(**pms_StackingRegressor_get_feature_names_out)`;
    return this._py`res_StackingRegressor_get_feature_names_out.tolist() if hasattr(res_StackingRegressor_get_feature_names_out, 'tolist') else res_StackingRegressor_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StackingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StackingRegressor_get_metadata_routing = {k: v for k, v in pms_StackingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_get_metadata_routing = bridgeStackingRegressor[${this.id}].get_metadata_routing(**pms_StackingRegressor_get_metadata_routing)`;
    return this._py`res_StackingRegressor_get_metadata_routing.tolist() if hasattr(res_StackingRegressor_get_metadata_routing, 'tolist') else res_StackingRegressor_get_metadata_routing`;
  }
  /**
    Predict target for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingRegressor must call init() before predict()");
    }
    await this._py.ex`pms_StackingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'predict_params': ${opts["predict_params"] ?? void 0}}

pms_StackingRegressor_predict = {k: v for k, v in pms_StackingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_predict = bridgeStackingRegressor[${this.id}].predict(**pms_StackingRegressor_predict)`;
    return this._py`res_StackingRegressor_predict.tolist() if hasattr(res_StackingRegressor_predict, 'tolist') else res_StackingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingRegressor must call init() before score()");
    }
    await this._py.ex`pms_StackingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StackingRegressor_score = {k: v for k, v in pms_StackingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_score = bridgeStackingRegressor[${this.id}].score(**pms_StackingRegressor_score)`;
    return this._py`res_StackingRegressor_score.tolist() if hasattr(res_StackingRegressor_score, 'tolist') else res_StackingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_StackingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StackingRegressor_set_fit_request = {k: v for k, v in pms_StackingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_set_fit_request = bridgeStackingRegressor[${this.id}].set_fit_request(**pms_StackingRegressor_set_fit_request)`;
    return this._py`res_StackingRegressor_set_fit_request.tolist() if hasattr(res_StackingRegressor_set_fit_request, 'tolist') else res_StackingRegressor_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingRegressor must call init() before set_output()");
    }
    await this._py.ex`pms_StackingRegressor_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_StackingRegressor_set_output = {k: v for k, v in pms_StackingRegressor_set_output.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_set_output = bridgeStackingRegressor[${this.id}].set_output(**pms_StackingRegressor_set_output)`;
    return this._py`res_StackingRegressor_set_output.tolist() if hasattr(res_StackingRegressor_set_output, 'tolist') else res_StackingRegressor_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_StackingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StackingRegressor_set_score_request = {k: v for k, v in pms_StackingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_set_score_request = bridgeStackingRegressor[${this.id}].set_score_request(**pms_StackingRegressor_set_score_request)`;
    return this._py`res_StackingRegressor_set_score_request.tolist() if hasattr(res_StackingRegressor_set_score_request, 'tolist') else res_StackingRegressor_set_score_request`;
  }
  /**
    Return the predictions for X for each estimator.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StackingRegressor must call init() before transform()");
    }
    await this._py.ex`pms_StackingRegressor_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_StackingRegressor_transform = {k: v for k, v in pms_StackingRegressor_transform.items() if v is not None}`;
    await this._py.ex`res_StackingRegressor_transform = bridgeStackingRegressor[${this.id}].transform(**pms_StackingRegressor_transform)`;
    return this._py`res_StackingRegressor_transform.tolist() if hasattr(res_StackingRegressor_transform, 'tolist') else res_StackingRegressor_transform`;
  }
  /**
    The elements of the `estimators` parameter, having been fitted on the training data. If an estimator has been set to `'drop'`, it will not appear in `estimators\_`. When `cv="prefit"`, `estimators\_` is set to `estimators` and is not fitted again.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingRegressor_estimators_ = bridgeStackingRegressor[${this.id}].estimators_`;
      return this._py`attr_StackingRegressor_estimators_.tolist() if hasattr(attr_StackingRegressor_estimators_, 'tolist') else attr_StackingRegressor_estimators_`;
    })();
  }
  /**
    Attribute to access any fitted sub-estimators by name.
   */
  get named_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before accessing named_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingRegressor_named_estimators_ = bridgeStackingRegressor[${this.id}].named_estimators_`;
      return this._py`attr_StackingRegressor_named_estimators_.tolist() if hasattr(attr_StackingRegressor_named_estimators_, 'tolist') else attr_StackingRegressor_named_estimators_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingRegressor_feature_names_in_ = bridgeStackingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_StackingRegressor_feature_names_in_.tolist() if hasattr(attr_StackingRegressor_feature_names_in_, 'tolist') else attr_StackingRegressor_feature_names_in_`;
    })();
  }
  /**
    The regressor to stacked the base estimators fitted.
   */
  get final_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before accessing final_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingRegressor_final_estimator_ = bridgeStackingRegressor[${this.id}].final_estimator_`;
      return this._py`attr_StackingRegressor_final_estimator_.tolist() if hasattr(attr_StackingRegressor_final_estimator_, 'tolist') else attr_StackingRegressor_final_estimator_`;
    })();
  }
  /**
    The method used by each base estimator.
   */
  get stack_method_() {
    if (this._isDisposed) {
      throw new Error(
        "This StackingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StackingRegressor must call init() before accessing stack_method_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StackingRegressor_stack_method_ = bridgeStackingRegressor[${this.id}].stack_method_`;
      return this._py`attr_StackingRegressor_stack_method_.tolist() if hasattr(attr_StackingRegressor_stack_method_, 'tolist') else attr_StackingRegressor_stack_method_`;
    })();
  }
};

// src/generated/ensemble/VotingClassifier.ts
import crypto65 from "node:crypto";
var VotingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `VotingClassifier${crypto65.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("VotingClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import VotingClassifier
try: bridgeVotingClassifier
except NameError: bridgeVotingClassifier = {}
`;
    await this._py.ex`ctor_VotingClassifier = {'estimators': ${this.opts["estimators"] ?? void 0}, 'voting': ${this.opts["voting"] ?? void 0}, 'weights': np.array(${this.opts["weights"] ?? void 0}) if ${this.opts["weights"] !== void 0} else None, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'flatten_transform': ${this.opts["flatten_transform"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_VotingClassifier = {k: v for k, v in ctor_VotingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeVotingClassifier[${this.id}] = VotingClassifier(**ctor_VotingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeVotingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_VotingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_VotingClassifier_fit = {k: v for k, v in pms_VotingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_fit = bridgeVotingClassifier[${this.id}].fit(**pms_VotingClassifier_fit)`;
    return this._py`res_VotingClassifier_fit.tolist() if hasattr(res_VotingClassifier_fit, 'tolist') else res_VotingClassifier_fit`;
  }
  /**
      Return class labels or probabilities for each estimator.
  
      Return predictions for X for each estimator.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_VotingClassifier_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_VotingClassifier_fit_transform = {k: v for k, v in pms_VotingClassifier_fit_transform.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_fit_transform = bridgeVotingClassifier[${this.id}].fit_transform(**pms_VotingClassifier_fit_transform)`;
    return this._py`res_VotingClassifier_fit_transform.tolist() if hasattr(res_VotingClassifier_fit_transform, 'tolist') else res_VotingClassifier_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_VotingClassifier_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_VotingClassifier_get_feature_names_out = {k: v for k, v in pms_VotingClassifier_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_get_feature_names_out = bridgeVotingClassifier[${this.id}].get_feature_names_out(**pms_VotingClassifier_get_feature_names_out)`;
    return this._py`res_VotingClassifier_get_feature_names_out.tolist() if hasattr(res_VotingClassifier_get_feature_names_out, 'tolist') else res_VotingClassifier_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_VotingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_VotingClassifier_get_metadata_routing = {k: v for k, v in pms_VotingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_get_metadata_routing = bridgeVotingClassifier[${this.id}].get_metadata_routing(**pms_VotingClassifier_get_metadata_routing)`;
    return this._py`res_VotingClassifier_get_metadata_routing.tolist() if hasattr(res_VotingClassifier_get_metadata_routing, 'tolist') else res_VotingClassifier_get_metadata_routing`;
  }
  /**
    Predict class labels for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before predict()");
    }
    await this._py.ex`pms_VotingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VotingClassifier_predict = {k: v for k, v in pms_VotingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_predict = bridgeVotingClassifier[${this.id}].predict(**pms_VotingClassifier_predict)`;
    return this._py`res_VotingClassifier_predict.tolist() if hasattr(res_VotingClassifier_predict, 'tolist') else res_VotingClassifier_predict`;
  }
  /**
    Compute probabilities of possible outcomes for samples in X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_VotingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VotingClassifier_predict_proba = {k: v for k, v in pms_VotingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_predict_proba = bridgeVotingClassifier[${this.id}].predict_proba(**pms_VotingClassifier_predict_proba)`;
    return this._py`res_VotingClassifier_predict_proba.tolist() if hasattr(res_VotingClassifier_predict_proba, 'tolist') else res_VotingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before score()");
    }
    await this._py.ex`pms_VotingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_VotingClassifier_score = {k: v for k, v in pms_VotingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_score = bridgeVotingClassifier[${this.id}].score(**pms_VotingClassifier_score)`;
    return this._py`res_VotingClassifier_score.tolist() if hasattr(res_VotingClassifier_score, 'tolist') else res_VotingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_VotingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_VotingClassifier_set_fit_request = {k: v for k, v in pms_VotingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_set_fit_request = bridgeVotingClassifier[${this.id}].set_fit_request(**pms_VotingClassifier_set_fit_request)`;
    return this._py`res_VotingClassifier_set_fit_request.tolist() if hasattr(res_VotingClassifier_set_fit_request, 'tolist') else res_VotingClassifier_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before set_output()");
    }
    await this._py.ex`pms_VotingClassifier_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_VotingClassifier_set_output = {k: v for k, v in pms_VotingClassifier_set_output.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_set_output = bridgeVotingClassifier[${this.id}].set_output(**pms_VotingClassifier_set_output)`;
    return this._py`res_VotingClassifier_set_output.tolist() if hasattr(res_VotingClassifier_set_output, 'tolist') else res_VotingClassifier_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_VotingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_VotingClassifier_set_score_request = {k: v for k, v in pms_VotingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_set_score_request = bridgeVotingClassifier[${this.id}].set_score_request(**pms_VotingClassifier_set_score_request)`;
    return this._py`res_VotingClassifier_set_score_request.tolist() if hasattr(res_VotingClassifier_set_score_request, 'tolist') else res_VotingClassifier_set_score_request`;
  }
  /**
    Return class labels or probabilities for X for each estimator.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before transform()");
    }
    await this._py.ex`pms_VotingClassifier_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VotingClassifier_transform = {k: v for k, v in pms_VotingClassifier_transform.items() if v is not None}`;
    await this._py.ex`res_VotingClassifier_transform = bridgeVotingClassifier[${this.id}].transform(**pms_VotingClassifier_transform)`;
    return this._py`res_VotingClassifier_transform.tolist() if hasattr(res_VotingClassifier_transform, 'tolist') else res_VotingClassifier_transform`;
  }
  /**
    The collection of fitted sub-estimators as defined in `estimators` that are not â€˜dropâ€™.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingClassifier_estimators_ = bridgeVotingClassifier[${this.id}].estimators_`;
      return this._py`attr_VotingClassifier_estimators_.tolist() if hasattr(attr_VotingClassifier_estimators_, 'tolist') else attr_VotingClassifier_estimators_`;
    })();
  }
  /**
    Attribute to access any fitted sub-estimators by name.
   */
  get named_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before accessing named_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingClassifier_named_estimators_ = bridgeVotingClassifier[${this.id}].named_estimators_`;
      return this._py`attr_VotingClassifier_named_estimators_.tolist() if hasattr(attr_VotingClassifier_named_estimators_, 'tolist') else attr_VotingClassifier_named_estimators_`;
    })();
  }
  /**
    Transformer used to encode the labels during fit and decode during prediction.
   */
  get le_() {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VotingClassifier must call init() before accessing le_");
    }
    return (async () => {
      await this._py.ex`attr_VotingClassifier_le_ = bridgeVotingClassifier[${this.id}].le_`;
      return this._py`attr_VotingClassifier_le_.tolist() if hasattr(attr_VotingClassifier_le_, 'tolist') else attr_VotingClassifier_le_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingClassifier_classes_ = bridgeVotingClassifier[${this.id}].classes_`;
      return this._py`attr_VotingClassifier_classes_.tolist() if hasattr(attr_VotingClassifier_classes_, 'tolist') else attr_VotingClassifier_classes_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This VotingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingClassifier_feature_names_in_ = bridgeVotingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_VotingClassifier_feature_names_in_.tolist() if hasattr(attr_VotingClassifier_feature_names_in_, 'tolist') else attr_VotingClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/VotingRegressor.ts
import crypto66 from "node:crypto";
var VotingRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `VotingRegressor${crypto66.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("VotingRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import VotingRegressor
try: bridgeVotingRegressor
except NameError: bridgeVotingRegressor = {}
`;
    await this._py.ex`ctor_VotingRegressor = {'estimators': ${this.opts["estimators"] ?? void 0}, 'weights': np.array(${this.opts["weights"] ?? void 0}) if ${this.opts["weights"] !== void 0} else None, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_VotingRegressor = {k: v for k, v in ctor_VotingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeVotingRegressor[${this.id}] = VotingRegressor(**ctor_VotingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeVotingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_VotingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_VotingRegressor_fit = {k: v for k, v in pms_VotingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_fit = bridgeVotingRegressor[${this.id}].fit(**pms_VotingRegressor_fit)`;
    return this._py`res_VotingRegressor_fit.tolist() if hasattr(res_VotingRegressor_fit, 'tolist') else res_VotingRegressor_fit`;
  }
  /**
      Return class labels or probabilities for each estimator.
  
      Return predictions for X for each estimator.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before fit_transform()");
    }
    await this._py.ex`pms_VotingRegressor_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_VotingRegressor_fit_transform = {k: v for k, v in pms_VotingRegressor_fit_transform.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_fit_transform = bridgeVotingRegressor[${this.id}].fit_transform(**pms_VotingRegressor_fit_transform)`;
    return this._py`res_VotingRegressor_fit_transform.tolist() if hasattr(res_VotingRegressor_fit_transform, 'tolist') else res_VotingRegressor_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_VotingRegressor_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_VotingRegressor_get_feature_names_out = {k: v for k, v in pms_VotingRegressor_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_get_feature_names_out = bridgeVotingRegressor[${this.id}].get_feature_names_out(**pms_VotingRegressor_get_feature_names_out)`;
    return this._py`res_VotingRegressor_get_feature_names_out.tolist() if hasattr(res_VotingRegressor_get_feature_names_out, 'tolist') else res_VotingRegressor_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_VotingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_VotingRegressor_get_metadata_routing = {k: v for k, v in pms_VotingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_get_metadata_routing = bridgeVotingRegressor[${this.id}].get_metadata_routing(**pms_VotingRegressor_get_metadata_routing)`;
    return this._py`res_VotingRegressor_get_metadata_routing.tolist() if hasattr(res_VotingRegressor_get_metadata_routing, 'tolist') else res_VotingRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the estimators in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before predict()");
    }
    await this._py.ex`pms_VotingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VotingRegressor_predict = {k: v for k, v in pms_VotingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_predict = bridgeVotingRegressor[${this.id}].predict(**pms_VotingRegressor_predict)`;
    return this._py`res_VotingRegressor_predict.tolist() if hasattr(res_VotingRegressor_predict, 'tolist') else res_VotingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before score()");
    }
    await this._py.ex`pms_VotingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_VotingRegressor_score = {k: v for k, v in pms_VotingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_score = bridgeVotingRegressor[${this.id}].score(**pms_VotingRegressor_score)`;
    return this._py`res_VotingRegressor_score.tolist() if hasattr(res_VotingRegressor_score, 'tolist') else res_VotingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_VotingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_VotingRegressor_set_fit_request = {k: v for k, v in pms_VotingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_set_fit_request = bridgeVotingRegressor[${this.id}].set_fit_request(**pms_VotingRegressor_set_fit_request)`;
    return this._py`res_VotingRegressor_set_fit_request.tolist() if hasattr(res_VotingRegressor_set_fit_request, 'tolist') else res_VotingRegressor_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before set_output()");
    }
    await this._py.ex`pms_VotingRegressor_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_VotingRegressor_set_output = {k: v for k, v in pms_VotingRegressor_set_output.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_set_output = bridgeVotingRegressor[${this.id}].set_output(**pms_VotingRegressor_set_output)`;
    return this._py`res_VotingRegressor_set_output.tolist() if hasattr(res_VotingRegressor_set_output, 'tolist') else res_VotingRegressor_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_VotingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_VotingRegressor_set_score_request = {k: v for k, v in pms_VotingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_set_score_request = bridgeVotingRegressor[${this.id}].set_score_request(**pms_VotingRegressor_set_score_request)`;
    return this._py`res_VotingRegressor_set_score_request.tolist() if hasattr(res_VotingRegressor_set_score_request, 'tolist') else res_VotingRegressor_set_score_request`;
  }
  /**
    Return predictions for X for each estimator.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("VotingRegressor must call init() before transform()");
    }
    await this._py.ex`pms_VotingRegressor_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VotingRegressor_transform = {k: v for k, v in pms_VotingRegressor_transform.items() if v is not None}`;
    await this._py.ex`res_VotingRegressor_transform = bridgeVotingRegressor[${this.id}].transform(**pms_VotingRegressor_transform)`;
    return this._py`res_VotingRegressor_transform.tolist() if hasattr(res_VotingRegressor_transform, 'tolist') else res_VotingRegressor_transform`;
  }
  /**
    The collection of fitted sub-estimators as defined in `estimators` that are not â€˜dropâ€™.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingRegressor_estimators_ = bridgeVotingRegressor[${this.id}].estimators_`;
      return this._py`attr_VotingRegressor_estimators_.tolist() if hasattr(attr_VotingRegressor_estimators_, 'tolist') else attr_VotingRegressor_estimators_`;
    })();
  }
  /**
    Attribute to access any fitted sub-estimators by name.
   */
  get named_estimators_() {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before accessing named_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingRegressor_named_estimators_ = bridgeVotingRegressor[${this.id}].named_estimators_`;
      return this._py`attr_VotingRegressor_named_estimators_.tolist() if hasattr(attr_VotingRegressor_named_estimators_, 'tolist') else attr_VotingRegressor_named_estimators_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This VotingRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "VotingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VotingRegressor_feature_names_in_ = bridgeVotingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_VotingRegressor_feature_names_in_.tolist() if hasattr(attr_VotingRegressor_feature_names_in_, 'tolist') else attr_VotingRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/exceptions/ConvergenceWarning.ts
import crypto67 from "node:crypto";
var ConvergenceWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ConvergenceWarning${crypto67.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ConvergenceWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ConvergenceWarning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import ConvergenceWarning
try: bridgeConvergenceWarning
except NameError: bridgeConvergenceWarning = {}
`;
    await this._py.ex`ctor_ConvergenceWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_ConvergenceWarning = {k: v for k, v in ctor_ConvergenceWarning.items() if v is not None}`;
    await this._py.ex`bridgeConvergenceWarning[${this.id}] = ConvergenceWarning(**ctor_ConvergenceWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeConvergenceWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ConvergenceWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConvergenceWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_ConvergenceWarning_with_traceback = {}

pms_ConvergenceWarning_with_traceback = {k: v for k, v in pms_ConvergenceWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_ConvergenceWarning_with_traceback = bridgeConvergenceWarning[${this.id}].with_traceback(**pms_ConvergenceWarning_with_traceback)`;
    return this._py`res_ConvergenceWarning_with_traceback.tolist() if hasattr(res_ConvergenceWarning_with_traceback, 'tolist') else res_ConvergenceWarning_with_traceback`;
  }
};

// src/generated/exceptions/DataConversionWarning.ts
import crypto68 from "node:crypto";
var DataConversionWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DataConversionWarning${crypto68.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DataConversionWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DataConversionWarning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import DataConversionWarning
try: bridgeDataConversionWarning
except NameError: bridgeDataConversionWarning = {}
`;
    await this._py.ex`ctor_DataConversionWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_DataConversionWarning = {k: v for k, v in ctor_DataConversionWarning.items() if v is not None}`;
    await this._py.ex`bridgeDataConversionWarning[${this.id}] = DataConversionWarning(**ctor_DataConversionWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDataConversionWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DataConversionWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DataConversionWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_DataConversionWarning_with_traceback = {}

pms_DataConversionWarning_with_traceback = {k: v for k, v in pms_DataConversionWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_DataConversionWarning_with_traceback = bridgeDataConversionWarning[${this.id}].with_traceback(**pms_DataConversionWarning_with_traceback)`;
    return this._py`res_DataConversionWarning_with_traceback.tolist() if hasattr(res_DataConversionWarning_with_traceback, 'tolist') else res_DataConversionWarning_with_traceback`;
  }
};

// src/generated/exceptions/DataDimensionalityWarning.ts
import crypto69 from "node:crypto";
var DataDimensionalityWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DataDimensionalityWarning${crypto69.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DataDimensionalityWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DataDimensionalityWarning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import DataDimensionalityWarning
try: bridgeDataDimensionalityWarning
except NameError: bridgeDataDimensionalityWarning = {}
`;
    await this._py.ex`ctor_DataDimensionalityWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_DataDimensionalityWarning = {k: v for k, v in ctor_DataDimensionalityWarning.items() if v is not None}`;
    await this._py.ex`bridgeDataDimensionalityWarning[${this.id}] = DataDimensionalityWarning(**ctor_DataDimensionalityWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDataDimensionalityWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DataDimensionalityWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DataDimensionalityWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_DataDimensionalityWarning_with_traceback = {}

pms_DataDimensionalityWarning_with_traceback = {k: v for k, v in pms_DataDimensionalityWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_DataDimensionalityWarning_with_traceback = bridgeDataDimensionalityWarning[${this.id}].with_traceback(**pms_DataDimensionalityWarning_with_traceback)`;
    return this._py`res_DataDimensionalityWarning_with_traceback.tolist() if hasattr(res_DataDimensionalityWarning_with_traceback, 'tolist') else res_DataDimensionalityWarning_with_traceback`;
  }
};

// src/generated/exceptions/EfficiencyWarning.ts
import crypto70 from "node:crypto";
var EfficiencyWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `EfficiencyWarning${crypto70.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This EfficiencyWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("EfficiencyWarning.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import EfficiencyWarning
try: bridgeEfficiencyWarning
except NameError: bridgeEfficiencyWarning = {}
`;
    await this._py.ex`ctor_EfficiencyWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_EfficiencyWarning = {k: v for k, v in ctor_EfficiencyWarning.items() if v is not None}`;
    await this._py.ex`bridgeEfficiencyWarning[${this.id}] = EfficiencyWarning(**ctor_EfficiencyWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeEfficiencyWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EfficiencyWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EfficiencyWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_EfficiencyWarning_with_traceback = {}

pms_EfficiencyWarning_with_traceback = {k: v for k, v in pms_EfficiencyWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_EfficiencyWarning_with_traceback = bridgeEfficiencyWarning[${this.id}].with_traceback(**pms_EfficiencyWarning_with_traceback)`;
    return this._py`res_EfficiencyWarning_with_traceback.tolist() if hasattr(res_EfficiencyWarning_with_traceback, 'tolist') else res_EfficiencyWarning_with_traceback`;
  }
};

// src/generated/exceptions/FitFailedWarning.ts
import crypto71 from "node:crypto";
var FitFailedWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FitFailedWarning${crypto71.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FitFailedWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FitFailedWarning.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import FitFailedWarning
try: bridgeFitFailedWarning
except NameError: bridgeFitFailedWarning = {}
`;
    await this._py.ex`ctor_FitFailedWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_FitFailedWarning = {k: v for k, v in ctor_FitFailedWarning.items() if v is not None}`;
    await this._py.ex`bridgeFitFailedWarning[${this.id}] = FitFailedWarning(**ctor_FitFailedWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFitFailedWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FitFailedWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FitFailedWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_FitFailedWarning_with_traceback = {}

pms_FitFailedWarning_with_traceback = {k: v for k, v in pms_FitFailedWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_FitFailedWarning_with_traceback = bridgeFitFailedWarning[${this.id}].with_traceback(**pms_FitFailedWarning_with_traceback)`;
    return this._py`res_FitFailedWarning_with_traceback.tolist() if hasattr(res_FitFailedWarning_with_traceback, 'tolist') else res_FitFailedWarning_with_traceback`;
  }
};

// src/generated/exceptions/InconsistentVersionWarning.ts
import crypto72 from "node:crypto";
var InconsistentVersionWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `InconsistentVersionWarning${crypto72.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This InconsistentVersionWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "InconsistentVersionWarning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import InconsistentVersionWarning
try: bridgeInconsistentVersionWarning
except NameError: bridgeInconsistentVersionWarning = {}
`;
    await this._py.ex`ctor_InconsistentVersionWarning = {'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'current_sklearn_version': ${this.opts["current_sklearn_version"] ?? void 0}, 'original_sklearn_version': ${this.opts["original_sklearn_version"] ?? void 0}}

ctor_InconsistentVersionWarning = {k: v for k, v in ctor_InconsistentVersionWarning.items() if v is not None}`;
    await this._py.ex`bridgeInconsistentVersionWarning[${this.id}] = InconsistentVersionWarning(**ctor_InconsistentVersionWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeInconsistentVersionWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This InconsistentVersionWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "InconsistentVersionWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_InconsistentVersionWarning_with_traceback = {}

pms_InconsistentVersionWarning_with_traceback = {k: v for k, v in pms_InconsistentVersionWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_InconsistentVersionWarning_with_traceback = bridgeInconsistentVersionWarning[${this.id}].with_traceback(**pms_InconsistentVersionWarning_with_traceback)`;
    return this._py`res_InconsistentVersionWarning_with_traceback.tolist() if hasattr(res_InconsistentVersionWarning_with_traceback, 'tolist') else res_InconsistentVersionWarning_with_traceback`;
  }
  get args() {
    if (this._isDisposed) {
      throw new Error(
        "This InconsistentVersionWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "InconsistentVersionWarning must call init() before accessing args"
      );
    }
    return (async () => {
      await this._py.ex`attr_InconsistentVersionWarning_args = bridgeInconsistentVersionWarning[${this.id}].args`;
      return this._py`attr_InconsistentVersionWarning_args.tolist() if hasattr(attr_InconsistentVersionWarning_args, 'tolist') else attr_InconsistentVersionWarning_args`;
    })();
  }
};

// src/generated/exceptions/NotFittedError.ts
import crypto73 from "node:crypto";
var NotFittedError = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NotFittedError${crypto73.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NotFittedError instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NotFittedError.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import NotFittedError
try: bridgeNotFittedError
except NameError: bridgeNotFittedError = {}
`;
    await this._py.ex`ctor_NotFittedError = {'args': ${this.opts["args"] ?? void 0}}

ctor_NotFittedError = {k: v for k, v in ctor_NotFittedError.items() if v is not None}`;
    await this._py.ex`bridgeNotFittedError[${this.id}] = NotFittedError(**ctor_NotFittedError)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNotFittedError[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error("This NotFittedError instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NotFittedError must call init() before with_traceback()");
    }
    await this._py.ex`pms_NotFittedError_with_traceback = {}

pms_NotFittedError_with_traceback = {k: v for k, v in pms_NotFittedError_with_traceback.items() if v is not None}`;
    await this._py.ex`res_NotFittedError_with_traceback = bridgeNotFittedError[${this.id}].with_traceback(**pms_NotFittedError_with_traceback)`;
    return this._py`res_NotFittedError_with_traceback.tolist() if hasattr(res_NotFittedError_with_traceback, 'tolist') else res_NotFittedError_with_traceback`;
  }
};

// src/generated/exceptions/UndefinedMetricWarning.ts
import crypto74 from "node:crypto";
var UndefinedMetricWarning = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `UndefinedMetricWarning${crypto74.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This UndefinedMetricWarning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "UndefinedMetricWarning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.exceptions import UndefinedMetricWarning
try: bridgeUndefinedMetricWarning
except NameError: bridgeUndefinedMetricWarning = {}
`;
    await this._py.ex`ctor_UndefinedMetricWarning = {'args': ${this.opts["args"] ?? void 0}}

ctor_UndefinedMetricWarning = {k: v for k, v in ctor_UndefinedMetricWarning.items() if v is not None}`;
    await this._py.ex`bridgeUndefinedMetricWarning[${this.id}] = UndefinedMetricWarning(**ctor_UndefinedMetricWarning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeUndefinedMetricWarning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Exception.with\_traceback(tb) â€“ set self.\_\_traceback\_\_ to tb and return self.
   */
  async with_traceback(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This UndefinedMetricWarning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "UndefinedMetricWarning must call init() before with_traceback()"
      );
    }
    await this._py.ex`pms_UndefinedMetricWarning_with_traceback = {}

pms_UndefinedMetricWarning_with_traceback = {k: v for k, v in pms_UndefinedMetricWarning_with_traceback.items() if v is not None}`;
    await this._py.ex`res_UndefinedMetricWarning_with_traceback = bridgeUndefinedMetricWarning[${this.id}].with_traceback(**pms_UndefinedMetricWarning_with_traceback)`;
    return this._py`res_UndefinedMetricWarning_with_traceback.tolist() if hasattr(res_UndefinedMetricWarning_with_traceback, 'tolist') else res_UndefinedMetricWarning_with_traceback`;
  }
};

// src/generated/feature_extraction/DictVectorizer.ts
import crypto75 from "node:crypto";
var DictVectorizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DictVectorizer${crypto75.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DictVectorizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction import DictVectorizer
try: bridgeDictVectorizer
except NameError: bridgeDictVectorizer = {}
`;
    await this._py.ex`ctor_DictVectorizer = {'dtype': ${this.opts["dtype"] ?? void 0}, 'separator': ${this.opts["separator"] ?? void 0}, 'sparse': ${this.opts["sparse"] ?? void 0}, 'sort': ${this.opts["sort"] ?? void 0}}

ctor_DictVectorizer = {k: v for k, v in ctor_DictVectorizer.items() if v is not None}`;
    await this._py.ex`bridgeDictVectorizer[${this.id}] = DictVectorizer(**ctor_DictVectorizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDictVectorizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a list of feature name -> indices mappings.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DictVectorizer must call init() before fit()");
    }
    await this._py.ex`pms_DictVectorizer_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_DictVectorizer_fit = {k: v for k, v in pms_DictVectorizer_fit.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_fit = bridgeDictVectorizer[${this.id}].fit(**pms_DictVectorizer_fit)`;
    return this._py`res_DictVectorizer_fit.tolist() if hasattr(res_DictVectorizer_fit, 'tolist') else res_DictVectorizer_fit`;
  }
  /**
      Learn a list of feature name -> indices mappings and transform X.
  
      Like fit(X) followed by transform(X), but does not require materializing X in memory.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DictVectorizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_DictVectorizer_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_DictVectorizer_fit_transform = {k: v for k, v in pms_DictVectorizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_fit_transform = bridgeDictVectorizer[${this.id}].fit_transform(**pms_DictVectorizer_fit_transform)`;
    return this._py`res_DictVectorizer_fit_transform.tolist() if hasattr(res_DictVectorizer_fit_transform, 'tolist') else res_DictVectorizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_DictVectorizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_DictVectorizer_get_feature_names_out = {k: v for k, v in pms_DictVectorizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_get_feature_names_out = bridgeDictVectorizer[${this.id}].get_feature_names_out(**pms_DictVectorizer_get_feature_names_out)`;
    return this._py`res_DictVectorizer_get_feature_names_out.tolist() if hasattr(res_DictVectorizer_get_feature_names_out, 'tolist') else res_DictVectorizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DictVectorizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DictVectorizer_get_metadata_routing = {k: v for k, v in pms_DictVectorizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_get_metadata_routing = bridgeDictVectorizer[${this.id}].get_metadata_routing(**pms_DictVectorizer_get_metadata_routing)`;
    return this._py`res_DictVectorizer_get_metadata_routing.tolist() if hasattr(res_DictVectorizer_get_metadata_routing, 'tolist') else res_DictVectorizer_get_metadata_routing`;
  }
  /**
      Transform array or sparse matrix X back to feature mappings.
  
      X must have been produced by this DictVectorizerâ€™s transform or fit\_transform method; it may only have passed through transformers that preserve the number of features and their order.
  
      In the case of one-hot/one-of-K coding, the constructed feature names and values are returned rather than the original ones.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_DictVectorizer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'dict_type': ${opts["dict_type"] ?? void 0}}

pms_DictVectorizer_inverse_transform = {k: v for k, v in pms_DictVectorizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_inverse_transform = bridgeDictVectorizer[${this.id}].inverse_transform(**pms_DictVectorizer_inverse_transform)`;
    return this._py`res_DictVectorizer_inverse_transform.tolist() if hasattr(res_DictVectorizer_inverse_transform, 'tolist') else res_DictVectorizer_inverse_transform`;
  }
  /**
      Restrict the features to those in support using feature selection.
  
      This function modifies the estimator in-place.
     */
  async restrict(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DictVectorizer must call init() before restrict()");
    }
    await this._py.ex`pms_DictVectorizer_restrict = {'support': ${opts["support"] ?? void 0}, 'indices': ${opts["indices"] ?? void 0}}

pms_DictVectorizer_restrict = {k: v for k, v in pms_DictVectorizer_restrict.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_restrict = bridgeDictVectorizer[${this.id}].restrict(**pms_DictVectorizer_restrict)`;
    return this._py`res_DictVectorizer_restrict.tolist() if hasattr(res_DictVectorizer_restrict, 'tolist') else res_DictVectorizer_restrict`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_DictVectorizer_set_inverse_transform_request = {'dict_type': ${opts["dict_type"] ?? void 0}}

pms_DictVectorizer_set_inverse_transform_request = {k: v for k, v in pms_DictVectorizer_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_set_inverse_transform_request = bridgeDictVectorizer[${this.id}].set_inverse_transform_request(**pms_DictVectorizer_set_inverse_transform_request)`;
    return this._py`res_DictVectorizer_set_inverse_transform_request.tolist() if hasattr(res_DictVectorizer_set_inverse_transform_request, 'tolist') else res_DictVectorizer_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DictVectorizer must call init() before set_output()");
    }
    await this._py.ex`pms_DictVectorizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_DictVectorizer_set_output = {k: v for k, v in pms_DictVectorizer_set_output.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_set_output = bridgeDictVectorizer[${this.id}].set_output(**pms_DictVectorizer_set_output)`;
    return this._py`res_DictVectorizer_set_output.tolist() if hasattr(res_DictVectorizer_set_output, 'tolist') else res_DictVectorizer_set_output`;
  }
  /**
      Transform feature->value dicts to array or sparse matrix.
  
      Named features not encountered during fit or fit\_transform will be silently ignored.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DictVectorizer must call init() before transform()");
    }
    await this._py.ex`pms_DictVectorizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DictVectorizer_transform = {k: v for k, v in pms_DictVectorizer_transform.items() if v is not None}`;
    await this._py.ex`res_DictVectorizer_transform = bridgeDictVectorizer[${this.id}].transform(**pms_DictVectorizer_transform)`;
    return this._py`res_DictVectorizer_transform.tolist() if hasattr(res_DictVectorizer_transform, 'tolist') else res_DictVectorizer_transform`;
  }
  /**
    A dictionary mapping feature names to feature indices.
   */
  get vocabulary_() {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before accessing vocabulary_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictVectorizer_vocabulary_ = bridgeDictVectorizer[${this.id}].vocabulary_`;
      return this._py`attr_DictVectorizer_vocabulary_.tolist() if hasattr(attr_DictVectorizer_vocabulary_, 'tolist') else attr_DictVectorizer_vocabulary_`;
    })();
  }
  /**
    A list of length n\_features containing the feature names (e.g., â€œf=hamâ€ and â€œf=spamâ€).
   */
  get feature_names_() {
    if (this._isDisposed) {
      throw new Error("This DictVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictVectorizer must call init() before accessing feature_names_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictVectorizer_feature_names_ = bridgeDictVectorizer[${this.id}].feature_names_`;
      return this._py`attr_DictVectorizer_feature_names_.tolist() if hasattr(attr_DictVectorizer_feature_names_, 'tolist') else attr_DictVectorizer_feature_names_`;
    })();
  }
};

// src/generated/feature_extraction/FeatureHasher.ts
import crypto76 from "node:crypto";
var FeatureHasher = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FeatureHasher${crypto76.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FeatureHasher.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction import FeatureHasher
try: bridgeFeatureHasher
except NameError: bridgeFeatureHasher = {}
`;
    await this._py.ex`ctor_FeatureHasher = {'n_features': ${this.opts["n_features"] ?? void 0}, 'input_type': ${this.opts["input_type"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'alternate_sign': ${this.opts["alternate_sign"] ?? void 0}}

ctor_FeatureHasher = {k: v for k, v in ctor_FeatureHasher.items() if v is not None}`;
    await this._py.ex`bridgeFeatureHasher[${this.id}] = FeatureHasher(**ctor_FeatureHasher)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFeatureHasher[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureHasher must call init() before fit()");
    }
    await this._py.ex`pms_FeatureHasher_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_FeatureHasher_fit = {k: v for k, v in pms_FeatureHasher_fit.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_fit = bridgeFeatureHasher[${this.id}].fit(**pms_FeatureHasher_fit)`;
    return this._py`res_FeatureHasher_fit.tolist() if hasattr(res_FeatureHasher_fit, 'tolist') else res_FeatureHasher_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureHasher must call init() before fit_transform()");
    }
    await this._py.ex`pms_FeatureHasher_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureHasher_fit_transform = {k: v for k, v in pms_FeatureHasher_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_fit_transform = bridgeFeatureHasher[${this.id}].fit_transform(**pms_FeatureHasher_fit_transform)`;
    return this._py`res_FeatureHasher_fit_transform.tolist() if hasattr(res_FeatureHasher_fit_transform, 'tolist') else res_FeatureHasher_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureHasher must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FeatureHasher_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FeatureHasher_get_metadata_routing = {k: v for k, v in pms_FeatureHasher_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_get_metadata_routing = bridgeFeatureHasher[${this.id}].get_metadata_routing(**pms_FeatureHasher_get_metadata_routing)`;
    return this._py`res_FeatureHasher_get_metadata_routing.tolist() if hasattr(res_FeatureHasher_get_metadata_routing, 'tolist') else res_FeatureHasher_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureHasher must call init() before set_output()");
    }
    await this._py.ex`pms_FeatureHasher_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FeatureHasher_set_output = {k: v for k, v in pms_FeatureHasher_set_output.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_set_output = bridgeFeatureHasher[${this.id}].set_output(**pms_FeatureHasher_set_output)`;
    return this._py`res_FeatureHasher_set_output.tolist() if hasattr(res_FeatureHasher_set_output, 'tolist') else res_FeatureHasher_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureHasher must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_FeatureHasher_set_transform_request = {'raw_X': ${opts["raw_X"] ?? void 0}}

pms_FeatureHasher_set_transform_request = {k: v for k, v in pms_FeatureHasher_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_set_transform_request = bridgeFeatureHasher[${this.id}].set_transform_request(**pms_FeatureHasher_set_transform_request)`;
    return this._py`res_FeatureHasher_set_transform_request.tolist() if hasattr(res_FeatureHasher_set_transform_request, 'tolist') else res_FeatureHasher_set_transform_request`;
  }
  /**
    Transform a sequence of instances to a scipy.sparse matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureHasher instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureHasher must call init() before transform()");
    }
    await this._py.ex`pms_FeatureHasher_transform = {'raw_X': ${opts["raw_X"] ?? void 0}}

pms_FeatureHasher_transform = {k: v for k, v in pms_FeatureHasher_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureHasher_transform = bridgeFeatureHasher[${this.id}].transform(**pms_FeatureHasher_transform)`;
    return this._py`res_FeatureHasher_transform.tolist() if hasattr(res_FeatureHasher_transform, 'tolist') else res_FeatureHasher_transform`;
  }
};

// src/generated/feature_extraction/image/PatchExtractor.ts
import crypto77 from "node:crypto";
var PatchExtractor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PatchExtractor${crypto77.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PatchExtractor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction.image import PatchExtractor
try: bridgePatchExtractor
except NameError: bridgePatchExtractor = {}
`;
    await this._py.ex`ctor_PatchExtractor = {'patch_size': ${this.opts["patch_size"] ?? void 0}, 'max_patches': ${this.opts["max_patches"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_PatchExtractor = {k: v for k, v in ctor_PatchExtractor.items() if v is not None}`;
    await this._py.ex`bridgePatchExtractor[${this.id}] = PatchExtractor(**ctor_PatchExtractor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePatchExtractor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validate the parameters of the estimator.
  
      This method allows to: (i) validate the parameters of the estimator and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PatchExtractor must call init() before fit()");
    }
    await this._py.ex`pms_PatchExtractor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PatchExtractor_fit = {k: v for k, v in pms_PatchExtractor_fit.items() if v is not None}`;
    await this._py.ex`res_PatchExtractor_fit = bridgePatchExtractor[${this.id}].fit(**pms_PatchExtractor_fit)`;
    return this._py`res_PatchExtractor_fit.tolist() if hasattr(res_PatchExtractor_fit, 'tolist') else res_PatchExtractor_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PatchExtractor must call init() before fit_transform()");
    }
    await this._py.ex`pms_PatchExtractor_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_PatchExtractor_fit_transform = {k: v for k, v in pms_PatchExtractor_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PatchExtractor_fit_transform = bridgePatchExtractor[${this.id}].fit_transform(**pms_PatchExtractor_fit_transform)`;
    return this._py`res_PatchExtractor_fit_transform.tolist() if hasattr(res_PatchExtractor_fit_transform, 'tolist') else res_PatchExtractor_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PatchExtractor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PatchExtractor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PatchExtractor_get_metadata_routing = {k: v for k, v in pms_PatchExtractor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PatchExtractor_get_metadata_routing = bridgePatchExtractor[${this.id}].get_metadata_routing(**pms_PatchExtractor_get_metadata_routing)`;
    return this._py`res_PatchExtractor_get_metadata_routing.tolist() if hasattr(res_PatchExtractor_get_metadata_routing, 'tolist') else res_PatchExtractor_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PatchExtractor must call init() before set_output()");
    }
    await this._py.ex`pms_PatchExtractor_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PatchExtractor_set_output = {k: v for k, v in pms_PatchExtractor_set_output.items() if v is not None}`;
    await this._py.ex`res_PatchExtractor_set_output = bridgePatchExtractor[${this.id}].set_output(**pms_PatchExtractor_set_output)`;
    return this._py`res_PatchExtractor_set_output.tolist() if hasattr(res_PatchExtractor_set_output, 'tolist') else res_PatchExtractor_set_output`;
  }
  /**
    Transform the image samples in `X` into a matrix of patch data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PatchExtractor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PatchExtractor must call init() before transform()");
    }
    await this._py.ex`pms_PatchExtractor_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PatchExtractor_transform = {k: v for k, v in pms_PatchExtractor_transform.items() if v is not None}`;
    await this._py.ex`res_PatchExtractor_transform = bridgePatchExtractor[${this.id}].transform(**pms_PatchExtractor_transform)`;
    return this._py`res_PatchExtractor_transform.tolist() if hasattr(res_PatchExtractor_transform, 'tolist') else res_PatchExtractor_transform`;
  }
};

// src/generated/feature_extraction/text/CountVectorizer.ts
import crypto78 from "node:crypto";
var CountVectorizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CountVectorizer${crypto78.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CountVectorizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer
try: bridgeCountVectorizer
except NameError: bridgeCountVectorizer = {}
`;
    await this._py.ex`ctor_CountVectorizer = {'input': ${this.opts["input"] ?? void 0}, 'encoding': ${this.opts["encoding"] ?? void 0}, 'decode_error': ${this.opts["decode_error"] ?? void 0}, 'strip_accents': ${this.opts["strip_accents"] ?? void 0}, 'lowercase': ${this.opts["lowercase"] ?? void 0}, 'preprocessor': ${this.opts["preprocessor"] ?? void 0}, 'tokenizer': ${this.opts["tokenizer"] ?? void 0}, 'stop_words': ${this.opts["stop_words"] ?? void 0}, 'token_pattern': ${this.opts["token_pattern"] ?? void 0}, 'ngram_range': ${this.opts["ngram_range"] ?? void 0}, 'analyzer': ${this.opts["analyzer"] ?? void 0}, 'max_df': ${this.opts["max_df"] ?? void 0}, 'min_df': ${this.opts["min_df"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'vocabulary': ${this.opts["vocabulary"] ?? void 0}, 'binary': ${this.opts["binary"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}}

ctor_CountVectorizer = {k: v for k, v in ctor_CountVectorizer.items() if v is not None}`;
    await this._py.ex`bridgeCountVectorizer[${this.id}] = CountVectorizer(**ctor_CountVectorizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCountVectorizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return a callable to process input data.
  
      The callable handles preprocessing, tokenization, and n-grams generation.
     */
  async build_analyzer(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before build_analyzer()"
      );
    }
    await this._py.ex`pms_CountVectorizer_build_analyzer = {}

pms_CountVectorizer_build_analyzer = {k: v for k, v in pms_CountVectorizer_build_analyzer.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_build_analyzer = bridgeCountVectorizer[${this.id}].build_analyzer(**pms_CountVectorizer_build_analyzer)`;
    return this._py`res_CountVectorizer_build_analyzer.tolist() if hasattr(res_CountVectorizer_build_analyzer, 'tolist') else res_CountVectorizer_build_analyzer`;
  }
  /**
    Return a function to preprocess the text before tokenization.
   */
  async build_preprocessor(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before build_preprocessor()"
      );
    }
    await this._py.ex`pms_CountVectorizer_build_preprocessor = {}

pms_CountVectorizer_build_preprocessor = {k: v for k, v in pms_CountVectorizer_build_preprocessor.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_build_preprocessor = bridgeCountVectorizer[${this.id}].build_preprocessor(**pms_CountVectorizer_build_preprocessor)`;
    return this._py`res_CountVectorizer_build_preprocessor.tolist() if hasattr(res_CountVectorizer_build_preprocessor, 'tolist') else res_CountVectorizer_build_preprocessor`;
  }
  /**
    Return a function that splits a string into a sequence of tokens.
   */
  async build_tokenizer(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before build_tokenizer()"
      );
    }
    await this._py.ex`pms_CountVectorizer_build_tokenizer = {}

pms_CountVectorizer_build_tokenizer = {k: v for k, v in pms_CountVectorizer_build_tokenizer.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_build_tokenizer = bridgeCountVectorizer[${this.id}].build_tokenizer(**pms_CountVectorizer_build_tokenizer)`;
    return this._py`res_CountVectorizer_build_tokenizer.tolist() if hasattr(res_CountVectorizer_build_tokenizer, 'tolist') else res_CountVectorizer_build_tokenizer`;
  }
  /**
      Decode the input into a string of unicode symbols.
  
      The decoding strategy depends on the vectorizer parameters.
     */
  async decode(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CountVectorizer must call init() before decode()");
    }
    await this._py.ex`pms_CountVectorizer_decode = {'doc': ${opts["doc"] ?? void 0}}

pms_CountVectorizer_decode = {k: v for k, v in pms_CountVectorizer_decode.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_decode = bridgeCountVectorizer[${this.id}].decode(**pms_CountVectorizer_decode)`;
    return this._py`res_CountVectorizer_decode.tolist() if hasattr(res_CountVectorizer_decode, 'tolist') else res_CountVectorizer_decode`;
  }
  /**
    Learn a vocabulary dictionary of all tokens in the raw documents.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CountVectorizer must call init() before fit()");
    }
    await this._py.ex`pms_CountVectorizer_fit = {'raw_documents': ${opts["raw_documents"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_CountVectorizer_fit = {k: v for k, v in pms_CountVectorizer_fit.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_fit = bridgeCountVectorizer[${this.id}].fit(**pms_CountVectorizer_fit)`;
    return this._py`res_CountVectorizer_fit.tolist() if hasattr(res_CountVectorizer_fit, 'tolist') else res_CountVectorizer_fit`;
  }
  /**
      Learn the vocabulary dictionary and return document-term matrix.
  
      This is equivalent to fit followed by transform, but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CountVectorizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_CountVectorizer_fit_transform = {'raw_documents': ${opts["raw_documents"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_CountVectorizer_fit_transform = {k: v for k, v in pms_CountVectorizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_fit_transform = bridgeCountVectorizer[${this.id}].fit_transform(**pms_CountVectorizer_fit_transform)`;
    return this._py`res_CountVectorizer_fit_transform.tolist() if hasattr(res_CountVectorizer_fit_transform, 'tolist') else res_CountVectorizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_CountVectorizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_CountVectorizer_get_feature_names_out = {k: v for k, v in pms_CountVectorizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_get_feature_names_out = bridgeCountVectorizer[${this.id}].get_feature_names_out(**pms_CountVectorizer_get_feature_names_out)`;
    return this._py`res_CountVectorizer_get_feature_names_out.tolist() if hasattr(res_CountVectorizer_get_feature_names_out, 'tolist') else res_CountVectorizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_CountVectorizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CountVectorizer_get_metadata_routing = {k: v for k, v in pms_CountVectorizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_get_metadata_routing = bridgeCountVectorizer[${this.id}].get_metadata_routing(**pms_CountVectorizer_get_metadata_routing)`;
    return this._py`res_CountVectorizer_get_metadata_routing.tolist() if hasattr(res_CountVectorizer_get_metadata_routing, 'tolist') else res_CountVectorizer_get_metadata_routing`;
  }
  /**
    Build or fetch the effective stop words list.
   */
  async get_stop_words(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before get_stop_words()"
      );
    }
    await this._py.ex`pms_CountVectorizer_get_stop_words = {}

pms_CountVectorizer_get_stop_words = {k: v for k, v in pms_CountVectorizer_get_stop_words.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_get_stop_words = bridgeCountVectorizer[${this.id}].get_stop_words(**pms_CountVectorizer_get_stop_words)`;
    return this._py`res_CountVectorizer_get_stop_words.tolist() if hasattr(res_CountVectorizer_get_stop_words, 'tolist') else res_CountVectorizer_get_stop_words`;
  }
  /**
    Return terms per document with nonzero entries in X.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_CountVectorizer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CountVectorizer_inverse_transform = {k: v for k, v in pms_CountVectorizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_inverse_transform = bridgeCountVectorizer[${this.id}].inverse_transform(**pms_CountVectorizer_inverse_transform)`;
    return this._py`res_CountVectorizer_inverse_transform.tolist() if hasattr(res_CountVectorizer_inverse_transform, 'tolist') else res_CountVectorizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_CountVectorizer_set_fit_request = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_CountVectorizer_set_fit_request = {k: v for k, v in pms_CountVectorizer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_set_fit_request = bridgeCountVectorizer[${this.id}].set_fit_request(**pms_CountVectorizer_set_fit_request)`;
    return this._py`res_CountVectorizer_set_fit_request.tolist() if hasattr(res_CountVectorizer_set_fit_request, 'tolist') else res_CountVectorizer_set_fit_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_CountVectorizer_set_transform_request = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_CountVectorizer_set_transform_request = {k: v for k, v in pms_CountVectorizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_set_transform_request = bridgeCountVectorizer[${this.id}].set_transform_request(**pms_CountVectorizer_set_transform_request)`;
    return this._py`res_CountVectorizer_set_transform_request.tolist() if hasattr(res_CountVectorizer_set_transform_request, 'tolist') else res_CountVectorizer_set_transform_request`;
  }
  /**
      Transform documents to document-term matrix.
  
      Extract token counts out of raw text documents using the vocabulary fitted with fit or the one provided to the constructor.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CountVectorizer must call init() before transform()");
    }
    await this._py.ex`pms_CountVectorizer_transform = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_CountVectorizer_transform = {k: v for k, v in pms_CountVectorizer_transform.items() if v is not None}`;
    await this._py.ex`res_CountVectorizer_transform = bridgeCountVectorizer[${this.id}].transform(**pms_CountVectorizer_transform)`;
    return this._py`res_CountVectorizer_transform.tolist() if hasattr(res_CountVectorizer_transform, 'tolist') else res_CountVectorizer_transform`;
  }
  /**
    A mapping of terms to feature indices.
   */
  get vocabulary_() {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before accessing vocabulary_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CountVectorizer_vocabulary_ = bridgeCountVectorizer[${this.id}].vocabulary_`;
      return this._py`attr_CountVectorizer_vocabulary_.tolist() if hasattr(attr_CountVectorizer_vocabulary_, 'tolist') else attr_CountVectorizer_vocabulary_`;
    })();
  }
  /**
    True if a fixed vocabulary of term to indices mapping is provided by the user.
   */
  get fixed_vocabulary_() {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before accessing fixed_vocabulary_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CountVectorizer_fixed_vocabulary_ = bridgeCountVectorizer[${this.id}].fixed_vocabulary_`;
      return this._py`attr_CountVectorizer_fixed_vocabulary_.tolist() if hasattr(attr_CountVectorizer_fixed_vocabulary_, 'tolist') else attr_CountVectorizer_fixed_vocabulary_`;
    })();
  }
  /**
    Terms that were ignored because they either:
   */
  get stop_words_() {
    if (this._isDisposed) {
      throw new Error("This CountVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CountVectorizer must call init() before accessing stop_words_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CountVectorizer_stop_words_ = bridgeCountVectorizer[${this.id}].stop_words_`;
      return this._py`attr_CountVectorizer_stop_words_.tolist() if hasattr(attr_CountVectorizer_stop_words_, 'tolist') else attr_CountVectorizer_stop_words_`;
    })();
  }
};

// src/generated/feature_extraction/text/HashingVectorizer.ts
import crypto79 from "node:crypto";
var HashingVectorizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HashingVectorizer${crypto79.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HashingVectorizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction.text import HashingVectorizer
try: bridgeHashingVectorizer
except NameError: bridgeHashingVectorizer = {}
`;
    await this._py.ex`ctor_HashingVectorizer = {'input': ${this.opts["input"] ?? void 0}, 'encoding': ${this.opts["encoding"] ?? void 0}, 'decode_error': ${this.opts["decode_error"] ?? void 0}, 'strip_accents': ${this.opts["strip_accents"] ?? void 0}, 'lowercase': ${this.opts["lowercase"] ?? void 0}, 'preprocessor': ${this.opts["preprocessor"] ?? void 0}, 'tokenizer': ${this.opts["tokenizer"] ?? void 0}, 'stop_words': ${this.opts["stop_words"] ?? void 0}, 'token_pattern': ${this.opts["token_pattern"] ?? void 0}, 'ngram_range': ${this.opts["ngram_range"] ?? void 0}, 'analyzer': ${this.opts["analyzer"] ?? void 0}, 'n_features': ${this.opts["n_features"] ?? void 0}, 'binary': ${this.opts["binary"] ?? void 0}, 'norm': ${this.opts["norm"] ?? void 0}, 'alternate_sign': ${this.opts["alternate_sign"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}}

ctor_HashingVectorizer = {k: v for k, v in ctor_HashingVectorizer.items() if v is not None}`;
    await this._py.ex`bridgeHashingVectorizer[${this.id}] = HashingVectorizer(**ctor_HashingVectorizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHashingVectorizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return a callable to process input data.
  
      The callable handles preprocessing, tokenization, and n-grams generation.
     */
  async build_analyzer(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before build_analyzer()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_build_analyzer = {}

pms_HashingVectorizer_build_analyzer = {k: v for k, v in pms_HashingVectorizer_build_analyzer.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_build_analyzer = bridgeHashingVectorizer[${this.id}].build_analyzer(**pms_HashingVectorizer_build_analyzer)`;
    return this._py`res_HashingVectorizer_build_analyzer.tolist() if hasattr(res_HashingVectorizer_build_analyzer, 'tolist') else res_HashingVectorizer_build_analyzer`;
  }
  /**
    Return a function to preprocess the text before tokenization.
   */
  async build_preprocessor(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before build_preprocessor()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_build_preprocessor = {}

pms_HashingVectorizer_build_preprocessor = {k: v for k, v in pms_HashingVectorizer_build_preprocessor.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_build_preprocessor = bridgeHashingVectorizer[${this.id}].build_preprocessor(**pms_HashingVectorizer_build_preprocessor)`;
    return this._py`res_HashingVectorizer_build_preprocessor.tolist() if hasattr(res_HashingVectorizer_build_preprocessor, 'tolist') else res_HashingVectorizer_build_preprocessor`;
  }
  /**
    Return a function that splits a string into a sequence of tokens.
   */
  async build_tokenizer(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before build_tokenizer()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_build_tokenizer = {}

pms_HashingVectorizer_build_tokenizer = {k: v for k, v in pms_HashingVectorizer_build_tokenizer.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_build_tokenizer = bridgeHashingVectorizer[${this.id}].build_tokenizer(**pms_HashingVectorizer_build_tokenizer)`;
    return this._py`res_HashingVectorizer_build_tokenizer.tolist() if hasattr(res_HashingVectorizer_build_tokenizer, 'tolist') else res_HashingVectorizer_build_tokenizer`;
  }
  /**
      Decode the input into a string of unicode symbols.
  
      The decoding strategy depends on the vectorizer parameters.
     */
  async decode(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HashingVectorizer must call init() before decode()");
    }
    await this._py.ex`pms_HashingVectorizer_decode = {'doc': ${opts["doc"] ?? void 0}}

pms_HashingVectorizer_decode = {k: v for k, v in pms_HashingVectorizer_decode.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_decode = bridgeHashingVectorizer[${this.id}].decode(**pms_HashingVectorizer_decode)`;
    return this._py`res_HashingVectorizer_decode.tolist() if hasattr(res_HashingVectorizer_decode, 'tolist') else res_HashingVectorizer_decode`;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HashingVectorizer must call init() before fit()");
    }
    await this._py.ex`pms_HashingVectorizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HashingVectorizer_fit = {k: v for k, v in pms_HashingVectorizer_fit.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_fit = bridgeHashingVectorizer[${this.id}].fit(**pms_HashingVectorizer_fit)`;
    return this._py`res_HashingVectorizer_fit.tolist() if hasattr(res_HashingVectorizer_fit, 'tolist') else res_HashingVectorizer_fit`;
  }
  /**
    Transform a sequence of documents to a document-term matrix.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_HashingVectorizer_fit_transform = {k: v for k, v in pms_HashingVectorizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_fit_transform = bridgeHashingVectorizer[${this.id}].fit_transform(**pms_HashingVectorizer_fit_transform)`;
    return this._py`res_HashingVectorizer_fit_transform.tolist() if hasattr(res_HashingVectorizer_fit_transform, 'tolist') else res_HashingVectorizer_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HashingVectorizer_get_metadata_routing = {k: v for k, v in pms_HashingVectorizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_get_metadata_routing = bridgeHashingVectorizer[${this.id}].get_metadata_routing(**pms_HashingVectorizer_get_metadata_routing)`;
    return this._py`res_HashingVectorizer_get_metadata_routing.tolist() if hasattr(res_HashingVectorizer_get_metadata_routing, 'tolist') else res_HashingVectorizer_get_metadata_routing`;
  }
  /**
    Build or fetch the effective stop words list.
   */
  async get_stop_words(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HashingVectorizer must call init() before get_stop_words()"
      );
    }
    await this._py.ex`pms_HashingVectorizer_get_stop_words = {}

pms_HashingVectorizer_get_stop_words = {k: v for k, v in pms_HashingVectorizer_get_stop_words.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_get_stop_words = bridgeHashingVectorizer[${this.id}].get_stop_words(**pms_HashingVectorizer_get_stop_words)`;
    return this._py`res_HashingVectorizer_get_stop_words.tolist() if hasattr(res_HashingVectorizer_get_stop_words, 'tolist') else res_HashingVectorizer_get_stop_words`;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HashingVectorizer must call init() before partial_fit()");
    }
    await this._py.ex`pms_HashingVectorizer_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HashingVectorizer_partial_fit = {k: v for k, v in pms_HashingVectorizer_partial_fit.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_partial_fit = bridgeHashingVectorizer[${this.id}].partial_fit(**pms_HashingVectorizer_partial_fit)`;
    return this._py`res_HashingVectorizer_partial_fit.tolist() if hasattr(res_HashingVectorizer_partial_fit, 'tolist') else res_HashingVectorizer_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HashingVectorizer must call init() before set_output()");
    }
    await this._py.ex`pms_HashingVectorizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_HashingVectorizer_set_output = {k: v for k, v in pms_HashingVectorizer_set_output.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_set_output = bridgeHashingVectorizer[${this.id}].set_output(**pms_HashingVectorizer_set_output)`;
    return this._py`res_HashingVectorizer_set_output.tolist() if hasattr(res_HashingVectorizer_set_output, 'tolist') else res_HashingVectorizer_set_output`;
  }
  /**
    Transform a sequence of documents to a document-term matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HashingVectorizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HashingVectorizer must call init() before transform()");
    }
    await this._py.ex`pms_HashingVectorizer_transform = {'X': ${opts["X"] ?? void 0}}

pms_HashingVectorizer_transform = {k: v for k, v in pms_HashingVectorizer_transform.items() if v is not None}`;
    await this._py.ex`res_HashingVectorizer_transform = bridgeHashingVectorizer[${this.id}].transform(**pms_HashingVectorizer_transform)`;
    return this._py`res_HashingVectorizer_transform.tolist() if hasattr(res_HashingVectorizer_transform, 'tolist') else res_HashingVectorizer_transform`;
  }
};

// src/generated/feature_extraction/text/TfidfTransformer.ts
import crypto80 from "node:crypto";
var TfidfTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TfidfTransformer${crypto80.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TfidfTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction.text import TfidfTransformer
try: bridgeTfidfTransformer
except NameError: bridgeTfidfTransformer = {}
`;
    await this._py.ex`ctor_TfidfTransformer = {'norm': ${this.opts["norm"] ?? void 0}, 'use_idf': ${this.opts["use_idf"] ?? void 0}, 'smooth_idf': ${this.opts["smooth_idf"] ?? void 0}, 'sublinear_tf': ${this.opts["sublinear_tf"] ?? void 0}}

ctor_TfidfTransformer = {k: v for k, v in ctor_TfidfTransformer.items() if v is not None}`;
    await this._py.ex`bridgeTfidfTransformer[${this.id}] = TfidfTransformer(**ctor_TfidfTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTfidfTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn the idf vector (global term weights).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TfidfTransformer must call init() before fit()");
    }
    await this._py.ex`pms_TfidfTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TfidfTransformer_fit = {k: v for k, v in pms_TfidfTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_fit = bridgeTfidfTransformer[${this.id}].fit(**pms_TfidfTransformer_fit)`;
    return this._py`res_TfidfTransformer_fit.tolist() if hasattr(res_TfidfTransformer_fit, 'tolist') else res_TfidfTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_TfidfTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_TfidfTransformer_fit_transform = {k: v for k, v in pms_TfidfTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_fit_transform = bridgeTfidfTransformer[${this.id}].fit_transform(**pms_TfidfTransformer_fit_transform)`;
    return this._py`res_TfidfTransformer_fit_transform.tolist() if hasattr(res_TfidfTransformer_fit_transform, 'tolist') else res_TfidfTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TfidfTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TfidfTransformer_get_feature_names_out = {k: v for k, v in pms_TfidfTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_get_feature_names_out = bridgeTfidfTransformer[${this.id}].get_feature_names_out(**pms_TfidfTransformer_get_feature_names_out)`;
    return this._py`res_TfidfTransformer_get_feature_names_out.tolist() if hasattr(res_TfidfTransformer_get_feature_names_out, 'tolist') else res_TfidfTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TfidfTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TfidfTransformer_get_metadata_routing = {k: v for k, v in pms_TfidfTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_get_metadata_routing = bridgeTfidfTransformer[${this.id}].get_metadata_routing(**pms_TfidfTransformer_get_metadata_routing)`;
    return this._py`res_TfidfTransformer_get_metadata_routing.tolist() if hasattr(res_TfidfTransformer_get_metadata_routing, 'tolist') else res_TfidfTransformer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TfidfTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_TfidfTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TfidfTransformer_set_output = {k: v for k, v in pms_TfidfTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_set_output = bridgeTfidfTransformer[${this.id}].set_output(**pms_TfidfTransformer_set_output)`;
    return this._py`res_TfidfTransformer_set_output.tolist() if hasattr(res_TfidfTransformer_set_output, 'tolist') else res_TfidfTransformer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_TfidfTransformer_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_TfidfTransformer_set_transform_request = {k: v for k, v in pms_TfidfTransformer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_set_transform_request = bridgeTfidfTransformer[${this.id}].set_transform_request(**pms_TfidfTransformer_set_transform_request)`;
    return this._py`res_TfidfTransformer_set_transform_request.tolist() if hasattr(res_TfidfTransformer_set_transform_request, 'tolist') else res_TfidfTransformer_set_transform_request`;
  }
  /**
    Transform a count matrix to a tf or tf-idf representation.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TfidfTransformer must call init() before transform()");
    }
    await this._py.ex`pms_TfidfTransformer_transform = {'X': ${opts["X"] ?? void 0}, 'copy': ${opts["copy"] ?? void 0}}

pms_TfidfTransformer_transform = {k: v for k, v in pms_TfidfTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_TfidfTransformer_transform = bridgeTfidfTransformer[${this.id}].transform(**pms_TfidfTransformer_transform)`;
    return this._py`res_TfidfTransformer_transform.tolist() if hasattr(res_TfidfTransformer_transform, 'tolist') else res_TfidfTransformer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TfidfTransformer_n_features_in_ = bridgeTfidfTransformer[${this.id}].n_features_in_`;
      return this._py`attr_TfidfTransformer_n_features_in_.tolist() if hasattr(attr_TfidfTransformer_n_features_in_, 'tolist') else attr_TfidfTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TfidfTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TfidfTransformer_feature_names_in_ = bridgeTfidfTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_TfidfTransformer_feature_names_in_.tolist() if hasattr(attr_TfidfTransformer_feature_names_in_, 'tolist') else attr_TfidfTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/feature_extraction/text/TfidfVectorizer.ts
import crypto81 from "node:crypto";
var TfidfVectorizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TfidfVectorizer${crypto81.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TfidfVectorizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
try: bridgeTfidfVectorizer
except NameError: bridgeTfidfVectorizer = {}
`;
    await this._py.ex`ctor_TfidfVectorizer = {'input': ${this.opts["input"] ?? void 0}, 'encoding': ${this.opts["encoding"] ?? void 0}, 'decode_error': ${this.opts["decode_error"] ?? void 0}, 'strip_accents': ${this.opts["strip_accents"] ?? void 0}, 'lowercase': ${this.opts["lowercase"] ?? void 0}, 'preprocessor': ${this.opts["preprocessor"] ?? void 0}, 'tokenizer': ${this.opts["tokenizer"] ?? void 0}, 'analyzer': ${this.opts["analyzer"] ?? void 0}, 'stop_words': ${this.opts["stop_words"] ?? void 0}, 'token_pattern': ${this.opts["token_pattern"] ?? void 0}, 'ngram_range': ${this.opts["ngram_range"] ?? void 0}, 'max_df': ${this.opts["max_df"] ?? void 0}, 'min_df': ${this.opts["min_df"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'vocabulary': ${this.opts["vocabulary"] ?? void 0}, 'binary': ${this.opts["binary"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'norm': ${this.opts["norm"] ?? void 0}, 'use_idf': ${this.opts["use_idf"] ?? void 0}, 'smooth_idf': ${this.opts["smooth_idf"] ?? void 0}, 'sublinear_tf': ${this.opts["sublinear_tf"] ?? void 0}}

ctor_TfidfVectorizer = {k: v for k, v in ctor_TfidfVectorizer.items() if v is not None}`;
    await this._py.ex`bridgeTfidfVectorizer[${this.id}] = TfidfVectorizer(**ctor_TfidfVectorizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTfidfVectorizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return a callable to process input data.
  
      The callable handles preprocessing, tokenization, and n-grams generation.
     */
  async build_analyzer(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before build_analyzer()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_build_analyzer = {}

pms_TfidfVectorizer_build_analyzer = {k: v for k, v in pms_TfidfVectorizer_build_analyzer.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_build_analyzer = bridgeTfidfVectorizer[${this.id}].build_analyzer(**pms_TfidfVectorizer_build_analyzer)`;
    return this._py`res_TfidfVectorizer_build_analyzer.tolist() if hasattr(res_TfidfVectorizer_build_analyzer, 'tolist') else res_TfidfVectorizer_build_analyzer`;
  }
  /**
    Return a function to preprocess the text before tokenization.
   */
  async build_preprocessor(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before build_preprocessor()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_build_preprocessor = {}

pms_TfidfVectorizer_build_preprocessor = {k: v for k, v in pms_TfidfVectorizer_build_preprocessor.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_build_preprocessor = bridgeTfidfVectorizer[${this.id}].build_preprocessor(**pms_TfidfVectorizer_build_preprocessor)`;
    return this._py`res_TfidfVectorizer_build_preprocessor.tolist() if hasattr(res_TfidfVectorizer_build_preprocessor, 'tolist') else res_TfidfVectorizer_build_preprocessor`;
  }
  /**
    Return a function that splits a string into a sequence of tokens.
   */
  async build_tokenizer(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before build_tokenizer()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_build_tokenizer = {}

pms_TfidfVectorizer_build_tokenizer = {k: v for k, v in pms_TfidfVectorizer_build_tokenizer.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_build_tokenizer = bridgeTfidfVectorizer[${this.id}].build_tokenizer(**pms_TfidfVectorizer_build_tokenizer)`;
    return this._py`res_TfidfVectorizer_build_tokenizer.tolist() if hasattr(res_TfidfVectorizer_build_tokenizer, 'tolist') else res_TfidfVectorizer_build_tokenizer`;
  }
  /**
      Decode the input into a string of unicode symbols.
  
      The decoding strategy depends on the vectorizer parameters.
     */
  async decode(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TfidfVectorizer must call init() before decode()");
    }
    await this._py.ex`pms_TfidfVectorizer_decode = {'doc': ${opts["doc"] ?? void 0}}

pms_TfidfVectorizer_decode = {k: v for k, v in pms_TfidfVectorizer_decode.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_decode = bridgeTfidfVectorizer[${this.id}].decode(**pms_TfidfVectorizer_decode)`;
    return this._py`res_TfidfVectorizer_decode.tolist() if hasattr(res_TfidfVectorizer_decode, 'tolist') else res_TfidfVectorizer_decode`;
  }
  /**
    Learn vocabulary and idf from training set.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TfidfVectorizer must call init() before fit()");
    }
    await this._py.ex`pms_TfidfVectorizer_fit = {'raw_documents': ${opts["raw_documents"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_TfidfVectorizer_fit = {k: v for k, v in pms_TfidfVectorizer_fit.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_fit = bridgeTfidfVectorizer[${this.id}].fit(**pms_TfidfVectorizer_fit)`;
    return this._py`res_TfidfVectorizer_fit.tolist() if hasattr(res_TfidfVectorizer_fit, 'tolist') else res_TfidfVectorizer_fit`;
  }
  /**
      Learn vocabulary and idf, return document-term matrix.
  
      This is equivalent to fit followed by transform, but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TfidfVectorizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_TfidfVectorizer_fit_transform = {'raw_documents': ${opts["raw_documents"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_TfidfVectorizer_fit_transform = {k: v for k, v in pms_TfidfVectorizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_fit_transform = bridgeTfidfVectorizer[${this.id}].fit_transform(**pms_TfidfVectorizer_fit_transform)`;
    return this._py`res_TfidfVectorizer_fit_transform.tolist() if hasattr(res_TfidfVectorizer_fit_transform, 'tolist') else res_TfidfVectorizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TfidfVectorizer_get_feature_names_out = {k: v for k, v in pms_TfidfVectorizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_get_feature_names_out = bridgeTfidfVectorizer[${this.id}].get_feature_names_out(**pms_TfidfVectorizer_get_feature_names_out)`;
    return this._py`res_TfidfVectorizer_get_feature_names_out.tolist() if hasattr(res_TfidfVectorizer_get_feature_names_out, 'tolist') else res_TfidfVectorizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TfidfVectorizer_get_metadata_routing = {k: v for k, v in pms_TfidfVectorizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_get_metadata_routing = bridgeTfidfVectorizer[${this.id}].get_metadata_routing(**pms_TfidfVectorizer_get_metadata_routing)`;
    return this._py`res_TfidfVectorizer_get_metadata_routing.tolist() if hasattr(res_TfidfVectorizer_get_metadata_routing, 'tolist') else res_TfidfVectorizer_get_metadata_routing`;
  }
  /**
    Build or fetch the effective stop words list.
   */
  async get_stop_words(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before get_stop_words()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_get_stop_words = {}

pms_TfidfVectorizer_get_stop_words = {k: v for k, v in pms_TfidfVectorizer_get_stop_words.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_get_stop_words = bridgeTfidfVectorizer[${this.id}].get_stop_words(**pms_TfidfVectorizer_get_stop_words)`;
    return this._py`res_TfidfVectorizer_get_stop_words.tolist() if hasattr(res_TfidfVectorizer_get_stop_words, 'tolist') else res_TfidfVectorizer_get_stop_words`;
  }
  /**
    Return terms per document with nonzero entries in X.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TfidfVectorizer_inverse_transform = {k: v for k, v in pms_TfidfVectorizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_inverse_transform = bridgeTfidfVectorizer[${this.id}].inverse_transform(**pms_TfidfVectorizer_inverse_transform)`;
    return this._py`res_TfidfVectorizer_inverse_transform.tolist() if hasattr(res_TfidfVectorizer_inverse_transform, 'tolist') else res_TfidfVectorizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_set_fit_request = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_TfidfVectorizer_set_fit_request = {k: v for k, v in pms_TfidfVectorizer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_set_fit_request = bridgeTfidfVectorizer[${this.id}].set_fit_request(**pms_TfidfVectorizer_set_fit_request)`;
    return this._py`res_TfidfVectorizer_set_fit_request.tolist() if hasattr(res_TfidfVectorizer_set_fit_request, 'tolist') else res_TfidfVectorizer_set_fit_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_TfidfVectorizer_set_transform_request = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_TfidfVectorizer_set_transform_request = {k: v for k, v in pms_TfidfVectorizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_set_transform_request = bridgeTfidfVectorizer[${this.id}].set_transform_request(**pms_TfidfVectorizer_set_transform_request)`;
    return this._py`res_TfidfVectorizer_set_transform_request.tolist() if hasattr(res_TfidfVectorizer_set_transform_request, 'tolist') else res_TfidfVectorizer_set_transform_request`;
  }
  /**
      Transform documents to document-term matrix.
  
      Uses the vocabulary and document frequencies (df) learned by fit (or fit\_transform).
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TfidfVectorizer must call init() before transform()");
    }
    await this._py.ex`pms_TfidfVectorizer_transform = {'raw_documents': ${opts["raw_documents"] ?? void 0}}

pms_TfidfVectorizer_transform = {k: v for k, v in pms_TfidfVectorizer_transform.items() if v is not None}`;
    await this._py.ex`res_TfidfVectorizer_transform = bridgeTfidfVectorizer[${this.id}].transform(**pms_TfidfVectorizer_transform)`;
    return this._py`res_TfidfVectorizer_transform.tolist() if hasattr(res_TfidfVectorizer_transform, 'tolist') else res_TfidfVectorizer_transform`;
  }
  /**
    A mapping of terms to feature indices.
   */
  get vocabulary_() {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before accessing vocabulary_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TfidfVectorizer_vocabulary_ = bridgeTfidfVectorizer[${this.id}].vocabulary_`;
      return this._py`attr_TfidfVectorizer_vocabulary_.tolist() if hasattr(attr_TfidfVectorizer_vocabulary_, 'tolist') else attr_TfidfVectorizer_vocabulary_`;
    })();
  }
  /**
    True if a fixed vocabulary of term to indices mapping is provided by the user.
   */
  get fixed_vocabulary_() {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before accessing fixed_vocabulary_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TfidfVectorizer_fixed_vocabulary_ = bridgeTfidfVectorizer[${this.id}].fixed_vocabulary_`;
      return this._py`attr_TfidfVectorizer_fixed_vocabulary_.tolist() if hasattr(attr_TfidfVectorizer_fixed_vocabulary_, 'tolist') else attr_TfidfVectorizer_fixed_vocabulary_`;
    })();
  }
  /**
    Terms that were ignored because they either:
   */
  get stop_words_() {
    if (this._isDisposed) {
      throw new Error("This TfidfVectorizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TfidfVectorizer must call init() before accessing stop_words_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TfidfVectorizer_stop_words_ = bridgeTfidfVectorizer[${this.id}].stop_words_`;
      return this._py`attr_TfidfVectorizer_stop_words_.tolist() if hasattr(attr_TfidfVectorizer_stop_words_, 'tolist') else attr_TfidfVectorizer_stop_words_`;
    })();
  }
};

// src/generated/feature_selection/GenericUnivariateSelect.ts
import crypto82 from "node:crypto";
var GenericUnivariateSelect = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GenericUnivariateSelect${crypto82.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GenericUnivariateSelect.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import GenericUnivariateSelect
try: bridgeGenericUnivariateSelect
except NameError: bridgeGenericUnivariateSelect = {}
`;
    await this._py.ex`ctor_GenericUnivariateSelect = {'score_func': ${this.opts["score_func"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'param': ${this.opts["param"] ?? void 0}}

ctor_GenericUnivariateSelect = {k: v for k, v in ctor_GenericUnivariateSelect.items() if v is not None}`;
    await this._py.ex`bridgeGenericUnivariateSelect[${this.id}] = GenericUnivariateSelect(**ctor_GenericUnivariateSelect)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGenericUnivariateSelect[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GenericUnivariateSelect must call init() before fit()");
    }
    await this._py.ex`pms_GenericUnivariateSelect_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GenericUnivariateSelect_fit = {k: v for k, v in pms_GenericUnivariateSelect_fit.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_fit = bridgeGenericUnivariateSelect[${this.id}].fit(**pms_GenericUnivariateSelect_fit)`;
    return this._py`res_GenericUnivariateSelect_fit.tolist() if hasattr(res_GenericUnivariateSelect_fit, 'tolist') else res_GenericUnivariateSelect_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_GenericUnivariateSelect_fit_transform = {k: v for k, v in pms_GenericUnivariateSelect_fit_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_fit_transform = bridgeGenericUnivariateSelect[${this.id}].fit_transform(**pms_GenericUnivariateSelect_fit_transform)`;
    return this._py`res_GenericUnivariateSelect_fit_transform.tolist() if hasattr(res_GenericUnivariateSelect_fit_transform, 'tolist') else res_GenericUnivariateSelect_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_GenericUnivariateSelect_get_feature_names_out = {k: v for k, v in pms_GenericUnivariateSelect_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_feature_names_out = bridgeGenericUnivariateSelect[${this.id}].get_feature_names_out(**pms_GenericUnivariateSelect_get_feature_names_out)`;
    return this._py`res_GenericUnivariateSelect_get_feature_names_out.tolist() if hasattr(res_GenericUnivariateSelect_get_feature_names_out, 'tolist') else res_GenericUnivariateSelect_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GenericUnivariateSelect_get_metadata_routing = {k: v for k, v in pms_GenericUnivariateSelect_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_metadata_routing = bridgeGenericUnivariateSelect[${this.id}].get_metadata_routing(**pms_GenericUnivariateSelect_get_metadata_routing)`;
    return this._py`res_GenericUnivariateSelect_get_metadata_routing.tolist() if hasattr(res_GenericUnivariateSelect_get_metadata_routing, 'tolist') else res_GenericUnivariateSelect_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before get_support()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_GenericUnivariateSelect_get_support = {k: v for k, v in pms_GenericUnivariateSelect_get_support.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_get_support = bridgeGenericUnivariateSelect[${this.id}].get_support(**pms_GenericUnivariateSelect_get_support)`;
    return this._py`res_GenericUnivariateSelect_get_support.tolist() if hasattr(res_GenericUnivariateSelect_get_support, 'tolist') else res_GenericUnivariateSelect_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GenericUnivariateSelect_inverse_transform = {k: v for k, v in pms_GenericUnivariateSelect_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_inverse_transform = bridgeGenericUnivariateSelect[${this.id}].inverse_transform(**pms_GenericUnivariateSelect_inverse_transform)`;
    return this._py`res_GenericUnivariateSelect_inverse_transform.tolist() if hasattr(res_GenericUnivariateSelect_inverse_transform, 'tolist') else res_GenericUnivariateSelect_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before set_output()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_GenericUnivariateSelect_set_output = {k: v for k, v in pms_GenericUnivariateSelect_set_output.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_set_output = bridgeGenericUnivariateSelect[${this.id}].set_output(**pms_GenericUnivariateSelect_set_output)`;
    return this._py`res_GenericUnivariateSelect_set_output.tolist() if hasattr(res_GenericUnivariateSelect_set_output, 'tolist') else res_GenericUnivariateSelect_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before transform()"
      );
    }
    await this._py.ex`pms_GenericUnivariateSelect_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GenericUnivariateSelect_transform = {k: v for k, v in pms_GenericUnivariateSelect_transform.items() if v is not None}`;
    await this._py.ex`res_GenericUnivariateSelect_transform = bridgeGenericUnivariateSelect[${this.id}].transform(**pms_GenericUnivariateSelect_transform)`;
    return this._py`res_GenericUnivariateSelect_transform.tolist() if hasattr(res_GenericUnivariateSelect_transform, 'tolist') else res_GenericUnivariateSelect_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_scores_ = bridgeGenericUnivariateSelect[${this.id}].scores_`;
      return this._py`attr_GenericUnivariateSelect_scores_.tolist() if hasattr(attr_GenericUnivariateSelect_scores_, 'tolist') else attr_GenericUnivariateSelect_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned scores only.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing pvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_pvalues_ = bridgeGenericUnivariateSelect[${this.id}].pvalues_`;
      return this._py`attr_GenericUnivariateSelect_pvalues_.tolist() if hasattr(attr_GenericUnivariateSelect_pvalues_, 'tolist') else attr_GenericUnivariateSelect_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_n_features_in_ = bridgeGenericUnivariateSelect[${this.id}].n_features_in_`;
      return this._py`attr_GenericUnivariateSelect_n_features_in_.tolist() if hasattr(attr_GenericUnivariateSelect_n_features_in_, 'tolist') else attr_GenericUnivariateSelect_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GenericUnivariateSelect instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GenericUnivariateSelect must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GenericUnivariateSelect_feature_names_in_ = bridgeGenericUnivariateSelect[${this.id}].feature_names_in_`;
      return this._py`attr_GenericUnivariateSelect_feature_names_in_.tolist() if hasattr(attr_GenericUnivariateSelect_feature_names_in_, 'tolist') else attr_GenericUnivariateSelect_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/RFE.ts
import crypto83 from "node:crypto";
var RFE = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RFE${crypto83.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RFE.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import RFE
try: bridgeRFE
except NameError: bridgeRFE = {}
`;
    await this._py.ex`ctor_RFE = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_features_to_select': ${this.opts["n_features_to_select"] ?? void 0}, 'step': ${this.opts["step"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_RFE = {k: v for k, v in ctor_RFE.items() if v is not None}`;
    await this._py.ex`bridgeRFE[${this.id}] = RFE(**ctor_RFE)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRFE[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before decision_function()");
    }
    await this._py.ex`pms_RFE_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_decision_function = {k: v for k, v in pms_RFE_decision_function.items() if v is not None}`;
    await this._py.ex`res_RFE_decision_function = bridgeRFE[${this.id}].decision_function(**pms_RFE_decision_function)`;
    return this._py`res_RFE_decision_function.tolist() if hasattr(res_RFE_decision_function, 'tolist') else res_RFE_decision_function`;
  }
  /**
    Fit the RFE model and then the underlying estimator on the selected features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before fit()");
    }
    await this._py.ex`pms_RFE_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_fit = {k: v for k, v in pms_RFE_fit.items() if v is not None}`;
    await this._py.ex`res_RFE_fit = bridgeRFE[${this.id}].fit(**pms_RFE_fit)`;
    return this._py`res_RFE_fit.tolist() if hasattr(res_RFE_fit, 'tolist') else res_RFE_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before fit_transform()");
    }
    await this._py.ex`pms_RFE_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_fit_transform = {k: v for k, v in pms_RFE_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_fit_transform = bridgeRFE[${this.id}].fit_transform(**pms_RFE_fit_transform)`;
    return this._py`res_RFE_fit_transform.tolist() if hasattr(res_RFE_fit_transform, 'tolist') else res_RFE_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_RFE_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RFE_get_feature_names_out = {k: v for k, v in pms_RFE_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RFE_get_feature_names_out = bridgeRFE[${this.id}].get_feature_names_out(**pms_RFE_get_feature_names_out)`;
    return this._py`res_RFE_get_feature_names_out.tolist() if hasattr(res_RFE_get_feature_names_out, 'tolist') else res_RFE_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RFE_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RFE_get_metadata_routing = {k: v for k, v in pms_RFE_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RFE_get_metadata_routing = bridgeRFE[${this.id}].get_metadata_routing(**pms_RFE_get_metadata_routing)`;
    return this._py`res_RFE_get_metadata_routing.tolist() if hasattr(res_RFE_get_metadata_routing, 'tolist') else res_RFE_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before get_support()");
    }
    await this._py.ex`pms_RFE_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_RFE_get_support = {k: v for k, v in pms_RFE_get_support.items() if v is not None}`;
    await this._py.ex`res_RFE_get_support = bridgeRFE[${this.id}].get_support(**pms_RFE_get_support)`;
    return this._py`res_RFE_get_support.tolist() if hasattr(res_RFE_get_support, 'tolist') else res_RFE_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before inverse_transform()");
    }
    await this._py.ex`pms_RFE_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_inverse_transform = {k: v for k, v in pms_RFE_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_inverse_transform = bridgeRFE[${this.id}].inverse_transform(**pms_RFE_inverse_transform)`;
    return this._py`res_RFE_inverse_transform.tolist() if hasattr(res_RFE_inverse_transform, 'tolist') else res_RFE_inverse_transform`;
  }
  /**
    Reduce X to the selected features and predict using the estimator.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict()");
    }
    await this._py.ex`pms_RFE_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict = {k: v for k, v in pms_RFE_predict.items() if v is not None}`;
    await this._py.ex`res_RFE_predict = bridgeRFE[${this.id}].predict(**pms_RFE_predict)`;
    return this._py`res_RFE_predict.tolist() if hasattr(res_RFE_predict, 'tolist') else res_RFE_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_RFE_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict_log_proba = {k: v for k, v in pms_RFE_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RFE_predict_log_proba = bridgeRFE[${this.id}].predict_log_proba(**pms_RFE_predict_log_proba)`;
    return this._py`res_RFE_predict_log_proba.tolist() if hasattr(res_RFE_predict_log_proba, 'tolist') else res_RFE_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before predict_proba()");
    }
    await this._py.ex`pms_RFE_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_predict_proba = {k: v for k, v in pms_RFE_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RFE_predict_proba = bridgeRFE[${this.id}].predict_proba(**pms_RFE_predict_proba)`;
    return this._py`res_RFE_predict_proba.tolist() if hasattr(res_RFE_predict_proba, 'tolist') else res_RFE_predict_proba`;
  }
  /**
    Reduce X to the selected features and return the score of the estimator.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before score()");
    }
    await this._py.ex`pms_RFE_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFE_score = {k: v for k, v in pms_RFE_score.items() if v is not None}`;
    await this._py.ex`res_RFE_score = bridgeRFE[${this.id}].score(**pms_RFE_score)`;
    return this._py`res_RFE_score.tolist() if hasattr(res_RFE_score, 'tolist') else res_RFE_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before set_output()");
    }
    await this._py.ex`pms_RFE_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RFE_set_output = {k: v for k, v in pms_RFE_set_output.items() if v is not None}`;
    await this._py.ex`res_RFE_set_output = bridgeRFE[${this.id}].set_output(**pms_RFE_set_output)`;
    return this._py`res_RFE_set_output.tolist() if hasattr(res_RFE_set_output, 'tolist') else res_RFE_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before transform()");
    }
    await this._py.ex`pms_RFE_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFE_transform = {k: v for k, v in pms_RFE_transform.items() if v is not None}`;
    await this._py.ex`res_RFE_transform = bridgeRFE[${this.id}].transform(**pms_RFE_transform)`;
    return this._py`res_RFE_transform.tolist() if hasattr(res_RFE_transform, 'tolist') else res_RFE_transform`;
  }
  /**
    The fitted estimator used to select features.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing estimator_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_estimator_ = bridgeRFE[${this.id}].estimator_`;
      return this._py`attr_RFE_estimator_.tolist() if hasattr(attr_RFE_estimator_, 'tolist') else attr_RFE_estimator_`;
    })();
  }
  /**
    The number of selected features.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_n_features_ = bridgeRFE[${this.id}].n_features_`;
      return this._py`attr_RFE_n_features_.tolist() if hasattr(attr_RFE_n_features_, 'tolist') else attr_RFE_n_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_n_features_in_ = bridgeRFE[${this.id}].n_features_in_`;
      return this._py`attr_RFE_n_features_in_.tolist() if hasattr(attr_RFE_n_features_in_, 'tolist') else attr_RFE_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_feature_names_in_ = bridgeRFE[${this.id}].feature_names_in_`;
      return this._py`attr_RFE_feature_names_in_.tolist() if hasattr(attr_RFE_feature_names_in_, 'tolist') else attr_RFE_feature_names_in_`;
    })();
  }
  /**
    The feature ranking, such that `ranking\_\[i\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.
   */
  get ranking_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing ranking_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_ranking_ = bridgeRFE[${this.id}].ranking_`;
      return this._py`attr_RFE_ranking_.tolist() if hasattr(attr_RFE_ranking_, 'tolist') else attr_RFE_ranking_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This RFE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFE must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_RFE_support_ = bridgeRFE[${this.id}].support_`;
      return this._py`attr_RFE_support_.tolist() if hasattr(attr_RFE_support_, 'tolist') else attr_RFE_support_`;
    })();
  }
};

// src/generated/feature_selection/RFECV.ts
import crypto84 from "node:crypto";
var RFECV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RFECV${crypto84.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RFECV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import RFECV
try: bridgeRFECV
except NameError: bridgeRFECV = {}
`;
    await this._py.ex`ctor_RFECV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'step': ${this.opts["step"] ?? void 0}, 'min_features_to_select': ${this.opts["min_features_to_select"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_RFECV = {k: v for k, v in ctor_RFECV.items() if v is not None}`;
    await this._py.ex`bridgeRFECV[${this.id}] = RFECV(**ctor_RFECV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRFECV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before decision_function()");
    }
    await this._py.ex`pms_RFECV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_decision_function = {k: v for k, v in pms_RFECV_decision_function.items() if v is not None}`;
    await this._py.ex`res_RFECV_decision_function = bridgeRFECV[${this.id}].decision_function(**pms_RFECV_decision_function)`;
    return this._py`res_RFECV_decision_function.tolist() if hasattr(res_RFECV_decision_function, 'tolist') else res_RFECV_decision_function`;
  }
  /**
    Fit the RFE model and automatically tune the number of selected features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before fit()");
    }
    await this._py.ex`pms_RFECV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RFECV_fit = {k: v for k, v in pms_RFECV_fit.items() if v is not None}`;
    await this._py.ex`res_RFECV_fit = bridgeRFECV[${this.id}].fit(**pms_RFECV_fit)`;
    return this._py`res_RFECV_fit.tolist() if hasattr(res_RFECV_fit, 'tolist') else res_RFECV_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before fit_transform()");
    }
    await this._py.ex`pms_RFECV_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFECV_fit_transform = {k: v for k, v in pms_RFECV_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_fit_transform = bridgeRFECV[${this.id}].fit_transform(**pms_RFECV_fit_transform)`;
    return this._py`res_RFECV_fit_transform.tolist() if hasattr(res_RFECV_fit_transform, 'tolist') else res_RFECV_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_RFECV_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RFECV_get_feature_names_out = {k: v for k, v in pms_RFECV_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_feature_names_out = bridgeRFECV[${this.id}].get_feature_names_out(**pms_RFECV_get_feature_names_out)`;
    return this._py`res_RFECV_get_feature_names_out.tolist() if hasattr(res_RFECV_get_feature_names_out, 'tolist') else res_RFECV_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RFECV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RFECV_get_metadata_routing = {k: v for k, v in pms_RFECV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_metadata_routing = bridgeRFECV[${this.id}].get_metadata_routing(**pms_RFECV_get_metadata_routing)`;
    return this._py`res_RFECV_get_metadata_routing.tolist() if hasattr(res_RFECV_get_metadata_routing, 'tolist') else res_RFECV_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before get_support()");
    }
    await this._py.ex`pms_RFECV_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_RFECV_get_support = {k: v for k, v in pms_RFECV_get_support.items() if v is not None}`;
    await this._py.ex`res_RFECV_get_support = bridgeRFECV[${this.id}].get_support(**pms_RFECV_get_support)`;
    return this._py`res_RFECV_get_support.tolist() if hasattr(res_RFECV_get_support, 'tolist') else res_RFECV_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before inverse_transform()");
    }
    await this._py.ex`pms_RFECV_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_inverse_transform = {k: v for k, v in pms_RFECV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_inverse_transform = bridgeRFECV[${this.id}].inverse_transform(**pms_RFECV_inverse_transform)`;
    return this._py`res_RFECV_inverse_transform.tolist() if hasattr(res_RFECV_inverse_transform, 'tolist') else res_RFECV_inverse_transform`;
  }
  /**
    Reduce X to the selected features and predict using the estimator.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict()");
    }
    await this._py.ex`pms_RFECV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict = {k: v for k, v in pms_RFECV_predict.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict = bridgeRFECV[${this.id}].predict(**pms_RFECV_predict)`;
    return this._py`res_RFECV_predict.tolist() if hasattr(res_RFECV_predict, 'tolist') else res_RFECV_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_RFECV_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict_log_proba = {k: v for k, v in pms_RFECV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict_log_proba = bridgeRFECV[${this.id}].predict_log_proba(**pms_RFECV_predict_log_proba)`;
    return this._py`res_RFECV_predict_log_proba.tolist() if hasattr(res_RFECV_predict_log_proba, 'tolist') else res_RFECV_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before predict_proba()");
    }
    await this._py.ex`pms_RFECV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_predict_proba = {k: v for k, v in pms_RFECV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RFECV_predict_proba = bridgeRFECV[${this.id}].predict_proba(**pms_RFECV_predict_proba)`;
    return this._py`res_RFECV_predict_proba.tolist() if hasattr(res_RFECV_predict_proba, 'tolist') else res_RFECV_predict_proba`;
  }
  /**
    Reduce X to the selected features and return the score of the estimator.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before score()");
    }
    await this._py.ex`pms_RFECV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RFECV_score = {k: v for k, v in pms_RFECV_score.items() if v is not None}`;
    await this._py.ex`res_RFECV_score = bridgeRFECV[${this.id}].score(**pms_RFECV_score)`;
    return this._py`res_RFECV_score.tolist() if hasattr(res_RFECV_score, 'tolist') else res_RFECV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_RFECV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_RFECV_set_fit_request = {k: v for k, v in pms_RFECV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RFECV_set_fit_request = bridgeRFECV[${this.id}].set_fit_request(**pms_RFECV_set_fit_request)`;
    return this._py`res_RFECV_set_fit_request.tolist() if hasattr(res_RFECV_set_fit_request, 'tolist') else res_RFECV_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before set_output()");
    }
    await this._py.ex`pms_RFECV_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RFECV_set_output = {k: v for k, v in pms_RFECV_set_output.items() if v is not None}`;
    await this._py.ex`res_RFECV_set_output = bridgeRFECV[${this.id}].set_output(**pms_RFECV_set_output)`;
    return this._py`res_RFECV_set_output.tolist() if hasattr(res_RFECV_set_output, 'tolist') else res_RFECV_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before transform()");
    }
    await this._py.ex`pms_RFECV_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RFECV_transform = {k: v for k, v in pms_RFECV_transform.items() if v is not None}`;
    await this._py.ex`res_RFECV_transform = bridgeRFECV[${this.id}].transform(**pms_RFECV_transform)`;
    return this._py`res_RFECV_transform.tolist() if hasattr(res_RFECV_transform, 'tolist') else res_RFECV_transform`;
  }
  /**
    The fitted estimator used to select features.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing estimator_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_estimator_ = bridgeRFECV[${this.id}].estimator_`;
      return this._py`attr_RFECV_estimator_.tolist() if hasattr(attr_RFECV_estimator_, 'tolist') else attr_RFECV_estimator_`;
    })();
  }
  /**
    A dict with keys:
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing cv_results_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_cv_results_ = bridgeRFECV[${this.id}].cv_results_`;
      return this._py`attr_RFECV_cv_results_.tolist() if hasattr(attr_RFECV_cv_results_, 'tolist') else attr_RFECV_cv_results_`;
    })();
  }
  /**
    The number of selected features with cross-validation.
   */
  get n_features_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing n_features_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_n_features_ = bridgeRFECV[${this.id}].n_features_`;
      return this._py`attr_RFECV_n_features_.tolist() if hasattr(attr_RFECV_n_features_, 'tolist') else attr_RFECV_n_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_n_features_in_ = bridgeRFECV[${this.id}].n_features_in_`;
      return this._py`attr_RFECV_n_features_in_.tolist() if hasattr(attr_RFECV_n_features_in_, 'tolist') else attr_RFECV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RFECV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RFECV_feature_names_in_ = bridgeRFECV[${this.id}].feature_names_in_`;
      return this._py`attr_RFECV_feature_names_in_.tolist() if hasattr(attr_RFECV_feature_names_in_, 'tolist') else attr_RFECV_feature_names_in_`;
    })();
  }
  /**
    The feature ranking, such that `ranking\_\[i\]` corresponds to the ranking position of the i-th feature. Selected (i.e., estimated best) features are assigned rank 1.
   */
  get ranking_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing ranking_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_ranking_ = bridgeRFECV[${this.id}].ranking_`;
      return this._py`attr_RFECV_ranking_.tolist() if hasattr(attr_RFECV_ranking_, 'tolist') else attr_RFECV_ranking_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This RFECV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RFECV must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_RFECV_support_ = bridgeRFECV[${this.id}].support_`;
      return this._py`attr_RFECV_support_.tolist() if hasattr(attr_RFECV_support_, 'tolist') else attr_RFECV_support_`;
    })();
  }
};

// src/generated/feature_selection/SelectFdr.ts
import crypto85 from "node:crypto";
var SelectFdr = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFdr${crypto85.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFdr.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFdr
try: bridgeSelectFdr
except NameError: bridgeSelectFdr = {}
`;
    await this._py.ex`ctor_SelectFdr = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFdr = {k: v for k, v in ctor_SelectFdr.items() if v is not None}`;
    await this._py.ex`bridgeSelectFdr[${this.id}] = SelectFdr(**ctor_SelectFdr)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFdr[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before fit()");
    }
    await this._py.ex`pms_SelectFdr_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFdr_fit = {k: v for k, v in pms_SelectFdr_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_fit = bridgeSelectFdr[${this.id}].fit(**pms_SelectFdr_fit)`;
    return this._py`res_SelectFdr_fit.tolist() if hasattr(res_SelectFdr_fit, 'tolist') else res_SelectFdr_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFdr_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFdr_fit_transform = {k: v for k, v in pms_SelectFdr_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_fit_transform = bridgeSelectFdr[${this.id}].fit_transform(**pms_SelectFdr_fit_transform)`;
    return this._py`res_SelectFdr_fit_transform.tolist() if hasattr(res_SelectFdr_fit_transform, 'tolist') else res_SelectFdr_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFdr_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFdr_get_feature_names_out = {k: v for k, v in pms_SelectFdr_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_feature_names_out = bridgeSelectFdr[${this.id}].get_feature_names_out(**pms_SelectFdr_get_feature_names_out)`;
    return this._py`res_SelectFdr_get_feature_names_out.tolist() if hasattr(res_SelectFdr_get_feature_names_out, 'tolist') else res_SelectFdr_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFdr_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFdr_get_metadata_routing = {k: v for k, v in pms_SelectFdr_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_metadata_routing = bridgeSelectFdr[${this.id}].get_metadata_routing(**pms_SelectFdr_get_metadata_routing)`;
    return this._py`res_SelectFdr_get_metadata_routing.tolist() if hasattr(res_SelectFdr_get_metadata_routing, 'tolist') else res_SelectFdr_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFdr_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFdr_get_support = {k: v for k, v in pms_SelectFdr_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_get_support = bridgeSelectFdr[${this.id}].get_support(**pms_SelectFdr_get_support)`;
    return this._py`res_SelectFdr_get_support.tolist() if hasattr(res_SelectFdr_get_support, 'tolist') else res_SelectFdr_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFdr_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFdr_inverse_transform = {k: v for k, v in pms_SelectFdr_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_inverse_transform = bridgeSelectFdr[${this.id}].inverse_transform(**pms_SelectFdr_inverse_transform)`;
    return this._py`res_SelectFdr_inverse_transform.tolist() if hasattr(res_SelectFdr_inverse_transform, 'tolist') else res_SelectFdr_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFdr_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFdr_set_output = {k: v for k, v in pms_SelectFdr_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_set_output = bridgeSelectFdr[${this.id}].set_output(**pms_SelectFdr_set_output)`;
    return this._py`res_SelectFdr_set_output.tolist() if hasattr(res_SelectFdr_set_output, 'tolist') else res_SelectFdr_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before transform()");
    }
    await this._py.ex`pms_SelectFdr_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFdr_transform = {k: v for k, v in pms_SelectFdr_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFdr_transform = bridgeSelectFdr[${this.id}].transform(**pms_SelectFdr_transform)`;
    return this._py`res_SelectFdr_transform.tolist() if hasattr(res_SelectFdr_transform, 'tolist') else res_SelectFdr_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_scores_ = bridgeSelectFdr[${this.id}].scores_`;
      return this._py`attr_SelectFdr_scores_.tolist() if hasattr(attr_SelectFdr_scores_, 'tolist') else attr_SelectFdr_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFdr must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_pvalues_ = bridgeSelectFdr[${this.id}].pvalues_`;
      return this._py`attr_SelectFdr_pvalues_.tolist() if hasattr(attr_SelectFdr_pvalues_, 'tolist') else attr_SelectFdr_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_n_features_in_ = bridgeSelectFdr[${this.id}].n_features_in_`;
      return this._py`attr_SelectFdr_n_features_in_.tolist() if hasattr(attr_SelectFdr_n_features_in_, 'tolist') else attr_SelectFdr_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFdr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFdr must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFdr_feature_names_in_ = bridgeSelectFdr[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFdr_feature_names_in_.tolist() if hasattr(attr_SelectFdr_feature_names_in_, 'tolist') else attr_SelectFdr_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFpr.ts
import crypto86 from "node:crypto";
var SelectFpr = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFpr${crypto86.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFpr.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFpr
try: bridgeSelectFpr
except NameError: bridgeSelectFpr = {}
`;
    await this._py.ex`ctor_SelectFpr = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFpr = {k: v for k, v in ctor_SelectFpr.items() if v is not None}`;
    await this._py.ex`bridgeSelectFpr[${this.id}] = SelectFpr(**ctor_SelectFpr)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFpr[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before fit()");
    }
    await this._py.ex`pms_SelectFpr_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFpr_fit = {k: v for k, v in pms_SelectFpr_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_fit = bridgeSelectFpr[${this.id}].fit(**pms_SelectFpr_fit)`;
    return this._py`res_SelectFpr_fit.tolist() if hasattr(res_SelectFpr_fit, 'tolist') else res_SelectFpr_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFpr_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFpr_fit_transform = {k: v for k, v in pms_SelectFpr_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_fit_transform = bridgeSelectFpr[${this.id}].fit_transform(**pms_SelectFpr_fit_transform)`;
    return this._py`res_SelectFpr_fit_transform.tolist() if hasattr(res_SelectFpr_fit_transform, 'tolist') else res_SelectFpr_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFpr_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFpr_get_feature_names_out = {k: v for k, v in pms_SelectFpr_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_feature_names_out = bridgeSelectFpr[${this.id}].get_feature_names_out(**pms_SelectFpr_get_feature_names_out)`;
    return this._py`res_SelectFpr_get_feature_names_out.tolist() if hasattr(res_SelectFpr_get_feature_names_out, 'tolist') else res_SelectFpr_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFpr_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFpr_get_metadata_routing = {k: v for k, v in pms_SelectFpr_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_metadata_routing = bridgeSelectFpr[${this.id}].get_metadata_routing(**pms_SelectFpr_get_metadata_routing)`;
    return this._py`res_SelectFpr_get_metadata_routing.tolist() if hasattr(res_SelectFpr_get_metadata_routing, 'tolist') else res_SelectFpr_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFpr_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFpr_get_support = {k: v for k, v in pms_SelectFpr_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_get_support = bridgeSelectFpr[${this.id}].get_support(**pms_SelectFpr_get_support)`;
    return this._py`res_SelectFpr_get_support.tolist() if hasattr(res_SelectFpr_get_support, 'tolist') else res_SelectFpr_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFpr_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFpr_inverse_transform = {k: v for k, v in pms_SelectFpr_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_inverse_transform = bridgeSelectFpr[${this.id}].inverse_transform(**pms_SelectFpr_inverse_transform)`;
    return this._py`res_SelectFpr_inverse_transform.tolist() if hasattr(res_SelectFpr_inverse_transform, 'tolist') else res_SelectFpr_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFpr_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFpr_set_output = {k: v for k, v in pms_SelectFpr_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_set_output = bridgeSelectFpr[${this.id}].set_output(**pms_SelectFpr_set_output)`;
    return this._py`res_SelectFpr_set_output.tolist() if hasattr(res_SelectFpr_set_output, 'tolist') else res_SelectFpr_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before transform()");
    }
    await this._py.ex`pms_SelectFpr_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFpr_transform = {k: v for k, v in pms_SelectFpr_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFpr_transform = bridgeSelectFpr[${this.id}].transform(**pms_SelectFpr_transform)`;
    return this._py`res_SelectFpr_transform.tolist() if hasattr(res_SelectFpr_transform, 'tolist') else res_SelectFpr_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_scores_ = bridgeSelectFpr[${this.id}].scores_`;
      return this._py`attr_SelectFpr_scores_.tolist() if hasattr(attr_SelectFpr_scores_, 'tolist') else attr_SelectFpr_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFpr must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_pvalues_ = bridgeSelectFpr[${this.id}].pvalues_`;
      return this._py`attr_SelectFpr_pvalues_.tolist() if hasattr(attr_SelectFpr_pvalues_, 'tolist') else attr_SelectFpr_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_n_features_in_ = bridgeSelectFpr[${this.id}].n_features_in_`;
      return this._py`attr_SelectFpr_n_features_in_.tolist() if hasattr(attr_SelectFpr_n_features_in_, 'tolist') else attr_SelectFpr_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFpr instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFpr must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFpr_feature_names_in_ = bridgeSelectFpr[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFpr_feature_names_in_.tolist() if hasattr(attr_SelectFpr_feature_names_in_, 'tolist') else attr_SelectFpr_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFromModel.ts
import crypto87 from "node:crypto";
var SelectFromModel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFromModel${crypto87.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFromModel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFromModel
try: bridgeSelectFromModel
except NameError: bridgeSelectFromModel = {}
`;
    await this._py.ex`ctor_SelectFromModel = {'estimator': ${this.opts["estimator"] ?? void 0}, 'threshold': ${this.opts["threshold"] ?? void 0}, 'prefit': ${this.opts["prefit"] ?? void 0}, 'norm_order': ${this.opts["norm_order"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'importance_getter': ${this.opts["importance_getter"] ?? void 0}}

ctor_SelectFromModel = {k: v for k, v in ctor_SelectFromModel.items() if v is not None}`;
    await this._py.ex`bridgeSelectFromModel[${this.id}] = SelectFromModel(**ctor_SelectFromModel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFromModel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SelectFromModel meta-transformer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before fit()");
    }
    await this._py.ex`pms_SelectFromModel_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_fit = {k: v for k, v in pms_SelectFromModel_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_fit = bridgeSelectFromModel[${this.id}].fit(**pms_SelectFromModel_fit)`;
    return this._py`res_SelectFromModel_fit.tolist() if hasattr(res_SelectFromModel_fit, 'tolist') else res_SelectFromModel_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFromModel_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_fit_transform = {k: v for k, v in pms_SelectFromModel_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_fit_transform = bridgeSelectFromModel[${this.id}].fit_transform(**pms_SelectFromModel_fit_transform)`;
    return this._py`res_SelectFromModel_fit_transform.tolist() if hasattr(res_SelectFromModel_fit_transform, 'tolist') else res_SelectFromModel_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFromModel_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFromModel_get_feature_names_out = {k: v for k, v in pms_SelectFromModel_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_feature_names_out = bridgeSelectFromModel[${this.id}].get_feature_names_out(**pms_SelectFromModel_get_feature_names_out)`;
    return this._py`res_SelectFromModel_get_feature_names_out.tolist() if hasattr(res_SelectFromModel_get_feature_names_out, 'tolist') else res_SelectFromModel_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFromModel_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFromModel_get_metadata_routing = {k: v for k, v in pms_SelectFromModel_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_metadata_routing = bridgeSelectFromModel[${this.id}].get_metadata_routing(**pms_SelectFromModel_get_metadata_routing)`;
    return this._py`res_SelectFromModel_get_metadata_routing.tolist() if hasattr(res_SelectFromModel_get_metadata_routing, 'tolist') else res_SelectFromModel_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFromModel_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFromModel_get_support = {k: v for k, v in pms_SelectFromModel_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_get_support = bridgeSelectFromModel[${this.id}].get_support(**pms_SelectFromModel_get_support)`;
    return this._py`res_SelectFromModel_get_support.tolist() if hasattr(res_SelectFromModel_get_support, 'tolist') else res_SelectFromModel_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectFromModel_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFromModel_inverse_transform = {k: v for k, v in pms_SelectFromModel_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_inverse_transform = bridgeSelectFromModel[${this.id}].inverse_transform(**pms_SelectFromModel_inverse_transform)`;
    return this._py`res_SelectFromModel_inverse_transform.tolist() if hasattr(res_SelectFromModel_inverse_transform, 'tolist') else res_SelectFromModel_inverse_transform`;
  }
  /**
    Fit the SelectFromModel meta-transformer only once.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before partial_fit()");
    }
    await this._py.ex`pms_SelectFromModel_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFromModel_partial_fit = {k: v for k, v in pms_SelectFromModel_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_partial_fit = bridgeSelectFromModel[${this.id}].partial_fit(**pms_SelectFromModel_partial_fit)`;
    return this._py`res_SelectFromModel_partial_fit.tolist() if hasattr(res_SelectFromModel_partial_fit, 'tolist') else res_SelectFromModel_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFromModel_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFromModel_set_output = {k: v for k, v in pms_SelectFromModel_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_set_output = bridgeSelectFromModel[${this.id}].set_output(**pms_SelectFromModel_set_output)`;
    return this._py`res_SelectFromModel_set_output.tolist() if hasattr(res_SelectFromModel_set_output, 'tolist') else res_SelectFromModel_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFromModel must call init() before transform()");
    }
    await this._py.ex`pms_SelectFromModel_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFromModel_transform = {k: v for k, v in pms_SelectFromModel_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFromModel_transform = bridgeSelectFromModel[${this.id}].transform(**pms_SelectFromModel_transform)`;
    return this._py`res_SelectFromModel_transform.tolist() if hasattr(res_SelectFromModel_transform, 'tolist') else res_SelectFromModel_transform`;
  }
  /**
    The base estimator from which the transformer is built. This attribute exist only when `fit` has been called.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_estimator_ = bridgeSelectFromModel[${this.id}].estimator_`;
      return this._py`attr_SelectFromModel_estimator_.tolist() if hasattr(attr_SelectFromModel_estimator_, 'tolist') else attr_SelectFromModel_estimator_`;
    })();
  }
  /**
    Maximum number of features calculated during [fit](../../glossary.html#term-fit). Only defined if the `max\_features` is not `undefined`.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_max_features_ = bridgeSelectFromModel[${this.id}].max_features_`;
      return this._py`attr_SelectFromModel_max_features_.tolist() if hasattr(attr_SelectFromModel_max_features_, 'tolist') else attr_SelectFromModel_max_features_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFromModel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFromModel must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFromModel_feature_names_in_ = bridgeSelectFromModel[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFromModel_feature_names_in_.tolist() if hasattr(attr_SelectFromModel_feature_names_in_, 'tolist') else attr_SelectFromModel_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectFwe.ts
import crypto88 from "node:crypto";
var SelectFwe = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectFwe${crypto88.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectFwe.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectFwe
try: bridgeSelectFwe
except NameError: bridgeSelectFwe = {}
`;
    await this._py.ex`ctor_SelectFwe = {'score_func': ${this.opts["score_func"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}}

ctor_SelectFwe = {k: v for k, v in ctor_SelectFwe.items() if v is not None}`;
    await this._py.ex`bridgeSelectFwe[${this.id}] = SelectFwe(**ctor_SelectFwe)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectFwe[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before fit()");
    }
    await this._py.ex`pms_SelectFwe_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectFwe_fit = {k: v for k, v in pms_SelectFwe_fit.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_fit = bridgeSelectFwe[${this.id}].fit(**pms_SelectFwe_fit)`;
    return this._py`res_SelectFwe_fit.tolist() if hasattr(res_SelectFwe_fit, 'tolist') else res_SelectFwe_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectFwe_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectFwe_fit_transform = {k: v for k, v in pms_SelectFwe_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_fit_transform = bridgeSelectFwe[${this.id}].fit_transform(**pms_SelectFwe_fit_transform)`;
    return this._py`res_SelectFwe_fit_transform.tolist() if hasattr(res_SelectFwe_fit_transform, 'tolist') else res_SelectFwe_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectFwe_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectFwe_get_feature_names_out = {k: v for k, v in pms_SelectFwe_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_feature_names_out = bridgeSelectFwe[${this.id}].get_feature_names_out(**pms_SelectFwe_get_feature_names_out)`;
    return this._py`res_SelectFwe_get_feature_names_out.tolist() if hasattr(res_SelectFwe_get_feature_names_out, 'tolist') else res_SelectFwe_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectFwe_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectFwe_get_metadata_routing = {k: v for k, v in pms_SelectFwe_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_metadata_routing = bridgeSelectFwe[${this.id}].get_metadata_routing(**pms_SelectFwe_get_metadata_routing)`;
    return this._py`res_SelectFwe_get_metadata_routing.tolist() if hasattr(res_SelectFwe_get_metadata_routing, 'tolist') else res_SelectFwe_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before get_support()");
    }
    await this._py.ex`pms_SelectFwe_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectFwe_get_support = {k: v for k, v in pms_SelectFwe_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_get_support = bridgeSelectFwe[${this.id}].get_support(**pms_SelectFwe_get_support)`;
    return this._py`res_SelectFwe_get_support.tolist() if hasattr(res_SelectFwe_get_support, 'tolist') else res_SelectFwe_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectFwe_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFwe_inverse_transform = {k: v for k, v in pms_SelectFwe_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_inverse_transform = bridgeSelectFwe[${this.id}].inverse_transform(**pms_SelectFwe_inverse_transform)`;
    return this._py`res_SelectFwe_inverse_transform.tolist() if hasattr(res_SelectFwe_inverse_transform, 'tolist') else res_SelectFwe_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before set_output()");
    }
    await this._py.ex`pms_SelectFwe_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectFwe_set_output = {k: v for k, v in pms_SelectFwe_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_set_output = bridgeSelectFwe[${this.id}].set_output(**pms_SelectFwe_set_output)`;
    return this._py`res_SelectFwe_set_output.tolist() if hasattr(res_SelectFwe_set_output, 'tolist') else res_SelectFwe_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before transform()");
    }
    await this._py.ex`pms_SelectFwe_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectFwe_transform = {k: v for k, v in pms_SelectFwe_transform.items() if v is not None}`;
    await this._py.ex`res_SelectFwe_transform = bridgeSelectFwe[${this.id}].transform(**pms_SelectFwe_transform)`;
    return this._py`res_SelectFwe_transform.tolist() if hasattr(res_SelectFwe_transform, 'tolist') else res_SelectFwe_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_scores_ = bridgeSelectFwe[${this.id}].scores_`;
      return this._py`attr_SelectFwe_scores_.tolist() if hasattr(attr_SelectFwe_scores_, 'tolist') else attr_SelectFwe_scores_`;
    })();
  }
  /**
    p-values of feature scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectFwe must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_pvalues_ = bridgeSelectFwe[${this.id}].pvalues_`;
      return this._py`attr_SelectFwe_pvalues_.tolist() if hasattr(attr_SelectFwe_pvalues_, 'tolist') else attr_SelectFwe_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_n_features_in_ = bridgeSelectFwe[${this.id}].n_features_in_`;
      return this._py`attr_SelectFwe_n_features_in_.tolist() if hasattr(attr_SelectFwe_n_features_in_, 'tolist') else attr_SelectFwe_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectFwe instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectFwe must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectFwe_feature_names_in_ = bridgeSelectFwe[${this.id}].feature_names_in_`;
      return this._py`attr_SelectFwe_feature_names_in_.tolist() if hasattr(attr_SelectFwe_feature_names_in_, 'tolist') else attr_SelectFwe_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectKBest.ts
import crypto89 from "node:crypto";
var SelectKBest = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectKBest${crypto89.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectKBest.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectKBest
try: bridgeSelectKBest
except NameError: bridgeSelectKBest = {}
`;
    await this._py.ex`ctor_SelectKBest = {'score_func': ${this.opts["score_func"] ?? void 0}, 'k': ${this.opts["k"] ?? void 0}}

ctor_SelectKBest = {k: v for k, v in ctor_SelectKBest.items() if v is not None}`;
    await this._py.ex`bridgeSelectKBest[${this.id}] = SelectKBest(**ctor_SelectKBest)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectKBest[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before fit()");
    }
    await this._py.ex`pms_SelectKBest_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectKBest_fit = {k: v for k, v in pms_SelectKBest_fit.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_fit = bridgeSelectKBest[${this.id}].fit(**pms_SelectKBest_fit)`;
    return this._py`res_SelectKBest_fit.tolist() if hasattr(res_SelectKBest_fit, 'tolist') else res_SelectKBest_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectKBest_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectKBest_fit_transform = {k: v for k, v in pms_SelectKBest_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_fit_transform = bridgeSelectKBest[${this.id}].fit_transform(**pms_SelectKBest_fit_transform)`;
    return this._py`res_SelectKBest_fit_transform.tolist() if hasattr(res_SelectKBest_fit_transform, 'tolist') else res_SelectKBest_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectKBest_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectKBest_get_feature_names_out = {k: v for k, v in pms_SelectKBest_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_feature_names_out = bridgeSelectKBest[${this.id}].get_feature_names_out(**pms_SelectKBest_get_feature_names_out)`;
    return this._py`res_SelectKBest_get_feature_names_out.tolist() if hasattr(res_SelectKBest_get_feature_names_out, 'tolist') else res_SelectKBest_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectKBest_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectKBest_get_metadata_routing = {k: v for k, v in pms_SelectKBest_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_metadata_routing = bridgeSelectKBest[${this.id}].get_metadata_routing(**pms_SelectKBest_get_metadata_routing)`;
    return this._py`res_SelectKBest_get_metadata_routing.tolist() if hasattr(res_SelectKBest_get_metadata_routing, 'tolist') else res_SelectKBest_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before get_support()");
    }
    await this._py.ex`pms_SelectKBest_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectKBest_get_support = {k: v for k, v in pms_SelectKBest_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_get_support = bridgeSelectKBest[${this.id}].get_support(**pms_SelectKBest_get_support)`;
    return this._py`res_SelectKBest_get_support.tolist() if hasattr(res_SelectKBest_get_support, 'tolist') else res_SelectKBest_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SelectKBest_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectKBest_inverse_transform = {k: v for k, v in pms_SelectKBest_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_inverse_transform = bridgeSelectKBest[${this.id}].inverse_transform(**pms_SelectKBest_inverse_transform)`;
    return this._py`res_SelectKBest_inverse_transform.tolist() if hasattr(res_SelectKBest_inverse_transform, 'tolist') else res_SelectKBest_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before set_output()");
    }
    await this._py.ex`pms_SelectKBest_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectKBest_set_output = {k: v for k, v in pms_SelectKBest_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_set_output = bridgeSelectKBest[${this.id}].set_output(**pms_SelectKBest_set_output)`;
    return this._py`res_SelectKBest_set_output.tolist() if hasattr(res_SelectKBest_set_output, 'tolist') else res_SelectKBest_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before transform()");
    }
    await this._py.ex`pms_SelectKBest_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectKBest_transform = {k: v for k, v in pms_SelectKBest_transform.items() if v is not None}`;
    await this._py.ex`res_SelectKBest_transform = bridgeSelectKBest[${this.id}].transform(**pms_SelectKBest_transform)`;
    return this._py`res_SelectKBest_transform.tolist() if hasattr(res_SelectKBest_transform, 'tolist') else res_SelectKBest_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_scores_ = bridgeSelectKBest[${this.id}].scores_`;
      return this._py`attr_SelectKBest_scores_.tolist() if hasattr(attr_SelectKBest_scores_, 'tolist') else attr_SelectKBest_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned only scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectKBest must call init() before accessing pvalues_");
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_pvalues_ = bridgeSelectKBest[${this.id}].pvalues_`;
      return this._py`attr_SelectKBest_pvalues_.tolist() if hasattr(attr_SelectKBest_pvalues_, 'tolist') else attr_SelectKBest_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_n_features_in_ = bridgeSelectKBest[${this.id}].n_features_in_`;
      return this._py`attr_SelectKBest_n_features_in_.tolist() if hasattr(attr_SelectKBest_n_features_in_, 'tolist') else attr_SelectKBest_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SelectKBest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectKBest must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectKBest_feature_names_in_ = bridgeSelectKBest[${this.id}].feature_names_in_`;
      return this._py`attr_SelectKBest_feature_names_in_.tolist() if hasattr(attr_SelectKBest_feature_names_in_, 'tolist') else attr_SelectKBest_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SelectorMixin.ts
import crypto90 from "node:crypto";
var SelectorMixin = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectorMixin${crypto90.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectorMixin.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectorMixin
try: bridgeSelectorMixin
except NameError: bridgeSelectorMixin = {}
`;
    await this._py.ex`ctor_SelectorMixin = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'y': np.array(${this.opts["y"] ?? void 0}) if ${this.opts["y"] !== void 0} else None, 'fit_params': ${this.opts["fit_params"] ?? void 0}}

ctor_SelectorMixin = {k: v for k, v in ctor_SelectorMixin.items() if v is not None}`;
    await this._py.ex`bridgeSelectorMixin[${this.id}] = SelectorMixin(**ctor_SelectorMixin)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectorMixin[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before fit_transform()");
    }
    await this._py.ex`pms_SelectorMixin_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectorMixin_fit_transform = {k: v for k, v in pms_SelectorMixin_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_fit_transform = bridgeSelectorMixin[${this.id}].fit_transform(**pms_SelectorMixin_fit_transform)`;
    return this._py`res_SelectorMixin_fit_transform.tolist() if hasattr(res_SelectorMixin_fit_transform, 'tolist') else res_SelectorMixin_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectorMixin must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectorMixin_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectorMixin_get_feature_names_out = {k: v for k, v in pms_SelectorMixin_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_get_feature_names_out = bridgeSelectorMixin[${this.id}].get_feature_names_out(**pms_SelectorMixin_get_feature_names_out)`;
    return this._py`res_SelectorMixin_get_feature_names_out.tolist() if hasattr(res_SelectorMixin_get_feature_names_out, 'tolist') else res_SelectorMixin_get_feature_names_out`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before get_support()");
    }
    await this._py.ex`pms_SelectorMixin_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectorMixin_get_support = {k: v for k, v in pms_SelectorMixin_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_get_support = bridgeSelectorMixin[${this.id}].get_support(**pms_SelectorMixin_get_support)`;
    return this._py`res_SelectorMixin_get_support.tolist() if hasattr(res_SelectorMixin_get_support, 'tolist') else res_SelectorMixin_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectorMixin must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectorMixin_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectorMixin_inverse_transform = {k: v for k, v in pms_SelectorMixin_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_inverse_transform = bridgeSelectorMixin[${this.id}].inverse_transform(**pms_SelectorMixin_inverse_transform)`;
    return this._py`res_SelectorMixin_inverse_transform.tolist() if hasattr(res_SelectorMixin_inverse_transform, 'tolist') else res_SelectorMixin_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before set_output()");
    }
    await this._py.ex`pms_SelectorMixin_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectorMixin_set_output = {k: v for k, v in pms_SelectorMixin_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_set_output = bridgeSelectorMixin[${this.id}].set_output(**pms_SelectorMixin_set_output)`;
    return this._py`res_SelectorMixin_set_output.tolist() if hasattr(res_SelectorMixin_set_output, 'tolist') else res_SelectorMixin_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before transform()");
    }
    await this._py.ex`pms_SelectorMixin_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectorMixin_transform = {k: v for k, v in pms_SelectorMixin_transform.items() if v is not None}`;
    await this._py.ex`res_SelectorMixin_transform = bridgeSelectorMixin[${this.id}].transform(**pms_SelectorMixin_transform)`;
    return this._py`res_SelectorMixin_transform.tolist() if hasattr(res_SelectorMixin_transform, 'tolist') else res_SelectorMixin_transform`;
  }
  /**
    Transformed array.
   */
  get X_new() {
    if (this._isDisposed) {
      throw new Error("This SelectorMixin instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SelectorMixin must call init() before accessing X_new");
    }
    return (async () => {
      await this._py.ex`attr_SelectorMixin_X_new = bridgeSelectorMixin[${this.id}].X_new`;
      return this._py`attr_SelectorMixin_X_new.tolist() if hasattr(attr_SelectorMixin_X_new, 'tolist') else attr_SelectorMixin_X_new`;
    })();
  }
};

// src/generated/feature_selection/SelectPercentile.ts
import crypto91 from "node:crypto";
var SelectPercentile = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelectPercentile${crypto91.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SelectPercentile.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SelectPercentile
try: bridgeSelectPercentile
except NameError: bridgeSelectPercentile = {}
`;
    await this._py.ex`ctor_SelectPercentile = {'score_func': ${this.opts["score_func"] ?? void 0}, 'percentile': ${this.opts["percentile"] ?? void 0}}

ctor_SelectPercentile = {k: v for k, v in ctor_SelectPercentile.items() if v is not None}`;
    await this._py.ex`bridgeSelectPercentile[${this.id}] = SelectPercentile(**ctor_SelectPercentile)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelectPercentile[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Run score function on (X, y) and get the appropriate features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before fit()");
    }
    await this._py.ex`pms_SelectPercentile_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelectPercentile_fit = {k: v for k, v in pms_SelectPercentile_fit.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_fit = bridgeSelectPercentile[${this.id}].fit(**pms_SelectPercentile_fit)`;
    return this._py`res_SelectPercentile_fit.tolist() if hasattr(res_SelectPercentile_fit, 'tolist') else res_SelectPercentile_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SelectPercentile_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SelectPercentile_fit_transform = {k: v for k, v in pms_SelectPercentile_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_fit_transform = bridgeSelectPercentile[${this.id}].fit_transform(**pms_SelectPercentile_fit_transform)`;
    return this._py`res_SelectPercentile_fit_transform.tolist() if hasattr(res_SelectPercentile_fit_transform, 'tolist') else res_SelectPercentile_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SelectPercentile_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SelectPercentile_get_feature_names_out = {k: v for k, v in pms_SelectPercentile_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_feature_names_out = bridgeSelectPercentile[${this.id}].get_feature_names_out(**pms_SelectPercentile_get_feature_names_out)`;
    return this._py`res_SelectPercentile_get_feature_names_out.tolist() if hasattr(res_SelectPercentile_get_feature_names_out, 'tolist') else res_SelectPercentile_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelectPercentile_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelectPercentile_get_metadata_routing = {k: v for k, v in pms_SelectPercentile_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_metadata_routing = bridgeSelectPercentile[${this.id}].get_metadata_routing(**pms_SelectPercentile_get_metadata_routing)`;
    return this._py`res_SelectPercentile_get_metadata_routing.tolist() if hasattr(res_SelectPercentile_get_metadata_routing, 'tolist') else res_SelectPercentile_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before get_support()");
    }
    await this._py.ex`pms_SelectPercentile_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SelectPercentile_get_support = {k: v for k, v in pms_SelectPercentile_get_support.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_get_support = bridgeSelectPercentile[${this.id}].get_support(**pms_SelectPercentile_get_support)`;
    return this._py`res_SelectPercentile_get_support.tolist() if hasattr(res_SelectPercentile_get_support, 'tolist') else res_SelectPercentile_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SelectPercentile_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectPercentile_inverse_transform = {k: v for k, v in pms_SelectPercentile_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_inverse_transform = bridgeSelectPercentile[${this.id}].inverse_transform(**pms_SelectPercentile_inverse_transform)`;
    return this._py`res_SelectPercentile_inverse_transform.tolist() if hasattr(res_SelectPercentile_inverse_transform, 'tolist') else res_SelectPercentile_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before set_output()");
    }
    await this._py.ex`pms_SelectPercentile_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SelectPercentile_set_output = {k: v for k, v in pms_SelectPercentile_set_output.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_set_output = bridgeSelectPercentile[${this.id}].set_output(**pms_SelectPercentile_set_output)`;
    return this._py`res_SelectPercentile_set_output.tolist() if hasattr(res_SelectPercentile_set_output, 'tolist') else res_SelectPercentile_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelectPercentile must call init() before transform()");
    }
    await this._py.ex`pms_SelectPercentile_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelectPercentile_transform = {k: v for k, v in pms_SelectPercentile_transform.items() if v is not None}`;
    await this._py.ex`res_SelectPercentile_transform = bridgeSelectPercentile[${this.id}].transform(**pms_SelectPercentile_transform)`;
    return this._py`res_SelectPercentile_transform.tolist() if hasattr(res_SelectPercentile_transform, 'tolist') else res_SelectPercentile_transform`;
  }
  /**
    Scores of features.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_scores_ = bridgeSelectPercentile[${this.id}].scores_`;
      return this._py`attr_SelectPercentile_scores_.tolist() if hasattr(attr_SelectPercentile_scores_, 'tolist') else attr_SelectPercentile_scores_`;
    })();
  }
  /**
    p-values of feature scores, `undefined` if `score\_func` returned only scores.
   */
  get pvalues_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing pvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_pvalues_ = bridgeSelectPercentile[${this.id}].pvalues_`;
      return this._py`attr_SelectPercentile_pvalues_.tolist() if hasattr(attr_SelectPercentile_pvalues_, 'tolist') else attr_SelectPercentile_pvalues_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_n_features_in_ = bridgeSelectPercentile[${this.id}].n_features_in_`;
      return this._py`attr_SelectPercentile_n_features_in_.tolist() if hasattr(attr_SelectPercentile_n_features_in_, 'tolist') else attr_SelectPercentile_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelectPercentile instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelectPercentile must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelectPercentile_feature_names_in_ = bridgeSelectPercentile[${this.id}].feature_names_in_`;
      return this._py`attr_SelectPercentile_feature_names_in_.tolist() if hasattr(attr_SelectPercentile_feature_names_in_, 'tolist') else attr_SelectPercentile_feature_names_in_`;
    })();
  }
};

// src/generated/feature_selection/SequentialFeatureSelector.ts
import crypto92 from "node:crypto";
var SequentialFeatureSelector = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SequentialFeatureSelector${crypto92.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SequentialFeatureSelector.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import SequentialFeatureSelector
try: bridgeSequentialFeatureSelector
except NameError: bridgeSequentialFeatureSelector = {}
`;
    await this._py.ex`ctor_SequentialFeatureSelector = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_features_to_select': ${this.opts["n_features_to_select"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'direction': ${this.opts["direction"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_SequentialFeatureSelector = {k: v for k, v in ctor_SequentialFeatureSelector.items() if v is not None}`;
    await this._py.ex`bridgeSequentialFeatureSelector[${this.id}] = SequentialFeatureSelector(**ctor_SequentialFeatureSelector)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSequentialFeatureSelector[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn the features to select from X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SequentialFeatureSelector must call init() before fit()");
    }
    await this._py.ex`pms_SequentialFeatureSelector_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SequentialFeatureSelector_fit = {k: v for k, v in pms_SequentialFeatureSelector_fit.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_fit = bridgeSequentialFeatureSelector[${this.id}].fit(**pms_SequentialFeatureSelector_fit)`;
    return this._py`res_SequentialFeatureSelector_fit.tolist() if hasattr(res_SequentialFeatureSelector_fit, 'tolist') else res_SequentialFeatureSelector_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SequentialFeatureSelector_fit_transform = {k: v for k, v in pms_SequentialFeatureSelector_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_fit_transform = bridgeSequentialFeatureSelector[${this.id}].fit_transform(**pms_SequentialFeatureSelector_fit_transform)`;
    return this._py`res_SequentialFeatureSelector_fit_transform.tolist() if hasattr(res_SequentialFeatureSelector_fit_transform, 'tolist') else res_SequentialFeatureSelector_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SequentialFeatureSelector_get_feature_names_out = {k: v for k, v in pms_SequentialFeatureSelector_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_feature_names_out = bridgeSequentialFeatureSelector[${this.id}].get_feature_names_out(**pms_SequentialFeatureSelector_get_feature_names_out)`;
    return this._py`res_SequentialFeatureSelector_get_feature_names_out.tolist() if hasattr(res_SequentialFeatureSelector_get_feature_names_out, 'tolist') else res_SequentialFeatureSelector_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SequentialFeatureSelector_get_metadata_routing = {k: v for k, v in pms_SequentialFeatureSelector_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_metadata_routing = bridgeSequentialFeatureSelector[${this.id}].get_metadata_routing(**pms_SequentialFeatureSelector_get_metadata_routing)`;
    return this._py`res_SequentialFeatureSelector_get_metadata_routing.tolist() if hasattr(res_SequentialFeatureSelector_get_metadata_routing, 'tolist') else res_SequentialFeatureSelector_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before get_support()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_SequentialFeatureSelector_get_support = {k: v for k, v in pms_SequentialFeatureSelector_get_support.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_get_support = bridgeSequentialFeatureSelector[${this.id}].get_support(**pms_SequentialFeatureSelector_get_support)`;
    return this._py`res_SequentialFeatureSelector_get_support.tolist() if hasattr(res_SequentialFeatureSelector_get_support, 'tolist') else res_SequentialFeatureSelector_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SequentialFeatureSelector_inverse_transform = {k: v for k, v in pms_SequentialFeatureSelector_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_inverse_transform = bridgeSequentialFeatureSelector[${this.id}].inverse_transform(**pms_SequentialFeatureSelector_inverse_transform)`;
    return this._py`res_SequentialFeatureSelector_inverse_transform.tolist() if hasattr(res_SequentialFeatureSelector_inverse_transform, 'tolist') else res_SequentialFeatureSelector_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before set_output()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SequentialFeatureSelector_set_output = {k: v for k, v in pms_SequentialFeatureSelector_set_output.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_set_output = bridgeSequentialFeatureSelector[${this.id}].set_output(**pms_SequentialFeatureSelector_set_output)`;
    return this._py`res_SequentialFeatureSelector_set_output.tolist() if hasattr(res_SequentialFeatureSelector_set_output, 'tolist') else res_SequentialFeatureSelector_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before transform()"
      );
    }
    await this._py.ex`pms_SequentialFeatureSelector_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SequentialFeatureSelector_transform = {k: v for k, v in pms_SequentialFeatureSelector_transform.items() if v is not None}`;
    await this._py.ex`res_SequentialFeatureSelector_transform = bridgeSequentialFeatureSelector[${this.id}].transform(**pms_SequentialFeatureSelector_transform)`;
    return this._py`res_SequentialFeatureSelector_transform.tolist() if hasattr(res_SequentialFeatureSelector_transform, 'tolist') else res_SequentialFeatureSelector_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_n_features_in_ = bridgeSequentialFeatureSelector[${this.id}].n_features_in_`;
      return this._py`attr_SequentialFeatureSelector_n_features_in_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_in_, 'tolist') else attr_SequentialFeatureSelector_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_feature_names_in_ = bridgeSequentialFeatureSelector[${this.id}].feature_names_in_`;
      return this._py`attr_SequentialFeatureSelector_feature_names_in_.tolist() if hasattr(attr_SequentialFeatureSelector_feature_names_in_, 'tolist') else attr_SequentialFeatureSelector_feature_names_in_`;
    })();
  }
  /**
    The number of features that were selected.
   */
  get n_features_to_select_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing n_features_to_select_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_n_features_to_select_ = bridgeSequentialFeatureSelector[${this.id}].n_features_to_select_`;
      return this._py`attr_SequentialFeatureSelector_n_features_to_select_.tolist() if hasattr(attr_SequentialFeatureSelector_n_features_to_select_, 'tolist') else attr_SequentialFeatureSelector_n_features_to_select_`;
    })();
  }
  /**
    The mask of selected features.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error(
        "This SequentialFeatureSelector instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SequentialFeatureSelector must call init() before accessing support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SequentialFeatureSelector_support_ = bridgeSequentialFeatureSelector[${this.id}].support_`;
      return this._py`attr_SequentialFeatureSelector_support_.tolist() if hasattr(attr_SequentialFeatureSelector_support_, 'tolist') else attr_SequentialFeatureSelector_support_`;
    })();
  }
};

// src/generated/feature_selection/VarianceThreshold.ts
import crypto93 from "node:crypto";
var VarianceThreshold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `VarianceThreshold${crypto93.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("VarianceThreshold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.feature_selection import VarianceThreshold
try: bridgeVarianceThreshold
except NameError: bridgeVarianceThreshold = {}
`;
    await this._py.ex`ctor_VarianceThreshold = {'threshold': ${this.opts["threshold"] ?? void 0}}

ctor_VarianceThreshold = {k: v for k, v in ctor_VarianceThreshold.items() if v is not None}`;
    await this._py.ex`bridgeVarianceThreshold[${this.id}] = VarianceThreshold(**ctor_VarianceThreshold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeVarianceThreshold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn empirical variances from X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before fit()");
    }
    await this._py.ex`pms_VarianceThreshold_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_VarianceThreshold_fit = {k: v for k, v in pms_VarianceThreshold_fit.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_fit = bridgeVarianceThreshold[${this.id}].fit(**pms_VarianceThreshold_fit)`;
    return this._py`res_VarianceThreshold_fit.tolist() if hasattr(res_VarianceThreshold_fit, 'tolist') else res_VarianceThreshold_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_VarianceThreshold_fit_transform = {k: v for k, v in pms_VarianceThreshold_fit_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_fit_transform = bridgeVarianceThreshold[${this.id}].fit_transform(**pms_VarianceThreshold_fit_transform)`;
    return this._py`res_VarianceThreshold_fit_transform.tolist() if hasattr(res_VarianceThreshold_fit_transform, 'tolist') else res_VarianceThreshold_fit_transform`;
  }
  /**
    Mask feature names according to selected features.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_VarianceThreshold_get_feature_names_out = {k: v for k, v in pms_VarianceThreshold_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_feature_names_out = bridgeVarianceThreshold[${this.id}].get_feature_names_out(**pms_VarianceThreshold_get_feature_names_out)`;
    return this._py`res_VarianceThreshold_get_feature_names_out.tolist() if hasattr(res_VarianceThreshold_get_feature_names_out, 'tolist') else res_VarianceThreshold_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_VarianceThreshold_get_metadata_routing = {k: v for k, v in pms_VarianceThreshold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_metadata_routing = bridgeVarianceThreshold[${this.id}].get_metadata_routing(**pms_VarianceThreshold_get_metadata_routing)`;
    return this._py`res_VarianceThreshold_get_metadata_routing.tolist() if hasattr(res_VarianceThreshold_get_metadata_routing, 'tolist') else res_VarianceThreshold_get_metadata_routing`;
  }
  /**
    Get a mask, or integer index, of the features selected.
   */
  async get_support(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before get_support()");
    }
    await this._py.ex`pms_VarianceThreshold_get_support = {'indices': ${opts["indices"] ?? void 0}}

pms_VarianceThreshold_get_support = {k: v for k, v in pms_VarianceThreshold_get_support.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_get_support = bridgeVarianceThreshold[${this.id}].get_support(**pms_VarianceThreshold_get_support)`;
    return this._py`res_VarianceThreshold_get_support.tolist() if hasattr(res_VarianceThreshold_get_support, 'tolist') else res_VarianceThreshold_get_support`;
  }
  /**
    Reverse the transformation operation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_VarianceThreshold_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VarianceThreshold_inverse_transform = {k: v for k, v in pms_VarianceThreshold_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_inverse_transform = bridgeVarianceThreshold[${this.id}].inverse_transform(**pms_VarianceThreshold_inverse_transform)`;
    return this._py`res_VarianceThreshold_inverse_transform.tolist() if hasattr(res_VarianceThreshold_inverse_transform, 'tolist') else res_VarianceThreshold_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before set_output()");
    }
    await this._py.ex`pms_VarianceThreshold_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_VarianceThreshold_set_output = {k: v for k, v in pms_VarianceThreshold_set_output.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_set_output = bridgeVarianceThreshold[${this.id}].set_output(**pms_VarianceThreshold_set_output)`;
    return this._py`res_VarianceThreshold_set_output.tolist() if hasattr(res_VarianceThreshold_set_output, 'tolist') else res_VarianceThreshold_set_output`;
  }
  /**
    Reduce X to the selected features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("VarianceThreshold must call init() before transform()");
    }
    await this._py.ex`pms_VarianceThreshold_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_VarianceThreshold_transform = {k: v for k, v in pms_VarianceThreshold_transform.items() if v is not None}`;
    await this._py.ex`res_VarianceThreshold_transform = bridgeVarianceThreshold[${this.id}].transform(**pms_VarianceThreshold_transform)`;
    return this._py`res_VarianceThreshold_transform.tolist() if hasattr(res_VarianceThreshold_transform, 'tolist') else res_VarianceThreshold_transform`;
  }
  /**
    Variances of individual features.
   */
  get variances_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing variances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_variances_ = bridgeVarianceThreshold[${this.id}].variances_`;
      return this._py`attr_VarianceThreshold_variances_.tolist() if hasattr(attr_VarianceThreshold_variances_, 'tolist') else attr_VarianceThreshold_variances_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_n_features_in_ = bridgeVarianceThreshold[${this.id}].n_features_in_`;
      return this._py`attr_VarianceThreshold_n_features_in_.tolist() if hasattr(attr_VarianceThreshold_n_features_in_, 'tolist') else attr_VarianceThreshold_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This VarianceThreshold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "VarianceThreshold must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_VarianceThreshold_feature_names_in_ = bridgeVarianceThreshold[${this.id}].feature_names_in_`;
      return this._py`attr_VarianceThreshold_feature_names_in_.tolist() if hasattr(attr_VarianceThreshold_feature_names_in_, 'tolist') else attr_VarianceThreshold_feature_names_in_`;
    })();
  }
};

// src/generated/gaussian_process/GaussianProcessClassifier.ts
import crypto94 from "node:crypto";
var GaussianProcessClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianProcessClassifier${crypto94.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianProcessClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process import GaussianProcessClassifier
try: bridgeGaussianProcessClassifier
except NameError: bridgeGaussianProcessClassifier = {}
`;
    await this._py.ex`ctor_GaussianProcessClassifier = {'kernel': ${this.opts["kernel"] ?? void 0}, 'optimizer': ${this.opts["optimizer"] ?? void 0}, 'n_restarts_optimizer': ${this.opts["n_restarts_optimizer"] ?? void 0}, 'max_iter_predict': ${this.opts["max_iter_predict"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'copy_X_train': ${this.opts["copy_X_train"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_GaussianProcessClassifier = {k: v for k, v in ctor_GaussianProcessClassifier.items() if v is not None}`;
    await this._py.ex`bridgeGaussianProcessClassifier[${this.id}] = GaussianProcessClassifier(**ctor_GaussianProcessClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianProcessClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian process classification model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianProcessClassifier must call init() before fit()");
    }
    await this._py.ex`pms_GaussianProcessClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GaussianProcessClassifier_fit = {k: v for k, v in pms_GaussianProcessClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_fit = bridgeGaussianProcessClassifier[${this.id}].fit(**pms_GaussianProcessClassifier_fit)`;
    return this._py`res_GaussianProcessClassifier_fit.tolist() if hasattr(res_GaussianProcessClassifier_fit, 'tolist') else res_GaussianProcessClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GaussianProcessClassifier_get_metadata_routing = {k: v for k, v in pms_GaussianProcessClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_get_metadata_routing = bridgeGaussianProcessClassifier[${this.id}].get_metadata_routing(**pms_GaussianProcessClassifier_get_metadata_routing)`;
    return this._py`res_GaussianProcessClassifier_get_metadata_routing.tolist() if hasattr(res_GaussianProcessClassifier_get_metadata_routing, 'tolist') else res_GaussianProcessClassifier_get_metadata_routing`;
  }
  /**
      Return log-marginal likelihood of theta for training data.
  
      In the case of multi-class classification, the mean log-marginal likelihood of the one-versus-rest classifiers are returned.
     */
  async log_marginal_likelihood(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before log_marginal_likelihood()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_log_marginal_likelihood = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}, 'clone_kernel': ${opts["clone_kernel"] ?? void 0}}

pms_GaussianProcessClassifier_log_marginal_likelihood = {k: v for k, v in pms_GaussianProcessClassifier_log_marginal_likelihood.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_log_marginal_likelihood = bridgeGaussianProcessClassifier[${this.id}].log_marginal_likelihood(**pms_GaussianProcessClassifier_log_marginal_likelihood)`;
    return this._py`res_GaussianProcessClassifier_log_marginal_likelihood.tolist() if hasattr(res_GaussianProcessClassifier_log_marginal_likelihood, 'tolist') else res_GaussianProcessClassifier_log_marginal_likelihood`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianProcessClassifier_predict = {k: v for k, v in pms_GaussianProcessClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_predict = bridgeGaussianProcessClassifier[${this.id}].predict(**pms_GaussianProcessClassifier_predict)`;
    return this._py`res_GaussianProcessClassifier_predict.tolist() if hasattr(res_GaussianProcessClassifier_predict, 'tolist') else res_GaussianProcessClassifier_predict`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianProcessClassifier_predict_proba = {k: v for k, v in pms_GaussianProcessClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_predict_proba = bridgeGaussianProcessClassifier[${this.id}].predict_proba(**pms_GaussianProcessClassifier_predict_proba)`;
    return this._py`res_GaussianProcessClassifier_predict_proba.tolist() if hasattr(res_GaussianProcessClassifier_predict_proba, 'tolist') else res_GaussianProcessClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianProcessClassifier_score = {k: v for k, v in pms_GaussianProcessClassifier_score.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_score = bridgeGaussianProcessClassifier[${this.id}].score(**pms_GaussianProcessClassifier_score)`;
    return this._py`res_GaussianProcessClassifier_score.tolist() if hasattr(res_GaussianProcessClassifier_score, 'tolist') else res_GaussianProcessClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GaussianProcessClassifier_set_score_request = {k: v for k, v in pms_GaussianProcessClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_set_score_request = bridgeGaussianProcessClassifier[${this.id}].set_score_request(**pms_GaussianProcessClassifier_set_score_request)`;
    return this._py`res_GaussianProcessClassifier_set_score_request.tolist() if hasattr(res_GaussianProcessClassifier_set_score_request, 'tolist') else res_GaussianProcessClassifier_set_score_request`;
  }
  /**
    The estimator instance that defines the likelihood function using the observed data.
   */
  get base_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing base_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_base_estimator_ = bridgeGaussianProcessClassifier[${this.id}].base_estimator_`;
      return this._py`attr_GaussianProcessClassifier_base_estimator_.tolist() if hasattr(attr_GaussianProcessClassifier_base_estimator_, 'tolist') else attr_GaussianProcessClassifier_base_estimator_`;
    })();
  }
  /**
    The log-marginal-likelihood of `self.kernel\_.theta`
   */
  get log_marginal_likelihood_value_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing log_marginal_likelihood_value_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_log_marginal_likelihood_value_ = bridgeGaussianProcessClassifier[${this.id}].log_marginal_likelihood_value_`;
      return this._py`attr_GaussianProcessClassifier_log_marginal_likelihood_value_.tolist() if hasattr(attr_GaussianProcessClassifier_log_marginal_likelihood_value_, 'tolist') else attr_GaussianProcessClassifier_log_marginal_likelihood_value_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_classes_ = bridgeGaussianProcessClassifier[${this.id}].classes_`;
      return this._py`attr_GaussianProcessClassifier_classes_.tolist() if hasattr(attr_GaussianProcessClassifier_classes_, 'tolist') else attr_GaussianProcessClassifier_classes_`;
    })();
  }
  /**
    The number of classes in the training data
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_n_classes_ = bridgeGaussianProcessClassifier[${this.id}].n_classes_`;
      return this._py`attr_GaussianProcessClassifier_n_classes_.tolist() if hasattr(attr_GaussianProcessClassifier_n_classes_, 'tolist') else attr_GaussianProcessClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_n_features_in_ = bridgeGaussianProcessClassifier[${this.id}].n_features_in_`;
      return this._py`attr_GaussianProcessClassifier_n_features_in_.tolist() if hasattr(attr_GaussianProcessClassifier_n_features_in_, 'tolist') else attr_GaussianProcessClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_feature_names_in_ = bridgeGaussianProcessClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianProcessClassifier_feature_names_in_.tolist() if hasattr(attr_GaussianProcessClassifier_feature_names_in_, 'tolist') else attr_GaussianProcessClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/gaussian_process/GaussianProcessRegressor.ts
import crypto95 from "node:crypto";
var GaussianProcessRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianProcessRegressor${crypto95.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianProcessRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
try: bridgeGaussianProcessRegressor
except NameError: bridgeGaussianProcessRegressor = {}
`;
    await this._py.ex`ctor_GaussianProcessRegressor = {'kernel': ${this.opts["kernel"] ?? void 0}, 'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'optimizer': ${this.opts["optimizer"] ?? void 0}, 'n_restarts_optimizer': ${this.opts["n_restarts_optimizer"] ?? void 0}, 'normalize_y': ${this.opts["normalize_y"] ?? void 0}, 'copy_X_train': ${this.opts["copy_X_train"] ?? void 0}, 'n_targets': ${this.opts["n_targets"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_GaussianProcessRegressor = {k: v for k, v in ctor_GaussianProcessRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGaussianProcessRegressor[${this.id}] = GaussianProcessRegressor(**ctor_GaussianProcessRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianProcessRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian process regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianProcessRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GaussianProcessRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GaussianProcessRegressor_fit = {k: v for k, v in pms_GaussianProcessRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_fit = bridgeGaussianProcessRegressor[${this.id}].fit(**pms_GaussianProcessRegressor_fit)`;
    return this._py`res_GaussianProcessRegressor_fit.tolist() if hasattr(res_GaussianProcessRegressor_fit, 'tolist') else res_GaussianProcessRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GaussianProcessRegressor_get_metadata_routing = {k: v for k, v in pms_GaussianProcessRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_get_metadata_routing = bridgeGaussianProcessRegressor[${this.id}].get_metadata_routing(**pms_GaussianProcessRegressor_get_metadata_routing)`;
    return this._py`res_GaussianProcessRegressor_get_metadata_routing.tolist() if hasattr(res_GaussianProcessRegressor_get_metadata_routing, 'tolist') else res_GaussianProcessRegressor_get_metadata_routing`;
  }
  /**
    Return log-marginal likelihood of theta for training data.
   */
  async log_marginal_likelihood(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before log_marginal_likelihood()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_log_marginal_likelihood = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}, 'clone_kernel': ${opts["clone_kernel"] ?? void 0}}

pms_GaussianProcessRegressor_log_marginal_likelihood = {k: v for k, v in pms_GaussianProcessRegressor_log_marginal_likelihood.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_log_marginal_likelihood = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood(**pms_GaussianProcessRegressor_log_marginal_likelihood)`;
    return this._py`res_GaussianProcessRegressor_log_marginal_likelihood.tolist() if hasattr(res_GaussianProcessRegressor_log_marginal_likelihood, 'tolist') else res_GaussianProcessRegressor_log_marginal_likelihood`;
  }
  /**
      Predict using the Gaussian process regression model.
  
      We can also predict based on an unfitted model by using the GP prior. In addition to the mean of the predictive distribution, optionally also returns its standard deviation (`return\_std=True`) or covariance (`return\_cov=True`). Note that at most one of the two can be requested.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}, 'return_cov': ${opts["return_cov"] ?? void 0}}

pms_GaussianProcessRegressor_predict = {k: v for k, v in pms_GaussianProcessRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_predict = bridgeGaussianProcessRegressor[${this.id}].predict(**pms_GaussianProcessRegressor_predict)`;
    return this._py`res_GaussianProcessRegressor_predict.tolist() if hasattr(res_GaussianProcessRegressor_predict, 'tolist') else res_GaussianProcessRegressor_predict`;
  }
  /**
    Draw samples from Gaussian process and evaluate at X.
   */
  async sample_y(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before sample_y()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_sample_y = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_samples': ${opts["n_samples"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_GaussianProcessRegressor_sample_y = {k: v for k, v in pms_GaussianProcessRegressor_sample_y.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_sample_y = bridgeGaussianProcessRegressor[${this.id}].sample_y(**pms_GaussianProcessRegressor_sample_y)`;
    return this._py`res_GaussianProcessRegressor_sample_y.tolist() if hasattr(res_GaussianProcessRegressor_sample_y, 'tolist') else res_GaussianProcessRegressor_sample_y`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianProcessRegressor_score = {k: v for k, v in pms_GaussianProcessRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_score = bridgeGaussianProcessRegressor[${this.id}].score(**pms_GaussianProcessRegressor_score)`;
    return this._py`res_GaussianProcessRegressor_score.tolist() if hasattr(res_GaussianProcessRegressor_score, 'tolist') else res_GaussianProcessRegressor_score`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_set_predict_request = {'return_cov': ${opts["return_cov"] ?? void 0}, 'return_std': ${opts["return_std"] ?? void 0}}

pms_GaussianProcessRegressor_set_predict_request = {k: v for k, v in pms_GaussianProcessRegressor_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_set_predict_request = bridgeGaussianProcessRegressor[${this.id}].set_predict_request(**pms_GaussianProcessRegressor_set_predict_request)`;
    return this._py`res_GaussianProcessRegressor_set_predict_request.tolist() if hasattr(res_GaussianProcessRegressor_set_predict_request, 'tolist') else res_GaussianProcessRegressor_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GaussianProcessRegressor_set_score_request = {k: v for k, v in pms_GaussianProcessRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_set_score_request = bridgeGaussianProcessRegressor[${this.id}].set_score_request(**pms_GaussianProcessRegressor_set_score_request)`;
    return this._py`res_GaussianProcessRegressor_set_score_request.tolist() if hasattr(res_GaussianProcessRegressor_set_score_request, 'tolist') else res_GaussianProcessRegressor_set_score_request`;
  }
  /**
    Feature vectors or other representations of training data (also required for prediction).
   */
  get X_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing X_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_X_train_ = bridgeGaussianProcessRegressor[${this.id}].X_train_`;
      return this._py`attr_GaussianProcessRegressor_X_train_.tolist() if hasattr(attr_GaussianProcessRegressor_X_train_, 'tolist') else attr_GaussianProcessRegressor_X_train_`;
    })();
  }
  /**
    Target values in training data (also required for prediction).
   */
  get y_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing y_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_y_train_ = bridgeGaussianProcessRegressor[${this.id}].y_train_`;
      return this._py`attr_GaussianProcessRegressor_y_train_.tolist() if hasattr(attr_GaussianProcessRegressor_y_train_, 'tolist') else attr_GaussianProcessRegressor_y_train_`;
    })();
  }
  /**
    The kernel used for prediction. The structure of the kernel is the same as the one passed as parameter but with optimized hyperparameters.
   */
  get kernel_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing kernel_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_kernel_ = bridgeGaussianProcessRegressor[${this.id}].kernel_`;
      return this._py`attr_GaussianProcessRegressor_kernel_.tolist() if hasattr(attr_GaussianProcessRegressor_kernel_, 'tolist') else attr_GaussianProcessRegressor_kernel_`;
    })();
  }
  /**
    Lower-triangular Cholesky decomposition of the kernel in `X\_train\_`.
   */
  get L_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing L_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_L_ = bridgeGaussianProcessRegressor[${this.id}].L_`;
      return this._py`attr_GaussianProcessRegressor_L_.tolist() if hasattr(attr_GaussianProcessRegressor_L_, 'tolist') else attr_GaussianProcessRegressor_L_`;
    })();
  }
  /**
    Dual coefficients of training data points in kernel space.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_alpha_ = bridgeGaussianProcessRegressor[${this.id}].alpha_`;
      return this._py`attr_GaussianProcessRegressor_alpha_.tolist() if hasattr(attr_GaussianProcessRegressor_alpha_, 'tolist') else attr_GaussianProcessRegressor_alpha_`;
    })();
  }
  /**
    The log-marginal-likelihood of `self.kernel\_.theta`.
   */
  get log_marginal_likelihood_value_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing log_marginal_likelihood_value_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_log_marginal_likelihood_value_ = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood_value_`;
      return this._py`attr_GaussianProcessRegressor_log_marginal_likelihood_value_.tolist() if hasattr(attr_GaussianProcessRegressor_log_marginal_likelihood_value_, 'tolist') else attr_GaussianProcessRegressor_log_marginal_likelihood_value_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_n_features_in_ = bridgeGaussianProcessRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GaussianProcessRegressor_n_features_in_.tolist() if hasattr(attr_GaussianProcessRegressor_n_features_in_, 'tolist') else attr_GaussianProcessRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_feature_names_in_ = bridgeGaussianProcessRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianProcessRegressor_feature_names_in_.tolist() if hasattr(attr_GaussianProcessRegressor_feature_names_in_, 'tolist') else attr_GaussianProcessRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/gaussian_process/kernels/CompoundKernel.ts
import crypto96 from "node:crypto";
var CompoundKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CompoundKernel${crypto96.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CompoundKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import CompoundKernel
try: bridgeCompoundKernel
except NameError: bridgeCompoundKernel = {}
`;
    await this._py.ex`ctor_CompoundKernel = {'kernels': ${this.opts["kernels"] ?? void 0}}

ctor_CompoundKernel = {k: v for k, v in ctor_CompoundKernel.items() if v is not None}`;
    await this._py.ex`bridgeCompoundKernel[${this.id}] = CompoundKernel(**ctor_CompoundKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCompoundKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return the kernel k(X, Y) and optionally its gradient.
  
      Note that this compound kernel returns the results of all simple kernel stacked along an additional axis.
     */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before __call__()");
    }
    await this._py.ex`pms_CompoundKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_CompoundKernel___call__ = {k: v for k, v in pms_CompoundKernel___call__.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel___call__ = bridgeCompoundKernel[${this.id}].__call__(**pms_CompoundKernel___call__)`;
    return this._py`res_CompoundKernel___call__.tolist() if hasattr(res_CompoundKernel___call__, 'tolist') else res_CompoundKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CompoundKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_CompoundKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_CompoundKernel_clone_with_theta = {k: v for k, v in pms_CompoundKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_clone_with_theta = bridgeCompoundKernel[${this.id}].clone_with_theta(**pms_CompoundKernel_clone_with_theta)`;
    return this._py`res_CompoundKernel_clone_with_theta.tolist() if hasattr(res_CompoundKernel_clone_with_theta, 'tolist') else res_CompoundKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before diag()");
    }
    await this._py.ex`pms_CompoundKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CompoundKernel_diag = {k: v for k, v in pms_CompoundKernel_diag.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_diag = bridgeCompoundKernel[${this.id}].diag(**pms_CompoundKernel_diag)`;
    return this._py`res_CompoundKernel_diag.tolist() if hasattr(res_CompoundKernel_diag, 'tolist') else res_CompoundKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_CompoundKernel_is_stationary = {}

pms_CompoundKernel_is_stationary = {k: v for k, v in pms_CompoundKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_is_stationary = bridgeCompoundKernel[${this.id}].is_stationary(**pms_CompoundKernel_is_stationary)`;
    return this._py`res_CompoundKernel_is_stationary.tolist() if hasattr(res_CompoundKernel_is_stationary, 'tolist') else res_CompoundKernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ConstantKernel.ts
import crypto97 from "node:crypto";
var ConstantKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ConstantKernel${crypto97.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ConstantKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ConstantKernel
try: bridgeConstantKernel
except NameError: bridgeConstantKernel = {}
`;
    await this._py.ex`ctor_ConstantKernel = {'constant_value': ${this.opts["constant_value"] ?? void 0}, 'constant_value_bounds': ${this.opts["constant_value_bounds"] ?? void 0}}

ctor_ConstantKernel = {k: v for k, v in ctor_ConstantKernel.items() if v is not None}`;
    await this._py.ex`bridgeConstantKernel[${this.id}] = ConstantKernel(**ctor_ConstantKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeConstantKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before __call__()");
    }
    await this._py.ex`pms_ConstantKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ConstantKernel___call__ = {k: v for k, v in pms_ConstantKernel___call__.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel___call__ = bridgeConstantKernel[${this.id}].__call__(**pms_ConstantKernel___call__)`;
    return this._py`res_ConstantKernel___call__.tolist() if hasattr(res_ConstantKernel___call__, 'tolist') else res_ConstantKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ConstantKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ConstantKernel_clone_with_theta = {k: v for k, v in pms_ConstantKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_clone_with_theta = bridgeConstantKernel[${this.id}].clone_with_theta(**pms_ConstantKernel_clone_with_theta)`;
    return this._py`res_ConstantKernel_clone_with_theta.tolist() if hasattr(res_ConstantKernel_clone_with_theta, 'tolist') else res_ConstantKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before diag()");
    }
    await this._py.ex`pms_ConstantKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ConstantKernel_diag = {k: v for k, v in pms_ConstantKernel_diag.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_diag = bridgeConstantKernel[${this.id}].diag(**pms_ConstantKernel_diag)`;
    return this._py`res_ConstantKernel_diag.tolist() if hasattr(res_ConstantKernel_diag, 'tolist') else res_ConstantKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_ConstantKernel_is_stationary = {}

pms_ConstantKernel_is_stationary = {k: v for k, v in pms_ConstantKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_is_stationary = bridgeConstantKernel[${this.id}].is_stationary(**pms_ConstantKernel_is_stationary)`;
    return this._py`res_ConstantKernel_is_stationary.tolist() if hasattr(res_ConstantKernel_is_stationary, 'tolist') else res_ConstantKernel_is_stationary`;
  }
  get hyperparameter_constant_value() {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before accessing hyperparameter_constant_value"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConstantKernel_hyperparameter_constant_value = bridgeConstantKernel[${this.id}].hyperparameter_constant_value`;
      return this._py`attr_ConstantKernel_hyperparameter_constant_value.tolist() if hasattr(attr_ConstantKernel_hyperparameter_constant_value, 'tolist') else attr_ConstantKernel_hyperparameter_constant_value`;
    })();
  }
};

// src/generated/gaussian_process/kernels/DotProduct.ts
import crypto98 from "node:crypto";
var DotProduct = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DotProduct${crypto98.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DotProduct.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import DotProduct
try: bridgeDotProduct
except NameError: bridgeDotProduct = {}
`;
    await this._py.ex`ctor_DotProduct = {'sigma_0': ${this.opts["sigma_0"] ?? void 0}, 'sigma_0_bounds': ${this.opts["sigma_0_bounds"] ?? void 0}}

ctor_DotProduct = {k: v for k, v in ctor_DotProduct.items() if v is not None}`;
    await this._py.ex`bridgeDotProduct[${this.id}] = DotProduct(**ctor_DotProduct)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDotProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before __call__()");
    }
    await this._py.ex`pms_DotProduct___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_DotProduct___call__ = {k: v for k, v in pms_DotProduct___call__.items() if v is not None}`;
    await this._py.ex`res_DotProduct___call__ = bridgeDotProduct[${this.id}].__call__(**pms_DotProduct___call__)`;
    return this._py`res_DotProduct___call__.tolist() if hasattr(res_DotProduct___call__, 'tolist') else res_DotProduct___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_DotProduct_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_DotProduct_clone_with_theta = {k: v for k, v in pms_DotProduct_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_DotProduct_clone_with_theta = bridgeDotProduct[${this.id}].clone_with_theta(**pms_DotProduct_clone_with_theta)`;
    return this._py`res_DotProduct_clone_with_theta.tolist() if hasattr(res_DotProduct_clone_with_theta, 'tolist') else res_DotProduct_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before diag()");
    }
    await this._py.ex`pms_DotProduct_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DotProduct_diag = {k: v for k, v in pms_DotProduct_diag.items() if v is not None}`;
    await this._py.ex`res_DotProduct_diag = bridgeDotProduct[${this.id}].diag(**pms_DotProduct_diag)`;
    return this._py`res_DotProduct_diag.tolist() if hasattr(res_DotProduct_diag, 'tolist') else res_DotProduct_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before is_stationary()");
    }
    await this._py.ex`pms_DotProduct_is_stationary = {}

pms_DotProduct_is_stationary = {k: v for k, v in pms_DotProduct_is_stationary.items() if v is not None}`;
    await this._py.ex`res_DotProduct_is_stationary = bridgeDotProduct[${this.id}].is_stationary(**pms_DotProduct_is_stationary)`;
    return this._py`res_DotProduct_is_stationary.tolist() if hasattr(res_DotProduct_is_stationary, 'tolist') else res_DotProduct_is_stationary`;
  }
  get hyperparameter_sigma_0() {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DotProduct must call init() before accessing hyperparameter_sigma_0"
      );
    }
    return (async () => {
      await this._py.ex`attr_DotProduct_hyperparameter_sigma_0 = bridgeDotProduct[${this.id}].hyperparameter_sigma_0`;
      return this._py`attr_DotProduct_hyperparameter_sigma_0.tolist() if hasattr(attr_DotProduct_hyperparameter_sigma_0, 'tolist') else attr_DotProduct_hyperparameter_sigma_0`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Exponentiation.ts
import crypto99 from "node:crypto";
var Exponentiation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Exponentiation${crypto99.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Exponentiation.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Exponentiation
try: bridgeExponentiation
except NameError: bridgeExponentiation = {}
`;
    await this._py.ex`ctor_Exponentiation = {'kernel': ${this.opts["kernel"] ?? void 0}, 'exponent': ${this.opts["exponent"] ?? void 0}}

ctor_Exponentiation = {k: v for k, v in ctor_Exponentiation.items() if v is not None}`;
    await this._py.ex`bridgeExponentiation[${this.id}] = Exponentiation(**ctor_Exponentiation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExponentiation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before __call__()");
    }
    await this._py.ex`pms_Exponentiation___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Exponentiation___call__ = {k: v for k, v in pms_Exponentiation___call__.items() if v is not None}`;
    await this._py.ex`res_Exponentiation___call__ = bridgeExponentiation[${this.id}].__call__(**pms_Exponentiation___call__)`;
    return this._py`res_Exponentiation___call__.tolist() if hasattr(res_Exponentiation___call__, 'tolist') else res_Exponentiation___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Exponentiation must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_Exponentiation_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Exponentiation_clone_with_theta = {k: v for k, v in pms_Exponentiation_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_clone_with_theta = bridgeExponentiation[${this.id}].clone_with_theta(**pms_Exponentiation_clone_with_theta)`;
    return this._py`res_Exponentiation_clone_with_theta.tolist() if hasattr(res_Exponentiation_clone_with_theta, 'tolist') else res_Exponentiation_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before diag()");
    }
    await this._py.ex`pms_Exponentiation_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Exponentiation_diag = {k: v for k, v in pms_Exponentiation_diag.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_diag = bridgeExponentiation[${this.id}].diag(**pms_Exponentiation_diag)`;
    return this._py`res_Exponentiation_diag.tolist() if hasattr(res_Exponentiation_diag, 'tolist') else res_Exponentiation_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before is_stationary()");
    }
    await this._py.ex`pms_Exponentiation_is_stationary = {}

pms_Exponentiation_is_stationary = {k: v for k, v in pms_Exponentiation_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_is_stationary = bridgeExponentiation[${this.id}].is_stationary(**pms_Exponentiation_is_stationary)`;
    return this._py`res_Exponentiation_is_stationary.tolist() if hasattr(res_Exponentiation_is_stationary, 'tolist') else res_Exponentiation_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ExpSineSquared.ts
import crypto100 from "node:crypto";
var ExpSineSquared = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExpSineSquared${crypto100.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ExpSineSquared.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ExpSineSquared
try: bridgeExpSineSquared
except NameError: bridgeExpSineSquared = {}
`;
    await this._py.ex`ctor_ExpSineSquared = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'periodicity': ${this.opts["periodicity"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'periodicity_bounds': ${this.opts["periodicity_bounds"] ?? void 0}}

ctor_ExpSineSquared = {k: v for k, v in ctor_ExpSineSquared.items() if v is not None}`;
    await this._py.ex`bridgeExpSineSquared[${this.id}] = ExpSineSquared(**ctor_ExpSineSquared)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExpSineSquared[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before __call__()");
    }
    await this._py.ex`pms_ExpSineSquared___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ExpSineSquared___call__ = {k: v for k, v in pms_ExpSineSquared___call__.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared___call__ = bridgeExpSineSquared[${this.id}].__call__(**pms_ExpSineSquared___call__)`;
    return this._py`res_ExpSineSquared___call__.tolist() if hasattr(res_ExpSineSquared___call__, 'tolist') else res_ExpSineSquared___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ExpSineSquared_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ExpSineSquared_clone_with_theta = {k: v for k, v in pms_ExpSineSquared_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_clone_with_theta = bridgeExpSineSquared[${this.id}].clone_with_theta(**pms_ExpSineSquared_clone_with_theta)`;
    return this._py`res_ExpSineSquared_clone_with_theta.tolist() if hasattr(res_ExpSineSquared_clone_with_theta, 'tolist') else res_ExpSineSquared_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before diag()");
    }
    await this._py.ex`pms_ExpSineSquared_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExpSineSquared_diag = {k: v for k, v in pms_ExpSineSquared_diag.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_diag = bridgeExpSineSquared[${this.id}].diag(**pms_ExpSineSquared_diag)`;
    return this._py`res_ExpSineSquared_diag.tolist() if hasattr(res_ExpSineSquared_diag, 'tolist') else res_ExpSineSquared_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before is_stationary()");
    }
    await this._py.ex`pms_ExpSineSquared_is_stationary = {}

pms_ExpSineSquared_is_stationary = {k: v for k, v in pms_ExpSineSquared_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_is_stationary = bridgeExpSineSquared[${this.id}].is_stationary(**pms_ExpSineSquared_is_stationary)`;
    return this._py`res_ExpSineSquared_is_stationary.tolist() if hasattr(res_ExpSineSquared_is_stationary, 'tolist') else res_ExpSineSquared_is_stationary`;
  }
  get hyperparameter_periodicity() {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before accessing hyperparameter_periodicity"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExpSineSquared_hyperparameter_periodicity = bridgeExpSineSquared[${this.id}].hyperparameter_periodicity`;
      return this._py`attr_ExpSineSquared_hyperparameter_periodicity.tolist() if hasattr(attr_ExpSineSquared_hyperparameter_periodicity, 'tolist') else attr_ExpSineSquared_hyperparameter_periodicity`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Hyperparameter.ts
import crypto101 from "node:crypto";
var Hyperparameter = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Hyperparameter${crypto101.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Hyperparameter.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Hyperparameter
try: bridgeHyperparameter
except NameError: bridgeHyperparameter = {}
`;
    await this._py.ex`ctor_Hyperparameter = {'name': ${this.opts["name"] ?? void 0}, 'value_type': ${this.opts["value_type"] ?? void 0}, 'bounds': ${this.opts["bounds"] ?? void 0}, 'n_elements': ${this.opts["n_elements"] ?? void 0}, 'fixed': ${this.opts["fixed"] ?? void 0}}

ctor_Hyperparameter = {k: v for k, v in ctor_Hyperparameter.items() if v is not None}`;
    await this._py.ex`bridgeHyperparameter[${this.id}] = Hyperparameter(**ctor_Hyperparameter)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHyperparameter[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Call self as a function.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before __call__()");
    }
    await this._py.ex`pms_Hyperparameter___call__ = {}

pms_Hyperparameter___call__ = {k: v for k, v in pms_Hyperparameter___call__.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter___call__ = bridgeHyperparameter[${this.id}].__call__(**pms_Hyperparameter___call__)`;
    return this._py`res_Hyperparameter___call__.tolist() if hasattr(res_Hyperparameter___call__, 'tolist') else res_Hyperparameter___call__`;
  }
  /**
    Return number of occurrences of value.
   */
  async count(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before count()");
    }
    await this._py.ex`pms_Hyperparameter_count = {}

pms_Hyperparameter_count = {k: v for k, v in pms_Hyperparameter_count.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_count = bridgeHyperparameter[${this.id}].count(**pms_Hyperparameter_count)`;
    return this._py`res_Hyperparameter_count.tolist() if hasattr(res_Hyperparameter_count, 'tolist') else res_Hyperparameter_count`;
  }
  /**
      Return first index of value.
  
      Raises ValueError if the value is not present.
     */
  async index(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before index()");
    }
    await this._py.ex`pms_Hyperparameter_index = {}

pms_Hyperparameter_index = {k: v for k, v in pms_Hyperparameter_index.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_index = bridgeHyperparameter[${this.id}].index(**pms_Hyperparameter_index)`;
    return this._py`res_Hyperparameter_index.tolist() if hasattr(res_Hyperparameter_index, 'tolist') else res_Hyperparameter_index`;
  }
};

// src/generated/gaussian_process/kernels/Kernel.ts
import crypto102 from "node:crypto";
var Kernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Kernel${crypto102.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Kernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Kernel
try: bridgeKernel
except NameError: bridgeKernel = {}
`;
    await this._py.ex`ctor_Kernel = {}

ctor_Kernel = {k: v for k, v in ctor_Kernel.items() if v is not None}`;
    await this._py.ex`bridgeKernel[${this.id}] = Kernel(**ctor_Kernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the kernel.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before __call__()");
    }
    await this._py.ex`pms_Kernel___call__ = {}

pms_Kernel___call__ = {k: v for k, v in pms_Kernel___call__.items() if v is not None}`;
    await this._py.ex`res_Kernel___call__ = bridgeKernel[${this.id}].__call__(**pms_Kernel___call__)`;
    return this._py`res_Kernel___call__.tolist() if hasattr(res_Kernel___call__, 'tolist') else res_Kernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Kernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Kernel_clone_with_theta = {k: v for k, v in pms_Kernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Kernel_clone_with_theta = bridgeKernel[${this.id}].clone_with_theta(**pms_Kernel_clone_with_theta)`;
    return this._py`res_Kernel_clone_with_theta.tolist() if hasattr(res_Kernel_clone_with_theta, 'tolist') else res_Kernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before diag()");
    }
    await this._py.ex`pms_Kernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Kernel_diag = {k: v for k, v in pms_Kernel_diag.items() if v is not None}`;
    await this._py.ex`res_Kernel_diag = bridgeKernel[${this.id}].diag(**pms_Kernel_diag)`;
    return this._py`res_Kernel_diag.tolist() if hasattr(res_Kernel_diag, 'tolist') else res_Kernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_Kernel_is_stationary = {}

pms_Kernel_is_stationary = {k: v for k, v in pms_Kernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Kernel_is_stationary = bridgeKernel[${this.id}].is_stationary(**pms_Kernel_is_stationary)`;
    return this._py`res_Kernel_is_stationary.tolist() if hasattr(res_Kernel_is_stationary, 'tolist') else res_Kernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/Matern.ts
import crypto103 from "node:crypto";
var Matern = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Matern${crypto103.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Matern.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Matern
try: bridgeMatern
except NameError: bridgeMatern = {}
`;
    await this._py.ex`ctor_Matern = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'nu': ${this.opts["nu"] ?? void 0}}

ctor_Matern = {k: v for k, v in ctor_Matern.items() if v is not None}`;
    await this._py.ex`bridgeMatern[${this.id}] = Matern(**ctor_Matern)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMatern[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before __call__()");
    }
    await this._py.ex`pms_Matern___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Matern___call__ = {k: v for k, v in pms_Matern___call__.items() if v is not None}`;
    await this._py.ex`res_Matern___call__ = bridgeMatern[${this.id}].__call__(**pms_Matern___call__)`;
    return this._py`res_Matern___call__.tolist() if hasattr(res_Matern___call__, 'tolist') else res_Matern___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Matern_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Matern_clone_with_theta = {k: v for k, v in pms_Matern_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Matern_clone_with_theta = bridgeMatern[${this.id}].clone_with_theta(**pms_Matern_clone_with_theta)`;
    return this._py`res_Matern_clone_with_theta.tolist() if hasattr(res_Matern_clone_with_theta, 'tolist') else res_Matern_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before diag()");
    }
    await this._py.ex`pms_Matern_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Matern_diag = {k: v for k, v in pms_Matern_diag.items() if v is not None}`;
    await this._py.ex`res_Matern_diag = bridgeMatern[${this.id}].diag(**pms_Matern_diag)`;
    return this._py`res_Matern_diag.tolist() if hasattr(res_Matern_diag, 'tolist') else res_Matern_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before is_stationary()");
    }
    await this._py.ex`pms_Matern_is_stationary = {}

pms_Matern_is_stationary = {k: v for k, v in pms_Matern_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Matern_is_stationary = bridgeMatern[${this.id}].is_stationary(**pms_Matern_is_stationary)`;
    return this._py`res_Matern_is_stationary.tolist() if hasattr(res_Matern_is_stationary, 'tolist') else res_Matern_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_Matern_anisotropic = bridgeMatern[${this.id}].anisotropic`;
      return this._py`attr_Matern_anisotropic.tolist() if hasattr(attr_Matern_anisotropic, 'tolist') else attr_Matern_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Matern must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_Matern_hyperparameter_length_scale = bridgeMatern[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_Matern_hyperparameter_length_scale.tolist() if hasattr(attr_Matern_hyperparameter_length_scale, 'tolist') else attr_Matern_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/PairwiseKernel.ts
import crypto104 from "node:crypto";
var PairwiseKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PairwiseKernel${crypto104.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PairwiseKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import PairwiseKernel
try: bridgePairwiseKernel
except NameError: bridgePairwiseKernel = {}
`;
    await this._py.ex`ctor_PairwiseKernel = {'gamma': ${this.opts["gamma"] ?? void 0}, 'gamma_bounds': ${this.opts["gamma_bounds"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'pairwise_kernels_kwargs': ${this.opts["pairwise_kernels_kwargs"] ?? void 0}}

ctor_PairwiseKernel = {k: v for k, v in ctor_PairwiseKernel.items() if v is not None}`;
    await this._py.ex`bridgePairwiseKernel[${this.id}] = PairwiseKernel(**ctor_PairwiseKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePairwiseKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before __call__()");
    }
    await this._py.ex`pms_PairwiseKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_PairwiseKernel___call__ = {k: v for k, v in pms_PairwiseKernel___call__.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel___call__ = bridgePairwiseKernel[${this.id}].__call__(**pms_PairwiseKernel___call__)`;
    return this._py`res_PairwiseKernel___call__.tolist() if hasattr(res_PairwiseKernel___call__, 'tolist') else res_PairwiseKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_PairwiseKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_PairwiseKernel_clone_with_theta = {k: v for k, v in pms_PairwiseKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_clone_with_theta = bridgePairwiseKernel[${this.id}].clone_with_theta(**pms_PairwiseKernel_clone_with_theta)`;
    return this._py`res_PairwiseKernel_clone_with_theta.tolist() if hasattr(res_PairwiseKernel_clone_with_theta, 'tolist') else res_PairwiseKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before diag()");
    }
    await this._py.ex`pms_PairwiseKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PairwiseKernel_diag = {k: v for k, v in pms_PairwiseKernel_diag.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_diag = bridgePairwiseKernel[${this.id}].diag(**pms_PairwiseKernel_diag)`;
    return this._py`res_PairwiseKernel_diag.tolist() if hasattr(res_PairwiseKernel_diag, 'tolist') else res_PairwiseKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_PairwiseKernel_is_stationary = {}

pms_PairwiseKernel_is_stationary = {k: v for k, v in pms_PairwiseKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_is_stationary = bridgePairwiseKernel[${this.id}].is_stationary(**pms_PairwiseKernel_is_stationary)`;
    return this._py`res_PairwiseKernel_is_stationary.tolist() if hasattr(res_PairwiseKernel_is_stationary, 'tolist') else res_PairwiseKernel_is_stationary`;
  }
  get hyperparameter_gamma() {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before accessing hyperparameter_gamma"
      );
    }
    return (async () => {
      await this._py.ex`attr_PairwiseKernel_hyperparameter_gamma = bridgePairwiseKernel[${this.id}].hyperparameter_gamma`;
      return this._py`attr_PairwiseKernel_hyperparameter_gamma.tolist() if hasattr(attr_PairwiseKernel_hyperparameter_gamma, 'tolist') else attr_PairwiseKernel_hyperparameter_gamma`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Product.ts
import crypto105 from "node:crypto";
var Product = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Product${crypto105.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Product.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Product
try: bridgeProduct
except NameError: bridgeProduct = {}
`;
    await this._py.ex`ctor_Product = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Product = {k: v for k, v in ctor_Product.items() if v is not None}`;
    await this._py.ex`bridgeProduct[${this.id}] = Product(**ctor_Product)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before __call__()");
    }
    await this._py.ex`pms_Product___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Product___call__ = {k: v for k, v in pms_Product___call__.items() if v is not None}`;
    await this._py.ex`res_Product___call__ = bridgeProduct[${this.id}].__call__(**pms_Product___call__)`;
    return this._py`res_Product___call__.tolist() if hasattr(res_Product___call__, 'tolist') else res_Product___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Product_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Product_clone_with_theta = {k: v for k, v in pms_Product_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Product_clone_with_theta = bridgeProduct[${this.id}].clone_with_theta(**pms_Product_clone_with_theta)`;
    return this._py`res_Product_clone_with_theta.tolist() if hasattr(res_Product_clone_with_theta, 'tolist') else res_Product_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before diag()");
    }
    await this._py.ex`pms_Product_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Product_diag = {k: v for k, v in pms_Product_diag.items() if v is not None}`;
    await this._py.ex`res_Product_diag = bridgeProduct[${this.id}].diag(**pms_Product_diag)`;
    return this._py`res_Product_diag.tolist() if hasattr(res_Product_diag, 'tolist') else res_Product_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before is_stationary()");
    }
    await this._py.ex`pms_Product_is_stationary = {}

pms_Product_is_stationary = {k: v for k, v in pms_Product_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Product_is_stationary = bridgeProduct[${this.id}].is_stationary(**pms_Product_is_stationary)`;
    return this._py`res_Product_is_stationary.tolist() if hasattr(res_Product_is_stationary, 'tolist') else res_Product_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/RationalQuadratic.ts
import crypto106 from "node:crypto";
var RationalQuadratic = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RationalQuadratic${crypto106.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RationalQuadratic.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RationalQuadratic
try: bridgeRationalQuadratic
except NameError: bridgeRationalQuadratic = {}
`;
    await this._py.ex`ctor_RationalQuadratic = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'alpha_bounds': ${this.opts["alpha_bounds"] ?? void 0}}

ctor_RationalQuadratic = {k: v for k, v in ctor_RationalQuadratic.items() if v is not None}`;
    await this._py.ex`bridgeRationalQuadratic[${this.id}] = RationalQuadratic(**ctor_RationalQuadratic)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRationalQuadratic[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before __call__()");
    }
    await this._py.ex`pms_RationalQuadratic___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RationalQuadratic___call__ = {k: v for k, v in pms_RationalQuadratic___call__.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic___call__ = bridgeRationalQuadratic[${this.id}].__call__(**pms_RationalQuadratic___call__)`;
    return this._py`res_RationalQuadratic___call__.tolist() if hasattr(res_RationalQuadratic___call__, 'tolist') else res_RationalQuadratic___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RationalQuadratic_clone_with_theta = {k: v for k, v in pms_RationalQuadratic_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_clone_with_theta = bridgeRationalQuadratic[${this.id}].clone_with_theta(**pms_RationalQuadratic_clone_with_theta)`;
    return this._py`res_RationalQuadratic_clone_with_theta.tolist() if hasattr(res_RationalQuadratic_clone_with_theta, 'tolist') else res_RationalQuadratic_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before diag()");
    }
    await this._py.ex`pms_RationalQuadratic_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RationalQuadratic_diag = {k: v for k, v in pms_RationalQuadratic_diag.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_diag = bridgeRationalQuadratic[${this.id}].diag(**pms_RationalQuadratic_diag)`;
    return this._py`res_RationalQuadratic_diag.tolist() if hasattr(res_RationalQuadratic_diag, 'tolist') else res_RationalQuadratic_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before is_stationary()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_is_stationary = {}

pms_RationalQuadratic_is_stationary = {k: v for k, v in pms_RationalQuadratic_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_is_stationary = bridgeRationalQuadratic[${this.id}].is_stationary(**pms_RationalQuadratic_is_stationary)`;
    return this._py`res_RationalQuadratic_is_stationary.tolist() if hasattr(res_RationalQuadratic_is_stationary, 'tolist') else res_RationalQuadratic_is_stationary`;
  }
  get hyperparameter_alpha() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_alpha"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_alpha = bridgeRationalQuadratic[${this.id}].hyperparameter_alpha`;
      return this._py`attr_RationalQuadratic_hyperparameter_alpha.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_alpha, 'tolist') else attr_RationalQuadratic_hyperparameter_alpha`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_length_scale = bridgeRationalQuadratic[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RationalQuadratic_hyperparameter_length_scale.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_length_scale, 'tolist') else attr_RationalQuadratic_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/RBF.ts
import crypto107 from "node:crypto";
var RBF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RBF${crypto107.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RBF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RBF
try: bridgeRBF
except NameError: bridgeRBF = {}
`;
    await this._py.ex`ctor_RBF = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}}

ctor_RBF = {k: v for k, v in ctor_RBF.items() if v is not None}`;
    await this._py.ex`bridgeRBF[${this.id}] = RBF(**ctor_RBF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRBF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before __call__()");
    }
    await this._py.ex`pms_RBF___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RBF___call__ = {k: v for k, v in pms_RBF___call__.items() if v is not None}`;
    await this._py.ex`res_RBF___call__ = bridgeRBF[${this.id}].__call__(**pms_RBF___call__)`;
    return this._py`res_RBF___call__.tolist() if hasattr(res_RBF___call__, 'tolist') else res_RBF___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_RBF_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RBF_clone_with_theta = {k: v for k, v in pms_RBF_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RBF_clone_with_theta = bridgeRBF[${this.id}].clone_with_theta(**pms_RBF_clone_with_theta)`;
    return this._py`res_RBF_clone_with_theta.tolist() if hasattr(res_RBF_clone_with_theta, 'tolist') else res_RBF_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before diag()");
    }
    await this._py.ex`pms_RBF_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RBF_diag = {k: v for k, v in pms_RBF_diag.items() if v is not None}`;
    await this._py.ex`res_RBF_diag = bridgeRBF[${this.id}].diag(**pms_RBF_diag)`;
    return this._py`res_RBF_diag.tolist() if hasattr(res_RBF_diag, 'tolist') else res_RBF_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before is_stationary()");
    }
    await this._py.ex`pms_RBF_is_stationary = {}

pms_RBF_is_stationary = {k: v for k, v in pms_RBF_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RBF_is_stationary = bridgeRBF[${this.id}].is_stationary(**pms_RBF_is_stationary)`;
    return this._py`res_RBF_is_stationary.tolist() if hasattr(res_RBF_is_stationary, 'tolist') else res_RBF_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_RBF_anisotropic = bridgeRBF[${this.id}].anisotropic`;
      return this._py`attr_RBF_anisotropic.tolist() if hasattr(attr_RBF_anisotropic, 'tolist') else attr_RBF_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBF must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBF_hyperparameter_length_scale = bridgeRBF[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RBF_hyperparameter_length_scale.tolist() if hasattr(attr_RBF_hyperparameter_length_scale, 'tolist') else attr_RBF_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Sum.ts
import crypto108 from "node:crypto";
var Sum = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Sum${crypto108.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Sum.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Sum
try: bridgeSum
except NameError: bridgeSum = {}
`;
    await this._py.ex`ctor_Sum = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Sum = {k: v for k, v in ctor_Sum.items() if v is not None}`;
    await this._py.ex`bridgeSum[${this.id}] = Sum(**ctor_Sum)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSum[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before __call__()");
    }
    await this._py.ex`pms_Sum___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Sum___call__ = {k: v for k, v in pms_Sum___call__.items() if v is not None}`;
    await this._py.ex`res_Sum___call__ = bridgeSum[${this.id}].__call__(**pms_Sum___call__)`;
    return this._py`res_Sum___call__.tolist() if hasattr(res_Sum___call__, 'tolist') else res_Sum___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Sum_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Sum_clone_with_theta = {k: v for k, v in pms_Sum_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Sum_clone_with_theta = bridgeSum[${this.id}].clone_with_theta(**pms_Sum_clone_with_theta)`;
    return this._py`res_Sum_clone_with_theta.tolist() if hasattr(res_Sum_clone_with_theta, 'tolist') else res_Sum_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before diag()");
    }
    await this._py.ex`pms_Sum_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Sum_diag = {k: v for k, v in pms_Sum_diag.items() if v is not None}`;
    await this._py.ex`res_Sum_diag = bridgeSum[${this.id}].diag(**pms_Sum_diag)`;
    return this._py`res_Sum_diag.tolist() if hasattr(res_Sum_diag, 'tolist') else res_Sum_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before is_stationary()");
    }
    await this._py.ex`pms_Sum_is_stationary = {}

pms_Sum_is_stationary = {k: v for k, v in pms_Sum_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Sum_is_stationary = bridgeSum[${this.id}].is_stationary(**pms_Sum_is_stationary)`;
    return this._py`res_Sum_is_stationary.tolist() if hasattr(res_Sum_is_stationary, 'tolist') else res_Sum_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/WhiteKernel.ts
import crypto109 from "node:crypto";
var WhiteKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `WhiteKernel${crypto109.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("WhiteKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import WhiteKernel
try: bridgeWhiteKernel
except NameError: bridgeWhiteKernel = {}
`;
    await this._py.ex`ctor_WhiteKernel = {'noise_level': ${this.opts["noise_level"] ?? void 0}, 'noise_level_bounds': ${this.opts["noise_level_bounds"] ?? void 0}}

ctor_WhiteKernel = {k: v for k, v in ctor_WhiteKernel.items() if v is not None}`;
    await this._py.ex`bridgeWhiteKernel[${this.id}] = WhiteKernel(**ctor_WhiteKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeWhiteKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before __call__()");
    }
    await this._py.ex`pms_WhiteKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_WhiteKernel___call__ = {k: v for k, v in pms_WhiteKernel___call__.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel___call__ = bridgeWhiteKernel[${this.id}].__call__(**pms_WhiteKernel___call__)`;
    return this._py`res_WhiteKernel___call__.tolist() if hasattr(res_WhiteKernel___call__, 'tolist') else res_WhiteKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_WhiteKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_WhiteKernel_clone_with_theta = {k: v for k, v in pms_WhiteKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_clone_with_theta = bridgeWhiteKernel[${this.id}].clone_with_theta(**pms_WhiteKernel_clone_with_theta)`;
    return this._py`res_WhiteKernel_clone_with_theta.tolist() if hasattr(res_WhiteKernel_clone_with_theta, 'tolist') else res_WhiteKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before diag()");
    }
    await this._py.ex`pms_WhiteKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_WhiteKernel_diag = {k: v for k, v in pms_WhiteKernel_diag.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_diag = bridgeWhiteKernel[${this.id}].diag(**pms_WhiteKernel_diag)`;
    return this._py`res_WhiteKernel_diag.tolist() if hasattr(res_WhiteKernel_diag, 'tolist') else res_WhiteKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_WhiteKernel_is_stationary = {}

pms_WhiteKernel_is_stationary = {k: v for k, v in pms_WhiteKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_is_stationary = bridgeWhiteKernel[${this.id}].is_stationary(**pms_WhiteKernel_is_stationary)`;
    return this._py`res_WhiteKernel_is_stationary.tolist() if hasattr(res_WhiteKernel_is_stationary, 'tolist') else res_WhiteKernel_is_stationary`;
  }
  get hyperparameter_noise_level() {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "WhiteKernel must call init() before accessing hyperparameter_noise_level"
      );
    }
    return (async () => {
      await this._py.ex`attr_WhiteKernel_hyperparameter_noise_level = bridgeWhiteKernel[${this.id}].hyperparameter_noise_level`;
      return this._py`attr_WhiteKernel_hyperparameter_noise_level.tolist() if hasattr(attr_WhiteKernel_hyperparameter_noise_level, 'tolist') else attr_WhiteKernel_hyperparameter_noise_level`;
    })();
  }
};

// src/generated/impute/IterativeImputer.ts
import crypto110 from "node:crypto";
var IterativeImputer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `IterativeImputer${crypto110.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IterativeImputer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.impute import IterativeImputer
try: bridgeIterativeImputer
except NameError: bridgeIterativeImputer = {}
`;
    await this._py.ex`ctor_IterativeImputer = {'estimator': ${this.opts["estimator"] ?? void 0}, 'missing_values': ${this.opts["missing_values"] ?? void 0}, 'sample_posterior': ${this.opts["sample_posterior"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'n_nearest_features': ${this.opts["n_nearest_features"] ?? void 0}, 'initial_strategy': ${this.opts["initial_strategy"] ?? void 0}, 'fill_value': ${this.opts["fill_value"] ?? void 0}, 'imputation_order': ${this.opts["imputation_order"] ?? void 0}, 'skip_complete': ${this.opts["skip_complete"] ?? void 0}, 'min_value': np.array(${this.opts["min_value"] ?? void 0}) if ${this.opts["min_value"] !== void 0} else None, 'max_value': np.array(${this.opts["max_value"] ?? void 0}) if ${this.opts["max_value"] !== void 0} else None, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'add_indicator': ${this.opts["add_indicator"] ?? void 0}, 'keep_empty_features': ${this.opts["keep_empty_features"] ?? void 0}}

ctor_IterativeImputer = {k: v for k, v in ctor_IterativeImputer.items() if v is not None}`;
    await this._py.ex`bridgeIterativeImputer[${this.id}] = IterativeImputer(**ctor_IterativeImputer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIterativeImputer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the imputer on `X` and return self.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IterativeImputer must call init() before fit()");
    }
    await this._py.ex`pms_IterativeImputer_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_IterativeImputer_fit = {k: v for k, v in pms_IterativeImputer_fit.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_fit = bridgeIterativeImputer[${this.id}].fit(**pms_IterativeImputer_fit)`;
    return this._py`res_IterativeImputer_fit.tolist() if hasattr(res_IterativeImputer_fit, 'tolist') else res_IterativeImputer_fit`;
  }
  /**
    Fit the imputer on `X` and return the transformed `X`.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_IterativeImputer_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_IterativeImputer_fit_transform = {k: v for k, v in pms_IterativeImputer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_fit_transform = bridgeIterativeImputer[${this.id}].fit_transform(**pms_IterativeImputer_fit_transform)`;
    return this._py`res_IterativeImputer_fit_transform.tolist() if hasattr(res_IterativeImputer_fit_transform, 'tolist') else res_IterativeImputer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_IterativeImputer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_IterativeImputer_get_feature_names_out = {k: v for k, v in pms_IterativeImputer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_get_feature_names_out = bridgeIterativeImputer[${this.id}].get_feature_names_out(**pms_IterativeImputer_get_feature_names_out)`;
    return this._py`res_IterativeImputer_get_feature_names_out.tolist() if hasattr(res_IterativeImputer_get_feature_names_out, 'tolist') else res_IterativeImputer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IterativeImputer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IterativeImputer_get_metadata_routing = {k: v for k, v in pms_IterativeImputer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_get_metadata_routing = bridgeIterativeImputer[${this.id}].get_metadata_routing(**pms_IterativeImputer_get_metadata_routing)`;
    return this._py`res_IterativeImputer_get_metadata_routing.tolist() if hasattr(res_IterativeImputer_get_metadata_routing, 'tolist') else res_IterativeImputer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IterativeImputer must call init() before set_output()");
    }
    await this._py.ex`pms_IterativeImputer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_IterativeImputer_set_output = {k: v for k, v in pms_IterativeImputer_set_output.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_set_output = bridgeIterativeImputer[${this.id}].set_output(**pms_IterativeImputer_set_output)`;
    return this._py`res_IterativeImputer_set_output.tolist() if hasattr(res_IterativeImputer_set_output, 'tolist') else res_IterativeImputer_set_output`;
  }
  /**
      Impute all missing values in `X`.
  
      Note that this is stochastic, and that if `random\_state` is not fixed, repeated calls, or permuted input, results will differ.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IterativeImputer must call init() before transform()");
    }
    await this._py.ex`pms_IterativeImputer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IterativeImputer_transform = {k: v for k, v in pms_IterativeImputer_transform.items() if v is not None}`;
    await this._py.ex`res_IterativeImputer_transform = bridgeIterativeImputer[${this.id}].transform(**pms_IterativeImputer_transform)`;
    return this._py`res_IterativeImputer_transform.tolist() if hasattr(res_IterativeImputer_transform, 'tolist') else res_IterativeImputer_transform`;
  }
  /**
    Imputer used to initialize the missing values.
   */
  get initial_imputer_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing initial_imputer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_initial_imputer_ = bridgeIterativeImputer[${this.id}].initial_imputer_`;
      return this._py`attr_IterativeImputer_initial_imputer_.tolist() if hasattr(attr_IterativeImputer_initial_imputer_, 'tolist') else attr_IterativeImputer_initial_imputer_`;
    })();
  }
  /**
    Each tuple has `(feat\_idx, neighbor\_feat\_idx, estimator)`, where `feat\_idx` is the current feature to be imputed, `neighbor\_feat\_idx` is the array of other features used to impute the current feature, and `estimator` is the trained estimator used for the imputation. Length is `self.n\_features\_with\_missing\_ \* self.n\_iter\_`.
   */
  get imputation_sequence_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing imputation_sequence_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_imputation_sequence_ = bridgeIterativeImputer[${this.id}].imputation_sequence_`;
      return this._py`attr_IterativeImputer_imputation_sequence_.tolist() if hasattr(attr_IterativeImputer_imputation_sequence_, 'tolist') else attr_IterativeImputer_imputation_sequence_`;
    })();
  }
  /**
    Number of iteration rounds that occurred. Will be less than `self.max\_iter` if early stopping criterion was reached.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_n_iter_ = bridgeIterativeImputer[${this.id}].n_iter_`;
      return this._py`attr_IterativeImputer_n_iter_.tolist() if hasattr(attr_IterativeImputer_n_iter_, 'tolist') else attr_IterativeImputer_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_n_features_in_ = bridgeIterativeImputer[${this.id}].n_features_in_`;
      return this._py`attr_IterativeImputer_n_features_in_.tolist() if hasattr(attr_IterativeImputer_n_features_in_, 'tolist') else attr_IterativeImputer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_feature_names_in_ = bridgeIterativeImputer[${this.id}].feature_names_in_`;
      return this._py`attr_IterativeImputer_feature_names_in_.tolist() if hasattr(attr_IterativeImputer_feature_names_in_, 'tolist') else attr_IterativeImputer_feature_names_in_`;
    })();
  }
  /**
    Number of features with missing values.
   */
  get n_features_with_missing_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing n_features_with_missing_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_n_features_with_missing_ = bridgeIterativeImputer[${this.id}].n_features_with_missing_`;
      return this._py`attr_IterativeImputer_n_features_with_missing_.tolist() if hasattr(attr_IterativeImputer_n_features_with_missing_, 'tolist') else attr_IterativeImputer_n_features_with_missing_`;
    })();
  }
  /**
    Indicator used to add binary indicators for missing values. `undefined` if `add\_indicator=False`.
   */
  get indicator_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing indicator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_indicator_ = bridgeIterativeImputer[${this.id}].indicator_`;
      return this._py`attr_IterativeImputer_indicator_.tolist() if hasattr(attr_IterativeImputer_indicator_, 'tolist') else attr_IterativeImputer_indicator_`;
    })();
  }
  /**
    RandomState instance that is generated either from a seed, the random number generator or by `np.random`.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This IterativeImputer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IterativeImputer must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IterativeImputer_random_state_ = bridgeIterativeImputer[${this.id}].random_state_`;
      return this._py`attr_IterativeImputer_random_state_.tolist() if hasattr(attr_IterativeImputer_random_state_, 'tolist') else attr_IterativeImputer_random_state_`;
    })();
  }
};

// src/generated/impute/KNNImputer.ts
import crypto111 from "node:crypto";
var KNNImputer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNNImputer${crypto111.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KNNImputer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.impute import KNNImputer
try: bridgeKNNImputer
except NameError: bridgeKNNImputer = {}
`;
    await this._py.ex`ctor_KNNImputer = {'missing_values': ${this.opts["missing_values"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'add_indicator': ${this.opts["add_indicator"] ?? void 0}, 'keep_empty_features': ${this.opts["keep_empty_features"] ?? void 0}}

ctor_KNNImputer = {k: v for k, v in ctor_KNNImputer.items() if v is not None}`;
    await this._py.ex`bridgeKNNImputer[${this.id}] = KNNImputer(**ctor_KNNImputer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNNImputer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the imputer on X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KNNImputer must call init() before fit()");
    }
    await this._py.ex`pms_KNNImputer_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_KNNImputer_fit = {k: v for k, v in pms_KNNImputer_fit.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_fit = bridgeKNNImputer[${this.id}].fit(**pms_KNNImputer_fit)`;
    return this._py`res_KNNImputer_fit.tolist() if hasattr(res_KNNImputer_fit, 'tolist') else res_KNNImputer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KNNImputer must call init() before fit_transform()");
    }
    await this._py.ex`pms_KNNImputer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_KNNImputer_fit_transform = {k: v for k, v in pms_KNNImputer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_fit_transform = bridgeKNNImputer[${this.id}].fit_transform(**pms_KNNImputer_fit_transform)`;
    return this._py`res_KNNImputer_fit_transform.tolist() if hasattr(res_KNNImputer_fit_transform, 'tolist') else res_KNNImputer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNNImputer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KNNImputer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KNNImputer_get_feature_names_out = {k: v for k, v in pms_KNNImputer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_get_feature_names_out = bridgeKNNImputer[${this.id}].get_feature_names_out(**pms_KNNImputer_get_feature_names_out)`;
    return this._py`res_KNNImputer_get_feature_names_out.tolist() if hasattr(res_KNNImputer_get_feature_names_out, 'tolist') else res_KNNImputer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNNImputer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNNImputer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNNImputer_get_metadata_routing = {k: v for k, v in pms_KNNImputer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_get_metadata_routing = bridgeKNNImputer[${this.id}].get_metadata_routing(**pms_KNNImputer_get_metadata_routing)`;
    return this._py`res_KNNImputer_get_metadata_routing.tolist() if hasattr(res_KNNImputer_get_metadata_routing, 'tolist') else res_KNNImputer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KNNImputer must call init() before set_output()");
    }
    await this._py.ex`pms_KNNImputer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KNNImputer_set_output = {k: v for k, v in pms_KNNImputer_set_output.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_set_output = bridgeKNNImputer[${this.id}].set_output(**pms_KNNImputer_set_output)`;
    return this._py`res_KNNImputer_set_output.tolist() if hasattr(res_KNNImputer_set_output, 'tolist') else res_KNNImputer_set_output`;
  }
  /**
    Impute all missing values in X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KNNImputer must call init() before transform()");
    }
    await this._py.ex`pms_KNNImputer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNNImputer_transform = {k: v for k, v in pms_KNNImputer_transform.items() if v is not None}`;
    await this._py.ex`res_KNNImputer_transform = bridgeKNNImputer[${this.id}].transform(**pms_KNNImputer_transform)`;
    return this._py`res_KNNImputer_transform.tolist() if hasattr(res_KNNImputer_transform, 'tolist') else res_KNNImputer_transform`;
  }
  /**
    Indicator used to add binary indicators for missing values. `undefined` if add\_indicator is `false`.
   */
  get indicator_() {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KNNImputer must call init() before accessing indicator_");
    }
    return (async () => {
      await this._py.ex`attr_KNNImputer_indicator_ = bridgeKNNImputer[${this.id}].indicator_`;
      return this._py`attr_KNNImputer_indicator_.tolist() if hasattr(attr_KNNImputer_indicator_, 'tolist') else attr_KNNImputer_indicator_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNNImputer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNNImputer_n_features_in_ = bridgeKNNImputer[${this.id}].n_features_in_`;
      return this._py`attr_KNNImputer_n_features_in_.tolist() if hasattr(attr_KNNImputer_n_features_in_, 'tolist') else attr_KNNImputer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KNNImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNNImputer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNNImputer_feature_names_in_ = bridgeKNNImputer[${this.id}].feature_names_in_`;
      return this._py`attr_KNNImputer_feature_names_in_.tolist() if hasattr(attr_KNNImputer_feature_names_in_, 'tolist') else attr_KNNImputer_feature_names_in_`;
    })();
  }
};

// src/generated/impute/MissingIndicator.ts
import crypto112 from "node:crypto";
var MissingIndicator = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MissingIndicator${crypto112.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MissingIndicator.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.impute import MissingIndicator
try: bridgeMissingIndicator
except NameError: bridgeMissingIndicator = {}
`;
    await this._py.ex`ctor_MissingIndicator = {'missing_values': ${this.opts["missing_values"] ?? void 0}, 'features': ${this.opts["features"] ?? void 0}, 'sparse': ${this.opts["sparse"] ?? void 0}, 'error_on_new': ${this.opts["error_on_new"] ?? void 0}}

ctor_MissingIndicator = {k: v for k, v in ctor_MissingIndicator.items() if v is not None}`;
    await this._py.ex`bridgeMissingIndicator[${this.id}] = MissingIndicator(**ctor_MissingIndicator)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMissingIndicator[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the transformer on `X`.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MissingIndicator must call init() before fit()");
    }
    await this._py.ex`pms_MissingIndicator_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MissingIndicator_fit = {k: v for k, v in pms_MissingIndicator_fit.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_fit = bridgeMissingIndicator[${this.id}].fit(**pms_MissingIndicator_fit)`;
    return this._py`res_MissingIndicator_fit.tolist() if hasattr(res_MissingIndicator_fit, 'tolist') else res_MissingIndicator_fit`;
  }
  /**
    Generate missing values indicator for `X`.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MissingIndicator_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MissingIndicator_fit_transform = {k: v for k, v in pms_MissingIndicator_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_fit_transform = bridgeMissingIndicator[${this.id}].fit_transform(**pms_MissingIndicator_fit_transform)`;
    return this._py`res_MissingIndicator_fit_transform.tolist() if hasattr(res_MissingIndicator_fit_transform, 'tolist') else res_MissingIndicator_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MissingIndicator_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MissingIndicator_get_feature_names_out = {k: v for k, v in pms_MissingIndicator_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_get_feature_names_out = bridgeMissingIndicator[${this.id}].get_feature_names_out(**pms_MissingIndicator_get_feature_names_out)`;
    return this._py`res_MissingIndicator_get_feature_names_out.tolist() if hasattr(res_MissingIndicator_get_feature_names_out, 'tolist') else res_MissingIndicator_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MissingIndicator_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MissingIndicator_get_metadata_routing = {k: v for k, v in pms_MissingIndicator_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_get_metadata_routing = bridgeMissingIndicator[${this.id}].get_metadata_routing(**pms_MissingIndicator_get_metadata_routing)`;
    return this._py`res_MissingIndicator_get_metadata_routing.tolist() if hasattr(res_MissingIndicator_get_metadata_routing, 'tolist') else res_MissingIndicator_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MissingIndicator must call init() before set_output()");
    }
    await this._py.ex`pms_MissingIndicator_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MissingIndicator_set_output = {k: v for k, v in pms_MissingIndicator_set_output.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_set_output = bridgeMissingIndicator[${this.id}].set_output(**pms_MissingIndicator_set_output)`;
    return this._py`res_MissingIndicator_set_output.tolist() if hasattr(res_MissingIndicator_set_output, 'tolist') else res_MissingIndicator_set_output`;
  }
  /**
    Generate missing values indicator for `X`.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MissingIndicator must call init() before transform()");
    }
    await this._py.ex`pms_MissingIndicator_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MissingIndicator_transform = {k: v for k, v in pms_MissingIndicator_transform.items() if v is not None}`;
    await this._py.ex`res_MissingIndicator_transform = bridgeMissingIndicator[${this.id}].transform(**pms_MissingIndicator_transform)`;
    return this._py`res_MissingIndicator_transform.tolist() if hasattr(res_MissingIndicator_transform, 'tolist') else res_MissingIndicator_transform`;
  }
  /**
    The features indices which will be returned when calling [`transform`](#sklearn.impute.MissingIndicator.transform "sklearn.impute.MissingIndicator.transform"). They are computed during [`fit`](#sklearn.impute.MissingIndicator.fit "sklearn.impute.MissingIndicator.fit"). If `features='all'`, `features\_` is equal to `range(n\_features)`.
   */
  get features_() {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before accessing features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MissingIndicator_features_ = bridgeMissingIndicator[${this.id}].features_`;
      return this._py`attr_MissingIndicator_features_.tolist() if hasattr(attr_MissingIndicator_features_, 'tolist') else attr_MissingIndicator_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MissingIndicator_n_features_in_ = bridgeMissingIndicator[${this.id}].n_features_in_`;
      return this._py`attr_MissingIndicator_n_features_in_.tolist() if hasattr(attr_MissingIndicator_n_features_in_, 'tolist') else attr_MissingIndicator_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MissingIndicator instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MissingIndicator must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MissingIndicator_feature_names_in_ = bridgeMissingIndicator[${this.id}].feature_names_in_`;
      return this._py`attr_MissingIndicator_feature_names_in_.tolist() if hasattr(attr_MissingIndicator_feature_names_in_, 'tolist') else attr_MissingIndicator_feature_names_in_`;
    })();
  }
};

// src/generated/impute/SimpleImputer.ts
import crypto113 from "node:crypto";
var SimpleImputer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SimpleImputer${crypto113.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SimpleImputer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.impute import SimpleImputer
try: bridgeSimpleImputer
except NameError: bridgeSimpleImputer = {}
`;
    await this._py.ex`ctor_SimpleImputer = {'missing_values': ${this.opts["missing_values"] ?? void 0}, 'strategy': ${this.opts["strategy"] ?? void 0}, 'fill_value': ${this.opts["fill_value"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'add_indicator': ${this.opts["add_indicator"] ?? void 0}, 'keep_empty_features': ${this.opts["keep_empty_features"] ?? void 0}}

ctor_SimpleImputer = {k: v for k, v in ctor_SimpleImputer.items() if v is not None}`;
    await this._py.ex`bridgeSimpleImputer[${this.id}] = SimpleImputer(**ctor_SimpleImputer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSimpleImputer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the imputer on `X`.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SimpleImputer must call init() before fit()");
    }
    await this._py.ex`pms_SimpleImputer_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_SimpleImputer_fit = {k: v for k, v in pms_SimpleImputer_fit.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_fit = bridgeSimpleImputer[${this.id}].fit(**pms_SimpleImputer_fit)`;
    return this._py`res_SimpleImputer_fit.tolist() if hasattr(res_SimpleImputer_fit, 'tolist') else res_SimpleImputer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SimpleImputer must call init() before fit_transform()");
    }
    await this._py.ex`pms_SimpleImputer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SimpleImputer_fit_transform = {k: v for k, v in pms_SimpleImputer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_fit_transform = bridgeSimpleImputer[${this.id}].fit_transform(**pms_SimpleImputer_fit_transform)`;
    return this._py`res_SimpleImputer_fit_transform.tolist() if hasattr(res_SimpleImputer_fit_transform, 'tolist') else res_SimpleImputer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SimpleImputer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SimpleImputer_get_feature_names_out = {k: v for k, v in pms_SimpleImputer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_get_feature_names_out = bridgeSimpleImputer[${this.id}].get_feature_names_out(**pms_SimpleImputer_get_feature_names_out)`;
    return this._py`res_SimpleImputer_get_feature_names_out.tolist() if hasattr(res_SimpleImputer_get_feature_names_out, 'tolist') else res_SimpleImputer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SimpleImputer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SimpleImputer_get_metadata_routing = {k: v for k, v in pms_SimpleImputer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_get_metadata_routing = bridgeSimpleImputer[${this.id}].get_metadata_routing(**pms_SimpleImputer_get_metadata_routing)`;
    return this._py`res_SimpleImputer_get_metadata_routing.tolist() if hasattr(res_SimpleImputer_get_metadata_routing, 'tolist') else res_SimpleImputer_get_metadata_routing`;
  }
  /**
      Convert the data back to the original representation.
  
      Inverts the `transform` operation performed on an array. This operation can only be performed after [`SimpleImputer`](#sklearn.impute.SimpleImputer "sklearn.impute.SimpleImputer") is instantiated with `add\_indicator=True`.
  
      Note that `inverse\_transform` can only invert the transform in features that have binary indicators for missing values. If a feature has no missing values at `fit` time, the feature wonâ€™t have a binary indicator, and the imputation done at `transform` time wonâ€™t be inverted.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SimpleImputer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SimpleImputer_inverse_transform = {k: v for k, v in pms_SimpleImputer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_inverse_transform = bridgeSimpleImputer[${this.id}].inverse_transform(**pms_SimpleImputer_inverse_transform)`;
    return this._py`res_SimpleImputer_inverse_transform.tolist() if hasattr(res_SimpleImputer_inverse_transform, 'tolist') else res_SimpleImputer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SimpleImputer must call init() before set_output()");
    }
    await this._py.ex`pms_SimpleImputer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SimpleImputer_set_output = {k: v for k, v in pms_SimpleImputer_set_output.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_set_output = bridgeSimpleImputer[${this.id}].set_output(**pms_SimpleImputer_set_output)`;
    return this._py`res_SimpleImputer_set_output.tolist() if hasattr(res_SimpleImputer_set_output, 'tolist') else res_SimpleImputer_set_output`;
  }
  /**
    Impute all missing values in `X`.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SimpleImputer must call init() before transform()");
    }
    await this._py.ex`pms_SimpleImputer_transform = {'X': ${opts["X"] ?? void 0}}

pms_SimpleImputer_transform = {k: v for k, v in pms_SimpleImputer_transform.items() if v is not None}`;
    await this._py.ex`res_SimpleImputer_transform = bridgeSimpleImputer[${this.id}].transform(**pms_SimpleImputer_transform)`;
    return this._py`res_SimpleImputer_transform.tolist() if hasattr(res_SimpleImputer_transform, 'tolist') else res_SimpleImputer_transform`;
  }
  /**
    The imputation fill value for each feature. Computing statistics can result in `np.nan` values. During [`transform`](#sklearn.impute.SimpleImputer.transform "sklearn.impute.SimpleImputer.transform"), features corresponding to `np.nan` statistics will be discarded.
   */
  get statistics_() {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before accessing statistics_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SimpleImputer_statistics_ = bridgeSimpleImputer[${this.id}].statistics_`;
      return this._py`attr_SimpleImputer_statistics_.tolist() if hasattr(attr_SimpleImputer_statistics_, 'tolist') else attr_SimpleImputer_statistics_`;
    })();
  }
  /**
    Indicator used to add binary indicators for missing values. `undefined` if `add\_indicator=False`.
   */
  get indicator_() {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before accessing indicator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SimpleImputer_indicator_ = bridgeSimpleImputer[${this.id}].indicator_`;
      return this._py`attr_SimpleImputer_indicator_.tolist() if hasattr(attr_SimpleImputer_indicator_, 'tolist') else attr_SimpleImputer_indicator_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SimpleImputer_n_features_in_ = bridgeSimpleImputer[${this.id}].n_features_in_`;
      return this._py`attr_SimpleImputer_n_features_in_.tolist() if hasattr(attr_SimpleImputer_n_features_in_, 'tolist') else attr_SimpleImputer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SimpleImputer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SimpleImputer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SimpleImputer_feature_names_in_ = bridgeSimpleImputer[${this.id}].feature_names_in_`;
      return this._py`attr_SimpleImputer_feature_names_in_.tolist() if hasattr(attr_SimpleImputer_feature_names_in_, 'tolist') else attr_SimpleImputer_feature_names_in_`;
    })();
  }
};

// src/generated/inspection/DecisionBoundaryDisplay.ts
import crypto114 from "node:crypto";
var DecisionBoundaryDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DecisionBoundaryDisplay${crypto114.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DecisionBoundaryDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.inspection import DecisionBoundaryDisplay
try: bridgeDecisionBoundaryDisplay
except NameError: bridgeDecisionBoundaryDisplay = {}
`;
    await this._py.ex`ctor_DecisionBoundaryDisplay = {'xx0': np.array(${this.opts["xx0"] ?? void 0}) if ${this.opts["xx0"] !== void 0} else None, 'xx1': np.array(${this.opts["xx1"] ?? void 0}) if ${this.opts["xx1"] !== void 0} else None, 'response': np.array(${this.opts["response"] ?? void 0}) if ${this.opts["response"] !== void 0} else None, 'xlabel': ${this.opts["xlabel"] ?? void 0}, 'ylabel': ${this.opts["ylabel"] ?? void 0}}

ctor_DecisionBoundaryDisplay = {k: v for k, v in ctor_DecisionBoundaryDisplay.items() if v is not None}`;
    await this._py.ex`bridgeDecisionBoundaryDisplay[${this.id}] = DecisionBoundaryDisplay(**ctor_DecisionBoundaryDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDecisionBoundaryDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot decision boundary given an estimator.
  
      Read more in the [User Guide](../../visualizations.html#visualizations).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionBoundaryDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_DecisionBoundaryDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'grid_resolution': ${opts["grid_resolution"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'plot_method': ${opts["plot_method"] ?? void 0}, 'response_method': ${opts["response_method"] ?? void 0}, 'xlabel': ${opts["xlabel"] ?? void 0}, 'ylabel': ${opts["ylabel"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DecisionBoundaryDisplay_from_estimator = {k: v for k, v in pms_DecisionBoundaryDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_DecisionBoundaryDisplay_from_estimator = bridgeDecisionBoundaryDisplay[${this.id}].from_estimator(**pms_DecisionBoundaryDisplay_from_estimator)`;
    return this._py`res_DecisionBoundaryDisplay_from_estimator.tolist() if hasattr(res_DecisionBoundaryDisplay_from_estimator, 'tolist') else res_DecisionBoundaryDisplay_from_estimator`;
  }
  /**
    Plot visualization.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionBoundaryDisplay must call init() before plot()");
    }
    await this._py.ex`pms_DecisionBoundaryDisplay_plot = {'plot_method': ${opts["plot_method"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'xlabel': ${opts["xlabel"] ?? void 0}, 'ylabel': ${opts["ylabel"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DecisionBoundaryDisplay_plot = {k: v for k, v in pms_DecisionBoundaryDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_DecisionBoundaryDisplay_plot = bridgeDecisionBoundaryDisplay[${this.id}].plot(**pms_DecisionBoundaryDisplay_plot)`;
    return this._py`res_DecisionBoundaryDisplay_plot.tolist() if hasattr(res_DecisionBoundaryDisplay_plot, 'tolist') else res_DecisionBoundaryDisplay_plot`;
  }
  /**
    If `plot\_method` is â€˜contourâ€™ or â€˜contourfâ€™, `surface\_` is a [`QuadContourSet`](https://matplotlib.org/stable/api/contour_api.html#matplotlib.contour.QuadContourSet "(in Matplotlib v3.8.1)"). If `plot\_method` is â€˜pcolormeshâ€™, `surface\_` is a [`QuadMesh`](https://matplotlib.org/stable/api/collections_api.html#matplotlib.collections.QuadMesh "(in Matplotlib v3.8.1)").
   */
  get surface_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionBoundaryDisplay must call init() before accessing surface_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionBoundaryDisplay_surface_ = bridgeDecisionBoundaryDisplay[${this.id}].surface_`;
      return this._py`attr_DecisionBoundaryDisplay_surface_.tolist() if hasattr(attr_DecisionBoundaryDisplay_surface_, 'tolist') else attr_DecisionBoundaryDisplay_surface_`;
    })();
  }
  /**
    Axes with confusion matrix.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionBoundaryDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionBoundaryDisplay_ax_ = bridgeDecisionBoundaryDisplay[${this.id}].ax_`;
      return this._py`attr_DecisionBoundaryDisplay_ax_.tolist() if hasattr(attr_DecisionBoundaryDisplay_ax_, 'tolist') else attr_DecisionBoundaryDisplay_ax_`;
    })();
  }
  /**
    Figure containing the confusion matrix.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionBoundaryDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionBoundaryDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionBoundaryDisplay_figure_ = bridgeDecisionBoundaryDisplay[${this.id}].figure_`;
      return this._py`attr_DecisionBoundaryDisplay_figure_.tolist() if hasattr(attr_DecisionBoundaryDisplay_figure_, 'tolist') else attr_DecisionBoundaryDisplay_figure_`;
    })();
  }
};

// src/generated/inspection/PartialDependenceDisplay.ts
import crypto115 from "node:crypto";
var PartialDependenceDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PartialDependenceDisplay${crypto115.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PartialDependenceDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.inspection import PartialDependenceDisplay
try: bridgePartialDependenceDisplay
except NameError: bridgePartialDependenceDisplay = {}
`;
    await this._py.ex`ctor_PartialDependenceDisplay = {'pd_results': ${this.opts["pd_results"] ?? void 0}, 'features': ${this.opts["features"] ?? void 0}, 'feature_names': ${this.opts["feature_names"] ?? void 0}, 'target_idx': ${this.opts["target_idx"] ?? void 0}, 'deciles': ${this.opts["deciles"] ?? void 0}, 'kind': ${this.opts["kind"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'is_categorical': ${this.opts["is_categorical"] ?? void 0}}

ctor_PartialDependenceDisplay = {k: v for k, v in ctor_PartialDependenceDisplay.items() if v is not None}`;
    await this._py.ex`bridgePartialDependenceDisplay[${this.id}] = PartialDependenceDisplay(**ctor_PartialDependenceDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePartialDependenceDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Partial dependence (PD) and individual conditional expectation (ICE) plots.
  
      Partial dependence plots, individual conditional expectation plots or an overlay of both of them can be plotted by setting the `kind` parameter. The `len(features)` plots are arranged in a grid with `n\_cols` columns. Two-way partial dependence plots are plotted as contour plots. The deciles of the feature values will be shown with tick marks on the x-axes for one-way plots, and on both axes for two-way plots.
  
      Read more in the [User Guide](../partial_dependence.html#partial-dependence).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_PartialDependenceDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'features': ${opts["features"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'categorical_features': np.array(${opts["categorical_features"] ?? void 0}) if ${opts["categorical_features"] !== void 0} else None, 'feature_names': np.array(${opts["feature_names"] ?? void 0}) if ${opts["feature_names"] !== void 0} else None, 'target': ${opts["target"] ?? void 0}, 'response_method': ${opts["response_method"] ?? void 0}, 'n_cols': ${opts["n_cols"] ?? void 0}, 'grid_resolution': ${opts["grid_resolution"] ?? void 0}, 'percentiles': ${opts["percentiles"] ?? void 0}, 'method': ${opts["method"] ?? void 0}, 'n_jobs': ${opts["n_jobs"] ?? void 0}, 'verbose': ${opts["verbose"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'ice_lines_kw': ${opts["ice_lines_kw"] ?? void 0}, 'pd_line_kw': ${opts["pd_line_kw"] ?? void 0}, 'contour_kw': ${opts["contour_kw"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kind': ${opts["kind"] ?? void 0}, 'centered': ${opts["centered"] ?? void 0}, 'subsample': ${opts["subsample"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_PartialDependenceDisplay_from_estimator = {k: v for k, v in pms_PartialDependenceDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_PartialDependenceDisplay_from_estimator = bridgePartialDependenceDisplay[${this.id}].from_estimator(**pms_PartialDependenceDisplay_from_estimator)`;
    return this._py`res_PartialDependenceDisplay_from_estimator.tolist() if hasattr(res_PartialDependenceDisplay_from_estimator, 'tolist') else res_PartialDependenceDisplay_from_estimator`;
  }
  /**
    Plot partial dependence plots.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PartialDependenceDisplay must call init() before plot()");
    }
    await this._py.ex`pms_PartialDependenceDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'n_cols': ${opts["n_cols"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'ice_lines_kw': ${opts["ice_lines_kw"] ?? void 0}, 'pd_line_kw': ${opts["pd_line_kw"] ?? void 0}, 'contour_kw': ${opts["contour_kw"] ?? void 0}, 'bar_kw': ${opts["bar_kw"] ?? void 0}, 'heatmap_kw': ${opts["heatmap_kw"] ?? void 0}, 'pdp_lim': ${opts["pdp_lim"] ?? void 0}, 'centered': ${opts["centered"] ?? void 0}}

pms_PartialDependenceDisplay_plot = {k: v for k, v in pms_PartialDependenceDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_PartialDependenceDisplay_plot = bridgePartialDependenceDisplay[${this.id}].plot(**pms_PartialDependenceDisplay_plot)`;
    return this._py`res_PartialDependenceDisplay_plot.tolist() if hasattr(res_PartialDependenceDisplay_plot, 'tolist') else res_PartialDependenceDisplay_plot`;
  }
  /**
    If `ax` is an axes or `undefined`, the `bounding\_ax\_` is the axes where the grid of partial dependence plots are drawn. If `ax` is a list of axes or a numpy array of axes, `bounding\_ax\_` is `undefined`.
   */
  get bounding_ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing bounding_ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_bounding_ax_ = bridgePartialDependenceDisplay[${this.id}].bounding_ax_`;
      return this._py`attr_PartialDependenceDisplay_bounding_ax_.tolist() if hasattr(attr_PartialDependenceDisplay_bounding_ax_, 'tolist') else attr_PartialDependenceDisplay_bounding_ax_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `axes\_\[i, j\]` is the axes on the i-th row and j-th column. If `ax` is a list of axes, `axes\_\[i\]` is the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes in that position.
   */
  get axes_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing axes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_axes_ = bridgePartialDependenceDisplay[${this.id}].axes_`;
      return this._py`attr_PartialDependenceDisplay_axes_.tolist() if hasattr(attr_PartialDependenceDisplay_axes_, 'tolist') else attr_PartialDependenceDisplay_axes_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `lines\_\[i, j\]` is the partial dependence curve on the i-th row and j-th column. If `ax` is a list of axes, `lines\_\[i\]` is the partial dependence curve corresponding to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a line plot.
   */
  get lines_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing lines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_lines_ = bridgePartialDependenceDisplay[${this.id}].lines_`;
      return this._py`attr_PartialDependenceDisplay_lines_.tolist() if hasattr(attr_PartialDependenceDisplay_lines_, 'tolist') else attr_PartialDependenceDisplay_lines_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `vlines\_\[i, j\]` is the line collection representing the x axis deciles of the i-th row and j-th column. If `ax` is a list of axes, `vlines\_\[i\]` corresponds to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a PDP plot.
   */
  get deciles_vlines_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing deciles_vlines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_deciles_vlines_ = bridgePartialDependenceDisplay[${this.id}].deciles_vlines_`;
      return this._py`attr_PartialDependenceDisplay_deciles_vlines_.tolist() if hasattr(attr_PartialDependenceDisplay_deciles_vlines_, 'tolist') else attr_PartialDependenceDisplay_deciles_vlines_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `vlines\_\[i, j\]` is the line collection representing the y axis deciles of the i-th row and j-th column. If `ax` is a list of axes, `vlines\_\[i\]` corresponds to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a 2-way plot.
   */
  get deciles_hlines_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing deciles_hlines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_deciles_hlines_ = bridgePartialDependenceDisplay[${this.id}].deciles_hlines_`;
      return this._py`attr_PartialDependenceDisplay_deciles_hlines_.tolist() if hasattr(attr_PartialDependenceDisplay_deciles_hlines_, 'tolist') else attr_PartialDependenceDisplay_deciles_hlines_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `contours\_\[i, j\]` is the partial dependence plot on the i-th row and j-th column. If `ax` is a list of axes, `contours\_\[i\]` is the partial dependence plot corresponding to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a contour plot.
   */
  get contours_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing contours_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_contours_ = bridgePartialDependenceDisplay[${this.id}].contours_`;
      return this._py`attr_PartialDependenceDisplay_contours_.tolist() if hasattr(attr_PartialDependenceDisplay_contours_, 'tolist') else attr_PartialDependenceDisplay_contours_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `bars\_\[i, j\]` is the partial dependence bar plot on the i-th row and j-th column (for a categorical feature). If `ax` is a list of axes, `bars\_\[i\]` is the partial dependence bar plot corresponding to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a bar plot.
   */
  get bars_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing bars_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_bars_ = bridgePartialDependenceDisplay[${this.id}].bars_`;
      return this._py`attr_PartialDependenceDisplay_bars_.tolist() if hasattr(attr_PartialDependenceDisplay_bars_, 'tolist') else attr_PartialDependenceDisplay_bars_`;
    })();
  }
  /**
    If `ax` is an axes or `undefined`, `heatmaps\_\[i, j\]` is the partial dependence heatmap on the i-th row and j-th column (for a pair of categorical features) . If `ax` is a list of axes, `heatmaps\_\[i\]` is the partial dependence heatmap corresponding to the i-th item in `ax`. Elements that are `undefined` correspond to a nonexisting axes or an axes that does not include a heatmap.
   */
  get heatmaps_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing heatmaps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_heatmaps_ = bridgePartialDependenceDisplay[${this.id}].heatmaps_`;
      return this._py`attr_PartialDependenceDisplay_heatmaps_.tolist() if hasattr(attr_PartialDependenceDisplay_heatmaps_, 'tolist') else attr_PartialDependenceDisplay_heatmaps_`;
    })();
  }
  /**
    Figure containing partial dependence plots.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This PartialDependenceDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PartialDependenceDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PartialDependenceDisplay_figure_ = bridgePartialDependenceDisplay[${this.id}].figure_`;
      return this._py`attr_PartialDependenceDisplay_figure_.tolist() if hasattr(attr_PartialDependenceDisplay_figure_, 'tolist') else attr_PartialDependenceDisplay_figure_`;
    })();
  }
};

// src/generated/isotonic/IsotonicRegression.ts
import crypto116 from "node:crypto";
var IsotonicRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `IsotonicRegression${crypto116.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "IsotonicRegression.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.isotonic import IsotonicRegression
try: bridgeIsotonicRegression
except NameError: bridgeIsotonicRegression = {}
`;
    await this._py.ex`ctor_IsotonicRegression = {'y_min': ${this.opts["y_min"] ?? void 0}, 'y_max': ${this.opts["y_max"] ?? void 0}, 'increasing': ${this.opts["increasing"] ?? void 0}, 'out_of_bounds': ${this.opts["out_of_bounds"] ?? void 0}}

ctor_IsotonicRegression = {k: v for k, v in ctor_IsotonicRegression.items() if v is not None}`;
    await this._py.ex`bridgeIsotonicRegression[${this.id}] = IsotonicRegression(**ctor_IsotonicRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIsotonicRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before fit()");
    }
    await this._py.ex`pms_IsotonicRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_IsotonicRegression_fit = {k: v for k, v in pms_IsotonicRegression_fit.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_fit = bridgeIsotonicRegression[${this.id}].fit(**pms_IsotonicRegression_fit)`;
    return this._py`res_IsotonicRegression_fit.tolist() if hasattr(res_IsotonicRegression_fit, 'tolist') else res_IsotonicRegression_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_IsotonicRegression_fit_transform = {k: v for k, v in pms_IsotonicRegression_fit_transform.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_fit_transform = bridgeIsotonicRegression[${this.id}].fit_transform(**pms_IsotonicRegression_fit_transform)`;
    return this._py`res_IsotonicRegression_fit_transform.tolist() if hasattr(res_IsotonicRegression_fit_transform, 'tolist') else res_IsotonicRegression_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_IsotonicRegression_get_feature_names_out = {k: v for k, v in pms_IsotonicRegression_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_get_feature_names_out = bridgeIsotonicRegression[${this.id}].get_feature_names_out(**pms_IsotonicRegression_get_feature_names_out)`;
    return this._py`res_IsotonicRegression_get_feature_names_out.tolist() if hasattr(res_IsotonicRegression_get_feature_names_out, 'tolist') else res_IsotonicRegression_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IsotonicRegression_get_metadata_routing = {k: v for k, v in pms_IsotonicRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_get_metadata_routing = bridgeIsotonicRegression[${this.id}].get_metadata_routing(**pms_IsotonicRegression_get_metadata_routing)`;
    return this._py`res_IsotonicRegression_get_metadata_routing.tolist() if hasattr(res_IsotonicRegression_get_metadata_routing, 'tolist') else res_IsotonicRegression_get_metadata_routing`;
  }
  /**
    Predict new data by linear interpolation.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before predict()");
    }
    await this._py.ex`pms_IsotonicRegression_predict = {'T': np.array(${opts["T"] ?? void 0}) if ${opts["T"] !== void 0} else None}

pms_IsotonicRegression_predict = {k: v for k, v in pms_IsotonicRegression_predict.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_predict = bridgeIsotonicRegression[${this.id}].predict(**pms_IsotonicRegression_predict)`;
    return this._py`res_IsotonicRegression_predict.tolist() if hasattr(res_IsotonicRegression_predict, 'tolist') else res_IsotonicRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before score()");
    }
    await this._py.ex`pms_IsotonicRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_IsotonicRegression_score = {k: v for k, v in pms_IsotonicRegression_score.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_score = bridgeIsotonicRegression[${this.id}].score(**pms_IsotonicRegression_score)`;
    return this._py`res_IsotonicRegression_score.tolist() if hasattr(res_IsotonicRegression_score, 'tolist') else res_IsotonicRegression_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_IsotonicRegression_set_fit_request = {k: v for k, v in pms_IsotonicRegression_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_set_fit_request = bridgeIsotonicRegression[${this.id}].set_fit_request(**pms_IsotonicRegression_set_fit_request)`;
    return this._py`res_IsotonicRegression_set_fit_request.tolist() if hasattr(res_IsotonicRegression_set_fit_request, 'tolist') else res_IsotonicRegression_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before set_output()");
    }
    await this._py.ex`pms_IsotonicRegression_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_IsotonicRegression_set_output = {k: v for k, v in pms_IsotonicRegression_set_output.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_set_output = bridgeIsotonicRegression[${this.id}].set_output(**pms_IsotonicRegression_set_output)`;
    return this._py`res_IsotonicRegression_set_output.tolist() if hasattr(res_IsotonicRegression_set_output, 'tolist') else res_IsotonicRegression_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_set_predict_request = {'T': ${opts["T"] ?? void 0}}

pms_IsotonicRegression_set_predict_request = {k: v for k, v in pms_IsotonicRegression_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_set_predict_request = bridgeIsotonicRegression[${this.id}].set_predict_request(**pms_IsotonicRegression_set_predict_request)`;
    return this._py`res_IsotonicRegression_set_predict_request.tolist() if hasattr(res_IsotonicRegression_set_predict_request, 'tolist') else res_IsotonicRegression_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_IsotonicRegression_set_score_request = {k: v for k, v in pms_IsotonicRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_set_score_request = bridgeIsotonicRegression[${this.id}].set_score_request(**pms_IsotonicRegression_set_score_request)`;
    return this._py`res_IsotonicRegression_set_score_request.tolist() if hasattr(res_IsotonicRegression_set_score_request, 'tolist') else res_IsotonicRegression_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_IsotonicRegression_set_transform_request = {'T': ${opts["T"] ?? void 0}}

pms_IsotonicRegression_set_transform_request = {k: v for k, v in pms_IsotonicRegression_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_set_transform_request = bridgeIsotonicRegression[${this.id}].set_transform_request(**pms_IsotonicRegression_set_transform_request)`;
    return this._py`res_IsotonicRegression_set_transform_request.tolist() if hasattr(res_IsotonicRegression_set_transform_request, 'tolist') else res_IsotonicRegression_set_transform_request`;
  }
  /**
    Transform new data by linear interpolation.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before transform()");
    }
    await this._py.ex`pms_IsotonicRegression_transform = {'T': np.array(${opts["T"] ?? void 0}) if ${opts["T"] !== void 0} else None}

pms_IsotonicRegression_transform = {k: v for k, v in pms_IsotonicRegression_transform.items() if v is not None}`;
    await this._py.ex`res_IsotonicRegression_transform = bridgeIsotonicRegression[${this.id}].transform(**pms_IsotonicRegression_transform)`;
    return this._py`res_IsotonicRegression_transform.tolist() if hasattr(res_IsotonicRegression_transform, 'tolist') else res_IsotonicRegression_transform`;
  }
  /**
    Minimum value of input array `X\_` for left bound.
   */
  get X_min_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before accessing X_min_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_X_min_ = bridgeIsotonicRegression[${this.id}].X_min_`;
      return this._py`attr_IsotonicRegression_X_min_.tolist() if hasattr(attr_IsotonicRegression_X_min_, 'tolist') else attr_IsotonicRegression_X_min_`;
    })();
  }
  /**
    Maximum value of input array `X\_` for right bound.
   */
  get X_max_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before accessing X_max_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_X_max_ = bridgeIsotonicRegression[${this.id}].X_max_`;
      return this._py`attr_IsotonicRegression_X_max_.tolist() if hasattr(attr_IsotonicRegression_X_max_, 'tolist') else attr_IsotonicRegression_X_max_`;
    })();
  }
  /**
    Unique ascending `X` values used to interpolate the y = f(X) monotonic function.
   */
  get X_thresholds_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before accessing X_thresholds_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_X_thresholds_ = bridgeIsotonicRegression[${this.id}].X_thresholds_`;
      return this._py`attr_IsotonicRegression_X_thresholds_.tolist() if hasattr(attr_IsotonicRegression_X_thresholds_, 'tolist') else attr_IsotonicRegression_X_thresholds_`;
    })();
  }
  /**
    De-duplicated `y` values suitable to interpolate the y = f(X) monotonic function.
   */
  get y_thresholds_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before accessing y_thresholds_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_y_thresholds_ = bridgeIsotonicRegression[${this.id}].y_thresholds_`;
      return this._py`attr_IsotonicRegression_y_thresholds_.tolist() if hasattr(attr_IsotonicRegression_y_thresholds_, 'tolist') else attr_IsotonicRegression_y_thresholds_`;
    })();
  }
  /**
    The stepwise interpolating function that covers the input domain `X`.
   */
  get f_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("IsotonicRegression must call init() before accessing f_");
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_f_ = bridgeIsotonicRegression[${this.id}].f_`;
      return this._py`attr_IsotonicRegression_f_.tolist() if hasattr(attr_IsotonicRegression_f_, 'tolist') else attr_IsotonicRegression_f_`;
    })();
  }
  /**
    Inferred value for `increasing`.
   */
  get increasing_() {
    if (this._isDisposed) {
      throw new Error(
        "This IsotonicRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsotonicRegression must call init() before accessing increasing_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsotonicRegression_increasing_ = bridgeIsotonicRegression[${this.id}].increasing_`;
      return this._py`attr_IsotonicRegression_increasing_.tolist() if hasattr(attr_IsotonicRegression_increasing_, 'tolist') else attr_IsotonicRegression_increasing_`;
    })();
  }
};

// src/generated/kernel_approximation/AdditiveChi2Sampler.ts
import crypto117 from "node:crypto";
var AdditiveChi2Sampler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AdditiveChi2Sampler${crypto117.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AdditiveChi2Sampler.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_approximation import AdditiveChi2Sampler
try: bridgeAdditiveChi2Sampler
except NameError: bridgeAdditiveChi2Sampler = {}
`;
    await this._py.ex`ctor_AdditiveChi2Sampler = {'sample_steps': ${this.opts["sample_steps"] ?? void 0}, 'sample_interval': ${this.opts["sample_interval"] ?? void 0}}

ctor_AdditiveChi2Sampler = {k: v for k, v in ctor_AdditiveChi2Sampler.items() if v is not None}`;
    await this._py.ex`bridgeAdditiveChi2Sampler[${this.id}] = AdditiveChi2Sampler(**ctor_AdditiveChi2Sampler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdditiveChi2Sampler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdditiveChi2Sampler must call init() before fit()");
    }
    await this._py.ex`pms_AdditiveChi2Sampler_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_AdditiveChi2Sampler_fit = {k: v for k, v in pms_AdditiveChi2Sampler_fit.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_fit = bridgeAdditiveChi2Sampler[${this.id}].fit(**pms_AdditiveChi2Sampler_fit)`;
    return this._py`res_AdditiveChi2Sampler_fit.tolist() if hasattr(res_AdditiveChi2Sampler_fit, 'tolist') else res_AdditiveChi2Sampler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_AdditiveChi2Sampler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_AdditiveChi2Sampler_fit_transform = {k: v for k, v in pms_AdditiveChi2Sampler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_fit_transform = bridgeAdditiveChi2Sampler[${this.id}].fit_transform(**pms_AdditiveChi2Sampler_fit_transform)`;
    return this._py`res_AdditiveChi2Sampler_fit_transform.tolist() if hasattr(res_AdditiveChi2Sampler_fit_transform, 'tolist') else res_AdditiveChi2Sampler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_AdditiveChi2Sampler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_AdditiveChi2Sampler_get_feature_names_out = {k: v for k, v in pms_AdditiveChi2Sampler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_get_feature_names_out = bridgeAdditiveChi2Sampler[${this.id}].get_feature_names_out(**pms_AdditiveChi2Sampler_get_feature_names_out)`;
    return this._py`res_AdditiveChi2Sampler_get_feature_names_out.tolist() if hasattr(res_AdditiveChi2Sampler_get_feature_names_out, 'tolist') else res_AdditiveChi2Sampler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AdditiveChi2Sampler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AdditiveChi2Sampler_get_metadata_routing = {k: v for k, v in pms_AdditiveChi2Sampler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_get_metadata_routing = bridgeAdditiveChi2Sampler[${this.id}].get_metadata_routing(**pms_AdditiveChi2Sampler_get_metadata_routing)`;
    return this._py`res_AdditiveChi2Sampler_get_metadata_routing.tolist() if hasattr(res_AdditiveChi2Sampler_get_metadata_routing, 'tolist') else res_AdditiveChi2Sampler_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before set_output()"
      );
    }
    await this._py.ex`pms_AdditiveChi2Sampler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_AdditiveChi2Sampler_set_output = {k: v for k, v in pms_AdditiveChi2Sampler_set_output.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_set_output = bridgeAdditiveChi2Sampler[${this.id}].set_output(**pms_AdditiveChi2Sampler_set_output)`;
    return this._py`res_AdditiveChi2Sampler_set_output.tolist() if hasattr(res_AdditiveChi2Sampler_set_output, 'tolist') else res_AdditiveChi2Sampler_set_output`;
  }
  /**
    Apply approximate feature map to X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdditiveChi2Sampler must call init() before transform()");
    }
    await this._py.ex`pms_AdditiveChi2Sampler_transform = {'X': ${opts["X"] ?? void 0}}

pms_AdditiveChi2Sampler_transform = {k: v for k, v in pms_AdditiveChi2Sampler_transform.items() if v is not None}`;
    await this._py.ex`res_AdditiveChi2Sampler_transform = bridgeAdditiveChi2Sampler[${this.id}].transform(**pms_AdditiveChi2Sampler_transform)`;
    return this._py`res_AdditiveChi2Sampler_transform.tolist() if hasattr(res_AdditiveChi2Sampler_transform, 'tolist') else res_AdditiveChi2Sampler_transform`;
  }
  /**
    Stored sampling interval. Specified as a parameter if `sample\_steps` not in {1,2,3}.
   */
  get sample_interval_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before accessing sample_interval_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdditiveChi2Sampler_sample_interval_ = bridgeAdditiveChi2Sampler[${this.id}].sample_interval_`;
      return this._py`attr_AdditiveChi2Sampler_sample_interval_.tolist() if hasattr(attr_AdditiveChi2Sampler_sample_interval_, 'tolist') else attr_AdditiveChi2Sampler_sample_interval_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdditiveChi2Sampler_n_features_in_ = bridgeAdditiveChi2Sampler[${this.id}].n_features_in_`;
      return this._py`attr_AdditiveChi2Sampler_n_features_in_.tolist() if hasattr(attr_AdditiveChi2Sampler_n_features_in_, 'tolist') else attr_AdditiveChi2Sampler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdditiveChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdditiveChi2Sampler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdditiveChi2Sampler_feature_names_in_ = bridgeAdditiveChi2Sampler[${this.id}].feature_names_in_`;
      return this._py`attr_AdditiveChi2Sampler_feature_names_in_.tolist() if hasattr(attr_AdditiveChi2Sampler_feature_names_in_, 'tolist') else attr_AdditiveChi2Sampler_feature_names_in_`;
    })();
  }
};

// src/generated/kernel_approximation/Nystroem.ts
import crypto118 from "node:crypto";
var Nystroem = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Nystroem${crypto118.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Nystroem.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_approximation import Nystroem
try: bridgeNystroem
except NameError: bridgeNystroem = {}
`;
    await this._py.ex`ctor_Nystroem = {'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_Nystroem = {k: v for k, v in ctor_Nystroem.items() if v is not None}`;
    await this._py.ex`bridgeNystroem[${this.id}] = Nystroem(**ctor_Nystroem)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNystroem[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit estimator to data.
  
      Samples a subset of training points, computes kernel on these and computes normalization matrix.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before fit()");
    }
    await this._py.ex`pms_Nystroem_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_Nystroem_fit = {k: v for k, v in pms_Nystroem_fit.items() if v is not None}`;
    await this._py.ex`res_Nystroem_fit = bridgeNystroem[${this.id}].fit(**pms_Nystroem_fit)`;
    return this._py`res_Nystroem_fit.tolist() if hasattr(res_Nystroem_fit, 'tolist') else res_Nystroem_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before fit_transform()");
    }
    await this._py.ex`pms_Nystroem_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Nystroem_fit_transform = {k: v for k, v in pms_Nystroem_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Nystroem_fit_transform = bridgeNystroem[${this.id}].fit_transform(**pms_Nystroem_fit_transform)`;
    return this._py`res_Nystroem_fit_transform.tolist() if hasattr(res_Nystroem_fit_transform, 'tolist') else res_Nystroem_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Nystroem must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Nystroem_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Nystroem_get_feature_names_out = {k: v for k, v in pms_Nystroem_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Nystroem_get_feature_names_out = bridgeNystroem[${this.id}].get_feature_names_out(**pms_Nystroem_get_feature_names_out)`;
    return this._py`res_Nystroem_get_feature_names_out.tolist() if hasattr(res_Nystroem_get_feature_names_out, 'tolist') else res_Nystroem_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Nystroem_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Nystroem_get_metadata_routing = {k: v for k, v in pms_Nystroem_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Nystroem_get_metadata_routing = bridgeNystroem[${this.id}].get_metadata_routing(**pms_Nystroem_get_metadata_routing)`;
    return this._py`res_Nystroem_get_metadata_routing.tolist() if hasattr(res_Nystroem_get_metadata_routing, 'tolist') else res_Nystroem_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before set_output()");
    }
    await this._py.ex`pms_Nystroem_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Nystroem_set_output = {k: v for k, v in pms_Nystroem_set_output.items() if v is not None}`;
    await this._py.ex`res_Nystroem_set_output = bridgeNystroem[${this.id}].set_output(**pms_Nystroem_set_output)`;
    return this._py`res_Nystroem_set_output.tolist() if hasattr(res_Nystroem_set_output, 'tolist') else res_Nystroem_set_output`;
  }
  /**
      Apply feature map to X.
  
      Computes an approximate feature map using the kernel between some training points and X.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before transform()");
    }
    await this._py.ex`pms_Nystroem_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Nystroem_transform = {k: v for k, v in pms_Nystroem_transform.items() if v is not None}`;
    await this._py.ex`res_Nystroem_transform = bridgeNystroem[${this.id}].transform(**pms_Nystroem_transform)`;
    return this._py`res_Nystroem_transform.tolist() if hasattr(res_Nystroem_transform, 'tolist') else res_Nystroem_transform`;
  }
  /**
    Subset of training points used to construct the feature map.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Nystroem must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_Nystroem_components_ = bridgeNystroem[${this.id}].components_`;
      return this._py`attr_Nystroem_components_.tolist() if hasattr(attr_Nystroem_components_, 'tolist') else attr_Nystroem_components_`;
    })();
  }
  /**
    Indices of `components\_` in the training set.
   */
  get component_indices_() {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Nystroem must call init() before accessing component_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Nystroem_component_indices_ = bridgeNystroem[${this.id}].component_indices_`;
      return this._py`attr_Nystroem_component_indices_.tolist() if hasattr(attr_Nystroem_component_indices_, 'tolist') else attr_Nystroem_component_indices_`;
    })();
  }
  /**
    Normalization matrix needed for embedding. Square root of the kernel matrix on `components\_`.
   */
  get normalization_() {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Nystroem must call init() before accessing normalization_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Nystroem_normalization_ = bridgeNystroem[${this.id}].normalization_`;
      return this._py`attr_Nystroem_normalization_.tolist() if hasattr(attr_Nystroem_normalization_, 'tolist') else attr_Nystroem_normalization_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Nystroem must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Nystroem_n_features_in_ = bridgeNystroem[${this.id}].n_features_in_`;
      return this._py`attr_Nystroem_n_features_in_.tolist() if hasattr(attr_Nystroem_n_features_in_, 'tolist') else attr_Nystroem_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Nystroem instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Nystroem must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Nystroem_feature_names_in_ = bridgeNystroem[${this.id}].feature_names_in_`;
      return this._py`attr_Nystroem_feature_names_in_.tolist() if hasattr(attr_Nystroem_feature_names_in_, 'tolist') else attr_Nystroem_feature_names_in_`;
    })();
  }
};

// src/generated/kernel_approximation/PolynomialCountSketch.ts
import crypto119 from "node:crypto";
var PolynomialCountSketch = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PolynomialCountSketch${crypto119.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PolynomialCountSketch.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_approximation import PolynomialCountSketch
try: bridgePolynomialCountSketch
except NameError: bridgePolynomialCountSketch = {}
`;
    await this._py.ex`ctor_PolynomialCountSketch = {'gamma': ${this.opts["gamma"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_PolynomialCountSketch = {k: v for k, v in ctor_PolynomialCountSketch.items() if v is not None}`;
    await this._py.ex`bridgePolynomialCountSketch[${this.id}] = PolynomialCountSketch(**ctor_PolynomialCountSketch)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePolynomialCountSketch[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit the model with X.
  
      Initializes the internal variables. The method needs no information about the distribution of data, so we only care about n\_features in X.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialCountSketch must call init() before fit()");
    }
    await this._py.ex`pms_PolynomialCountSketch_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PolynomialCountSketch_fit = {k: v for k, v in pms_PolynomialCountSketch_fit.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_fit = bridgePolynomialCountSketch[${this.id}].fit(**pms_PolynomialCountSketch_fit)`;
    return this._py`res_PolynomialCountSketch_fit.tolist() if hasattr(res_PolynomialCountSketch_fit, 'tolist') else res_PolynomialCountSketch_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_PolynomialCountSketch_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_PolynomialCountSketch_fit_transform = {k: v for k, v in pms_PolynomialCountSketch_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_fit_transform = bridgePolynomialCountSketch[${this.id}].fit_transform(**pms_PolynomialCountSketch_fit_transform)`;
    return this._py`res_PolynomialCountSketch_fit_transform.tolist() if hasattr(res_PolynomialCountSketch_fit_transform, 'tolist') else res_PolynomialCountSketch_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PolynomialCountSketch_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PolynomialCountSketch_get_feature_names_out = {k: v for k, v in pms_PolynomialCountSketch_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_get_feature_names_out = bridgePolynomialCountSketch[${this.id}].get_feature_names_out(**pms_PolynomialCountSketch_get_feature_names_out)`;
    return this._py`res_PolynomialCountSketch_get_feature_names_out.tolist() if hasattr(res_PolynomialCountSketch_get_feature_names_out, 'tolist') else res_PolynomialCountSketch_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PolynomialCountSketch_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PolynomialCountSketch_get_metadata_routing = {k: v for k, v in pms_PolynomialCountSketch_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_get_metadata_routing = bridgePolynomialCountSketch[${this.id}].get_metadata_routing(**pms_PolynomialCountSketch_get_metadata_routing)`;
    return this._py`res_PolynomialCountSketch_get_metadata_routing.tolist() if hasattr(res_PolynomialCountSketch_get_metadata_routing, 'tolist') else res_PolynomialCountSketch_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before set_output()"
      );
    }
    await this._py.ex`pms_PolynomialCountSketch_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PolynomialCountSketch_set_output = {k: v for k, v in pms_PolynomialCountSketch_set_output.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_set_output = bridgePolynomialCountSketch[${this.id}].set_output(**pms_PolynomialCountSketch_set_output)`;
    return this._py`res_PolynomialCountSketch_set_output.tolist() if hasattr(res_PolynomialCountSketch_set_output, 'tolist') else res_PolynomialCountSketch_set_output`;
  }
  /**
    Generate the feature map approximation for X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before transform()"
      );
    }
    await this._py.ex`pms_PolynomialCountSketch_transform = {'X': ${opts["X"] ?? void 0}}

pms_PolynomialCountSketch_transform = {k: v for k, v in pms_PolynomialCountSketch_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialCountSketch_transform = bridgePolynomialCountSketch[${this.id}].transform(**pms_PolynomialCountSketch_transform)`;
    return this._py`res_PolynomialCountSketch_transform.tolist() if hasattr(res_PolynomialCountSketch_transform, 'tolist') else res_PolynomialCountSketch_transform`;
  }
  /**
    Array of indexes in range \[0, n\_components) used to represent the 2-wise independent hash functions for Count Sketch computation.
   */
  get indexHash_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before accessing indexHash_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialCountSketch_indexHash_ = bridgePolynomialCountSketch[${this.id}].indexHash_`;
      return this._py`attr_PolynomialCountSketch_indexHash_.tolist() if hasattr(attr_PolynomialCountSketch_indexHash_, 'tolist') else attr_PolynomialCountSketch_indexHash_`;
    })();
  }
  /**
    Array with random entries in {+1, -1}, used to represent the 2-wise independent hash functions for Count Sketch computation.
   */
  get bitHash_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before accessing bitHash_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialCountSketch_bitHash_ = bridgePolynomialCountSketch[${this.id}].bitHash_`;
      return this._py`attr_PolynomialCountSketch_bitHash_.tolist() if hasattr(attr_PolynomialCountSketch_bitHash_, 'tolist') else attr_PolynomialCountSketch_bitHash_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialCountSketch_n_features_in_ = bridgePolynomialCountSketch[${this.id}].n_features_in_`;
      return this._py`attr_PolynomialCountSketch_n_features_in_.tolist() if hasattr(attr_PolynomialCountSketch_n_features_in_, 'tolist') else attr_PolynomialCountSketch_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialCountSketch instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialCountSketch must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialCountSketch_feature_names_in_ = bridgePolynomialCountSketch[${this.id}].feature_names_in_`;
      return this._py`attr_PolynomialCountSketch_feature_names_in_.tolist() if hasattr(attr_PolynomialCountSketch_feature_names_in_, 'tolist') else attr_PolynomialCountSketch_feature_names_in_`;
    })();
  }
};

// src/generated/kernel_approximation/RBFSampler.ts
import crypto120 from "node:crypto";
var RBFSampler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RBFSampler${crypto120.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RBFSampler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_approximation import RBFSampler
try: bridgeRBFSampler
except NameError: bridgeRBFSampler = {}
`;
    await this._py.ex`ctor_RBFSampler = {'gamma': ${this.opts["gamma"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RBFSampler = {k: v for k, v in ctor_RBFSampler.items() if v is not None}`;
    await this._py.ex`bridgeRBFSampler[${this.id}] = RBFSampler(**ctor_RBFSampler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRBFSampler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit the model with X.
  
      Samples random projection according to n\_features.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBFSampler must call init() before fit()");
    }
    await this._py.ex`pms_RBFSampler_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_RBFSampler_fit = {k: v for k, v in pms_RBFSampler_fit.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_fit = bridgeRBFSampler[${this.id}].fit(**pms_RBFSampler_fit)`;
    return this._py`res_RBFSampler_fit.tolist() if hasattr(res_RBFSampler_fit, 'tolist') else res_RBFSampler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBFSampler must call init() before fit_transform()");
    }
    await this._py.ex`pms_RBFSampler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RBFSampler_fit_transform = {k: v for k, v in pms_RBFSampler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_fit_transform = bridgeRBFSampler[${this.id}].fit_transform(**pms_RBFSampler_fit_transform)`;
    return this._py`res_RBFSampler_fit_transform.tolist() if hasattr(res_RBFSampler_fit_transform, 'tolist') else res_RBFSampler_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RBFSampler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RBFSampler_get_feature_names_out = {k: v for k, v in pms_RBFSampler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_get_feature_names_out = bridgeRBFSampler[${this.id}].get_feature_names_out(**pms_RBFSampler_get_feature_names_out)`;
    return this._py`res_RBFSampler_get_feature_names_out.tolist() if hasattr(res_RBFSampler_get_feature_names_out, 'tolist') else res_RBFSampler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RBFSampler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RBFSampler_get_metadata_routing = {k: v for k, v in pms_RBFSampler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_get_metadata_routing = bridgeRBFSampler[${this.id}].get_metadata_routing(**pms_RBFSampler_get_metadata_routing)`;
    return this._py`res_RBFSampler_get_metadata_routing.tolist() if hasattr(res_RBFSampler_get_metadata_routing, 'tolist') else res_RBFSampler_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBFSampler must call init() before set_output()");
    }
    await this._py.ex`pms_RBFSampler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RBFSampler_set_output = {k: v for k, v in pms_RBFSampler_set_output.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_set_output = bridgeRBFSampler[${this.id}].set_output(**pms_RBFSampler_set_output)`;
    return this._py`res_RBFSampler_set_output.tolist() if hasattr(res_RBFSampler_set_output, 'tolist') else res_RBFSampler_set_output`;
  }
  /**
    Apply the approximate feature map to X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBFSampler must call init() before transform()");
    }
    await this._py.ex`pms_RBFSampler_transform = {'X': ${opts["X"] ?? void 0}}

pms_RBFSampler_transform = {k: v for k, v in pms_RBFSampler_transform.items() if v is not None}`;
    await this._py.ex`res_RBFSampler_transform = bridgeRBFSampler[${this.id}].transform(**pms_RBFSampler_transform)`;
    return this._py`res_RBFSampler_transform.tolist() if hasattr(res_RBFSampler_transform, 'tolist') else res_RBFSampler_transform`;
  }
  /**
    Random offset used to compute the projection in the `n\_components` dimensions of the feature space.
   */
  get random_offset_() {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before accessing random_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBFSampler_random_offset_ = bridgeRBFSampler[${this.id}].random_offset_`;
      return this._py`attr_RBFSampler_random_offset_.tolist() if hasattr(attr_RBFSampler_random_offset_, 'tolist') else attr_RBFSampler_random_offset_`;
    })();
  }
  /**
    Random projection directions drawn from the Fourier transform of the RBF kernel.
   */
  get random_weights_() {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before accessing random_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBFSampler_random_weights_ = bridgeRBFSampler[${this.id}].random_weights_`;
      return this._py`attr_RBFSampler_random_weights_.tolist() if hasattr(attr_RBFSampler_random_weights_, 'tolist') else attr_RBFSampler_random_weights_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBFSampler_n_features_in_ = bridgeRBFSampler[${this.id}].n_features_in_`;
      return this._py`attr_RBFSampler_n_features_in_.tolist() if hasattr(attr_RBFSampler_n_features_in_, 'tolist') else attr_RBFSampler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RBFSampler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBFSampler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBFSampler_feature_names_in_ = bridgeRBFSampler[${this.id}].feature_names_in_`;
      return this._py`attr_RBFSampler_feature_names_in_.tolist() if hasattr(attr_RBFSampler_feature_names_in_, 'tolist') else attr_RBFSampler_feature_names_in_`;
    })();
  }
};

// src/generated/kernel_approximation/SkewedChi2Sampler.ts
import crypto121 from "node:crypto";
var SkewedChi2Sampler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SkewedChi2Sampler${crypto121.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SkewedChi2Sampler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_approximation import SkewedChi2Sampler
try: bridgeSkewedChi2Sampler
except NameError: bridgeSkewedChi2Sampler = {}
`;
    await this._py.ex`ctor_SkewedChi2Sampler = {'skewedness': ${this.opts["skewedness"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SkewedChi2Sampler = {k: v for k, v in ctor_SkewedChi2Sampler.items() if v is not None}`;
    await this._py.ex`bridgeSkewedChi2Sampler[${this.id}] = SkewedChi2Sampler(**ctor_SkewedChi2Sampler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSkewedChi2Sampler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit the model with X.
  
      Samples random projection according to n\_features.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SkewedChi2Sampler must call init() before fit()");
    }
    await this._py.ex`pms_SkewedChi2Sampler_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_SkewedChi2Sampler_fit = {k: v for k, v in pms_SkewedChi2Sampler_fit.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_fit = bridgeSkewedChi2Sampler[${this.id}].fit(**pms_SkewedChi2Sampler_fit)`;
    return this._py`res_SkewedChi2Sampler_fit.tolist() if hasattr(res_SkewedChi2Sampler_fit, 'tolist') else res_SkewedChi2Sampler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SkewedChi2Sampler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SkewedChi2Sampler_fit_transform = {k: v for k, v in pms_SkewedChi2Sampler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_fit_transform = bridgeSkewedChi2Sampler[${this.id}].fit_transform(**pms_SkewedChi2Sampler_fit_transform)`;
    return this._py`res_SkewedChi2Sampler_fit_transform.tolist() if hasattr(res_SkewedChi2Sampler_fit_transform, 'tolist') else res_SkewedChi2Sampler_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SkewedChi2Sampler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SkewedChi2Sampler_get_feature_names_out = {k: v for k, v in pms_SkewedChi2Sampler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_get_feature_names_out = bridgeSkewedChi2Sampler[${this.id}].get_feature_names_out(**pms_SkewedChi2Sampler_get_feature_names_out)`;
    return this._py`res_SkewedChi2Sampler_get_feature_names_out.tolist() if hasattr(res_SkewedChi2Sampler_get_feature_names_out, 'tolist') else res_SkewedChi2Sampler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SkewedChi2Sampler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SkewedChi2Sampler_get_metadata_routing = {k: v for k, v in pms_SkewedChi2Sampler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_get_metadata_routing = bridgeSkewedChi2Sampler[${this.id}].get_metadata_routing(**pms_SkewedChi2Sampler_get_metadata_routing)`;
    return this._py`res_SkewedChi2Sampler_get_metadata_routing.tolist() if hasattr(res_SkewedChi2Sampler_get_metadata_routing, 'tolist') else res_SkewedChi2Sampler_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SkewedChi2Sampler must call init() before set_output()");
    }
    await this._py.ex`pms_SkewedChi2Sampler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SkewedChi2Sampler_set_output = {k: v for k, v in pms_SkewedChi2Sampler_set_output.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_set_output = bridgeSkewedChi2Sampler[${this.id}].set_output(**pms_SkewedChi2Sampler_set_output)`;
    return this._py`res_SkewedChi2Sampler_set_output.tolist() if hasattr(res_SkewedChi2Sampler_set_output, 'tolist') else res_SkewedChi2Sampler_set_output`;
  }
  /**
    Apply the approximate feature map to X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SkewedChi2Sampler must call init() before transform()");
    }
    await this._py.ex`pms_SkewedChi2Sampler_transform = {'X': ${opts["X"] ?? void 0}}

pms_SkewedChi2Sampler_transform = {k: v for k, v in pms_SkewedChi2Sampler_transform.items() if v is not None}`;
    await this._py.ex`res_SkewedChi2Sampler_transform = bridgeSkewedChi2Sampler[${this.id}].transform(**pms_SkewedChi2Sampler_transform)`;
    return this._py`res_SkewedChi2Sampler_transform.tolist() if hasattr(res_SkewedChi2Sampler_transform, 'tolist') else res_SkewedChi2Sampler_transform`;
  }
  /**
    Weight array, sampled from a secant hyperbolic distribution, which will be used to linearly transform the log of the data.
   */
  get random_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before accessing random_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SkewedChi2Sampler_random_weights_ = bridgeSkewedChi2Sampler[${this.id}].random_weights_`;
      return this._py`attr_SkewedChi2Sampler_random_weights_.tolist() if hasattr(attr_SkewedChi2Sampler_random_weights_, 'tolist') else attr_SkewedChi2Sampler_random_weights_`;
    })();
  }
  /**
    Bias term, which will be added to the data. It is uniformly distributed between 0 and 2\*pi.
   */
  get random_offset_() {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before accessing random_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SkewedChi2Sampler_random_offset_ = bridgeSkewedChi2Sampler[${this.id}].random_offset_`;
      return this._py`attr_SkewedChi2Sampler_random_offset_.tolist() if hasattr(attr_SkewedChi2Sampler_random_offset_, 'tolist') else attr_SkewedChi2Sampler_random_offset_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SkewedChi2Sampler_n_features_in_ = bridgeSkewedChi2Sampler[${this.id}].n_features_in_`;
      return this._py`attr_SkewedChi2Sampler_n_features_in_.tolist() if hasattr(attr_SkewedChi2Sampler_n_features_in_, 'tolist') else attr_SkewedChi2Sampler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SkewedChi2Sampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SkewedChi2Sampler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SkewedChi2Sampler_feature_names_in_ = bridgeSkewedChi2Sampler[${this.id}].feature_names_in_`;
      return this._py`attr_SkewedChi2Sampler_feature_names_in_.tolist() if hasattr(attr_SkewedChi2Sampler_feature_names_in_, 'tolist') else attr_SkewedChi2Sampler_feature_names_in_`;
    })();
  }
};

// src/generated/kernel_ridge/KernelRidge.ts
import crypto122 from "node:crypto";
var KernelRidge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelRidge${crypto122.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelRidge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.kernel_ridge import KernelRidge
try: bridgeKernelRidge
except NameError: bridgeKernelRidge = {}
`;
    await this._py.ex`ctor_KernelRidge = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}}

ctor_KernelRidge = {k: v for k, v in ctor_KernelRidge.items() if v is not None}`;
    await this._py.ex`bridgeKernelRidge[${this.id}] = KernelRidge(**ctor_KernelRidge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Kernel Ridge regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before fit()");
    }
    await this._py.ex`pms_KernelRidge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KernelRidge_fit = {k: v for k, v in pms_KernelRidge_fit.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_fit = bridgeKernelRidge[${this.id}].fit(**pms_KernelRidge_fit)`;
    return this._py`res_KernelRidge_fit.tolist() if hasattr(res_KernelRidge_fit, 'tolist') else res_KernelRidge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelRidge must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelRidge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelRidge_get_metadata_routing = {k: v for k, v in pms_KernelRidge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_get_metadata_routing = bridgeKernelRidge[${this.id}].get_metadata_routing(**pms_KernelRidge_get_metadata_routing)`;
    return this._py`res_KernelRidge_get_metadata_routing.tolist() if hasattr(res_KernelRidge_get_metadata_routing, 'tolist') else res_KernelRidge_get_metadata_routing`;
  }
  /**
    Predict using the kernel ridge model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before predict()");
    }
    await this._py.ex`pms_KernelRidge_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelRidge_predict = {k: v for k, v in pms_KernelRidge_predict.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_predict = bridgeKernelRidge[${this.id}].predict(**pms_KernelRidge_predict)`;
    return this._py`res_KernelRidge_predict.tolist() if hasattr(res_KernelRidge_predict, 'tolist') else res_KernelRidge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before score()");
    }
    await this._py.ex`pms_KernelRidge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KernelRidge_score = {k: v for k, v in pms_KernelRidge_score.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_score = bridgeKernelRidge[${this.id}].score(**pms_KernelRidge_score)`;
    return this._py`res_KernelRidge_score.tolist() if hasattr(res_KernelRidge_score, 'tolist') else res_KernelRidge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KernelRidge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KernelRidge_set_fit_request = {k: v for k, v in pms_KernelRidge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_set_fit_request = bridgeKernelRidge[${this.id}].set_fit_request(**pms_KernelRidge_set_fit_request)`;
    return this._py`res_KernelRidge_set_fit_request.tolist() if hasattr(res_KernelRidge_set_fit_request, 'tolist') else res_KernelRidge_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before set_score_request()");
    }
    await this._py.ex`pms_KernelRidge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KernelRidge_set_score_request = {k: v for k, v in pms_KernelRidge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KernelRidge_set_score_request = bridgeKernelRidge[${this.id}].set_score_request(**pms_KernelRidge_set_score_request)`;
    return this._py`res_KernelRidge_set_score_request.tolist() if hasattr(res_KernelRidge_set_score_request, 'tolist') else res_KernelRidge_set_score_request`;
  }
  /**
    Representation of weight vector(s) in kernel space
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelRidge must call init() before accessing dual_coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelRidge_dual_coef_ = bridgeKernelRidge[${this.id}].dual_coef_`;
      return this._py`attr_KernelRidge_dual_coef_.tolist() if hasattr(attr_KernelRidge_dual_coef_, 'tolist') else attr_KernelRidge_dual_coef_`;
    })();
  }
  /**
    Training data, which is also required for prediction. If kernel == â€œprecomputedâ€ this is instead the precomputed training matrix, of shape (n\_samples, n\_samples).
   */
  get X_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelRidge must call init() before accessing X_fit_");
    }
    return (async () => {
      await this._py.ex`attr_KernelRidge_X_fit_ = bridgeKernelRidge[${this.id}].X_fit_`;
      return this._py`attr_KernelRidge_X_fit_.tolist() if hasattr(attr_KernelRidge_X_fit_, 'tolist') else attr_KernelRidge_X_fit_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelRidge must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelRidge_n_features_in_ = bridgeKernelRidge[${this.id}].n_features_in_`;
      return this._py`attr_KernelRidge_n_features_in_.tolist() if hasattr(attr_KernelRidge_n_features_in_, 'tolist') else attr_KernelRidge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelRidge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelRidge_feature_names_in_ = bridgeKernelRidge[${this.id}].feature_names_in_`;
      return this._py`attr_KernelRidge_feature_names_in_.tolist() if hasattr(attr_KernelRidge_feature_names_in_, 'tolist') else attr_KernelRidge_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/ARDRegression.ts
import crypto123 from "node:crypto";
var ARDRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ARDRegression${crypto123.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ARDRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ARDRegression
try: bridgeARDRegression
except NameError: bridgeARDRegression = {}
`;
    await this._py.ex`ctor_ARDRegression = {'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'alpha_1': ${this.opts["alpha_1"] ?? void 0}, 'alpha_2': ${this.opts["alpha_2"] ?? void 0}, 'lambda_1': ${this.opts["lambda_1"] ?? void 0}, 'lambda_2': ${this.opts["lambda_2"] ?? void 0}, 'compute_score': ${this.opts["compute_score"] ?? void 0}, 'threshold_lambda': ${this.opts["threshold_lambda"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}}

ctor_ARDRegression = {k: v for k, v in ctor_ARDRegression.items() if v is not None}`;
    await this._py.ex`bridgeARDRegression[${this.id}] = ARDRegression(**ctor_ARDRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeARDRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit the model according to the given training data and parameters.
  
      Iterative procedure to maximize the evidence
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before fit()");
    }
    await this._py.ex`pms_ARDRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_ARDRegression_fit = {k: v for k, v in pms_ARDRegression_fit.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_fit = bridgeARDRegression[${this.id}].fit(**pms_ARDRegression_fit)`;
    return this._py`res_ARDRegression_fit.tolist() if hasattr(res_ARDRegression_fit, 'tolist') else res_ARDRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ARDRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ARDRegression_get_metadata_routing = {k: v for k, v in pms_ARDRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_get_metadata_routing = bridgeARDRegression[${this.id}].get_metadata_routing(**pms_ARDRegression_get_metadata_routing)`;
    return this._py`res_ARDRegression_get_metadata_routing.tolist() if hasattr(res_ARDRegression_get_metadata_routing, 'tolist') else res_ARDRegression_get_metadata_routing`;
  }
  /**
      Predict using the linear model.
  
      In addition to the mean of the predictive distribution, also its standard deviation can be returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before predict()");
    }
    await this._py.ex`pms_ARDRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_ARDRegression_predict = {k: v for k, v in pms_ARDRegression_predict.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_predict = bridgeARDRegression[${this.id}].predict(**pms_ARDRegression_predict)`;
    return this._py`res_ARDRegression_predict.tolist() if hasattr(res_ARDRegression_predict, 'tolist') else res_ARDRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before score()");
    }
    await this._py.ex`pms_ARDRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ARDRegression_score = {k: v for k, v in pms_ARDRegression_score.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_score = bridgeARDRegression[${this.id}].score(**pms_ARDRegression_score)`;
    return this._py`res_ARDRegression_score.tolist() if hasattr(res_ARDRegression_score, 'tolist') else res_ARDRegression_score`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_ARDRegression_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_ARDRegression_set_predict_request = {k: v for k, v in pms_ARDRegression_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_set_predict_request = bridgeARDRegression[${this.id}].set_predict_request(**pms_ARDRegression_set_predict_request)`;
    return this._py`res_ARDRegression_set_predict_request.tolist() if hasattr(res_ARDRegression_set_predict_request, 'tolist') else res_ARDRegression_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ARDRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ARDRegression_set_score_request = {k: v for k, v in pms_ARDRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_set_score_request = bridgeARDRegression[${this.id}].set_score_request(**pms_ARDRegression_set_score_request)`;
    return this._py`res_ARDRegression_set_score_request.tolist() if hasattr(res_ARDRegression_set_score_request, 'tolist') else res_ARDRegression_set_score_request`;
  }
  /**
    Coefficients of the regression model (mean of distribution)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_coef_ = bridgeARDRegression[${this.id}].coef_`;
      return this._py`attr_ARDRegression_coef_.tolist() if hasattr(attr_ARDRegression_coef_, 'tolist') else attr_ARDRegression_coef_`;
    })();
  }
  /**
    estimated precision of the noise.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_alpha_ = bridgeARDRegression[${this.id}].alpha_`;
      return this._py`attr_ARDRegression_alpha_.tolist() if hasattr(attr_ARDRegression_alpha_, 'tolist') else attr_ARDRegression_alpha_`;
    })();
  }
  /**
    estimated precisions of the weights.
   */
  get lambda_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing lambda_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_lambda_ = bridgeARDRegression[${this.id}].lambda_`;
      return this._py`attr_ARDRegression_lambda_.tolist() if hasattr(attr_ARDRegression_lambda_, 'tolist') else attr_ARDRegression_lambda_`;
    })();
  }
  /**
    estimated variance-covariance matrix of the weights
   */
  get sigma_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing sigma_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_sigma_ = bridgeARDRegression[${this.id}].sigma_`;
      return this._py`attr_ARDRegression_sigma_.tolist() if hasattr(attr_ARDRegression_sigma_, 'tolist') else attr_ARDRegression_sigma_`;
    })();
  }
  /**
    if computed, value of the objective function (to be maximized)
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_scores_ = bridgeARDRegression[${this.id}].scores_`;
      return this._py`attr_ARDRegression_scores_.tolist() if hasattr(attr_ARDRegression_scores_, 'tolist') else attr_ARDRegression_scores_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_n_iter_ = bridgeARDRegression[${this.id}].n_iter_`;
      return this._py`attr_ARDRegression_n_iter_.tolist() if hasattr(attr_ARDRegression_n_iter_, 'tolist') else attr_ARDRegression_n_iter_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_intercept_ = bridgeARDRegression[${this.id}].intercept_`;
      return this._py`attr_ARDRegression_intercept_.tolist() if hasattr(attr_ARDRegression_intercept_, 'tolist') else attr_ARDRegression_intercept_`;
    })();
  }
  /**
    If `fit\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\_features) otherwise.
   */
  get X_offset_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing X_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_X_offset_ = bridgeARDRegression[${this.id}].X_offset_`;
      return this._py`attr_ARDRegression_X_offset_.tolist() if hasattr(attr_ARDRegression_X_offset_, 'tolist') else attr_ARDRegression_X_offset_`;
    })();
  }
  /**
    Set to np.ones(n\_features).
   */
  get X_scale_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing X_scale_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_X_scale_ = bridgeARDRegression[${this.id}].X_scale_`;
      return this._py`attr_ARDRegression_X_scale_.tolist() if hasattr(attr_ARDRegression_X_scale_, 'tolist') else attr_ARDRegression_X_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_n_features_in_ = bridgeARDRegression[${this.id}].n_features_in_`;
      return this._py`attr_ARDRegression_n_features_in_.tolist() if hasattr(attr_ARDRegression_n_features_in_, 'tolist') else attr_ARDRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_feature_names_in_ = bridgeARDRegression[${this.id}].feature_names_in_`;
      return this._py`attr_ARDRegression_feature_names_in_.tolist() if hasattr(attr_ARDRegression_feature_names_in_, 'tolist') else attr_ARDRegression_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/BayesianRidge.ts
import crypto124 from "node:crypto";
var BayesianRidge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BayesianRidge${crypto124.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BayesianRidge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import BayesianRidge
try: bridgeBayesianRidge
except NameError: bridgeBayesianRidge = {}
`;
    await this._py.ex`ctor_BayesianRidge = {'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'alpha_1': ${this.opts["alpha_1"] ?? void 0}, 'alpha_2': ${this.opts["alpha_2"] ?? void 0}, 'lambda_1': ${this.opts["lambda_1"] ?? void 0}, 'lambda_2': ${this.opts["lambda_2"] ?? void 0}, 'alpha_init': ${this.opts["alpha_init"] ?? void 0}, 'lambda_init': ${this.opts["lambda_init"] ?? void 0}, 'compute_score': ${this.opts["compute_score"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}}

ctor_BayesianRidge = {k: v for k, v in ctor_BayesianRidge.items() if v is not None}`;
    await this._py.ex`bridgeBayesianRidge[${this.id}] = BayesianRidge(**ctor_BayesianRidge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBayesianRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before fit()");
    }
    await this._py.ex`pms_BayesianRidge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_fit = {k: v for k, v in pms_BayesianRidge_fit.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_fit = bridgeBayesianRidge[${this.id}].fit(**pms_BayesianRidge_fit)`;
    return this._py`res_BayesianRidge_fit.tolist() if hasattr(res_BayesianRidge_fit, 'tolist') else res_BayesianRidge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BayesianRidge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BayesianRidge_get_metadata_routing = {k: v for k, v in pms_BayesianRidge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_get_metadata_routing = bridgeBayesianRidge[${this.id}].get_metadata_routing(**pms_BayesianRidge_get_metadata_routing)`;
    return this._py`res_BayesianRidge_get_metadata_routing.tolist() if hasattr(res_BayesianRidge_get_metadata_routing, 'tolist') else res_BayesianRidge_get_metadata_routing`;
  }
  /**
      Predict using the linear model.
  
      In addition to the mean of the predictive distribution, also its standard deviation can be returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before predict()");
    }
    await this._py.ex`pms_BayesianRidge_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_predict = {k: v for k, v in pms_BayesianRidge_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_predict = bridgeBayesianRidge[${this.id}].predict(**pms_BayesianRidge_predict)`;
    return this._py`res_BayesianRidge_predict.tolist() if hasattr(res_BayesianRidge_predict, 'tolist') else res_BayesianRidge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before score()");
    }
    await this._py.ex`pms_BayesianRidge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_score = {k: v for k, v in pms_BayesianRidge_score.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_score = bridgeBayesianRidge[${this.id}].score(**pms_BayesianRidge_score)`;
    return this._py`res_BayesianRidge_score.tolist() if hasattr(res_BayesianRidge_score, 'tolist') else res_BayesianRidge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_BayesianRidge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_fit_request = {k: v for k, v in pms_BayesianRidge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_fit_request = bridgeBayesianRidge[${this.id}].set_fit_request(**pms_BayesianRidge_set_fit_request)`;
    return this._py`res_BayesianRidge_set_fit_request.tolist() if hasattr(res_BayesianRidge_set_fit_request, 'tolist') else res_BayesianRidge_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_set_predict_request = {k: v for k, v in pms_BayesianRidge_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_predict_request = bridgeBayesianRidge[${this.id}].set_predict_request(**pms_BayesianRidge_set_predict_request)`;
    return this._py`res_BayesianRidge_set_predict_request.tolist() if hasattr(res_BayesianRidge_set_predict_request, 'tolist') else res_BayesianRidge_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_score_request = {k: v for k, v in pms_BayesianRidge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_score_request = bridgeBayesianRidge[${this.id}].set_score_request(**pms_BayesianRidge_set_score_request)`;
    return this._py`res_BayesianRidge_set_score_request.tolist() if hasattr(res_BayesianRidge_set_score_request, 'tolist') else res_BayesianRidge_set_score_request`;
  }
  /**
    Coefficients of the regression model (mean of distribution)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_coef_ = bridgeBayesianRidge[${this.id}].coef_`;
      return this._py`attr_BayesianRidge_coef_.tolist() if hasattr(attr_BayesianRidge_coef_, 'tolist') else attr_BayesianRidge_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_intercept_ = bridgeBayesianRidge[${this.id}].intercept_`;
      return this._py`attr_BayesianRidge_intercept_.tolist() if hasattr(attr_BayesianRidge_intercept_, 'tolist') else attr_BayesianRidge_intercept_`;
    })();
  }
  /**
    Estimated precision of the noise.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_alpha_ = bridgeBayesianRidge[${this.id}].alpha_`;
      return this._py`attr_BayesianRidge_alpha_.tolist() if hasattr(attr_BayesianRidge_alpha_, 'tolist') else attr_BayesianRidge_alpha_`;
    })();
  }
  /**
    Estimated precision of the weights.
   */
  get lambda_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing lambda_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_lambda_ = bridgeBayesianRidge[${this.id}].lambda_`;
      return this._py`attr_BayesianRidge_lambda_.tolist() if hasattr(attr_BayesianRidge_lambda_, 'tolist') else attr_BayesianRidge_lambda_`;
    })();
  }
  /**
    Estimated variance-covariance matrix of the weights
   */
  get sigma_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing sigma_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_sigma_ = bridgeBayesianRidge[${this.id}].sigma_`;
      return this._py`attr_BayesianRidge_sigma_.tolist() if hasattr(attr_BayesianRidge_sigma_, 'tolist') else attr_BayesianRidge_sigma_`;
    })();
  }
  /**
    If computed\_score is `true`, value of the log marginal likelihood (to be maximized) at each iteration of the optimization. The array starts with the value of the log marginal likelihood obtained for the initial values of alpha and lambda and ends with the value obtained for the estimated alpha and lambda.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_scores_ = bridgeBayesianRidge[${this.id}].scores_`;
      return this._py`attr_BayesianRidge_scores_.tolist() if hasattr(attr_BayesianRidge_scores_, 'tolist') else attr_BayesianRidge_scores_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_iter_ = bridgeBayesianRidge[${this.id}].n_iter_`;
      return this._py`attr_BayesianRidge_n_iter_.tolist() if hasattr(attr_BayesianRidge_n_iter_, 'tolist') else attr_BayesianRidge_n_iter_`;
    })();
  }
  /**
    If `fit\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\_features) otherwise.
   */
  get X_offset_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_offset_ = bridgeBayesianRidge[${this.id}].X_offset_`;
      return this._py`attr_BayesianRidge_X_offset_.tolist() if hasattr(attr_BayesianRidge_X_offset_, 'tolist') else attr_BayesianRidge_X_offset_`;
    })();
  }
  /**
    Set to np.ones(n\_features).
   */
  get X_scale_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_scale_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_scale_ = bridgeBayesianRidge[${this.id}].X_scale_`;
      return this._py`attr_BayesianRidge_X_scale_.tolist() if hasattr(attr_BayesianRidge_X_scale_, 'tolist') else attr_BayesianRidge_X_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_features_in_ = bridgeBayesianRidge[${this.id}].n_features_in_`;
      return this._py`attr_BayesianRidge_n_features_in_.tolist() if hasattr(attr_BayesianRidge_n_features_in_, 'tolist') else attr_BayesianRidge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_feature_names_in_ = bridgeBayesianRidge[${this.id}].feature_names_in_`;
      return this._py`attr_BayesianRidge_feature_names_in_.tolist() if hasattr(attr_BayesianRidge_feature_names_in_, 'tolist') else attr_BayesianRidge_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/ElasticNet.ts
import crypto125 from "node:crypto";
var ElasticNet = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ElasticNet${crypto125.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ElasticNet.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ElasticNet
try: bridgeElasticNet
except NameError: bridgeElasticNet = {}
`;
    await this._py.ex`ctor_ElasticNet = {'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_ElasticNet = {k: v for k, v in ctor_ElasticNet.items() if v is not None}`;
    await this._py.ex`bridgeElasticNet[${this.id}] = ElasticNet(**ctor_ElasticNet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeElasticNet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before fit()");
    }
    await this._py.ex`pms_ElasticNet_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ElasticNet_fit = {k: v for k, v in pms_ElasticNet_fit.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_fit = bridgeElasticNet[${this.id}].fit(**pms_ElasticNet_fit)`;
    return this._py`res_ElasticNet_fit.tolist() if hasattr(res_ElasticNet_fit, 'tolist') else res_ElasticNet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ElasticNet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ElasticNet_get_metadata_routing = {k: v for k, v in pms_ElasticNet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_get_metadata_routing = bridgeElasticNet[${this.id}].get_metadata_routing(**pms_ElasticNet_get_metadata_routing)`;
    return this._py`res_ElasticNet_get_metadata_routing.tolist() if hasattr(res_ElasticNet_get_metadata_routing, 'tolist') else res_ElasticNet_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before path()");
    }
    await this._py.ex`pms_ElasticNet_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_ElasticNet_path = {k: v for k, v in pms_ElasticNet_path.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_path = bridgeElasticNet[${this.id}].path(**pms_ElasticNet_path)`;
    return this._py`res_ElasticNet_path.tolist() if hasattr(res_ElasticNet_path, 'tolist') else res_ElasticNet_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before predict()");
    }
    await this._py.ex`pms_ElasticNet_predict = {'X': ${opts["X"] ?? void 0}}

pms_ElasticNet_predict = {k: v for k, v in pms_ElasticNet_predict.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_predict = bridgeElasticNet[${this.id}].predict(**pms_ElasticNet_predict)`;
    return this._py`res_ElasticNet_predict.tolist() if hasattr(res_ElasticNet_predict, 'tolist') else res_ElasticNet_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before score()");
    }
    await this._py.ex`pms_ElasticNet_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNet_score = {k: v for k, v in pms_ElasticNet_score.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_score = bridgeElasticNet[${this.id}].score(**pms_ElasticNet_score)`;
    return this._py`res_ElasticNet_score.tolist() if hasattr(res_ElasticNet_score, 'tolist') else res_ElasticNet_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before set_fit_request()");
    }
    await this._py.ex`pms_ElasticNet_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNet_set_fit_request = {k: v for k, v in pms_ElasticNet_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_set_fit_request = bridgeElasticNet[${this.id}].set_fit_request(**pms_ElasticNet_set_fit_request)`;
    return this._py`res_ElasticNet_set_fit_request.tolist() if hasattr(res_ElasticNet_set_fit_request, 'tolist') else res_ElasticNet_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before set_score_request()");
    }
    await this._py.ex`pms_ElasticNet_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNet_set_score_request = {k: v for k, v in pms_ElasticNet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_set_score_request = bridgeElasticNet[${this.id}].set_score_request(**pms_ElasticNet_set_score_request)`;
    return this._py`res_ElasticNet_set_score_request.tolist() if hasattr(res_ElasticNet_set_score_request, 'tolist') else res_ElasticNet_set_score_request`;
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_coef_ = bridgeElasticNet[${this.id}].coef_`;
      return this._py`attr_ElasticNet_coef_.tolist() if hasattr(attr_ElasticNet_coef_, 'tolist') else attr_ElasticNet_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_intercept_ = bridgeElasticNet[${this.id}].intercept_`;
      return this._py`attr_ElasticNet_intercept_.tolist() if hasattr(attr_ElasticNet_intercept_, 'tolist') else attr_ElasticNet_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_n_iter_ = bridgeElasticNet[${this.id}].n_iter_`;
      return this._py`attr_ElasticNet_n_iter_.tolist() if hasattr(attr_ElasticNet_n_iter_, 'tolist') else attr_ElasticNet_n_iter_`;
    })();
  }
  /**
    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_dual_gap_ = bridgeElasticNet[${this.id}].dual_gap_`;
      return this._py`attr_ElasticNet_dual_gap_.tolist() if hasattr(attr_ElasticNet_dual_gap_, 'tolist') else attr_ElasticNet_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_n_features_in_ = bridgeElasticNet[${this.id}].n_features_in_`;
      return this._py`attr_ElasticNet_n_features_in_.tolist() if hasattr(attr_ElasticNet_n_features_in_, 'tolist') else attr_ElasticNet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_feature_names_in_ = bridgeElasticNet[${this.id}].feature_names_in_`;
      return this._py`attr_ElasticNet_feature_names_in_.tolist() if hasattr(attr_ElasticNet_feature_names_in_, 'tolist') else attr_ElasticNet_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/ElasticNetCV.ts
import crypto126 from "node:crypto";
var ElasticNetCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ElasticNetCV${crypto126.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ElasticNetCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ElasticNetCV
try: bridgeElasticNetCV
except NameError: bridgeElasticNetCV = {}
`;
    await this._py.ex`ctor_ElasticNetCV = {'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_ElasticNetCV = {k: v for k, v in ctor_ElasticNetCV.items() if v is not None}`;
    await this._py.ex`bridgeElasticNetCV[${this.id}] = ElasticNetCV(**ctor_ElasticNetCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeElasticNetCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit linear model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before fit()");
    }
    await this._py.ex`pms_ElasticNetCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNetCV_fit = {k: v for k, v in pms_ElasticNetCV_fit.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_fit = bridgeElasticNetCV[${this.id}].fit(**pms_ElasticNetCV_fit)`;
    return this._py`res_ElasticNetCV_fit.tolist() if hasattr(res_ElasticNetCV_fit, 'tolist') else res_ElasticNetCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ElasticNetCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ElasticNetCV_get_metadata_routing = {k: v for k, v in pms_ElasticNetCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_get_metadata_routing = bridgeElasticNetCV[${this.id}].get_metadata_routing(**pms_ElasticNetCV_get_metadata_routing)`;
    return this._py`res_ElasticNetCV_get_metadata_routing.tolist() if hasattr(res_ElasticNetCV_get_metadata_routing, 'tolist') else res_ElasticNetCV_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before path()");
    }
    await this._py.ex`pms_ElasticNetCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_ElasticNetCV_path = {k: v for k, v in pms_ElasticNetCV_path.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_path = bridgeElasticNetCV[${this.id}].path(**pms_ElasticNetCV_path)`;
    return this._py`res_ElasticNetCV_path.tolist() if hasattr(res_ElasticNetCV_path, 'tolist') else res_ElasticNetCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before predict()");
    }
    await this._py.ex`pms_ElasticNetCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_ElasticNetCV_predict = {k: v for k, v in pms_ElasticNetCV_predict.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_predict = bridgeElasticNetCV[${this.id}].predict(**pms_ElasticNetCV_predict)`;
    return this._py`res_ElasticNetCV_predict.tolist() if hasattr(res_ElasticNetCV_predict, 'tolist') else res_ElasticNetCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before score()");
    }
    await this._py.ex`pms_ElasticNetCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNetCV_score = {k: v for k, v in pms_ElasticNetCV_score.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_score = bridgeElasticNetCV[${this.id}].score(**pms_ElasticNetCV_score)`;
    return this._py`res_ElasticNetCV_score.tolist() if hasattr(res_ElasticNetCV_score, 'tolist') else res_ElasticNetCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_ElasticNetCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNetCV_set_fit_request = {k: v for k, v in pms_ElasticNetCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_set_fit_request = bridgeElasticNetCV[${this.id}].set_fit_request(**pms_ElasticNetCV_set_fit_request)`;
    return this._py`res_ElasticNetCV_set_fit_request.tolist() if hasattr(res_ElasticNetCV_set_fit_request, 'tolist') else res_ElasticNetCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ElasticNetCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNetCV_set_score_request = {k: v for k, v in pms_ElasticNetCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_set_score_request = bridgeElasticNetCV[${this.id}].set_score_request(**pms_ElasticNetCV_set_score_request)`;
    return this._py`res_ElasticNetCV_set_score_request.tolist() if hasattr(res_ElasticNetCV_set_score_request, 'tolist') else res_ElasticNetCV_set_score_request`;
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_alpha_ = bridgeElasticNetCV[${this.id}].alpha_`;
      return this._py`attr_ElasticNetCV_alpha_.tolist() if hasattr(attr_ElasticNetCV_alpha_, 'tolist') else attr_ElasticNetCV_alpha_`;
    })();
  }
  /**
    The compromise between l1 and l2 penalization chosen by cross validation.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_l1_ratio_ = bridgeElasticNetCV[${this.id}].l1_ratio_`;
      return this._py`attr_ElasticNetCV_l1_ratio_.tolist() if hasattr(attr_ElasticNetCV_l1_ratio_, 'tolist') else attr_ElasticNetCV_l1_ratio_`;
    })();
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_coef_ = bridgeElasticNetCV[${this.id}].coef_`;
      return this._py`attr_ElasticNetCV_coef_.tolist() if hasattr(attr_ElasticNetCV_coef_, 'tolist') else attr_ElasticNetCV_coef_`;
    })();
  }
  /**
    Independent term in the decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_intercept_ = bridgeElasticNetCV[${this.id}].intercept_`;
      return this._py`attr_ElasticNetCV_intercept_.tolist() if hasattr(attr_ElasticNetCV_intercept_, 'tolist') else attr_ElasticNetCV_intercept_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying l1\_ratio and alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_mse_path_ = bridgeElasticNetCV[${this.id}].mse_path_`;
      return this._py`attr_ElasticNetCV_mse_path_.tolist() if hasattr(attr_ElasticNetCV_mse_path_, 'tolist') else attr_ElasticNetCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting, for each l1\_ratio.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_alphas_ = bridgeElasticNetCV[${this.id}].alphas_`;
      return this._py`attr_ElasticNetCV_alphas_.tolist() if hasattr(attr_ElasticNetCV_alphas_, 'tolist') else attr_ElasticNetCV_alphas_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_dual_gap_ = bridgeElasticNetCV[${this.id}].dual_gap_`;
      return this._py`attr_ElasticNetCV_dual_gap_.tolist() if hasattr(attr_ElasticNetCV_dual_gap_, 'tolist') else attr_ElasticNetCV_dual_gap_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_n_iter_ = bridgeElasticNetCV[${this.id}].n_iter_`;
      return this._py`attr_ElasticNetCV_n_iter_.tolist() if hasattr(attr_ElasticNetCV_n_iter_, 'tolist') else attr_ElasticNetCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_n_features_in_ = bridgeElasticNetCV[${this.id}].n_features_in_`;
      return this._py`attr_ElasticNetCV_n_features_in_.tolist() if hasattr(attr_ElasticNetCV_n_features_in_, 'tolist') else attr_ElasticNetCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_feature_names_in_ = bridgeElasticNetCV[${this.id}].feature_names_in_`;
      return this._py`attr_ElasticNetCV_feature_names_in_.tolist() if hasattr(attr_ElasticNetCV_feature_names_in_, 'tolist') else attr_ElasticNetCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/GammaRegressor.ts
import crypto127 from "node:crypto";
var GammaRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GammaRegressor${crypto127.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GammaRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import GammaRegressor
try: bridgeGammaRegressor
except NameError: bridgeGammaRegressor = {}
`;
    await this._py.ex`ctor_GammaRegressor = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_GammaRegressor = {k: v for k, v in ctor_GammaRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGammaRegressor[${this.id}] = GammaRegressor(**ctor_GammaRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGammaRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GammaRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GammaRegressor_fit = {k: v for k, v in pms_GammaRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_fit = bridgeGammaRegressor[${this.id}].fit(**pms_GammaRegressor_fit)`;
    return this._py`res_GammaRegressor_fit.tolist() if hasattr(res_GammaRegressor_fit, 'tolist') else res_GammaRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GammaRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GammaRegressor_get_metadata_routing = {k: v for k, v in pms_GammaRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_get_metadata_routing = bridgeGammaRegressor[${this.id}].get_metadata_routing(**pms_GammaRegressor_get_metadata_routing)`;
    return this._py`res_GammaRegressor_get_metadata_routing.tolist() if hasattr(res_GammaRegressor_get_metadata_routing, 'tolist') else res_GammaRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before predict()");
    }
    await this._py.ex`pms_GammaRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GammaRegressor_predict = {k: v for k, v in pms_GammaRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_predict = bridgeGammaRegressor[${this.id}].predict(**pms_GammaRegressor_predict)`;
    return this._py`res_GammaRegressor_predict.tolist() if hasattr(res_GammaRegressor_predict, 'tolist') else res_GammaRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before score()");
    }
    await this._py.ex`pms_GammaRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GammaRegressor_score = {k: v for k, v in pms_GammaRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_score = bridgeGammaRegressor[${this.id}].score(**pms_GammaRegressor_score)`;
    return this._py`res_GammaRegressor_score.tolist() if hasattr(res_GammaRegressor_score, 'tolist') else res_GammaRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GammaRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GammaRegressor_set_fit_request = {k: v for k, v in pms_GammaRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_set_fit_request = bridgeGammaRegressor[${this.id}].set_fit_request(**pms_GammaRegressor_set_fit_request)`;
    return this._py`res_GammaRegressor_set_fit_request.tolist() if hasattr(res_GammaRegressor_set_fit_request, 'tolist') else res_GammaRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GammaRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GammaRegressor_set_score_request = {k: v for k, v in pms_GammaRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_set_score_request = bridgeGammaRegressor[${this.id}].set_score_request(**pms_GammaRegressor_set_score_request)`;
    return this._py`res_GammaRegressor_set_score_request.tolist() if hasattr(res_GammaRegressor_set_score_request, 'tolist') else res_GammaRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_coef_ = bridgeGammaRegressor[${this.id}].coef_`;
      return this._py`attr_GammaRegressor_coef_.tolist() if hasattr(attr_GammaRegressor_coef_, 'tolist') else attr_GammaRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_intercept_ = bridgeGammaRegressor[${this.id}].intercept_`;
      return this._py`attr_GammaRegressor_intercept_.tolist() if hasattr(attr_GammaRegressor_intercept_, 'tolist') else attr_GammaRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_n_features_in_ = bridgeGammaRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GammaRegressor_n_features_in_.tolist() if hasattr(attr_GammaRegressor_n_features_in_, 'tolist') else attr_GammaRegressor_n_features_in_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_n_iter_ = bridgeGammaRegressor[${this.id}].n_iter_`;
      return this._py`attr_GammaRegressor_n_iter_.tolist() if hasattr(attr_GammaRegressor_n_iter_, 'tolist') else attr_GammaRegressor_n_iter_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_feature_names_in_ = bridgeGammaRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GammaRegressor_feature_names_in_.tolist() if hasattr(attr_GammaRegressor_feature_names_in_, 'tolist') else attr_GammaRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/HuberRegressor.ts
import crypto128 from "node:crypto";
var HuberRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HuberRegressor${crypto128.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HuberRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import HuberRegressor
try: bridgeHuberRegressor
except NameError: bridgeHuberRegressor = {}
`;
    await this._py.ex`ctor_HuberRegressor = {'epsilon': ${this.opts["epsilon"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_HuberRegressor = {k: v for k, v in ctor_HuberRegressor.items() if v is not None}`;
    await this._py.ex`bridgeHuberRegressor[${this.id}] = HuberRegressor(**ctor_HuberRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHuberRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before fit()");
    }
    await this._py.ex`pms_HuberRegressor_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_fit = {k: v for k, v in pms_HuberRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_fit = bridgeHuberRegressor[${this.id}].fit(**pms_HuberRegressor_fit)`;
    return this._py`res_HuberRegressor_fit.tolist() if hasattr(res_HuberRegressor_fit, 'tolist') else res_HuberRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HuberRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HuberRegressor_get_metadata_routing = {k: v for k, v in pms_HuberRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_get_metadata_routing = bridgeHuberRegressor[${this.id}].get_metadata_routing(**pms_HuberRegressor_get_metadata_routing)`;
    return this._py`res_HuberRegressor_get_metadata_routing.tolist() if hasattr(res_HuberRegressor_get_metadata_routing, 'tolist') else res_HuberRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before predict()");
    }
    await this._py.ex`pms_HuberRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_HuberRegressor_predict = {k: v for k, v in pms_HuberRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_predict = bridgeHuberRegressor[${this.id}].predict(**pms_HuberRegressor_predict)`;
    return this._py`res_HuberRegressor_predict.tolist() if hasattr(res_HuberRegressor_predict, 'tolist') else res_HuberRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before score()");
    }
    await this._py.ex`pms_HuberRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HuberRegressor_score = {k: v for k, v in pms_HuberRegressor_score.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_score = bridgeHuberRegressor[${this.id}].score(**pms_HuberRegressor_score)`;
    return this._py`res_HuberRegressor_score.tolist() if hasattr(res_HuberRegressor_score, 'tolist') else res_HuberRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HuberRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_set_fit_request = {k: v for k, v in pms_HuberRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_set_fit_request = bridgeHuberRegressor[${this.id}].set_fit_request(**pms_HuberRegressor_set_fit_request)`;
    return this._py`res_HuberRegressor_set_fit_request.tolist() if hasattr(res_HuberRegressor_set_fit_request, 'tolist') else res_HuberRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HuberRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_set_score_request = {k: v for k, v in pms_HuberRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_set_score_request = bridgeHuberRegressor[${this.id}].set_score_request(**pms_HuberRegressor_set_score_request)`;
    return this._py`res_HuberRegressor_set_score_request.tolist() if hasattr(res_HuberRegressor_set_score_request, 'tolist') else res_HuberRegressor_set_score_request`;
  }
  /**
    Features got by optimizing the L2-regularized Huber loss.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_coef_ = bridgeHuberRegressor[${this.id}].coef_`;
      return this._py`attr_HuberRegressor_coef_.tolist() if hasattr(attr_HuberRegressor_coef_, 'tolist') else attr_HuberRegressor_coef_`;
    })();
  }
  /**
    Bias.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_intercept_ = bridgeHuberRegressor[${this.id}].intercept_`;
      return this._py`attr_HuberRegressor_intercept_.tolist() if hasattr(attr_HuberRegressor_intercept_, 'tolist') else attr_HuberRegressor_intercept_`;
    })();
  }
  /**
    The value by which `|y \- Xw \- c|` is scaled down.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_scale_ = bridgeHuberRegressor[${this.id}].scale_`;
      return this._py`attr_HuberRegressor_scale_.tolist() if hasattr(attr_HuberRegressor_scale_, 'tolist') else attr_HuberRegressor_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_n_features_in_ = bridgeHuberRegressor[${this.id}].n_features_in_`;
      return this._py`attr_HuberRegressor_n_features_in_.tolist() if hasattr(attr_HuberRegressor_n_features_in_, 'tolist') else attr_HuberRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_feature_names_in_ = bridgeHuberRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_HuberRegressor_feature_names_in_.tolist() if hasattr(attr_HuberRegressor_feature_names_in_, 'tolist') else attr_HuberRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of iterations that `scipy.optimize.minimize(method="L-BFGS-B")` has run for.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_n_iter_ = bridgeHuberRegressor[${this.id}].n_iter_`;
      return this._py`attr_HuberRegressor_n_iter_.tolist() if hasattr(attr_HuberRegressor_n_iter_, 'tolist') else attr_HuberRegressor_n_iter_`;
    })();
  }
  /**
    A boolean mask which is set to `true` where the samples are identified as outliers.
   */
  get outliers_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing outliers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_outliers_ = bridgeHuberRegressor[${this.id}].outliers_`;
      return this._py`attr_HuberRegressor_outliers_.tolist() if hasattr(attr_HuberRegressor_outliers_, 'tolist') else attr_HuberRegressor_outliers_`;
    })();
  }
};

// src/generated/linear_model/Lars.ts
import crypto129 from "node:crypto";
var Lars = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Lars${crypto129.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Lars.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Lars
try: bridgeLars
except NameError: bridgeLars = {}
`;
    await this._py.ex`ctor_Lars = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'n_nonzero_coefs': ${this.opts["n_nonzero_coefs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'fit_path': ${this.opts["fit_path"] ?? void 0}, 'jitter': ${this.opts["jitter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_Lars = {k: v for k, v in ctor_Lars.items() if v is not None}`;
    await this._py.ex`bridgeLars[${this.id}] = Lars(**ctor_Lars)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLars[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before fit()");
    }
    await this._py.ex`pms_Lars_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None}

pms_Lars_fit = {k: v for k, v in pms_Lars_fit.items() if v is not None}`;
    await this._py.ex`res_Lars_fit = bridgeLars[${this.id}].fit(**pms_Lars_fit)`;
    return this._py`res_Lars_fit.tolist() if hasattr(res_Lars_fit, 'tolist') else res_Lars_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Lars_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Lars_get_metadata_routing = {k: v for k, v in pms_Lars_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Lars_get_metadata_routing = bridgeLars[${this.id}].get_metadata_routing(**pms_Lars_get_metadata_routing)`;
    return this._py`res_Lars_get_metadata_routing.tolist() if hasattr(res_Lars_get_metadata_routing, 'tolist') else res_Lars_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before predict()");
    }
    await this._py.ex`pms_Lars_predict = {'X': ${opts["X"] ?? void 0}}

pms_Lars_predict = {k: v for k, v in pms_Lars_predict.items() if v is not None}`;
    await this._py.ex`res_Lars_predict = bridgeLars[${this.id}].predict(**pms_Lars_predict)`;
    return this._py`res_Lars_predict.tolist() if hasattr(res_Lars_predict, 'tolist') else res_Lars_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before score()");
    }
    await this._py.ex`pms_Lars_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Lars_score = {k: v for k, v in pms_Lars_score.items() if v is not None}`;
    await this._py.ex`res_Lars_score = bridgeLars[${this.id}].score(**pms_Lars_score)`;
    return this._py`res_Lars_score.tolist() if hasattr(res_Lars_score, 'tolist') else res_Lars_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Lars_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_Lars_set_fit_request = {k: v for k, v in pms_Lars_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Lars_set_fit_request = bridgeLars[${this.id}].set_fit_request(**pms_Lars_set_fit_request)`;
    return this._py`res_Lars_set_fit_request.tolist() if hasattr(res_Lars_set_fit_request, 'tolist') else res_Lars_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before set_score_request()");
    }
    await this._py.ex`pms_Lars_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lars_set_score_request = {k: v for k, v in pms_Lars_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Lars_set_score_request = bridgeLars[${this.id}].set_score_request(**pms_Lars_set_score_request)`;
    return this._py`res_Lars_set_score_request.tolist() if hasattr(res_Lars_set_score_request, 'tolist') else res_Lars_set_score_request`;
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_alphas_ = bridgeLars[${this.id}].alphas_`;
      return this._py`attr_Lars_alphas_.tolist() if hasattr(attr_Lars_alphas_, 'tolist') else attr_Lars_alphas_`;
    })();
  }
  /**
    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_active_ = bridgeLars[${this.id}].active_`;
      return this._py`attr_Lars_active_.tolist() if hasattr(attr_Lars_active_, 'tolist') else attr_Lars_active_`;
    })();
  }
  /**
    The varying values of the coefficients along the path. It is not present if the `fit\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_coef_path_ = bridgeLars[${this.id}].coef_path_`;
      return this._py`attr_Lars_coef_path_.tolist() if hasattr(attr_Lars_coef_path_, 'tolist') else attr_Lars_coef_path_`;
    })();
  }
  /**
    Parameter vector (w in the formulation formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_coef_ = bridgeLars[${this.id}].coef_`;
      return this._py`attr_Lars_coef_.tolist() if hasattr(attr_Lars_coef_, 'tolist') else attr_Lars_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_intercept_ = bridgeLars[${this.id}].intercept_`;
      return this._py`attr_Lars_intercept_.tolist() if hasattr(attr_Lars_intercept_, 'tolist') else attr_Lars_intercept_`;
    })();
  }
  /**
    The number of iterations taken by lars\_path to find the grid of alphas for each target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_n_iter_ = bridgeLars[${this.id}].n_iter_`;
      return this._py`attr_Lars_n_iter_.tolist() if hasattr(attr_Lars_n_iter_, 'tolist') else attr_Lars_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_n_features_in_ = bridgeLars[${this.id}].n_features_in_`;
      return this._py`attr_Lars_n_features_in_.tolist() if hasattr(attr_Lars_n_features_in_, 'tolist') else attr_Lars_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Lars must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Lars_feature_names_in_ = bridgeLars[${this.id}].feature_names_in_`;
      return this._py`attr_Lars_feature_names_in_.tolist() if hasattr(attr_Lars_feature_names_in_, 'tolist') else attr_Lars_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LarsCV.ts
import crypto130 from "node:crypto";
var LarsCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LarsCV${crypto130.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LarsCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LarsCV
try: bridgeLarsCV
except NameError: bridgeLarsCV = {}
`;
    await this._py.ex`ctor_LarsCV = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'max_n_alphas': ${this.opts["max_n_alphas"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}}

ctor_LarsCV = {k: v for k, v in ctor_LarsCV.items() if v is not None}`;
    await this._py.ex`bridgeLarsCV[${this.id}] = LarsCV(**ctor_LarsCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLarsCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before fit()");
    }
    await this._py.ex`pms_LarsCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LarsCV_fit = {k: v for k, v in pms_LarsCV_fit.items() if v is not None}`;
    await this._py.ex`res_LarsCV_fit = bridgeLarsCV[${this.id}].fit(**pms_LarsCV_fit)`;
    return this._py`res_LarsCV_fit.tolist() if hasattr(res_LarsCV_fit, 'tolist') else res_LarsCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_LarsCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LarsCV_get_metadata_routing = {k: v for k, v in pms_LarsCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LarsCV_get_metadata_routing = bridgeLarsCV[${this.id}].get_metadata_routing(**pms_LarsCV_get_metadata_routing)`;
    return this._py`res_LarsCV_get_metadata_routing.tolist() if hasattr(res_LarsCV_get_metadata_routing, 'tolist') else res_LarsCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before predict()");
    }
    await this._py.ex`pms_LarsCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LarsCV_predict = {k: v for k, v in pms_LarsCV_predict.items() if v is not None}`;
    await this._py.ex`res_LarsCV_predict = bridgeLarsCV[${this.id}].predict(**pms_LarsCV_predict)`;
    return this._py`res_LarsCV_predict.tolist() if hasattr(res_LarsCV_predict, 'tolist') else res_LarsCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before score()");
    }
    await this._py.ex`pms_LarsCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LarsCV_score = {k: v for k, v in pms_LarsCV_score.items() if v is not None}`;
    await this._py.ex`res_LarsCV_score = bridgeLarsCV[${this.id}].score(**pms_LarsCV_score)`;
    return this._py`res_LarsCV_score.tolist() if hasattr(res_LarsCV_score, 'tolist') else res_LarsCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LarsCV_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LarsCV_set_fit_request = {k: v for k, v in pms_LarsCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LarsCV_set_fit_request = bridgeLarsCV[${this.id}].set_fit_request(**pms_LarsCV_set_fit_request)`;
    return this._py`res_LarsCV_set_fit_request.tolist() if hasattr(res_LarsCV_set_fit_request, 'tolist') else res_LarsCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LarsCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LarsCV_set_score_request = {k: v for k, v in pms_LarsCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LarsCV_set_score_request = bridgeLarsCV[${this.id}].set_score_request(**pms_LarsCV_set_score_request)`;
    return this._py`res_LarsCV_set_score_request.tolist() if hasattr(res_LarsCV_set_score_request, 'tolist') else res_LarsCV_set_score_request`;
  }
  /**
    Indices of active variables at the end of the path. If this is a list of lists, the outer list length is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_active_ = bridgeLarsCV[${this.id}].active_`;
      return this._py`attr_LarsCV_active_.tolist() if hasattr(attr_LarsCV_active_, 'tolist') else attr_LarsCV_active_`;
    })();
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_coef_ = bridgeLarsCV[${this.id}].coef_`;
      return this._py`attr_LarsCV_coef_.tolist() if hasattr(attr_LarsCV_coef_, 'tolist') else attr_LarsCV_coef_`;
    })();
  }
  /**
    independent term in decision function
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_intercept_ = bridgeLarsCV[${this.id}].intercept_`;
      return this._py`attr_LarsCV_intercept_.tolist() if hasattr(attr_LarsCV_intercept_, 'tolist') else attr_LarsCV_intercept_`;
    })();
  }
  /**
    the varying values of the coefficients along the path
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_coef_path_ = bridgeLarsCV[${this.id}].coef_path_`;
      return this._py`attr_LarsCV_coef_path_.tolist() if hasattr(attr_LarsCV_coef_path_, 'tolist') else attr_LarsCV_coef_path_`;
    })();
  }
  /**
    the estimated regularization parameter alpha
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_alpha_ = bridgeLarsCV[${this.id}].alpha_`;
      return this._py`attr_LarsCV_alpha_.tolist() if hasattr(attr_LarsCV_alpha_, 'tolist') else attr_LarsCV_alpha_`;
    })();
  }
  /**
    the different values of alpha along the path
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_alphas_ = bridgeLarsCV[${this.id}].alphas_`;
      return this._py`attr_LarsCV_alphas_.tolist() if hasattr(attr_LarsCV_alphas_, 'tolist') else attr_LarsCV_alphas_`;
    })();
  }
  /**
    all the values of alpha along the path for the different folds
   */
  get cv_alphas_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing cv_alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_cv_alphas_ = bridgeLarsCV[${this.id}].cv_alphas_`;
      return this._py`attr_LarsCV_cv_alphas_.tolist() if hasattr(attr_LarsCV_cv_alphas_, 'tolist') else attr_LarsCV_cv_alphas_`;
    })();
  }
  /**
    the mean square error on left-out for each fold along the path (alpha values given by `cv\_alphas`)
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_mse_path_ = bridgeLarsCV[${this.id}].mse_path_`;
      return this._py`attr_LarsCV_mse_path_.tolist() if hasattr(attr_LarsCV_mse_path_, 'tolist') else attr_LarsCV_mse_path_`;
    })();
  }
  /**
    the number of iterations run by Lars with the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_n_iter_ = bridgeLarsCV[${this.id}].n_iter_`;
      return this._py`attr_LarsCV_n_iter_.tolist() if hasattr(attr_LarsCV_n_iter_, 'tolist') else attr_LarsCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_n_features_in_ = bridgeLarsCV[${this.id}].n_features_in_`;
      return this._py`attr_LarsCV_n_features_in_.tolist() if hasattr(attr_LarsCV_n_features_in_, 'tolist') else attr_LarsCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LarsCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_feature_names_in_ = bridgeLarsCV[${this.id}].feature_names_in_`;
      return this._py`attr_LarsCV_feature_names_in_.tolist() if hasattr(attr_LarsCV_feature_names_in_, 'tolist') else attr_LarsCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/Lasso.ts
import crypto131 from "node:crypto";
var Lasso = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Lasso${crypto131.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Lasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Lasso
try: bridgeLasso
except NameError: bridgeLasso = {}
`;
    await this._py.ex`ctor_Lasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_Lasso = {k: v for k, v in ctor_Lasso.items() if v is not None}`;
    await this._py.ex`bridgeLasso[${this.id}] = Lasso(**ctor_Lasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before fit()");
    }
    await this._py.ex`pms_Lasso_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_Lasso_fit = {k: v for k, v in pms_Lasso_fit.items() if v is not None}`;
    await this._py.ex`res_Lasso_fit = bridgeLasso[${this.id}].fit(**pms_Lasso_fit)`;
    return this._py`res_Lasso_fit.tolist() if hasattr(res_Lasso_fit, 'tolist') else res_Lasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Lasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Lasso_get_metadata_routing = {k: v for k, v in pms_Lasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Lasso_get_metadata_routing = bridgeLasso[${this.id}].get_metadata_routing(**pms_Lasso_get_metadata_routing)`;
    return this._py`res_Lasso_get_metadata_routing.tolist() if hasattr(res_Lasso_get_metadata_routing, 'tolist') else res_Lasso_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before path()");
    }
    await this._py.ex`pms_Lasso_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_Lasso_path = {k: v for k, v in pms_Lasso_path.items() if v is not None}`;
    await this._py.ex`res_Lasso_path = bridgeLasso[${this.id}].path(**pms_Lasso_path)`;
    return this._py`res_Lasso_path.tolist() if hasattr(res_Lasso_path, 'tolist') else res_Lasso_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before predict()");
    }
    await this._py.ex`pms_Lasso_predict = {'X': ${opts["X"] ?? void 0}}

pms_Lasso_predict = {k: v for k, v in pms_Lasso_predict.items() if v is not None}`;
    await this._py.ex`res_Lasso_predict = bridgeLasso[${this.id}].predict(**pms_Lasso_predict)`;
    return this._py`res_Lasso_predict.tolist() if hasattr(res_Lasso_predict, 'tolist') else res_Lasso_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before score()");
    }
    await this._py.ex`pms_Lasso_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Lasso_score = {k: v for k, v in pms_Lasso_score.items() if v is not None}`;
    await this._py.ex`res_Lasso_score = bridgeLasso[${this.id}].score(**pms_Lasso_score)`;
    return this._py`res_Lasso_score.tolist() if hasattr(res_Lasso_score, 'tolist') else res_Lasso_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Lasso_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lasso_set_fit_request = {k: v for k, v in pms_Lasso_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Lasso_set_fit_request = bridgeLasso[${this.id}].set_fit_request(**pms_Lasso_set_fit_request)`;
    return this._py`res_Lasso_set_fit_request.tolist() if hasattr(res_Lasso_set_fit_request, 'tolist') else res_Lasso_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before set_score_request()");
    }
    await this._py.ex`pms_Lasso_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lasso_set_score_request = {k: v for k, v in pms_Lasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Lasso_set_score_request = bridgeLasso[${this.id}].set_score_request(**pms_Lasso_set_score_request)`;
    return this._py`res_Lasso_set_score_request.tolist() if hasattr(res_Lasso_set_score_request, 'tolist') else res_Lasso_set_score_request`;
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_coef_ = bridgeLasso[${this.id}].coef_`;
      return this._py`attr_Lasso_coef_.tolist() if hasattr(attr_Lasso_coef_, 'tolist') else attr_Lasso_coef_`;
    })();
  }
  /**
    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_dual_gap_ = bridgeLasso[${this.id}].dual_gap_`;
      return this._py`attr_Lasso_dual_gap_.tolist() if hasattr(attr_Lasso_dual_gap_, 'tolist') else attr_Lasso_dual_gap_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_intercept_ = bridgeLasso[${this.id}].intercept_`;
      return this._py`attr_Lasso_intercept_.tolist() if hasattr(attr_Lasso_intercept_, 'tolist') else attr_Lasso_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_n_iter_ = bridgeLasso[${this.id}].n_iter_`;
      return this._py`attr_Lasso_n_iter_.tolist() if hasattr(attr_Lasso_n_iter_, 'tolist') else attr_Lasso_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_n_features_in_ = bridgeLasso[${this.id}].n_features_in_`;
      return this._py`attr_Lasso_n_features_in_.tolist() if hasattr(attr_Lasso_n_features_in_, 'tolist') else attr_Lasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Lasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Lasso_feature_names_in_ = bridgeLasso[${this.id}].feature_names_in_`;
      return this._py`attr_Lasso_feature_names_in_.tolist() if hasattr(attr_Lasso_feature_names_in_, 'tolist') else attr_Lasso_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoCV.ts
import crypto132 from "node:crypto";
var LassoCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoCV${crypto132.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoCV
try: bridgeLassoCV
except NameError: bridgeLassoCV = {}
`;
    await this._py.ex`ctor_LassoCV = {'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_LassoCV = {k: v for k, v in ctor_LassoCV.items() if v is not None}`;
    await this._py.ex`bridgeLassoCV[${this.id}] = LassoCV(**ctor_LassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit linear model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before fit()");
    }
    await this._py.ex`pms_LassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoCV_fit = {k: v for k, v in pms_LassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_LassoCV_fit = bridgeLassoCV[${this.id}].fit(**pms_LassoCV_fit)`;
    return this._py`res_LassoCV_fit.tolist() if hasattr(res_LassoCV_fit, 'tolist') else res_LassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_LassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoCV_get_metadata_routing = {k: v for k, v in pms_LassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoCV_get_metadata_routing = bridgeLassoCV[${this.id}].get_metadata_routing(**pms_LassoCV_get_metadata_routing)`;
    return this._py`res_LassoCV_get_metadata_routing.tolist() if hasattr(res_LassoCV_get_metadata_routing, 'tolist') else res_LassoCV_get_metadata_routing`;
  }
  /**
      Compute Lasso path with coordinate descent.
  
      The Lasso optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before path()");
    }
    await this._py.ex`pms_LassoCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_LassoCV_path = {k: v for k, v in pms_LassoCV_path.items() if v is not None}`;
    await this._py.ex`res_LassoCV_path = bridgeLassoCV[${this.id}].path(**pms_LassoCV_path)`;
    return this._py`res_LassoCV_path.tolist() if hasattr(res_LassoCV_path, 'tolist') else res_LassoCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before predict()");
    }
    await this._py.ex`pms_LassoCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoCV_predict = {k: v for k, v in pms_LassoCV_predict.items() if v is not None}`;
    await this._py.ex`res_LassoCV_predict = bridgeLassoCV[${this.id}].predict(**pms_LassoCV_predict)`;
    return this._py`res_LassoCV_predict.tolist() if hasattr(res_LassoCV_predict, 'tolist') else res_LassoCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before score()");
    }
    await this._py.ex`pms_LassoCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoCV_score = {k: v for k, v in pms_LassoCV_score.items() if v is not None}`;
    await this._py.ex`res_LassoCV_score = bridgeLassoCV[${this.id}].score(**pms_LassoCV_score)`;
    return this._py`res_LassoCV_score.tolist() if hasattr(res_LassoCV_score, 'tolist') else res_LassoCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoCV_set_fit_request = {k: v for k, v in pms_LassoCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoCV_set_fit_request = bridgeLassoCV[${this.id}].set_fit_request(**pms_LassoCV_set_fit_request)`;
    return this._py`res_LassoCV_set_fit_request.tolist() if hasattr(res_LassoCV_set_fit_request, 'tolist') else res_LassoCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoCV_set_score_request = {k: v for k, v in pms_LassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoCV_set_score_request = bridgeLassoCV[${this.id}].set_score_request(**pms_LassoCV_set_score_request)`;
    return this._py`res_LassoCV_set_score_request.tolist() if hasattr(res_LassoCV_set_score_request, 'tolist') else res_LassoCV_set_score_request`;
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_alpha_ = bridgeLassoCV[${this.id}].alpha_`;
      return this._py`attr_LassoCV_alpha_.tolist() if hasattr(attr_LassoCV_alpha_, 'tolist') else attr_LassoCV_alpha_`;
    })();
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_coef_ = bridgeLassoCV[${this.id}].coef_`;
      return this._py`attr_LassoCV_coef_.tolist() if hasattr(attr_LassoCV_coef_, 'tolist') else attr_LassoCV_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_intercept_ = bridgeLassoCV[${this.id}].intercept_`;
      return this._py`attr_LassoCV_intercept_.tolist() if hasattr(attr_LassoCV_intercept_, 'tolist') else attr_LassoCV_intercept_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_mse_path_ = bridgeLassoCV[${this.id}].mse_path_`;
      return this._py`attr_LassoCV_mse_path_.tolist() if hasattr(attr_LassoCV_mse_path_, 'tolist') else attr_LassoCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_alphas_ = bridgeLassoCV[${this.id}].alphas_`;
      return this._py`attr_LassoCV_alphas_.tolist() if hasattr(attr_LassoCV_alphas_, 'tolist') else attr_LassoCV_alphas_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha (`alpha\_`).
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_dual_gap_ = bridgeLassoCV[${this.id}].dual_gap_`;
      return this._py`attr_LassoCV_dual_gap_.tolist() if hasattr(attr_LassoCV_dual_gap_, 'tolist') else attr_LassoCV_dual_gap_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_n_iter_ = bridgeLassoCV[${this.id}].n_iter_`;
      return this._py`attr_LassoCV_n_iter_.tolist() if hasattr(attr_LassoCV_n_iter_, 'tolist') else attr_LassoCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_n_features_in_ = bridgeLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_LassoCV_n_features_in_.tolist() if hasattr(attr_LassoCV_n_features_in_, 'tolist') else attr_LassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_feature_names_in_ = bridgeLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_LassoCV_feature_names_in_.tolist() if hasattr(attr_LassoCV_feature_names_in_, 'tolist') else attr_LassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLars.ts
import crypto133 from "node:crypto";
var LassoLars = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLars${crypto133.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLars.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLars
try: bridgeLassoLars
except NameError: bridgeLassoLars = {}
`;
    await this._py.ex`ctor_LassoLars = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'fit_path': ${this.opts["fit_path"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'jitter': ${this.opts["jitter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_LassoLars = {k: v for k, v in ctor_LassoLars.items() if v is not None}`;
    await this._py.ex`bridgeLassoLars[${this.id}] = LassoLars(**ctor_LassoLars)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLars[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before fit()");
    }
    await this._py.ex`pms_LassoLars_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None}

pms_LassoLars_fit = {k: v for k, v in pms_LassoLars_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLars_fit = bridgeLassoLars[${this.id}].fit(**pms_LassoLars_fit)`;
    return this._py`res_LassoLars_fit.tolist() if hasattr(res_LassoLars_fit, 'tolist') else res_LassoLars_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLars_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLars_get_metadata_routing = {k: v for k, v in pms_LassoLars_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLars_get_metadata_routing = bridgeLassoLars[${this.id}].get_metadata_routing(**pms_LassoLars_get_metadata_routing)`;
    return this._py`res_LassoLars_get_metadata_routing.tolist() if hasattr(res_LassoLars_get_metadata_routing, 'tolist') else res_LassoLars_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before predict()");
    }
    await this._py.ex`pms_LassoLars_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLars_predict = {k: v for k, v in pms_LassoLars_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLars_predict = bridgeLassoLars[${this.id}].predict(**pms_LassoLars_predict)`;
    return this._py`res_LassoLars_predict.tolist() if hasattr(res_LassoLars_predict, 'tolist') else res_LassoLars_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before score()");
    }
    await this._py.ex`pms_LassoLars_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLars_score = {k: v for k, v in pms_LassoLars_score.items() if v is not None}`;
    await this._py.ex`res_LassoLars_score = bridgeLassoLars[${this.id}].score(**pms_LassoLars_score)`;
    return this._py`res_LassoLars_score.tolist() if hasattr(res_LassoLars_score, 'tolist') else res_LassoLars_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLars_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LassoLars_set_fit_request = {k: v for k, v in pms_LassoLars_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLars_set_fit_request = bridgeLassoLars[${this.id}].set_fit_request(**pms_LassoLars_set_fit_request)`;
    return this._py`res_LassoLars_set_fit_request.tolist() if hasattr(res_LassoLars_set_fit_request, 'tolist') else res_LassoLars_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLars_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLars_set_score_request = {k: v for k, v in pms_LassoLars_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLars_set_score_request = bridgeLassoLars[${this.id}].set_score_request(**pms_LassoLars_set_score_request)`;
    return this._py`res_LassoLars_set_score_request.tolist() if hasattr(res_LassoLars_set_score_request, 'tolist') else res_LassoLars_set_score_request`;
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_alphas_ = bridgeLassoLars[${this.id}].alphas_`;
      return this._py`attr_LassoLars_alphas_.tolist() if hasattr(attr_LassoLars_alphas_, 'tolist') else attr_LassoLars_alphas_`;
    })();
  }
  /**
    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_active_ = bridgeLassoLars[${this.id}].active_`;
      return this._py`attr_LassoLars_active_.tolist() if hasattr(attr_LassoLars_active_, 'tolist') else attr_LassoLars_active_`;
    })();
  }
  /**
    If a list is passed itâ€™s expected to be one of n\_targets such arrays. The varying values of the coefficients along the path. It is not present if the `fit\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_coef_path_ = bridgeLassoLars[${this.id}].coef_path_`;
      return this._py`attr_LassoLars_coef_path_.tolist() if hasattr(attr_LassoLars_coef_path_, 'tolist') else attr_LassoLars_coef_path_`;
    })();
  }
  /**
    Parameter vector (w in the formulation formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_coef_ = bridgeLassoLars[${this.id}].coef_`;
      return this._py`attr_LassoLars_coef_.tolist() if hasattr(attr_LassoLars_coef_, 'tolist') else attr_LassoLars_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_intercept_ = bridgeLassoLars[${this.id}].intercept_`;
      return this._py`attr_LassoLars_intercept_.tolist() if hasattr(attr_LassoLars_intercept_, 'tolist') else attr_LassoLars_intercept_`;
    })();
  }
  /**
    The number of iterations taken by lars\_path to find the grid of alphas for each target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_n_iter_ = bridgeLassoLars[${this.id}].n_iter_`;
      return this._py`attr_LassoLars_n_iter_.tolist() if hasattr(attr_LassoLars_n_iter_, 'tolist') else attr_LassoLars_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_n_features_in_ = bridgeLassoLars[${this.id}].n_features_in_`;
      return this._py`attr_LassoLars_n_features_in_.tolist() if hasattr(attr_LassoLars_n_features_in_, 'tolist') else attr_LassoLars_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_feature_names_in_ = bridgeLassoLars[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLars_feature_names_in_.tolist() if hasattr(attr_LassoLars_feature_names_in_, 'tolist') else attr_LassoLars_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLarsCV.ts
import crypto134 from "node:crypto";
var LassoLarsCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLarsCV${crypto134.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLarsCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLarsCV
try: bridgeLassoLarsCV
except NameError: bridgeLassoLarsCV = {}
`;
    await this._py.ex`ctor_LassoLarsCV = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'max_n_alphas': ${this.opts["max_n_alphas"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}}

ctor_LassoLarsCV = {k: v for k, v in ctor_LassoLarsCV.items() if v is not None}`;
    await this._py.ex`bridgeLassoLarsCV[${this.id}] = LassoLarsCV(**ctor_LassoLarsCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLarsCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before fit()");
    }
    await this._py.ex`pms_LassoLarsCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LassoLarsCV_fit = {k: v for k, v in pms_LassoLarsCV_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_fit = bridgeLassoLarsCV[${this.id}].fit(**pms_LassoLarsCV_fit)`;
    return this._py`res_LassoLarsCV_fit.tolist() if hasattr(res_LassoLarsCV_fit, 'tolist') else res_LassoLarsCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLarsCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLarsCV_get_metadata_routing = {k: v for k, v in pms_LassoLarsCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_get_metadata_routing = bridgeLassoLarsCV[${this.id}].get_metadata_routing(**pms_LassoLarsCV_get_metadata_routing)`;
    return this._py`res_LassoLarsCV_get_metadata_routing.tolist() if hasattr(res_LassoLarsCV_get_metadata_routing, 'tolist') else res_LassoLarsCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before predict()");
    }
    await this._py.ex`pms_LassoLarsCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLarsCV_predict = {k: v for k, v in pms_LassoLarsCV_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_predict = bridgeLassoLarsCV[${this.id}].predict(**pms_LassoLarsCV_predict)`;
    return this._py`res_LassoLarsCV_predict.tolist() if hasattr(res_LassoLarsCV_predict, 'tolist') else res_LassoLarsCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before score()");
    }
    await this._py.ex`pms_LassoLarsCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLarsCV_score = {k: v for k, v in pms_LassoLarsCV_score.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_score = bridgeLassoLarsCV[${this.id}].score(**pms_LassoLarsCV_score)`;
    return this._py`res_LassoLarsCV_score.tolist() if hasattr(res_LassoLarsCV_score, 'tolist') else res_LassoLarsCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLarsCV_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LassoLarsCV_set_fit_request = {k: v for k, v in pms_LassoLarsCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_set_fit_request = bridgeLassoLarsCV[${this.id}].set_fit_request(**pms_LassoLarsCV_set_fit_request)`;
    return this._py`res_LassoLarsCV_set_fit_request.tolist() if hasattr(res_LassoLarsCV_set_fit_request, 'tolist') else res_LassoLarsCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLarsCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLarsCV_set_score_request = {k: v for k, v in pms_LassoLarsCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_set_score_request = bridgeLassoLarsCV[${this.id}].set_score_request(**pms_LassoLarsCV_set_score_request)`;
    return this._py`res_LassoLarsCV_set_score_request.tolist() if hasattr(res_LassoLarsCV_set_score_request, 'tolist') else res_LassoLarsCV_set_score_request`;
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_coef_ = bridgeLassoLarsCV[${this.id}].coef_`;
      return this._py`attr_LassoLarsCV_coef_.tolist() if hasattr(attr_LassoLarsCV_coef_, 'tolist') else attr_LassoLarsCV_coef_`;
    })();
  }
  /**
    independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_intercept_ = bridgeLassoLarsCV[${this.id}].intercept_`;
      return this._py`attr_LassoLarsCV_intercept_.tolist() if hasattr(attr_LassoLarsCV_intercept_, 'tolist') else attr_LassoLarsCV_intercept_`;
    })();
  }
  /**
    the varying values of the coefficients along the path
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing coef_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_coef_path_ = bridgeLassoLarsCV[${this.id}].coef_path_`;
      return this._py`attr_LassoLarsCV_coef_path_.tolist() if hasattr(attr_LassoLarsCV_coef_path_, 'tolist') else attr_LassoLarsCV_coef_path_`;
    })();
  }
  /**
    the estimated regularization parameter alpha
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_alpha_ = bridgeLassoLarsCV[${this.id}].alpha_`;
      return this._py`attr_LassoLarsCV_alpha_.tolist() if hasattr(attr_LassoLarsCV_alpha_, 'tolist') else attr_LassoLarsCV_alpha_`;
    })();
  }
  /**
    the different values of alpha along the path
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_alphas_ = bridgeLassoLarsCV[${this.id}].alphas_`;
      return this._py`attr_LassoLarsCV_alphas_.tolist() if hasattr(attr_LassoLarsCV_alphas_, 'tolist') else attr_LassoLarsCV_alphas_`;
    })();
  }
  /**
    all the values of alpha along the path for the different folds
   */
  get cv_alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing cv_alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_cv_alphas_ = bridgeLassoLarsCV[${this.id}].cv_alphas_`;
      return this._py`attr_LassoLarsCV_cv_alphas_.tolist() if hasattr(attr_LassoLarsCV_cv_alphas_, 'tolist') else attr_LassoLarsCV_cv_alphas_`;
    })();
  }
  /**
    the mean square error on left-out for each fold along the path (alpha values given by `cv\_alphas`)
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_mse_path_ = bridgeLassoLarsCV[${this.id}].mse_path_`;
      return this._py`attr_LassoLarsCV_mse_path_.tolist() if hasattr(attr_LassoLarsCV_mse_path_, 'tolist') else attr_LassoLarsCV_mse_path_`;
    })();
  }
  /**
    the number of iterations run by Lars with the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_n_iter_ = bridgeLassoLarsCV[${this.id}].n_iter_`;
      return this._py`attr_LassoLarsCV_n_iter_.tolist() if hasattr(attr_LassoLarsCV_n_iter_, 'tolist') else attr_LassoLarsCV_n_iter_`;
    })();
  }
  /**
    Indices of active variables at the end of the path.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_active_ = bridgeLassoLarsCV[${this.id}].active_`;
      return this._py`attr_LassoLarsCV_active_.tolist() if hasattr(attr_LassoLarsCV_active_, 'tolist') else attr_LassoLarsCV_active_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_n_features_in_ = bridgeLassoLarsCV[${this.id}].n_features_in_`;
      return this._py`attr_LassoLarsCV_n_features_in_.tolist() if hasattr(attr_LassoLarsCV_n_features_in_, 'tolist') else attr_LassoLarsCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_feature_names_in_ = bridgeLassoLarsCV[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLarsCV_feature_names_in_.tolist() if hasattr(attr_LassoLarsCV_feature_names_in_, 'tolist') else attr_LassoLarsCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLarsIC.ts
import crypto135 from "node:crypto";
var LassoLarsIC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLarsIC${crypto135.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLarsIC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLarsIC
try: bridgeLassoLarsIC
except NameError: bridgeLassoLarsIC = {}
`;
    await this._py.ex`ctor_LassoLarsIC = {'criterion': ${this.opts["criterion"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'noise_variance': ${this.opts["noise_variance"] ?? void 0}}

ctor_LassoLarsIC = {k: v for k, v in ctor_LassoLarsIC.items() if v is not None}`;
    await this._py.ex`bridgeLassoLarsIC[${this.id}] = LassoLarsIC(**ctor_LassoLarsIC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLarsIC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before fit()");
    }
    await this._py.ex`pms_LassoLarsIC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}}

pms_LassoLarsIC_fit = {k: v for k, v in pms_LassoLarsIC_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_fit = bridgeLassoLarsIC[${this.id}].fit(**pms_LassoLarsIC_fit)`;
    return this._py`res_LassoLarsIC_fit.tolist() if hasattr(res_LassoLarsIC_fit, 'tolist') else res_LassoLarsIC_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLarsIC_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLarsIC_get_metadata_routing = {k: v for k, v in pms_LassoLarsIC_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_get_metadata_routing = bridgeLassoLarsIC[${this.id}].get_metadata_routing(**pms_LassoLarsIC_get_metadata_routing)`;
    return this._py`res_LassoLarsIC_get_metadata_routing.tolist() if hasattr(res_LassoLarsIC_get_metadata_routing, 'tolist') else res_LassoLarsIC_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before predict()");
    }
    await this._py.ex`pms_LassoLarsIC_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLarsIC_predict = {k: v for k, v in pms_LassoLarsIC_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_predict = bridgeLassoLarsIC[${this.id}].predict(**pms_LassoLarsIC_predict)`;
    return this._py`res_LassoLarsIC_predict.tolist() if hasattr(res_LassoLarsIC_predict, 'tolist') else res_LassoLarsIC_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before score()");
    }
    await this._py.ex`pms_LassoLarsIC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLarsIC_score = {k: v for k, v in pms_LassoLarsIC_score.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_score = bridgeLassoLarsIC[${this.id}].score(**pms_LassoLarsIC_score)`;
    return this._py`res_LassoLarsIC_score.tolist() if hasattr(res_LassoLarsIC_score, 'tolist') else res_LassoLarsIC_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLarsIC_set_fit_request = {'copy_X': ${opts["copy_X"] ?? void 0}}

pms_LassoLarsIC_set_fit_request = {k: v for k, v in pms_LassoLarsIC_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_set_fit_request = bridgeLassoLarsIC[${this.id}].set_fit_request(**pms_LassoLarsIC_set_fit_request)`;
    return this._py`res_LassoLarsIC_set_fit_request.tolist() if hasattr(res_LassoLarsIC_set_fit_request, 'tolist') else res_LassoLarsIC_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLarsIC_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLarsIC_set_score_request = {k: v for k, v in pms_LassoLarsIC_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_set_score_request = bridgeLassoLarsIC[${this.id}].set_score_request(**pms_LassoLarsIC_set_score_request)`;
    return this._py`res_LassoLarsIC_set_score_request.tolist() if hasattr(res_LassoLarsIC_set_score_request, 'tolist') else res_LassoLarsIC_set_score_request`;
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_coef_ = bridgeLassoLarsIC[${this.id}].coef_`;
      return this._py`attr_LassoLarsIC_coef_.tolist() if hasattr(attr_LassoLarsIC_coef_, 'tolist') else attr_LassoLarsIC_coef_`;
    })();
  }
  /**
    independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_intercept_ = bridgeLassoLarsIC[${this.id}].intercept_`;
      return this._py`attr_LassoLarsIC_intercept_.tolist() if hasattr(attr_LassoLarsIC_intercept_, 'tolist') else attr_LassoLarsIC_intercept_`;
    })();
  }
  /**
    the alpha parameter chosen by the information criterion
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_alpha_ = bridgeLassoLarsIC[${this.id}].alpha_`;
      return this._py`attr_LassoLarsIC_alpha_.tolist() if hasattr(attr_LassoLarsIC_alpha_, 'tolist') else attr_LassoLarsIC_alpha_`;
    })();
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If a list, it will be of length `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_alphas_ = bridgeLassoLarsIC[${this.id}].alphas_`;
      return this._py`attr_LassoLarsIC_alphas_.tolist() if hasattr(attr_LassoLarsIC_alphas_, 'tolist') else attr_LassoLarsIC_alphas_`;
    })();
  }
  /**
    number of iterations run by lars\_path to find the grid of alphas.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_n_iter_ = bridgeLassoLarsIC[${this.id}].n_iter_`;
      return this._py`attr_LassoLarsIC_n_iter_.tolist() if hasattr(attr_LassoLarsIC_n_iter_, 'tolist') else attr_LassoLarsIC_n_iter_`;
    })();
  }
  /**
    The value of the information criteria (â€˜aicâ€™, â€˜bicâ€™) across all alphas. The alpha which has the smallest information criterion is chosen, as specified in [\[1\]](#rde9cc43d0d41-1).
   */
  get criterion_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing criterion_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_criterion_ = bridgeLassoLarsIC[${this.id}].criterion_`;
      return this._py`attr_LassoLarsIC_criterion_.tolist() if hasattr(attr_LassoLarsIC_criterion_, 'tolist') else attr_LassoLarsIC_criterion_`;
    })();
  }
  /**
    The estimated noise variance from the data used to compute the criterion.
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_noise_variance_ = bridgeLassoLarsIC[${this.id}].noise_variance_`;
      return this._py`attr_LassoLarsIC_noise_variance_.tolist() if hasattr(attr_LassoLarsIC_noise_variance_, 'tolist') else attr_LassoLarsIC_noise_variance_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_n_features_in_ = bridgeLassoLarsIC[${this.id}].n_features_in_`;
      return this._py`attr_LassoLarsIC_n_features_in_.tolist() if hasattr(attr_LassoLarsIC_n_features_in_, 'tolist') else attr_LassoLarsIC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_feature_names_in_ = bridgeLassoLarsIC[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLarsIC_feature_names_in_.tolist() if hasattr(attr_LassoLarsIC_feature_names_in_, 'tolist') else attr_LassoLarsIC_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LinearRegression.ts
import crypto136 from "node:crypto";
var LinearRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearRegression${crypto136.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LinearRegression
try: bridgeLinearRegression
except NameError: bridgeLinearRegression = {}
`;
    await this._py.ex`ctor_LinearRegression = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}}

ctor_LinearRegression = {k: v for k, v in ctor_LinearRegression.items() if v is not None}`;
    await this._py.ex`bridgeLinearRegression[${this.id}] = LinearRegression(**ctor_LinearRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit linear model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before fit()");
    }
    await this._py.ex`pms_LinearRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearRegression_fit = {k: v for k, v in pms_LinearRegression_fit.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_fit = bridgeLinearRegression[${this.id}].fit(**pms_LinearRegression_fit)`;
    return this._py`res_LinearRegression_fit.tolist() if hasattr(res_LinearRegression_fit, 'tolist') else res_LinearRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearRegression_get_metadata_routing = {k: v for k, v in pms_LinearRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_get_metadata_routing = bridgeLinearRegression[${this.id}].get_metadata_routing(**pms_LinearRegression_get_metadata_routing)`;
    return this._py`res_LinearRegression_get_metadata_routing.tolist() if hasattr(res_LinearRegression_get_metadata_routing, 'tolist') else res_LinearRegression_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before predict()");
    }
    await this._py.ex`pms_LinearRegression_predict = {'X': ${opts["X"] ?? void 0}}

pms_LinearRegression_predict = {k: v for k, v in pms_LinearRegression_predict.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_predict = bridgeLinearRegression[${this.id}].predict(**pms_LinearRegression_predict)`;
    return this._py`res_LinearRegression_predict.tolist() if hasattr(res_LinearRegression_predict, 'tolist') else res_LinearRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before score()");
    }
    await this._py.ex`pms_LinearRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearRegression_score = {k: v for k, v in pms_LinearRegression_score.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_score = bridgeLinearRegression[${this.id}].score(**pms_LinearRegression_score)`;
    return this._py`res_LinearRegression_score.tolist() if hasattr(res_LinearRegression_score, 'tolist') else res_LinearRegression_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LinearRegression_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearRegression_set_fit_request = {k: v for k, v in pms_LinearRegression_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_set_fit_request = bridgeLinearRegression[${this.id}].set_fit_request(**pms_LinearRegression_set_fit_request)`;
    return this._py`res_LinearRegression_set_fit_request.tolist() if hasattr(res_LinearRegression_set_fit_request, 'tolist') else res_LinearRegression_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LinearRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearRegression_set_score_request = {k: v for k, v in pms_LinearRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_set_score_request = bridgeLinearRegression[${this.id}].set_score_request(**pms_LinearRegression_set_score_request)`;
    return this._py`res_LinearRegression_set_score_request.tolist() if hasattr(res_LinearRegression_set_score_request, 'tolist') else res_LinearRegression_set_score_request`;
  }
  /**
    Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n\_targets, n\_features), while if only one target is passed, this is a 1D array of length n\_features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_coef_ = bridgeLinearRegression[${this.id}].coef_`;
      return this._py`attr_LinearRegression_coef_.tolist() if hasattr(attr_LinearRegression_coef_, 'tolist') else attr_LinearRegression_coef_`;
    })();
  }
  /**
    Rank of matrix `X`. Only available when `X` is dense.
   */
  get rank_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing rank_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_rank_ = bridgeLinearRegression[${this.id}].rank_`;
      return this._py`attr_LinearRegression_rank_.tolist() if hasattr(attr_LinearRegression_rank_, 'tolist') else attr_LinearRegression_rank_`;
    })();
  }
  /**
    Singular values of `X`. Only available when `X` is dense.
   */
  get singular_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing singular_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_singular_ = bridgeLinearRegression[${this.id}].singular_`;
      return this._py`attr_LinearRegression_singular_.tolist() if hasattr(attr_LinearRegression_singular_, 'tolist') else attr_LinearRegression_singular_`;
    })();
  }
  /**
    Independent term in the linear model. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_intercept_ = bridgeLinearRegression[${this.id}].intercept_`;
      return this._py`attr_LinearRegression_intercept_.tolist() if hasattr(attr_LinearRegression_intercept_, 'tolist') else attr_LinearRegression_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_n_features_in_ = bridgeLinearRegression[${this.id}].n_features_in_`;
      return this._py`attr_LinearRegression_n_features_in_.tolist() if hasattr(attr_LinearRegression_n_features_in_, 'tolist') else attr_LinearRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_feature_names_in_ = bridgeLinearRegression[${this.id}].feature_names_in_`;
      return this._py`attr_LinearRegression_feature_names_in_.tolist() if hasattr(attr_LinearRegression_feature_names_in_, 'tolist') else attr_LinearRegression_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LogisticRegression.ts
import crypto137 from "node:crypto";
var LogisticRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LogisticRegression${crypto137.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LogisticRegression.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LogisticRegression
try: bridgeLogisticRegression
except NameError: bridgeLogisticRegression = {}
`;
    await this._py.ex`ctor_LogisticRegression = {'penalty': ${this.opts["penalty"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}}

ctor_LogisticRegression = {k: v for k, v in ctor_LogisticRegression.items() if v is not None}`;
    await this._py.ex`bridgeLogisticRegression[${this.id}] = LogisticRegression(**ctor_LogisticRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLogisticRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LogisticRegression_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_decision_function = {k: v for k, v in pms_LogisticRegression_decision_function.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_decision_function = bridgeLogisticRegression[${this.id}].decision_function(**pms_LogisticRegression_decision_function)`;
    return this._py`res_LogisticRegression_decision_function.tolist() if hasattr(res_LogisticRegression_decision_function, 'tolist') else res_LogisticRegression_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before densify()");
    }
    await this._py.ex`pms_LogisticRegression_densify = {}

pms_LogisticRegression_densify = {k: v for k, v in pms_LogisticRegression_densify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_densify = bridgeLogisticRegression[${this.id}].densify(**pms_LogisticRegression_densify)`;
    return this._py`res_LogisticRegression_densify.tolist() if hasattr(res_LogisticRegression_densify, 'tolist') else res_LogisticRegression_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before fit()");
    }
    await this._py.ex`pms_LogisticRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegression_fit = {k: v for k, v in pms_LogisticRegression_fit.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_fit = bridgeLogisticRegression[${this.id}].fit(**pms_LogisticRegression_fit)`;
    return this._py`res_LogisticRegression_fit.tolist() if hasattr(res_LogisticRegression_fit, 'tolist') else res_LogisticRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LogisticRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LogisticRegression_get_metadata_routing = {k: v for k, v in pms_LogisticRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_get_metadata_routing = bridgeLogisticRegression[${this.id}].get_metadata_routing(**pms_LogisticRegression_get_metadata_routing)`;
    return this._py`res_LogisticRegression_get_metadata_routing.tolist() if hasattr(res_LogisticRegression_get_metadata_routing, 'tolist') else res_LogisticRegression_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before predict()");
    }
    await this._py.ex`pms_LogisticRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict = {k: v for k, v in pms_LogisticRegression_predict.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict = bridgeLogisticRegression[${this.id}].predict(**pms_LogisticRegression_predict)`;
    return this._py`res_LogisticRegression_predict.tolist() if hasattr(res_LogisticRegression_predict, 'tolist') else res_LogisticRegression_predict`;
  }
  /**
      Predict logarithm of probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegression_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict_log_proba = {k: v for k, v in pms_LogisticRegression_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict_log_proba = bridgeLogisticRegression[${this.id}].predict_log_proba(**pms_LogisticRegression_predict_log_proba)`;
    return this._py`res_LogisticRegression_predict_log_proba.tolist() if hasattr(res_LogisticRegression_predict_log_proba, 'tolist') else res_LogisticRegression_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
  
      For a multi\_class problem, if multi\_class is set to be â€œmultinomialâ€ the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegression_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict_proba = {k: v for k, v in pms_LogisticRegression_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict_proba = bridgeLogisticRegression[${this.id}].predict_proba(**pms_LogisticRegression_predict_proba)`;
    return this._py`res_LogisticRegression_predict_proba.tolist() if hasattr(res_LogisticRegression_predict_proba, 'tolist') else res_LogisticRegression_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before score()");
    }
    await this._py.ex`pms_LogisticRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegression_score = {k: v for k, v in pms_LogisticRegression_score.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_score = bridgeLogisticRegression[${this.id}].score(**pms_LogisticRegression_score)`;
    return this._py`res_LogisticRegression_score.tolist() if hasattr(res_LogisticRegression_score, 'tolist') else res_LogisticRegression_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LogisticRegression_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegression_set_fit_request = {k: v for k, v in pms_LogisticRegression_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_set_fit_request = bridgeLogisticRegression[${this.id}].set_fit_request(**pms_LogisticRegression_set_fit_request)`;
    return this._py`res_LogisticRegression_set_fit_request.tolist() if hasattr(res_LogisticRegression_set_fit_request, 'tolist') else res_LogisticRegression_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LogisticRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegression_set_score_request = {k: v for k, v in pms_LogisticRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_set_score_request = bridgeLogisticRegression[${this.id}].set_score_request(**pms_LogisticRegression_set_score_request)`;
    return this._py`res_LogisticRegression_set_score_request.tolist() if hasattr(res_LogisticRegression_set_score_request, 'tolist') else res_LogisticRegression_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before sparsify()");
    }
    await this._py.ex`pms_LogisticRegression_sparsify = {}

pms_LogisticRegression_sparsify = {k: v for k, v in pms_LogisticRegression_sparsify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_sparsify = bridgeLogisticRegression[${this.id}].sparsify(**pms_LogisticRegression_sparsify)`;
    return this._py`res_LogisticRegression_sparsify.tolist() if hasattr(res_LogisticRegression_sparsify, 'tolist') else res_LogisticRegression_sparsify`;
  }
  /**
    A list of class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_classes_ = bridgeLogisticRegression[${this.id}].classes_`;
      return this._py`attr_LogisticRegression_classes_.tolist() if hasattr(attr_LogisticRegression_classes_, 'tolist') else attr_LogisticRegression_classes_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary. In particular, when `multi\_class='multinomial'`, `coef\_` corresponds to outcome 1 (`true`) and `\-coef\_` corresponds to outcome 0 (`false`).
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_coef_ = bridgeLogisticRegression[${this.id}].coef_`;
      return this._py`attr_LogisticRegression_coef_.tolist() if hasattr(attr_LogisticRegression_coef_, 'tolist') else attr_LogisticRegression_coef_`;
    })();
  }
  /**
      Intercept (a.k.a. bias) added to the decision function.
  
      If `fit\_intercept` is set to `false`, the intercept is set to zero. `intercept\_` is of shape (1,) when the given problem is binary. In particular, when `multi\_class='multinomial'`, `intercept\_` corresponds to outcome 1 (`true`) and `\-intercept\_` corresponds to outcome 0 (`false`).
     */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_intercept_ = bridgeLogisticRegression[${this.id}].intercept_`;
      return this._py`attr_LogisticRegression_intercept_.tolist() if hasattr(attr_LogisticRegression_intercept_, 'tolist') else attr_LogisticRegression_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_n_features_in_ = bridgeLogisticRegression[${this.id}].n_features_in_`;
      return this._py`attr_LogisticRegression_n_features_in_.tolist() if hasattr(attr_LogisticRegression_n_features_in_, 'tolist') else attr_LogisticRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_feature_names_in_ = bridgeLogisticRegression[${this.id}].feature_names_in_`;
      return this._py`attr_LogisticRegression_feature_names_in_.tolist() if hasattr(attr_LogisticRegression_feature_names_in_, 'tolist') else attr_LogisticRegression_feature_names_in_`;
    })();
  }
  /**
    Actual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_n_iter_ = bridgeLogisticRegression[${this.id}].n_iter_`;
      return this._py`attr_LogisticRegression_n_iter_.tolist() if hasattr(attr_LogisticRegression_n_iter_, 'tolist') else attr_LogisticRegression_n_iter_`;
    })();
  }
};

// src/generated/linear_model/LogisticRegressionCV.ts
import crypto138 from "node:crypto";
var LogisticRegressionCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LogisticRegressionCV${crypto138.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LogisticRegressionCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LogisticRegressionCV
try: bridgeLogisticRegressionCV
except NameError: bridgeLogisticRegressionCV = {}
`;
    await this._py.ex`ctor_LogisticRegressionCV = {'Cs': ${this.opts["Cs"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'l1_ratios': ${this.opts["l1_ratios"] ?? void 0}}

ctor_LogisticRegressionCV = {k: v for k, v in ctor_LogisticRegressionCV.items() if v is not None}`;
    await this._py.ex`bridgeLogisticRegressionCV[${this.id}] = LogisticRegressionCV(**ctor_LogisticRegressionCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLogisticRegressionCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_decision_function = {k: v for k, v in pms_LogisticRegressionCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_decision_function = bridgeLogisticRegressionCV[${this.id}].decision_function(**pms_LogisticRegressionCV_decision_function)`;
    return this._py`res_LogisticRegressionCV_decision_function.tolist() if hasattr(res_LogisticRegressionCV_decision_function, 'tolist') else res_LogisticRegressionCV_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before densify()");
    }
    await this._py.ex`pms_LogisticRegressionCV_densify = {}

pms_LogisticRegressionCV_densify = {k: v for k, v in pms_LogisticRegressionCV_densify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_densify = bridgeLogisticRegressionCV[${this.id}].densify(**pms_LogisticRegressionCV_densify)`;
    return this._py`res_LogisticRegressionCV_densify.tolist() if hasattr(res_LogisticRegressionCV_densify, 'tolist') else res_LogisticRegressionCV_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before fit()");
    }
    await this._py.ex`pms_LogisticRegressionCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegressionCV_fit = {k: v for k, v in pms_LogisticRegressionCV_fit.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_fit = bridgeLogisticRegressionCV[${this.id}].fit(**pms_LogisticRegressionCV_fit)`;
    return this._py`res_LogisticRegressionCV_fit.tolist() if hasattr(res_LogisticRegressionCV_fit, 'tolist') else res_LogisticRegressionCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LogisticRegressionCV_get_metadata_routing = {k: v for k, v in pms_LogisticRegressionCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_get_metadata_routing = bridgeLogisticRegressionCV[${this.id}].get_metadata_routing(**pms_LogisticRegressionCV_get_metadata_routing)`;
    return this._py`res_LogisticRegressionCV_get_metadata_routing.tolist() if hasattr(res_LogisticRegressionCV_get_metadata_routing, 'tolist') else res_LogisticRegressionCV_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before predict()");
    }
    await this._py.ex`pms_LogisticRegressionCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict = {k: v for k, v in pms_LogisticRegressionCV_predict.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict = bridgeLogisticRegressionCV[${this.id}].predict(**pms_LogisticRegressionCV_predict)`;
    return this._py`res_LogisticRegressionCV_predict.tolist() if hasattr(res_LogisticRegressionCV_predict, 'tolist') else res_LogisticRegressionCV_predict`;
  }
  /**
      Predict logarithm of probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict_log_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict_log_proba = bridgeLogisticRegressionCV[${this.id}].predict_log_proba(**pms_LogisticRegressionCV_predict_log_proba)`;
    return this._py`res_LogisticRegressionCV_predict_log_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_log_proba, 'tolist') else res_LogisticRegressionCV_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
  
      For a multi\_class problem, if multi\_class is set to be â€œmultinomialâ€ the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict_proba = bridgeLogisticRegressionCV[${this.id}].predict_proba(**pms_LogisticRegressionCV_predict_proba)`;
    return this._py`res_LogisticRegressionCV_predict_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_proba, 'tolist') else res_LogisticRegressionCV_predict_proba`;
  }
  /**
    Score using the `scoring` option on the given test data and labels.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before score()");
    }
    await this._py.ex`pms_LogisticRegressionCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegressionCV_score = {k: v for k, v in pms_LogisticRegressionCV_score.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_score = bridgeLogisticRegressionCV[${this.id}].score(**pms_LogisticRegressionCV_score)`;
    return this._py`res_LogisticRegressionCV_score.tolist() if hasattr(res_LogisticRegressionCV_score, 'tolist') else res_LogisticRegressionCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegressionCV_set_fit_request = {k: v for k, v in pms_LogisticRegressionCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_set_fit_request = bridgeLogisticRegressionCV[${this.id}].set_fit_request(**pms_LogisticRegressionCV_set_fit_request)`;
    return this._py`res_LogisticRegressionCV_set_fit_request.tolist() if hasattr(res_LogisticRegressionCV_set_fit_request, 'tolist') else res_LogisticRegressionCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegressionCV_set_score_request = {k: v for k, v in pms_LogisticRegressionCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_set_score_request = bridgeLogisticRegressionCV[${this.id}].set_score_request(**pms_LogisticRegressionCV_set_score_request)`;
    return this._py`res_LogisticRegressionCV_set_score_request.tolist() if hasattr(res_LogisticRegressionCV_set_score_request, 'tolist') else res_LogisticRegressionCV_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before sparsify()");
    }
    await this._py.ex`pms_LogisticRegressionCV_sparsify = {}

pms_LogisticRegressionCV_sparsify = {k: v for k, v in pms_LogisticRegressionCV_sparsify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_sparsify = bridgeLogisticRegressionCV[${this.id}].sparsify(**pms_LogisticRegressionCV_sparsify)`;
    return this._py`res_LogisticRegressionCV_sparsify.tolist() if hasattr(res_LogisticRegressionCV_sparsify, 'tolist') else res_LogisticRegressionCV_sparsify`;
  }
  /**
    A list of class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_classes_ = bridgeLogisticRegressionCV[${this.id}].classes_`;
      return this._py`attr_LogisticRegressionCV_classes_.tolist() if hasattr(attr_LogisticRegressionCV_classes_, 'tolist') else attr_LogisticRegressionCV_classes_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_coef_ = bridgeLogisticRegressionCV[${this.id}].coef_`;
      return this._py`attr_LogisticRegressionCV_coef_.tolist() if hasattr(attr_LogisticRegressionCV_coef_, 'tolist') else attr_LogisticRegressionCV_coef_`;
    })();
  }
  /**
      Intercept (a.k.a. bias) added to the decision function.
  
      If `fit\_intercept` is set to `false`, the intercept is set to zero. `intercept\_` is of shape(1,) when the problem is binary.
     */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_intercept_ = bridgeLogisticRegressionCV[${this.id}].intercept_`;
      return this._py`attr_LogisticRegressionCV_intercept_.tolist() if hasattr(attr_LogisticRegressionCV_intercept_, 'tolist') else attr_LogisticRegressionCV_intercept_`;
    })();
  }
  /**
    Array of C i.e. inverse of regularization parameter values used for cross-validation.
   */
  get Cs_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing Cs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_Cs_ = bridgeLogisticRegressionCV[${this.id}].Cs_`;
      return this._py`attr_LogisticRegressionCV_Cs_.tolist() if hasattr(attr_LogisticRegressionCV_Cs_, 'tolist') else attr_LogisticRegressionCV_Cs_`;
    })();
  }
  /**
    Array of l1\_ratios used for cross-validation. If no l1\_ratio is used (i.e. penalty is not â€˜elasticnetâ€™), this is set to `\[`undefined`\]`
   */
  get l1_ratios_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing l1_ratios_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_l1_ratios_ = bridgeLogisticRegressionCV[${this.id}].l1_ratios_`;
      return this._py`attr_LogisticRegressionCV_l1_ratios_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratios_, 'tolist') else attr_LogisticRegressionCV_l1_ratios_`;
    })();
  }
  /**
    dict with classes as the keys, and the path of coefficients obtained during cross-validating across each fold and then across each Cs after doing an OvR for the corresponding class as values. If the â€˜multi\_classâ€™ option is set to â€˜multinomialâ€™, then the coefs\_paths are the coefficients corresponding to each class. Each dict value has shape `(n\_folds, n\_cs, n\_features)` or `(n\_folds, n\_cs, n\_features + 1)` depending on whether the intercept is fit or not. If `penalty='elasticnet'`, the shape is `(n\_folds, n\_cs, n\_l1\_ratios\_, n\_features)` or `(n\_folds, n\_cs, n\_l1\_ratios\_, n\_features + 1)`.
   */
  get coefs_paths_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing coefs_paths_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_coefs_paths_ = bridgeLogisticRegressionCV[${this.id}].coefs_paths_`;
      return this._py`attr_LogisticRegressionCV_coefs_paths_.tolist() if hasattr(attr_LogisticRegressionCV_coefs_paths_, 'tolist') else attr_LogisticRegressionCV_coefs_paths_`;
    })();
  }
  /**
    dict with classes as the keys, and the values as the grid of scores obtained during cross-validating each fold, after doing an OvR for the corresponding class. If the â€˜multi\_classâ€™ option given is â€˜multinomialâ€™ then the same scores are repeated across all classes, since this is the multinomial class. Each dict value has shape `(n\_folds, n\_cs)` or `(n\_folds, n\_cs, n\_l1\_ratios)` if `penalty='elasticnet'`.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_scores_ = bridgeLogisticRegressionCV[${this.id}].scores_`;
      return this._py`attr_LogisticRegressionCV_scores_.tolist() if hasattr(attr_LogisticRegressionCV_scores_, 'tolist') else attr_LogisticRegressionCV_scores_`;
    })();
  }
  /**
    Array of C that maps to the best scores across every class. If refit is set to `false`, then for each class, the best C is the average of the Câ€™s that correspond to the best scores for each fold. `C\_` is of shape(n\_classes,) when the problem is binary.
   */
  get C_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing C_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_C_ = bridgeLogisticRegressionCV[${this.id}].C_`;
      return this._py`attr_LogisticRegressionCV_C_.tolist() if hasattr(attr_LogisticRegressionCV_C_, 'tolist') else attr_LogisticRegressionCV_C_`;
    })();
  }
  /**
    Array of l1\_ratio that maps to the best scores across every class. If refit is set to `false`, then for each class, the best l1\_ratio is the average of the l1\_ratioâ€™s that correspond to the best scores for each fold. `l1\_ratio\_` is of shape(n\_classes,) when the problem is binary.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_l1_ratio_ = bridgeLogisticRegressionCV[${this.id}].l1_ratio_`;
      return this._py`attr_LogisticRegressionCV_l1_ratio_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratio_, 'tolist') else attr_LogisticRegressionCV_l1_ratio_`;
    })();
  }
  /**
    Actual number of iterations for all classes, folds and Cs. In the binary or multinomial cases, the first dimension is equal to 1. If `penalty='elasticnet'`, the shape is `(n\_classes, n\_folds, n\_cs, n\_l1\_ratios)` or `(1, n\_folds, n\_cs, n\_l1\_ratios)`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_n_iter_ = bridgeLogisticRegressionCV[${this.id}].n_iter_`;
      return this._py`attr_LogisticRegressionCV_n_iter_.tolist() if hasattr(attr_LogisticRegressionCV_n_iter_, 'tolist') else attr_LogisticRegressionCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_n_features_in_ = bridgeLogisticRegressionCV[${this.id}].n_features_in_`;
      return this._py`attr_LogisticRegressionCV_n_features_in_.tolist() if hasattr(attr_LogisticRegressionCV_n_features_in_, 'tolist') else attr_LogisticRegressionCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_feature_names_in_ = bridgeLogisticRegressionCV[${this.id}].feature_names_in_`;
      return this._py`attr_LogisticRegressionCV_feature_names_in_.tolist() if hasattr(attr_LogisticRegressionCV_feature_names_in_, 'tolist') else attr_LogisticRegressionCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskElasticNet.ts
import crypto139 from "node:crypto";
var MultiTaskElasticNet = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskElasticNet${crypto139.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiTaskElasticNet.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskElasticNet
try: bridgeMultiTaskElasticNet
except NameError: bridgeMultiTaskElasticNet = {}
`;
    await this._py.ex`ctor_MultiTaskElasticNet = {'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskElasticNet = {k: v for k, v in ctor_MultiTaskElasticNet.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskElasticNet[${this.id}] = MultiTaskElasticNet(**ctor_MultiTaskElasticNet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskElasticNet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit MultiTaskElasticNet model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskElasticNet_fit = {k: v for k, v in pms_MultiTaskElasticNet_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_fit = bridgeMultiTaskElasticNet[${this.id}].fit(**pms_MultiTaskElasticNet_fit)`;
    return this._py`res_MultiTaskElasticNet_fit.tolist() if hasattr(res_MultiTaskElasticNet_fit, 'tolist') else res_MultiTaskElasticNet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskElasticNet_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_get_metadata_routing = bridgeMultiTaskElasticNet[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNet_get_metadata_routing)`;
    return this._py`res_MultiTaskElasticNet_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNet_get_metadata_routing, 'tolist') else res_MultiTaskElasticNet_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskElasticNet_path = {k: v for k, v in pms_MultiTaskElasticNet_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_path = bridgeMultiTaskElasticNet[${this.id}].path(**pms_MultiTaskElasticNet_path)`;
    return this._py`res_MultiTaskElasticNet_path.tolist() if hasattr(res_MultiTaskElasticNet_path, 'tolist') else res_MultiTaskElasticNet_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskElasticNet_predict = {k: v for k, v in pms_MultiTaskElasticNet_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_predict = bridgeMultiTaskElasticNet[${this.id}].predict(**pms_MultiTaskElasticNet_predict)`;
    return this._py`res_MultiTaskElasticNet_predict.tolist() if hasattr(res_MultiTaskElasticNet_predict, 'tolist') else res_MultiTaskElasticNet_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskElasticNet_score = {k: v for k, v in pms_MultiTaskElasticNet_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_score = bridgeMultiTaskElasticNet[${this.id}].score(**pms_MultiTaskElasticNet_score)`;
    return this._py`res_MultiTaskElasticNet_score.tolist() if hasattr(res_MultiTaskElasticNet_score, 'tolist') else res_MultiTaskElasticNet_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNet_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNet_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_set_fit_request = bridgeMultiTaskElasticNet[${this.id}].set_fit_request(**pms_MultiTaskElasticNet_set_fit_request)`;
    return this._py`res_MultiTaskElasticNet_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNet_set_fit_request, 'tolist') else res_MultiTaskElasticNet_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNet_set_score_request = {k: v for k, v in pms_MultiTaskElasticNet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_set_score_request = bridgeMultiTaskElasticNet[${this.id}].set_score_request(**pms_MultiTaskElasticNet_set_score_request)`;
    return this._py`res_MultiTaskElasticNet_set_score_request.tolist() if hasattr(res_MultiTaskElasticNet_set_score_request, 'tolist') else res_MultiTaskElasticNet_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_intercept_ = bridgeMultiTaskElasticNet[${this.id}].intercept_`;
      return this._py`attr_MultiTaskElasticNet_intercept_.tolist() if hasattr(attr_MultiTaskElasticNet_intercept_, 'tolist') else attr_MultiTaskElasticNet_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). If a 1D y is passed in at fit (non multi-task usage), `coef\_` is then a 1D array. Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_coef_ = bridgeMultiTaskElasticNet[${this.id}].coef_`;
      return this._py`attr_MultiTaskElasticNet_coef_.tolist() if hasattr(attr_MultiTaskElasticNet_coef_, 'tolist') else attr_MultiTaskElasticNet_coef_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_n_iter_ = bridgeMultiTaskElasticNet[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskElasticNet_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNet_n_iter_, 'tolist') else attr_MultiTaskElasticNet_n_iter_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_dual_gap_ = bridgeMultiTaskElasticNet[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskElasticNet_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNet_dual_gap_, 'tolist') else attr_MultiTaskElasticNet_dual_gap_`;
    })();
  }
  /**
    The tolerance scaled scaled by the variance of the target `y`.
   */
  get eps_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing eps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_eps_ = bridgeMultiTaskElasticNet[${this.id}].eps_`;
      return this._py`attr_MultiTaskElasticNet_eps_.tolist() if hasattr(attr_MultiTaskElasticNet_eps_, 'tolist') else attr_MultiTaskElasticNet_eps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_n_features_in_ = bridgeMultiTaskElasticNet[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskElasticNet_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNet_n_features_in_, 'tolist') else attr_MultiTaskElasticNet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_feature_names_in_ = bridgeMultiTaskElasticNet[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskElasticNet_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNet_feature_names_in_, 'tolist') else attr_MultiTaskElasticNet_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskElasticNetCV.ts
import crypto140 from "node:crypto";
var MultiTaskElasticNetCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskElasticNetCV${crypto140.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiTaskElasticNetCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskElasticNetCV
try: bridgeMultiTaskElasticNetCV
except NameError: bridgeMultiTaskElasticNetCV = {}
`;
    await this._py.ex`ctor_MultiTaskElasticNetCV = {'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskElasticNetCV = {k: v for k, v in ctor_MultiTaskElasticNetCV.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskElasticNetCV[${this.id}] = MultiTaskElasticNetCV(**ctor_MultiTaskElasticNetCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskElasticNetCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit MultiTaskElasticNet model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskElasticNetCV_fit = {k: v for k, v in pms_MultiTaskElasticNetCV_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_fit = bridgeMultiTaskElasticNetCV[${this.id}].fit(**pms_MultiTaskElasticNetCV_fit)`;
    return this._py`res_MultiTaskElasticNetCV_fit.tolist() if hasattr(res_MultiTaskElasticNetCV_fit, 'tolist') else res_MultiTaskElasticNetCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskElasticNetCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNetCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_get_metadata_routing = bridgeMultiTaskElasticNetCV[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNetCV_get_metadata_routing)`;
    return this._py`res_MultiTaskElasticNetCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNetCV_get_metadata_routing, 'tolist') else res_MultiTaskElasticNetCV_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskElasticNetCV_path = {k: v for k, v in pms_MultiTaskElasticNetCV_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_path = bridgeMultiTaskElasticNetCV[${this.id}].path(**pms_MultiTaskElasticNetCV_path)`;
    return this._py`res_MultiTaskElasticNetCV_path.tolist() if hasattr(res_MultiTaskElasticNetCV_path, 'tolist') else res_MultiTaskElasticNetCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskElasticNetCV_predict = {k: v for k, v in pms_MultiTaskElasticNetCV_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_predict = bridgeMultiTaskElasticNetCV[${this.id}].predict(**pms_MultiTaskElasticNetCV_predict)`;
    return this._py`res_MultiTaskElasticNetCV_predict.tolist() if hasattr(res_MultiTaskElasticNetCV_predict, 'tolist') else res_MultiTaskElasticNetCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskElasticNetCV_score = {k: v for k, v in pms_MultiTaskElasticNetCV_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_score = bridgeMultiTaskElasticNetCV[${this.id}].score(**pms_MultiTaskElasticNetCV_score)`;
    return this._py`res_MultiTaskElasticNetCV_score.tolist() if hasattr(res_MultiTaskElasticNetCV_score, 'tolist') else res_MultiTaskElasticNetCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNetCV_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_set_fit_request = bridgeMultiTaskElasticNetCV[${this.id}].set_fit_request(**pms_MultiTaskElasticNetCV_set_fit_request)`;
    return this._py`res_MultiTaskElasticNetCV_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_fit_request, 'tolist') else res_MultiTaskElasticNetCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNetCV_set_score_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_set_score_request = bridgeMultiTaskElasticNetCV[${this.id}].set_score_request(**pms_MultiTaskElasticNetCV_set_score_request)`;
    return this._py`res_MultiTaskElasticNetCV_set_score_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_score_request, 'tolist') else res_MultiTaskElasticNetCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_intercept_ = bridgeMultiTaskElasticNetCV[${this.id}].intercept_`;
      return this._py`attr_MultiTaskElasticNetCV_intercept_.tolist() if hasattr(attr_MultiTaskElasticNetCV_intercept_, 'tolist') else attr_MultiTaskElasticNetCV_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_coef_ = bridgeMultiTaskElasticNetCV[${this.id}].coef_`;
      return this._py`attr_MultiTaskElasticNetCV_coef_.tolist() if hasattr(attr_MultiTaskElasticNetCV_coef_, 'tolist') else attr_MultiTaskElasticNetCV_coef_`;
    })();
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_alpha_ = bridgeMultiTaskElasticNetCV[${this.id}].alpha_`;
      return this._py`attr_MultiTaskElasticNetCV_alpha_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alpha_, 'tolist') else attr_MultiTaskElasticNetCV_alpha_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_mse_path_ = bridgeMultiTaskElasticNetCV[${this.id}].mse_path_`;
      return this._py`attr_MultiTaskElasticNetCV_mse_path_.tolist() if hasattr(attr_MultiTaskElasticNetCV_mse_path_, 'tolist') else attr_MultiTaskElasticNetCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting, for each l1\_ratio.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_alphas_ = bridgeMultiTaskElasticNetCV[${this.id}].alphas_`;
      return this._py`attr_MultiTaskElasticNetCV_alphas_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alphas_, 'tolist') else attr_MultiTaskElasticNetCV_alphas_`;
    })();
  }
  /**
    Best l1\_ratio obtained by cross-validation.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_l1_ratio_ = bridgeMultiTaskElasticNetCV[${this.id}].l1_ratio_`;
      return this._py`attr_MultiTaskElasticNetCV_l1_ratio_.tolist() if hasattr(attr_MultiTaskElasticNetCV_l1_ratio_, 'tolist') else attr_MultiTaskElasticNetCV_l1_ratio_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_n_iter_ = bridgeMultiTaskElasticNetCV[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskElasticNetCV_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_iter_, 'tolist') else attr_MultiTaskElasticNetCV_n_iter_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_dual_gap_ = bridgeMultiTaskElasticNetCV[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskElasticNetCV_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNetCV_dual_gap_, 'tolist') else attr_MultiTaskElasticNetCV_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_n_features_in_ = bridgeMultiTaskElasticNetCV[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskElasticNetCV_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_features_in_, 'tolist') else attr_MultiTaskElasticNetCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_feature_names_in_ = bridgeMultiTaskElasticNetCV[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskElasticNetCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_feature_names_in_, 'tolist') else attr_MultiTaskElasticNetCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskLasso.ts
import crypto141 from "node:crypto";
var MultiTaskLasso = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskLasso${crypto141.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MultiTaskLasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskLasso
try: bridgeMultiTaskLasso
except NameError: bridgeMultiTaskLasso = {}
`;
    await this._py.ex`ctor_MultiTaskLasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskLasso = {k: v for k, v in ctor_MultiTaskLasso.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskLasso[${this.id}] = MultiTaskLasso(**ctor_MultiTaskLasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit MultiTaskElasticNet model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskLasso_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskLasso_fit = {k: v for k, v in pms_MultiTaskLasso_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_fit = bridgeMultiTaskLasso[${this.id}].fit(**pms_MultiTaskLasso_fit)`;
    return this._py`res_MultiTaskLasso_fit.tolist() if hasattr(res_MultiTaskLasso_fit, 'tolist') else res_MultiTaskLasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskLasso_get_metadata_routing = {k: v for k, v in pms_MultiTaskLasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_get_metadata_routing = bridgeMultiTaskLasso[${this.id}].get_metadata_routing(**pms_MultiTaskLasso_get_metadata_routing)`;
    return this._py`res_MultiTaskLasso_get_metadata_routing.tolist() if hasattr(res_MultiTaskLasso_get_metadata_routing, 'tolist') else res_MultiTaskLasso_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskLasso_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskLasso_path = {k: v for k, v in pms_MultiTaskLasso_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_path = bridgeMultiTaskLasso[${this.id}].path(**pms_MultiTaskLasso_path)`;
    return this._py`res_MultiTaskLasso_path.tolist() if hasattr(res_MultiTaskLasso_path, 'tolist') else res_MultiTaskLasso_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskLasso_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskLasso_predict = {k: v for k, v in pms_MultiTaskLasso_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_predict = bridgeMultiTaskLasso[${this.id}].predict(**pms_MultiTaskLasso_predict)`;
    return this._py`res_MultiTaskLasso_predict.tolist() if hasattr(res_MultiTaskLasso_predict, 'tolist') else res_MultiTaskLasso_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskLasso_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskLasso_score = {k: v for k, v in pms_MultiTaskLasso_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_score = bridgeMultiTaskLasso[${this.id}].score(**pms_MultiTaskLasso_score)`;
    return this._py`res_MultiTaskLasso_score.tolist() if hasattr(res_MultiTaskLasso_score, 'tolist') else res_MultiTaskLasso_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLasso_set_fit_request = {k: v for k, v in pms_MultiTaskLasso_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_set_fit_request = bridgeMultiTaskLasso[${this.id}].set_fit_request(**pms_MultiTaskLasso_set_fit_request)`;
    return this._py`res_MultiTaskLasso_set_fit_request.tolist() if hasattr(res_MultiTaskLasso_set_fit_request, 'tolist') else res_MultiTaskLasso_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLasso_set_score_request = {k: v for k, v in pms_MultiTaskLasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_set_score_request = bridgeMultiTaskLasso[${this.id}].set_score_request(**pms_MultiTaskLasso_set_score_request)`;
    return this._py`res_MultiTaskLasso_set_score_request.tolist() if hasattr(res_MultiTaskLasso_set_score_request, 'tolist') else res_MultiTaskLasso_set_score_request`;
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_coef_ = bridgeMultiTaskLasso[${this.id}].coef_`;
      return this._py`attr_MultiTaskLasso_coef_.tolist() if hasattr(attr_MultiTaskLasso_coef_, 'tolist') else attr_MultiTaskLasso_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_intercept_ = bridgeMultiTaskLasso[${this.id}].intercept_`;
      return this._py`attr_MultiTaskLasso_intercept_.tolist() if hasattr(attr_MultiTaskLasso_intercept_, 'tolist') else attr_MultiTaskLasso_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_n_iter_ = bridgeMultiTaskLasso[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskLasso_n_iter_.tolist() if hasattr(attr_MultiTaskLasso_n_iter_, 'tolist') else attr_MultiTaskLasso_n_iter_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization for each alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_dual_gap_ = bridgeMultiTaskLasso[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskLasso_dual_gap_.tolist() if hasattr(attr_MultiTaskLasso_dual_gap_, 'tolist') else attr_MultiTaskLasso_dual_gap_`;
    })();
  }
  /**
    The tolerance scaled scaled by the variance of the target `y`.
   */
  get eps_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before accessing eps_");
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_eps_ = bridgeMultiTaskLasso[${this.id}].eps_`;
      return this._py`attr_MultiTaskLasso_eps_.tolist() if hasattr(attr_MultiTaskLasso_eps_, 'tolist') else attr_MultiTaskLasso_eps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_n_features_in_ = bridgeMultiTaskLasso[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskLasso_n_features_in_.tolist() if hasattr(attr_MultiTaskLasso_n_features_in_, 'tolist') else attr_MultiTaskLasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_feature_names_in_ = bridgeMultiTaskLasso[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskLasso_feature_names_in_.tolist() if hasattr(attr_MultiTaskLasso_feature_names_in_, 'tolist') else attr_MultiTaskLasso_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskLassoCV.ts
import crypto142 from "node:crypto";
var MultiTaskLassoCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskLassoCV${crypto142.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MultiTaskLassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskLassoCV
try: bridgeMultiTaskLassoCV
except NameError: bridgeMultiTaskLassoCV = {}
`;
    await this._py.ex`ctor_MultiTaskLassoCV = {'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskLassoCV = {k: v for k, v in ctor_MultiTaskLassoCV.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskLassoCV[${this.id}] = MultiTaskLassoCV(**ctor_MultiTaskLassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit MultiTaskLasso model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskLassoCV_fit = {k: v for k, v in pms_MultiTaskLassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_fit = bridgeMultiTaskLassoCV[${this.id}].fit(**pms_MultiTaskLassoCV_fit)`;
    return this._py`res_MultiTaskLassoCV_fit.tolist() if hasattr(res_MultiTaskLassoCV_fit, 'tolist') else res_MultiTaskLassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskLassoCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskLassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_get_metadata_routing = bridgeMultiTaskLassoCV[${this.id}].get_metadata_routing(**pms_MultiTaskLassoCV_get_metadata_routing)`;
    return this._py`res_MultiTaskLassoCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskLassoCV_get_metadata_routing, 'tolist') else res_MultiTaskLassoCV_get_metadata_routing`;
  }
  /**
      Compute Lasso path with coordinate descent.
  
      The Lasso optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskLassoCV_path = {k: v for k, v in pms_MultiTaskLassoCV_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_path = bridgeMultiTaskLassoCV[${this.id}].path(**pms_MultiTaskLassoCV_path)`;
    return this._py`res_MultiTaskLassoCV_path.tolist() if hasattr(res_MultiTaskLassoCV_path, 'tolist') else res_MultiTaskLassoCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskLassoCV_predict = {k: v for k, v in pms_MultiTaskLassoCV_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_predict = bridgeMultiTaskLassoCV[${this.id}].predict(**pms_MultiTaskLassoCV_predict)`;
    return this._py`res_MultiTaskLassoCV_predict.tolist() if hasattr(res_MultiTaskLassoCV_predict, 'tolist') else res_MultiTaskLassoCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskLassoCV_score = {k: v for k, v in pms_MultiTaskLassoCV_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_score = bridgeMultiTaskLassoCV[${this.id}].score(**pms_MultiTaskLassoCV_score)`;
    return this._py`res_MultiTaskLassoCV_score.tolist() if hasattr(res_MultiTaskLassoCV_score, 'tolist') else res_MultiTaskLassoCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLassoCV_set_fit_request = {k: v for k, v in pms_MultiTaskLassoCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_set_fit_request = bridgeMultiTaskLassoCV[${this.id}].set_fit_request(**pms_MultiTaskLassoCV_set_fit_request)`;
    return this._py`res_MultiTaskLassoCV_set_fit_request.tolist() if hasattr(res_MultiTaskLassoCV_set_fit_request, 'tolist') else res_MultiTaskLassoCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLassoCV_set_score_request = {k: v for k, v in pms_MultiTaskLassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_set_score_request = bridgeMultiTaskLassoCV[${this.id}].set_score_request(**pms_MultiTaskLassoCV_set_score_request)`;
    return this._py`res_MultiTaskLassoCV_set_score_request.tolist() if hasattr(res_MultiTaskLassoCV_set_score_request, 'tolist') else res_MultiTaskLassoCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_intercept_ = bridgeMultiTaskLassoCV[${this.id}].intercept_`;
      return this._py`attr_MultiTaskLassoCV_intercept_.tolist() if hasattr(attr_MultiTaskLassoCV_intercept_, 'tolist') else attr_MultiTaskLassoCV_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_coef_ = bridgeMultiTaskLassoCV[${this.id}].coef_`;
      return this._py`attr_MultiTaskLassoCV_coef_.tolist() if hasattr(attr_MultiTaskLassoCV_coef_, 'tolist') else attr_MultiTaskLassoCV_coef_`;
    })();
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_alpha_ = bridgeMultiTaskLassoCV[${this.id}].alpha_`;
      return this._py`attr_MultiTaskLassoCV_alpha_.tolist() if hasattr(attr_MultiTaskLassoCV_alpha_, 'tolist') else attr_MultiTaskLassoCV_alpha_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_mse_path_ = bridgeMultiTaskLassoCV[${this.id}].mse_path_`;
      return this._py`attr_MultiTaskLassoCV_mse_path_.tolist() if hasattr(attr_MultiTaskLassoCV_mse_path_, 'tolist') else attr_MultiTaskLassoCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_alphas_ = bridgeMultiTaskLassoCV[${this.id}].alphas_`;
      return this._py`attr_MultiTaskLassoCV_alphas_.tolist() if hasattr(attr_MultiTaskLassoCV_alphas_, 'tolist') else attr_MultiTaskLassoCV_alphas_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_n_iter_ = bridgeMultiTaskLassoCV[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskLassoCV_n_iter_.tolist() if hasattr(attr_MultiTaskLassoCV_n_iter_, 'tolist') else attr_MultiTaskLassoCV_n_iter_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_dual_gap_ = bridgeMultiTaskLassoCV[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskLassoCV_dual_gap_.tolist() if hasattr(attr_MultiTaskLassoCV_dual_gap_, 'tolist') else attr_MultiTaskLassoCV_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_n_features_in_ = bridgeMultiTaskLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskLassoCV_n_features_in_.tolist() if hasattr(attr_MultiTaskLassoCV_n_features_in_, 'tolist') else attr_MultiTaskLassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_feature_names_in_ = bridgeMultiTaskLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskLassoCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskLassoCV_feature_names_in_, 'tolist') else attr_MultiTaskLassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/OrthogonalMatchingPursuit.ts
import crypto143 from "node:crypto";
var OrthogonalMatchingPursuit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrthogonalMatchingPursuit${crypto143.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OrthogonalMatchingPursuit.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import OrthogonalMatchingPursuit
try: bridgeOrthogonalMatchingPursuit
except NameError: bridgeOrthogonalMatchingPursuit = {}
`;
    await this._py.ex`ctor_OrthogonalMatchingPursuit = {'n_nonzero_coefs': ${this.opts["n_nonzero_coefs"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}}

ctor_OrthogonalMatchingPursuit = {k: v for k, v in ctor_OrthogonalMatchingPursuit.items() if v is not None}`;
    await this._py.ex`bridgeOrthogonalMatchingPursuit[${this.id}] = OrthogonalMatchingPursuit(**ctor_OrthogonalMatchingPursuit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrthogonalMatchingPursuit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OrthogonalMatchingPursuit must call init() before fit()");
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OrthogonalMatchingPursuit_fit = {k: v for k, v in pms_OrthogonalMatchingPursuit_fit.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_fit = bridgeOrthogonalMatchingPursuit[${this.id}].fit(**pms_OrthogonalMatchingPursuit_fit)`;
    return this._py`res_OrthogonalMatchingPursuit_fit.tolist() if hasattr(res_OrthogonalMatchingPursuit_fit, 'tolist') else res_OrthogonalMatchingPursuit_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrthogonalMatchingPursuit_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_get_metadata_routing = bridgeOrthogonalMatchingPursuit[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuit_get_metadata_routing)`;
    return this._py`res_OrthogonalMatchingPursuit_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuit_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuit_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before predict()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_predict = {'X': ${opts["X"] ?? void 0}}

pms_OrthogonalMatchingPursuit_predict = {k: v for k, v in pms_OrthogonalMatchingPursuit_predict.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_predict = bridgeOrthogonalMatchingPursuit[${this.id}].predict(**pms_OrthogonalMatchingPursuit_predict)`;
    return this._py`res_OrthogonalMatchingPursuit_predict.tolist() if hasattr(res_OrthogonalMatchingPursuit_predict, 'tolist') else res_OrthogonalMatchingPursuit_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before score()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OrthogonalMatchingPursuit_score = {k: v for k, v in pms_OrthogonalMatchingPursuit_score.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_score = bridgeOrthogonalMatchingPursuit[${this.id}].score(**pms_OrthogonalMatchingPursuit_score)`;
    return this._py`res_OrthogonalMatchingPursuit_score.tolist() if hasattr(res_OrthogonalMatchingPursuit_score, 'tolist') else res_OrthogonalMatchingPursuit_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OrthogonalMatchingPursuit_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuit_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_set_score_request = bridgeOrthogonalMatchingPursuit[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuit_set_score_request)`;
    return this._py`res_OrthogonalMatchingPursuit_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuit_set_score_request, 'tolist') else res_OrthogonalMatchingPursuit_set_score_request`;
  }
  /**
    Parameter vector (w in the formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_coef_ = bridgeOrthogonalMatchingPursuit[${this.id}].coef_`;
      return this._py`attr_OrthogonalMatchingPursuit_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_coef_, 'tolist') else attr_OrthogonalMatchingPursuit_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_intercept_ = bridgeOrthogonalMatchingPursuit[${this.id}].intercept_`;
      return this._py`attr_OrthogonalMatchingPursuit_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_intercept_, 'tolist') else attr_OrthogonalMatchingPursuit_intercept_`;
    })();
  }
  /**
    Number of active features across every target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_iter_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_iter_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuit_n_iter_`;
    })();
  }
  /**
    The number of non-zero coefficients in the solution. If `n\_nonzero\_coefs` is `undefined` and `tol` is `undefined` this value is either set to 10% of `n\_features` or 1, whichever is greater.
   */
  get n_nonzero_coefs_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_nonzero_coefs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_nonzero_coefs_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuit_n_nonzero_coefs_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_features_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_features_in_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuit_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_feature_names_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].feature_names_in_`;
      return this._py`attr_OrthogonalMatchingPursuit_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuit_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/OrthogonalMatchingPursuitCV.ts
import crypto144 from "node:crypto";
var OrthogonalMatchingPursuitCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrthogonalMatchingPursuitCV${crypto144.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OrthogonalMatchingPursuitCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import OrthogonalMatchingPursuitCV
try: bridgeOrthogonalMatchingPursuitCV
except NameError: bridgeOrthogonalMatchingPursuitCV = {}
`;
    await this._py.ex`ctor_OrthogonalMatchingPursuitCV = {'copy': ${this.opts["copy"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_OrthogonalMatchingPursuitCV = {k: v for k, v in ctor_OrthogonalMatchingPursuitCV.items() if v is not None}`;
    await this._py.ex`bridgeOrthogonalMatchingPursuitCV[${this.id}] = OrthogonalMatchingPursuitCV(**ctor_OrthogonalMatchingPursuitCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrthogonalMatchingPursuitCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before fit()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OrthogonalMatchingPursuitCV_fit = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_fit.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_fit = bridgeOrthogonalMatchingPursuitCV[${this.id}].fit(**pms_OrthogonalMatchingPursuitCV_fit)`;
    return this._py`res_OrthogonalMatchingPursuitCV_fit.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_fit, 'tolist') else res_OrthogonalMatchingPursuitCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_get_metadata_routing = bridgeOrthogonalMatchingPursuitCV[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuitCV_get_metadata_routing)`;
    return this._py`res_OrthogonalMatchingPursuitCV_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuitCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before predict()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_predict = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_predict.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_predict = bridgeOrthogonalMatchingPursuitCV[${this.id}].predict(**pms_OrthogonalMatchingPursuitCV_predict)`;
    return this._py`res_OrthogonalMatchingPursuitCV_predict.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_predict, 'tolist') else res_OrthogonalMatchingPursuitCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before score()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OrthogonalMatchingPursuitCV_score = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_score.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_score = bridgeOrthogonalMatchingPursuitCV[${this.id}].score(**pms_OrthogonalMatchingPursuitCV_score)`;
    return this._py`res_OrthogonalMatchingPursuitCV_score.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_score, 'tolist') else res_OrthogonalMatchingPursuitCV_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_set_score_request = bridgeOrthogonalMatchingPursuitCV[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuitCV_set_score_request)`;
    return this._py`res_OrthogonalMatchingPursuitCV_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_set_score_request, 'tolist') else res_OrthogonalMatchingPursuitCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_intercept_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].intercept_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_intercept_, 'tolist') else attr_OrthogonalMatchingPursuitCV_intercept_`;
    })();
  }
  /**
    Parameter vector (w in the problem formulation).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_coef_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].coef_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_coef_, 'tolist') else attr_OrthogonalMatchingPursuitCV_coef_`;
    })();
  }
  /**
    Estimated number of non-zero coefficients giving the best mean squared error over the cross-validation folds.
   */
  get n_nonzero_coefs_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_nonzero_coefs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_nonzero_coefs_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_`;
    })();
  }
  /**
    Number of active features across every target for the model refit with the best hyperparameters got by cross-validating across all folds.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_iter_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_iter_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_features_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_features_in_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_feature_names_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].feature_names_in_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/PassiveAggressiveClassifier.ts
import crypto145 from "node:crypto";
var PassiveAggressiveClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PassiveAggressiveClassifier${crypto145.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PassiveAggressiveClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import PassiveAggressiveClassifier
try: bridgePassiveAggressiveClassifier
except NameError: bridgePassiveAggressiveClassifier = {}
`;
    await this._py.ex`ctor_PassiveAggressiveClassifier = {'C': ${this.opts["C"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_PassiveAggressiveClassifier = {k: v for k, v in ctor_PassiveAggressiveClassifier.items() if v is not None}`;
    await this._py.ex`bridgePassiveAggressiveClassifier[${this.id}] = PassiveAggressiveClassifier(**ctor_PassiveAggressiveClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePassiveAggressiveClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PassiveAggressiveClassifier_decision_function = {k: v for k, v in pms_PassiveAggressiveClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_decision_function = bridgePassiveAggressiveClassifier[${this.id}].decision_function(**pms_PassiveAggressiveClassifier_decision_function)`;
    return this._py`res_PassiveAggressiveClassifier_decision_function.tolist() if hasattr(res_PassiveAggressiveClassifier_decision_function, 'tolist') else res_PassiveAggressiveClassifier_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before densify()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_densify = {}

pms_PassiveAggressiveClassifier_densify = {k: v for k, v in pms_PassiveAggressiveClassifier_densify.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_densify = bridgePassiveAggressiveClassifier[${this.id}].densify(**pms_PassiveAggressiveClassifier_densify)`;
    return this._py`res_PassiveAggressiveClassifier_densify.tolist() if hasattr(res_PassiveAggressiveClassifier_densify, 'tolist') else res_PassiveAggressiveClassifier_densify`;
  }
  /**
    Fit linear model with Passive Aggressive algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None}

pms_PassiveAggressiveClassifier_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_fit = bridgePassiveAggressiveClassifier[${this.id}].fit(**pms_PassiveAggressiveClassifier_fit)`;
    return this._py`res_PassiveAggressiveClassifier_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_fit, 'tolist') else res_PassiveAggressiveClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PassiveAggressiveClassifier_get_metadata_routing = {k: v for k, v in pms_PassiveAggressiveClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_get_metadata_routing = bridgePassiveAggressiveClassifier[${this.id}].get_metadata_routing(**pms_PassiveAggressiveClassifier_get_metadata_routing)`;
    return this._py`res_PassiveAggressiveClassifier_get_metadata_routing.tolist() if hasattr(res_PassiveAggressiveClassifier_get_metadata_routing, 'tolist') else res_PassiveAggressiveClassifier_get_metadata_routing`;
  }
  /**
    Fit linear model with Passive Aggressive algorithm.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None}

pms_PassiveAggressiveClassifier_partial_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_partial_fit = bridgePassiveAggressiveClassifier[${this.id}].partial_fit(**pms_PassiveAggressiveClassifier_partial_fit)`;
    return this._py`res_PassiveAggressiveClassifier_partial_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_partial_fit, 'tolist') else res_PassiveAggressiveClassifier_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PassiveAggressiveClassifier_predict = {k: v for k, v in pms_PassiveAggressiveClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_predict = bridgePassiveAggressiveClassifier[${this.id}].predict(**pms_PassiveAggressiveClassifier_predict)`;
    return this._py`res_PassiveAggressiveClassifier_predict.tolist() if hasattr(res_PassiveAggressiveClassifier_predict, 'tolist') else res_PassiveAggressiveClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PassiveAggressiveClassifier_score = {k: v for k, v in pms_PassiveAggressiveClassifier_score.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_score = bridgePassiveAggressiveClassifier[${this.id}].score(**pms_PassiveAggressiveClassifier_score)`;
    return this._py`res_PassiveAggressiveClassifier_score.tolist() if hasattr(res_PassiveAggressiveClassifier_score, 'tolist') else res_PassiveAggressiveClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_fit_request(**pms_PassiveAggressiveClassifier_set_fit_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_partial_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_partial_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_partial_fit_request(**pms_PassiveAggressiveClassifier_set_partial_fit_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_partial_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_partial_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_score_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_score_request = bridgePassiveAggressiveClassifier[${this.id}].set_score_request(**pms_PassiveAggressiveClassifier_set_score_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_score_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_score_request, 'tolist') else res_PassiveAggressiveClassifier_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before sparsify()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_sparsify = {}

pms_PassiveAggressiveClassifier_sparsify = {k: v for k, v in pms_PassiveAggressiveClassifier_sparsify.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_sparsify = bridgePassiveAggressiveClassifier[${this.id}].sparsify(**pms_PassiveAggressiveClassifier_sparsify)`;
    return this._py`res_PassiveAggressiveClassifier_sparsify.tolist() if hasattr(res_PassiveAggressiveClassifier_sparsify, 'tolist') else res_PassiveAggressiveClassifier_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_coef_ = bridgePassiveAggressiveClassifier[${this.id}].coef_`;
      return this._py`attr_PassiveAggressiveClassifier_coef_.tolist() if hasattr(attr_PassiveAggressiveClassifier_coef_, 'tolist') else attr_PassiveAggressiveClassifier_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_intercept_ = bridgePassiveAggressiveClassifier[${this.id}].intercept_`;
      return this._py`attr_PassiveAggressiveClassifier_intercept_.tolist() if hasattr(attr_PassiveAggressiveClassifier_intercept_, 'tolist') else attr_PassiveAggressiveClassifier_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_n_features_in_ = bridgePassiveAggressiveClassifier[${this.id}].n_features_in_`;
      return this._py`attr_PassiveAggressiveClassifier_n_features_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_features_in_, 'tolist') else attr_PassiveAggressiveClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_feature_names_in_ = bridgePassiveAggressiveClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_PassiveAggressiveClassifier_feature_names_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_feature_names_in_, 'tolist') else attr_PassiveAggressiveClassifier_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_n_iter_ = bridgePassiveAggressiveClassifier[${this.id}].n_iter_`;
      return this._py`attr_PassiveAggressiveClassifier_n_iter_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_iter_, 'tolist') else attr_PassiveAggressiveClassifier_n_iter_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_classes_ = bridgePassiveAggressiveClassifier[${this.id}].classes_`;
      return this._py`attr_PassiveAggressiveClassifier_classes_.tolist() if hasattr(attr_PassiveAggressiveClassifier_classes_, 'tolist') else attr_PassiveAggressiveClassifier_classes_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing t_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_t_ = bridgePassiveAggressiveClassifier[${this.id}].t_`;
      return this._py`attr_PassiveAggressiveClassifier_t_.tolist() if hasattr(attr_PassiveAggressiveClassifier_t_, 'tolist') else attr_PassiveAggressiveClassifier_t_`;
    })();
  }
  /**
    Loss function used by the algorithm.
   */
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_loss_function_ = bridgePassiveAggressiveClassifier[${this.id}].loss_function_`;
      return this._py`attr_PassiveAggressiveClassifier_loss_function_.tolist() if hasattr(attr_PassiveAggressiveClassifier_loss_function_, 'tolist') else attr_PassiveAggressiveClassifier_loss_function_`;
    })();
  }
};

// src/generated/linear_model/Perceptron.ts
import crypto146 from "node:crypto";
var Perceptron = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Perceptron${crypto146.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Perceptron.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Perceptron
try: bridgePerceptron
except NameError: bridgePerceptron = {}
`;
    await this._py.ex`ctor_Perceptron = {'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}}

ctor_Perceptron = {k: v for k, v in ctor_Perceptron.items() if v is not None}`;
    await this._py.ex`bridgePerceptron[${this.id}] = Perceptron(**ctor_Perceptron)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePerceptron[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before decision_function()");
    }
    await this._py.ex`pms_Perceptron_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Perceptron_decision_function = {k: v for k, v in pms_Perceptron_decision_function.items() if v is not None}`;
    await this._py.ex`res_Perceptron_decision_function = bridgePerceptron[${this.id}].decision_function(**pms_Perceptron_decision_function)`;
    return this._py`res_Perceptron_decision_function.tolist() if hasattr(res_Perceptron_decision_function, 'tolist') else res_Perceptron_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before densify()");
    }
    await this._py.ex`pms_Perceptron_densify = {}

pms_Perceptron_densify = {k: v for k, v in pms_Perceptron_densify.items() if v is not None}`;
    await this._py.ex`res_Perceptron_densify = bridgePerceptron[${this.id}].densify(**pms_Perceptron_densify)`;
    return this._py`res_Perceptron_densify.tolist() if hasattr(res_Perceptron_densify, 'tolist') else res_Perceptron_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before fit()");
    }
    await this._py.ex`pms_Perceptron_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_fit = {k: v for k, v in pms_Perceptron_fit.items() if v is not None}`;
    await this._py.ex`res_Perceptron_fit = bridgePerceptron[${this.id}].fit(**pms_Perceptron_fit)`;
    return this._py`res_Perceptron_fit.tolist() if hasattr(res_Perceptron_fit, 'tolist') else res_Perceptron_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Perceptron_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Perceptron_get_metadata_routing = {k: v for k, v in pms_Perceptron_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Perceptron_get_metadata_routing = bridgePerceptron[${this.id}].get_metadata_routing(**pms_Perceptron_get_metadata_routing)`;
    return this._py`res_Perceptron_get_metadata_routing.tolist() if hasattr(res_Perceptron_get_metadata_routing, 'tolist') else res_Perceptron_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before partial_fit()");
    }
    await this._py.ex`pms_Perceptron_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_partial_fit = {k: v for k, v in pms_Perceptron_partial_fit.items() if v is not None}`;
    await this._py.ex`res_Perceptron_partial_fit = bridgePerceptron[${this.id}].partial_fit(**pms_Perceptron_partial_fit)`;
    return this._py`res_Perceptron_partial_fit.tolist() if hasattr(res_Perceptron_partial_fit, 'tolist') else res_Perceptron_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before predict()");
    }
    await this._py.ex`pms_Perceptron_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Perceptron_predict = {k: v for k, v in pms_Perceptron_predict.items() if v is not None}`;
    await this._py.ex`res_Perceptron_predict = bridgePerceptron[${this.id}].predict(**pms_Perceptron_predict)`;
    return this._py`res_Perceptron_predict.tolist() if hasattr(res_Perceptron_predict, 'tolist') else res_Perceptron_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before score()");
    }
    await this._py.ex`pms_Perceptron_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Perceptron_score = {k: v for k, v in pms_Perceptron_score.items() if v is not None}`;
    await this._py.ex`res_Perceptron_score = bridgePerceptron[${this.id}].score(**pms_Perceptron_score)`;
    return this._py`res_Perceptron_score.tolist() if hasattr(res_Perceptron_score, 'tolist') else res_Perceptron_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Perceptron_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_fit_request = {k: v for k, v in pms_Perceptron_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_fit_request = bridgePerceptron[${this.id}].set_fit_request(**pms_Perceptron_set_fit_request)`;
    return this._py`res_Perceptron_set_fit_request.tolist() if hasattr(res_Perceptron_set_fit_request, 'tolist') else res_Perceptron_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_Perceptron_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_partial_fit_request = {k: v for k, v in pms_Perceptron_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_partial_fit_request = bridgePerceptron[${this.id}].set_partial_fit_request(**pms_Perceptron_set_partial_fit_request)`;
    return this._py`res_Perceptron_set_partial_fit_request.tolist() if hasattr(res_Perceptron_set_partial_fit_request, 'tolist') else res_Perceptron_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before set_score_request()");
    }
    await this._py.ex`pms_Perceptron_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_score_request = {k: v for k, v in pms_Perceptron_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_score_request = bridgePerceptron[${this.id}].set_score_request(**pms_Perceptron_set_score_request)`;
    return this._py`res_Perceptron_set_score_request.tolist() if hasattr(res_Perceptron_set_score_request, 'tolist') else res_Perceptron_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before sparsify()");
    }
    await this._py.ex`pms_Perceptron_sparsify = {}

pms_Perceptron_sparsify = {k: v for k, v in pms_Perceptron_sparsify.items() if v is not None}`;
    await this._py.ex`res_Perceptron_sparsify = bridgePerceptron[${this.id}].sparsify(**pms_Perceptron_sparsify)`;
    return this._py`res_Perceptron_sparsify.tolist() if hasattr(res_Perceptron_sparsify, 'tolist') else res_Perceptron_sparsify`;
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_classes_ = bridgePerceptron[${this.id}].classes_`;
      return this._py`attr_Perceptron_classes_.tolist() if hasattr(attr_Perceptron_classes_, 'tolist') else attr_Perceptron_classes_`;
    })();
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_coef_ = bridgePerceptron[${this.id}].coef_`;
      return this._py`attr_Perceptron_coef_.tolist() if hasattr(attr_Perceptron_coef_, 'tolist') else attr_Perceptron_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_intercept_ = bridgePerceptron[${this.id}].intercept_`;
      return this._py`attr_Perceptron_intercept_.tolist() if hasattr(attr_Perceptron_intercept_, 'tolist') else attr_Perceptron_intercept_`;
    })();
  }
  /**
    The function that determines the loss, or difference between the output of the algorithm and the target values.
   */
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_loss_function_ = bridgePerceptron[${this.id}].loss_function_`;
      return this._py`attr_Perceptron_loss_function_.tolist() if hasattr(attr_Perceptron_loss_function_, 'tolist') else attr_Perceptron_loss_function_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_n_features_in_ = bridgePerceptron[${this.id}].n_features_in_`;
      return this._py`attr_Perceptron_n_features_in_.tolist() if hasattr(attr_Perceptron_n_features_in_, 'tolist') else attr_Perceptron_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_feature_names_in_ = bridgePerceptron[${this.id}].feature_names_in_`;
      return this._py`attr_Perceptron_feature_names_in_.tolist() if hasattr(attr_Perceptron_feature_names_in_, 'tolist') else attr_Perceptron_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_n_iter_ = bridgePerceptron[${this.id}].n_iter_`;
      return this._py`attr_Perceptron_n_iter_.tolist() if hasattr(attr_Perceptron_n_iter_, 'tolist') else attr_Perceptron_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_t_ = bridgePerceptron[${this.id}].t_`;
      return this._py`attr_Perceptron_t_.tolist() if hasattr(attr_Perceptron_t_, 'tolist') else attr_Perceptron_t_`;
    })();
  }
};

// src/generated/linear_model/PoissonRegressor.ts
import crypto147 from "node:crypto";
var PoissonRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PoissonRegressor${crypto147.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PoissonRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import PoissonRegressor
try: bridgePoissonRegressor
except NameError: bridgePoissonRegressor = {}
`;
    await this._py.ex`ctor_PoissonRegressor = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_PoissonRegressor = {k: v for k, v in ctor_PoissonRegressor.items() if v is not None}`;
    await this._py.ex`bridgePoissonRegressor[${this.id}] = PoissonRegressor(**ctor_PoissonRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePoissonRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before fit()");
    }
    await this._py.ex`pms_PoissonRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PoissonRegressor_fit = {k: v for k, v in pms_PoissonRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_fit = bridgePoissonRegressor[${this.id}].fit(**pms_PoissonRegressor_fit)`;
    return this._py`res_PoissonRegressor_fit.tolist() if hasattr(res_PoissonRegressor_fit, 'tolist') else res_PoissonRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PoissonRegressor_get_metadata_routing = {k: v for k, v in pms_PoissonRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_get_metadata_routing = bridgePoissonRegressor[${this.id}].get_metadata_routing(**pms_PoissonRegressor_get_metadata_routing)`;
    return this._py`res_PoissonRegressor_get_metadata_routing.tolist() if hasattr(res_PoissonRegressor_get_metadata_routing, 'tolist') else res_PoissonRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before predict()");
    }
    await this._py.ex`pms_PoissonRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PoissonRegressor_predict = {k: v for k, v in pms_PoissonRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_predict = bridgePoissonRegressor[${this.id}].predict(**pms_PoissonRegressor_predict)`;
    return this._py`res_PoissonRegressor_predict.tolist() if hasattr(res_PoissonRegressor_predict, 'tolist') else res_PoissonRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before score()");
    }
    await this._py.ex`pms_PoissonRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PoissonRegressor_score = {k: v for k, v in pms_PoissonRegressor_score.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_score = bridgePoissonRegressor[${this.id}].score(**pms_PoissonRegressor_score)`;
    return this._py`res_PoissonRegressor_score.tolist() if hasattr(res_PoissonRegressor_score, 'tolist') else res_PoissonRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PoissonRegressor_set_fit_request = {k: v for k, v in pms_PoissonRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_set_fit_request = bridgePoissonRegressor[${this.id}].set_fit_request(**pms_PoissonRegressor_set_fit_request)`;
    return this._py`res_PoissonRegressor_set_fit_request.tolist() if hasattr(res_PoissonRegressor_set_fit_request, 'tolist') else res_PoissonRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PoissonRegressor_set_score_request = {k: v for k, v in pms_PoissonRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_set_score_request = bridgePoissonRegressor[${this.id}].set_score_request(**pms_PoissonRegressor_set_score_request)`;
    return this._py`res_PoissonRegressor_set_score_request.tolist() if hasattr(res_PoissonRegressor_set_score_request, 'tolist') else res_PoissonRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_coef_ = bridgePoissonRegressor[${this.id}].coef_`;
      return this._py`attr_PoissonRegressor_coef_.tolist() if hasattr(attr_PoissonRegressor_coef_, 'tolist') else attr_PoissonRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_intercept_ = bridgePoissonRegressor[${this.id}].intercept_`;
      return this._py`attr_PoissonRegressor_intercept_.tolist() if hasattr(attr_PoissonRegressor_intercept_, 'tolist') else attr_PoissonRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_n_features_in_ = bridgePoissonRegressor[${this.id}].n_features_in_`;
      return this._py`attr_PoissonRegressor_n_features_in_.tolist() if hasattr(attr_PoissonRegressor_n_features_in_, 'tolist') else attr_PoissonRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_feature_names_in_ = bridgePoissonRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_PoissonRegressor_feature_names_in_.tolist() if hasattr(attr_PoissonRegressor_feature_names_in_, 'tolist') else attr_PoissonRegressor_feature_names_in_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_n_iter_ = bridgePoissonRegressor[${this.id}].n_iter_`;
      return this._py`attr_PoissonRegressor_n_iter_.tolist() if hasattr(attr_PoissonRegressor_n_iter_, 'tolist') else attr_PoissonRegressor_n_iter_`;
    })();
  }
};

// src/generated/linear_model/QuantileRegressor.ts
import crypto148 from "node:crypto";
var QuantileRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `QuantileRegressor${crypto148.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("QuantileRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import QuantileRegressor
try: bridgeQuantileRegressor
except NameError: bridgeQuantileRegressor = {}
`;
    await this._py.ex`ctor_QuantileRegressor = {'quantile': ${this.opts["quantile"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'solver_options': ${this.opts["solver_options"] ?? void 0}}

ctor_QuantileRegressor = {k: v for k, v in ctor_QuantileRegressor.items() if v is not None}`;
    await this._py.ex`bridgeQuantileRegressor[${this.id}] = QuantileRegressor(**ctor_QuantileRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuantileRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before fit()");
    }
    await this._py.ex`pms_QuantileRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuantileRegressor_fit = {k: v for k, v in pms_QuantileRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_fit = bridgeQuantileRegressor[${this.id}].fit(**pms_QuantileRegressor_fit)`;
    return this._py`res_QuantileRegressor_fit.tolist() if hasattr(res_QuantileRegressor_fit, 'tolist') else res_QuantileRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuantileRegressor_get_metadata_routing = {k: v for k, v in pms_QuantileRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_get_metadata_routing = bridgeQuantileRegressor[${this.id}].get_metadata_routing(**pms_QuantileRegressor_get_metadata_routing)`;
    return this._py`res_QuantileRegressor_get_metadata_routing.tolist() if hasattr(res_QuantileRegressor_get_metadata_routing, 'tolist') else res_QuantileRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before predict()");
    }
    await this._py.ex`pms_QuantileRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_QuantileRegressor_predict = {k: v for k, v in pms_QuantileRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_predict = bridgeQuantileRegressor[${this.id}].predict(**pms_QuantileRegressor_predict)`;
    return this._py`res_QuantileRegressor_predict.tolist() if hasattr(res_QuantileRegressor_predict, 'tolist') else res_QuantileRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before score()");
    }
    await this._py.ex`pms_QuantileRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuantileRegressor_score = {k: v for k, v in pms_QuantileRegressor_score.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_score = bridgeQuantileRegressor[${this.id}].score(**pms_QuantileRegressor_score)`;
    return this._py`res_QuantileRegressor_score.tolist() if hasattr(res_QuantileRegressor_score, 'tolist') else res_QuantileRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuantileRegressor_set_fit_request = {k: v for k, v in pms_QuantileRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_set_fit_request = bridgeQuantileRegressor[${this.id}].set_fit_request(**pms_QuantileRegressor_set_fit_request)`;
    return this._py`res_QuantileRegressor_set_fit_request.tolist() if hasattr(res_QuantileRegressor_set_fit_request, 'tolist') else res_QuantileRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuantileRegressor_set_score_request = {k: v for k, v in pms_QuantileRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_set_score_request = bridgeQuantileRegressor[${this.id}].set_score_request(**pms_QuantileRegressor_set_score_request)`;
    return this._py`res_QuantileRegressor_set_score_request.tolist() if hasattr(res_QuantileRegressor_set_score_request, 'tolist') else res_QuantileRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_coef_ = bridgeQuantileRegressor[${this.id}].coef_`;
      return this._py`attr_QuantileRegressor_coef_.tolist() if hasattr(attr_QuantileRegressor_coef_, 'tolist') else attr_QuantileRegressor_coef_`;
    })();
  }
  /**
    The intercept of the model, aka bias term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_intercept_ = bridgeQuantileRegressor[${this.id}].intercept_`;
      return this._py`attr_QuantileRegressor_intercept_.tolist() if hasattr(attr_QuantileRegressor_intercept_, 'tolist') else attr_QuantileRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_n_features_in_ = bridgeQuantileRegressor[${this.id}].n_features_in_`;
      return this._py`attr_QuantileRegressor_n_features_in_.tolist() if hasattr(attr_QuantileRegressor_n_features_in_, 'tolist') else attr_QuantileRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_feature_names_in_ = bridgeQuantileRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_QuantileRegressor_feature_names_in_.tolist() if hasattr(attr_QuantileRegressor_feature_names_in_, 'tolist') else attr_QuantileRegressor_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations performed by the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_n_iter_ = bridgeQuantileRegressor[${this.id}].n_iter_`;
      return this._py`attr_QuantileRegressor_n_iter_.tolist() if hasattr(attr_QuantileRegressor_n_iter_, 'tolist') else attr_QuantileRegressor_n_iter_`;
    })();
  }
};

// src/generated/linear_model/RANSACRegressor.ts
import crypto149 from "node:crypto";
var RANSACRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RANSACRegressor${crypto149.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RANSACRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RANSACRegressor
try: bridgeRANSACRegressor
except NameError: bridgeRANSACRegressor = {}
`;
    await this._py.ex`ctor_RANSACRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'residual_threshold': ${this.opts["residual_threshold"] ?? void 0}, 'is_data_valid': ${this.opts["is_data_valid"] ?? void 0}, 'is_model_valid': ${this.opts["is_model_valid"] ?? void 0}, 'max_trials': ${this.opts["max_trials"] ?? void 0}, 'max_skips': ${this.opts["max_skips"] ?? void 0}, 'stop_n_inliers': ${this.opts["stop_n_inliers"] ?? void 0}, 'stop_score': ${this.opts["stop_score"] ?? void 0}, 'stop_probability': ${this.opts["stop_probability"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RANSACRegressor = {k: v for k, v in ctor_RANSACRegressor.items() if v is not None}`;
    await this._py.ex`bridgeRANSACRegressor[${this.id}] = RANSACRegressor(**ctor_RANSACRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRANSACRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit estimator using RANSAC algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before fit()");
    }
    await this._py.ex`pms_RANSACRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RANSACRegressor_fit = {k: v for k, v in pms_RANSACRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_fit = bridgeRANSACRegressor[${this.id}].fit(**pms_RANSACRegressor_fit)`;
    return this._py`res_RANSACRegressor_fit.tolist() if hasattr(res_RANSACRegressor_fit, 'tolist') else res_RANSACRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RANSACRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RANSACRegressor_get_metadata_routing = {k: v for k, v in pms_RANSACRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_get_metadata_routing = bridgeRANSACRegressor[${this.id}].get_metadata_routing(**pms_RANSACRegressor_get_metadata_routing)`;
    return this._py`res_RANSACRegressor_get_metadata_routing.tolist() if hasattr(res_RANSACRegressor_get_metadata_routing, 'tolist') else res_RANSACRegressor_get_metadata_routing`;
  }
  /**
      Predict using the estimated model.
  
      This is a wrapper for `estimator\_.predict(X)`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before predict()");
    }
    await this._py.ex`pms_RANSACRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RANSACRegressor_predict = {k: v for k, v in pms_RANSACRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_predict = bridgeRANSACRegressor[${this.id}].predict(**pms_RANSACRegressor_predict)`;
    return this._py`res_RANSACRegressor_predict.tolist() if hasattr(res_RANSACRegressor_predict, 'tolist') else res_RANSACRegressor_predict`;
  }
  /**
      Return the score of the prediction.
  
      This is a wrapper for `estimator\_.score(X, y)`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before score()");
    }
    await this._py.ex`pms_RANSACRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RANSACRegressor_score = {k: v for k, v in pms_RANSACRegressor_score.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_score = bridgeRANSACRegressor[${this.id}].score(**pms_RANSACRegressor_score)`;
    return this._py`res_RANSACRegressor_score.tolist() if hasattr(res_RANSACRegressor_score, 'tolist') else res_RANSACRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RANSACRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RANSACRegressor_set_fit_request = {k: v for k, v in pms_RANSACRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_set_fit_request = bridgeRANSACRegressor[${this.id}].set_fit_request(**pms_RANSACRegressor_set_fit_request)`;
    return this._py`res_RANSACRegressor_set_fit_request.tolist() if hasattr(res_RANSACRegressor_set_fit_request, 'tolist') else res_RANSACRegressor_set_fit_request`;
  }
  /**
    Best fitted model (copy of the `estimator` object).
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_estimator_ = bridgeRANSACRegressor[${this.id}].estimator_`;
      return this._py`attr_RANSACRegressor_estimator_.tolist() if hasattr(attr_RANSACRegressor_estimator_, 'tolist') else attr_RANSACRegressor_estimator_`;
    })();
  }
  /**
    Number of random selection trials until one of the stop criteria is met. It is always `<= max\_trials`.
   */
  get n_trials_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_trials_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_trials_ = bridgeRANSACRegressor[${this.id}].n_trials_`;
      return this._py`attr_RANSACRegressor_n_trials_.tolist() if hasattr(attr_RANSACRegressor_n_trials_, 'tolist') else attr_RANSACRegressor_n_trials_`;
    })();
  }
  /**
    Boolean mask of inliers classified as `true`.
   */
  get inlier_mask_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing inlier_mask_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_inlier_mask_ = bridgeRANSACRegressor[${this.id}].inlier_mask_`;
      return this._py`attr_RANSACRegressor_inlier_mask_.tolist() if hasattr(attr_RANSACRegressor_inlier_mask_, 'tolist') else attr_RANSACRegressor_inlier_mask_`;
    })();
  }
  /**
    Number of iterations skipped due to finding zero inliers.
   */
  get n_skips_no_inliers_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_no_inliers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_no_inliers_ = bridgeRANSACRegressor[${this.id}].n_skips_no_inliers_`;
      return this._py`attr_RANSACRegressor_n_skips_no_inliers_.tolist() if hasattr(attr_RANSACRegressor_n_skips_no_inliers_, 'tolist') else attr_RANSACRegressor_n_skips_no_inliers_`;
    })();
  }
  /**
    Number of iterations skipped due to invalid data defined by `is\_data\_valid`.
   */
  get n_skips_invalid_data_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_invalid_data_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_invalid_data_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_data_`;
      return this._py`attr_RANSACRegressor_n_skips_invalid_data_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_data_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_data_`;
    })();
  }
  /**
    Number of iterations skipped due to an invalid model defined by `is\_model\_valid`.
   */
  get n_skips_invalid_model_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_invalid_model_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_invalid_model_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_model_`;
      return this._py`attr_RANSACRegressor_n_skips_invalid_model_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_model_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_model_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_features_in_ = bridgeRANSACRegressor[${this.id}].n_features_in_`;
      return this._py`attr_RANSACRegressor_n_features_in_.tolist() if hasattr(attr_RANSACRegressor_n_features_in_, 'tolist') else attr_RANSACRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_feature_names_in_ = bridgeRANSACRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_RANSACRegressor_feature_names_in_.tolist() if hasattr(attr_RANSACRegressor_feature_names_in_, 'tolist') else attr_RANSACRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/Ridge.ts
import crypto150 from "node:crypto";
var Ridge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Ridge${crypto150.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Ridge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Ridge
try: bridgeRidge
except NameError: bridgeRidge = {}
`;
    await this._py.ex`ctor_Ridge = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_Ridge = {k: v for k, v in ctor_Ridge.items() if v is not None}`;
    await this._py.ex`bridgeRidge[${this.id}] = Ridge(**ctor_Ridge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Ridge regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before fit()");
    }
    await this._py.ex`pms_Ridge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Ridge_fit = {k: v for k, v in pms_Ridge_fit.items() if v is not None}`;
    await this._py.ex`res_Ridge_fit = bridgeRidge[${this.id}].fit(**pms_Ridge_fit)`;
    return this._py`res_Ridge_fit.tolist() if hasattr(res_Ridge_fit, 'tolist') else res_Ridge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Ridge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Ridge_get_metadata_routing = {k: v for k, v in pms_Ridge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Ridge_get_metadata_routing = bridgeRidge[${this.id}].get_metadata_routing(**pms_Ridge_get_metadata_routing)`;
    return this._py`res_Ridge_get_metadata_routing.tolist() if hasattr(res_Ridge_get_metadata_routing, 'tolist') else res_Ridge_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before predict()");
    }
    await this._py.ex`pms_Ridge_predict = {'X': ${opts["X"] ?? void 0}}

pms_Ridge_predict = {k: v for k, v in pms_Ridge_predict.items() if v is not None}`;
    await this._py.ex`res_Ridge_predict = bridgeRidge[${this.id}].predict(**pms_Ridge_predict)`;
    return this._py`res_Ridge_predict.tolist() if hasattr(res_Ridge_predict, 'tolist') else res_Ridge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before score()");
    }
    await this._py.ex`pms_Ridge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Ridge_score = {k: v for k, v in pms_Ridge_score.items() if v is not None}`;
    await this._py.ex`res_Ridge_score = bridgeRidge[${this.id}].score(**pms_Ridge_score)`;
    return this._py`res_Ridge_score.tolist() if hasattr(res_Ridge_score, 'tolist') else res_Ridge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Ridge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Ridge_set_fit_request = {k: v for k, v in pms_Ridge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Ridge_set_fit_request = bridgeRidge[${this.id}].set_fit_request(**pms_Ridge_set_fit_request)`;
    return this._py`res_Ridge_set_fit_request.tolist() if hasattr(res_Ridge_set_fit_request, 'tolist') else res_Ridge_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before set_score_request()");
    }
    await this._py.ex`pms_Ridge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Ridge_set_score_request = {k: v for k, v in pms_Ridge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Ridge_set_score_request = bridgeRidge[${this.id}].set_score_request(**pms_Ridge_set_score_request)`;
    return this._py`res_Ridge_set_score_request.tolist() if hasattr(res_Ridge_set_score_request, 'tolist') else res_Ridge_set_score_request`;
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_coef_ = bridgeRidge[${this.id}].coef_`;
      return this._py`attr_Ridge_coef_.tolist() if hasattr(attr_Ridge_coef_, 'tolist') else attr_Ridge_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_intercept_ = bridgeRidge[${this.id}].intercept_`;
      return this._py`attr_Ridge_intercept_.tolist() if hasattr(attr_Ridge_intercept_, 'tolist') else attr_Ridge_intercept_`;
    })();
  }
  /**
    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_n_iter_ = bridgeRidge[${this.id}].n_iter_`;
      return this._py`attr_Ridge_n_iter_.tolist() if hasattr(attr_Ridge_n_iter_, 'tolist') else attr_Ridge_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_n_features_in_ = bridgeRidge[${this.id}].n_features_in_`;
      return this._py`attr_Ridge_n_features_in_.tolist() if hasattr(attr_Ridge_n_features_in_, 'tolist') else attr_Ridge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Ridge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Ridge_feature_names_in_ = bridgeRidge[${this.id}].feature_names_in_`;
      return this._py`attr_Ridge_feature_names_in_.tolist() if hasattr(attr_Ridge_feature_names_in_, 'tolist') else attr_Ridge_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeClassifier.ts
import crypto151 from "node:crypto";
var RidgeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeClassifier${crypto151.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeClassifier
try: bridgeRidgeClassifier
except NameError: bridgeRidgeClassifier = {}
`;
    await this._py.ex`ctor_RidgeClassifier = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RidgeClassifier = {k: v for k, v in ctor_RidgeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRidgeClassifier[${this.id}] = RidgeClassifier(**ctor_RidgeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifier_decision_function = {k: v for k, v in pms_RidgeClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_decision_function = bridgeRidgeClassifier[${this.id}].decision_function(**pms_RidgeClassifier_decision_function)`;
    return this._py`res_RidgeClassifier_decision_function.tolist() if hasattr(res_RidgeClassifier_decision_function, 'tolist') else res_RidgeClassifier_decision_function`;
  }
  /**
    Fit Ridge classifier model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RidgeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifier_fit = {k: v for k, v in pms_RidgeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_fit = bridgeRidgeClassifier[${this.id}].fit(**pms_RidgeClassifier_fit)`;
    return this._py`res_RidgeClassifier_fit.tolist() if hasattr(res_RidgeClassifier_fit, 'tolist') else res_RidgeClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeClassifier_get_metadata_routing = {k: v for k, v in pms_RidgeClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_get_metadata_routing = bridgeRidgeClassifier[${this.id}].get_metadata_routing(**pms_RidgeClassifier_get_metadata_routing)`;
    return this._py`res_RidgeClassifier_get_metadata_routing.tolist() if hasattr(res_RidgeClassifier_get_metadata_routing, 'tolist') else res_RidgeClassifier_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in `X`.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before predict()");
    }
    await this._py.ex`pms_RidgeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifier_predict = {k: v for k, v in pms_RidgeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_predict = bridgeRidgeClassifier[${this.id}].predict(**pms_RidgeClassifier_predict)`;
    return this._py`res_RidgeClassifier_predict.tolist() if hasattr(res_RidgeClassifier_predict, 'tolist') else res_RidgeClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before score()");
    }
    await this._py.ex`pms_RidgeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifier_score = {k: v for k, v in pms_RidgeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_score = bridgeRidgeClassifier[${this.id}].score(**pms_RidgeClassifier_score)`;
    return this._py`res_RidgeClassifier_score.tolist() if hasattr(res_RidgeClassifier_score, 'tolist') else res_RidgeClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifier_set_fit_request = {k: v for k, v in pms_RidgeClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_set_fit_request = bridgeRidgeClassifier[${this.id}].set_fit_request(**pms_RidgeClassifier_set_fit_request)`;
    return this._py`res_RidgeClassifier_set_fit_request.tolist() if hasattr(res_RidgeClassifier_set_fit_request, 'tolist') else res_RidgeClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifier_set_score_request = {k: v for k, v in pms_RidgeClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_set_score_request = bridgeRidgeClassifier[${this.id}].set_score_request(**pms_RidgeClassifier_set_score_request)`;
    return this._py`res_RidgeClassifier_set_score_request.tolist() if hasattr(res_RidgeClassifier_set_score_request, 'tolist') else res_RidgeClassifier_set_score_request`;
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_coef_ = bridgeRidgeClassifier[${this.id}].coef_`;
      return this._py`attr_RidgeClassifier_coef_.tolist() if hasattr(attr_RidgeClassifier_coef_, 'tolist') else attr_RidgeClassifier_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_intercept_ = bridgeRidgeClassifier[${this.id}].intercept_`;
      return this._py`attr_RidgeClassifier_intercept_.tolist() if hasattr(attr_RidgeClassifier_intercept_, 'tolist') else attr_RidgeClassifier_intercept_`;
    })();
  }
  /**
    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_n_iter_ = bridgeRidgeClassifier[${this.id}].n_iter_`;
      return this._py`attr_RidgeClassifier_n_iter_.tolist() if hasattr(attr_RidgeClassifier_n_iter_, 'tolist') else attr_RidgeClassifier_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_n_features_in_ = bridgeRidgeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RidgeClassifier_n_features_in_.tolist() if hasattr(attr_RidgeClassifier_n_features_in_, 'tolist') else attr_RidgeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_feature_names_in_ = bridgeRidgeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeClassifier_feature_names_in_.tolist() if hasattr(attr_RidgeClassifier_feature_names_in_, 'tolist') else attr_RidgeClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeClassifierCV.ts
import crypto152 from "node:crypto";
var RidgeClassifierCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeClassifierCV${crypto152.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeClassifierCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeClassifierCV
try: bridgeRidgeClassifierCV
except NameError: bridgeRidgeClassifierCV = {}
`;
    await this._py.ex`ctor_RidgeClassifierCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'store_cv_values': ${this.opts["store_cv_values"] ?? void 0}}

ctor_RidgeClassifierCV = {k: v for k, v in ctor_RidgeClassifierCV.items() if v is not None}`;
    await this._py.ex`bridgeRidgeClassifierCV[${this.id}] = RidgeClassifierCV(**ctor_RidgeClassifierCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeClassifierCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifierCV_decision_function = {k: v for k, v in pms_RidgeClassifierCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_decision_function = bridgeRidgeClassifierCV[${this.id}].decision_function(**pms_RidgeClassifierCV_decision_function)`;
    return this._py`res_RidgeClassifierCV_decision_function.tolist() if hasattr(res_RidgeClassifierCV_decision_function, 'tolist') else res_RidgeClassifierCV_decision_function`;
  }
  /**
    Fit Ridge classifier with cv.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before fit()");
    }
    await this._py.ex`pms_RidgeClassifierCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifierCV_fit = {k: v for k, v in pms_RidgeClassifierCV_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_fit = bridgeRidgeClassifierCV[${this.id}].fit(**pms_RidgeClassifierCV_fit)`;
    return this._py`res_RidgeClassifierCV_fit.tolist() if hasattr(res_RidgeClassifierCV_fit, 'tolist') else res_RidgeClassifierCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeClassifierCV_get_metadata_routing = {k: v for k, v in pms_RidgeClassifierCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_get_metadata_routing = bridgeRidgeClassifierCV[${this.id}].get_metadata_routing(**pms_RidgeClassifierCV_get_metadata_routing)`;
    return this._py`res_RidgeClassifierCV_get_metadata_routing.tolist() if hasattr(res_RidgeClassifierCV_get_metadata_routing, 'tolist') else res_RidgeClassifierCV_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in `X`.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before predict()");
    }
    await this._py.ex`pms_RidgeClassifierCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifierCV_predict = {k: v for k, v in pms_RidgeClassifierCV_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_predict = bridgeRidgeClassifierCV[${this.id}].predict(**pms_RidgeClassifierCV_predict)`;
    return this._py`res_RidgeClassifierCV_predict.tolist() if hasattr(res_RidgeClassifierCV_predict, 'tolist') else res_RidgeClassifierCV_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before score()");
    }
    await this._py.ex`pms_RidgeClassifierCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifierCV_score = {k: v for k, v in pms_RidgeClassifierCV_score.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_score = bridgeRidgeClassifierCV[${this.id}].score(**pms_RidgeClassifierCV_score)`;
    return this._py`res_RidgeClassifierCV_score.tolist() if hasattr(res_RidgeClassifierCV_score, 'tolist') else res_RidgeClassifierCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifierCV_set_fit_request = {k: v for k, v in pms_RidgeClassifierCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_set_fit_request = bridgeRidgeClassifierCV[${this.id}].set_fit_request(**pms_RidgeClassifierCV_set_fit_request)`;
    return this._py`res_RidgeClassifierCV_set_fit_request.tolist() if hasattr(res_RidgeClassifierCV_set_fit_request, 'tolist') else res_RidgeClassifierCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifierCV_set_score_request = {k: v for k, v in pms_RidgeClassifierCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_set_score_request = bridgeRidgeClassifierCV[${this.id}].set_score_request(**pms_RidgeClassifierCV_set_score_request)`;
    return this._py`res_RidgeClassifierCV_set_score_request.tolist() if hasattr(res_RidgeClassifierCV_set_score_request, 'tolist') else res_RidgeClassifierCV_set_score_request`;
  }
  /**
    Cross-validation values for each alpha (only if `store\_cv\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.
   */
  get cv_values_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing cv_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_cv_values_ = bridgeRidgeClassifierCV[${this.id}].cv_values_`;
      return this._py`attr_RidgeClassifierCV_cv_values_.tolist() if hasattr(attr_RidgeClassifierCV_cv_values_, 'tolist') else attr_RidgeClassifierCV_cv_values_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_coef_ = bridgeRidgeClassifierCV[${this.id}].coef_`;
      return this._py`attr_RidgeClassifierCV_coef_.tolist() if hasattr(attr_RidgeClassifierCV_coef_, 'tolist') else attr_RidgeClassifierCV_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_intercept_ = bridgeRidgeClassifierCV[${this.id}].intercept_`;
      return this._py`attr_RidgeClassifierCV_intercept_.tolist() if hasattr(attr_RidgeClassifierCV_intercept_, 'tolist') else attr_RidgeClassifierCV_intercept_`;
    })();
  }
  /**
    Estimated regularization parameter.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_alpha_ = bridgeRidgeClassifierCV[${this.id}].alpha_`;
      return this._py`attr_RidgeClassifierCV_alpha_.tolist() if hasattr(attr_RidgeClassifierCV_alpha_, 'tolist') else attr_RidgeClassifierCV_alpha_`;
    })();
  }
  /**
    Score of base estimator with best alpha.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_best_score_ = bridgeRidgeClassifierCV[${this.id}].best_score_`;
      return this._py`attr_RidgeClassifierCV_best_score_.tolist() if hasattr(attr_RidgeClassifierCV_best_score_, 'tolist') else attr_RidgeClassifierCV_best_score_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_n_features_in_ = bridgeRidgeClassifierCV[${this.id}].n_features_in_`;
      return this._py`attr_RidgeClassifierCV_n_features_in_.tolist() if hasattr(attr_RidgeClassifierCV_n_features_in_, 'tolist') else attr_RidgeClassifierCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_feature_names_in_ = bridgeRidgeClassifierCV[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeClassifierCV_feature_names_in_.tolist() if hasattr(attr_RidgeClassifierCV_feature_names_in_, 'tolist') else attr_RidgeClassifierCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeCV.ts
import crypto153 from "node:crypto";
var RidgeCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeCV${crypto153.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeCV
try: bridgeRidgeCV
except NameError: bridgeRidgeCV = {}
`;
    await this._py.ex`ctor_RidgeCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'gcv_mode': ${this.opts["gcv_mode"] ?? void 0}, 'store_cv_values': ${this.opts["store_cv_values"] ?? void 0}, 'alpha_per_target': ${this.opts["alpha_per_target"] ?? void 0}}

ctor_RidgeCV = {k: v for k, v in ctor_RidgeCV.items() if v is not None}`;
    await this._py.ex`bridgeRidgeCV[${this.id}] = RidgeCV(**ctor_RidgeCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Ridge regression model with cv.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before fit()");
    }
    await this._py.ex`pms_RidgeCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeCV_fit = {k: v for k, v in pms_RidgeCV_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_fit = bridgeRidgeCV[${this.id}].fit(**pms_RidgeCV_fit)`;
    return this._py`res_RidgeCV_fit.tolist() if hasattr(res_RidgeCV_fit, 'tolist') else res_RidgeCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RidgeCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeCV_get_metadata_routing = {k: v for k, v in pms_RidgeCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_get_metadata_routing = bridgeRidgeCV[${this.id}].get_metadata_routing(**pms_RidgeCV_get_metadata_routing)`;
    return this._py`res_RidgeCV_get_metadata_routing.tolist() if hasattr(res_RidgeCV_get_metadata_routing, 'tolist') else res_RidgeCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before predict()");
    }
    await this._py.ex`pms_RidgeCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_RidgeCV_predict = {k: v for k, v in pms_RidgeCV_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_predict = bridgeRidgeCV[${this.id}].predict(**pms_RidgeCV_predict)`;
    return this._py`res_RidgeCV_predict.tolist() if hasattr(res_RidgeCV_predict, 'tolist') else res_RidgeCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before score()");
    }
    await this._py.ex`pms_RidgeCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeCV_score = {k: v for k, v in pms_RidgeCV_score.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_score = bridgeRidgeCV[${this.id}].score(**pms_RidgeCV_score)`;
    return this._py`res_RidgeCV_score.tolist() if hasattr(res_RidgeCV_score, 'tolist') else res_RidgeCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_RidgeCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeCV_set_fit_request = {k: v for k, v in pms_RidgeCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_set_fit_request = bridgeRidgeCV[${this.id}].set_fit_request(**pms_RidgeCV_set_fit_request)`;
    return this._py`res_RidgeCV_set_fit_request.tolist() if hasattr(res_RidgeCV_set_fit_request, 'tolist') else res_RidgeCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_RidgeCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeCV_set_score_request = {k: v for k, v in pms_RidgeCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_set_score_request = bridgeRidgeCV[${this.id}].set_score_request(**pms_RidgeCV_set_score_request)`;
    return this._py`res_RidgeCV_set_score_request.tolist() if hasattr(res_RidgeCV_set_score_request, 'tolist') else res_RidgeCV_set_score_request`;
  }
  /**
    Cross-validation values for each alpha (only available if `store\_cv\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.
   */
  get cv_values_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing cv_values_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_cv_values_ = bridgeRidgeCV[${this.id}].cv_values_`;
      return this._py`attr_RidgeCV_cv_values_.tolist() if hasattr(attr_RidgeCV_cv_values_, 'tolist') else attr_RidgeCV_cv_values_`;
    })();
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_coef_ = bridgeRidgeCV[${this.id}].coef_`;
      return this._py`attr_RidgeCV_coef_.tolist() if hasattr(attr_RidgeCV_coef_, 'tolist') else attr_RidgeCV_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_intercept_ = bridgeRidgeCV[${this.id}].intercept_`;
      return this._py`attr_RidgeCV_intercept_.tolist() if hasattr(attr_RidgeCV_intercept_, 'tolist') else attr_RidgeCV_intercept_`;
    })();
  }
  /**
    Estimated regularization parameter, or, if `alpha\_per\_target=True`, the estimated regularization parameter for each target.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_alpha_ = bridgeRidgeCV[${this.id}].alpha_`;
      return this._py`attr_RidgeCV_alpha_.tolist() if hasattr(attr_RidgeCV_alpha_, 'tolist') else attr_RidgeCV_alpha_`;
    })();
  }
  /**
    Score of base estimator with best alpha, or, if `alpha\_per\_target=True`, a score for each target.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing best_score_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_best_score_ = bridgeRidgeCV[${this.id}].best_score_`;
      return this._py`attr_RidgeCV_best_score_.tolist() if hasattr(attr_RidgeCV_best_score_, 'tolist') else attr_RidgeCV_best_score_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_n_features_in_ = bridgeRidgeCV[${this.id}].n_features_in_`;
      return this._py`attr_RidgeCV_n_features_in_.tolist() if hasattr(attr_RidgeCV_n_features_in_, 'tolist') else attr_RidgeCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_feature_names_in_ = bridgeRidgeCV[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeCV_feature_names_in_.tolist() if hasattr(attr_RidgeCV_feature_names_in_, 'tolist') else attr_RidgeCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDClassifier.ts
import crypto154 from "node:crypto";
var SGDClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDClassifier${crypto154.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDClassifier
try: bridgeSGDClassifier
except NameError: bridgeSGDClassifier = {}
`;
    await this._py.ex`ctor_SGDClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDClassifier = {k: v for k, v in ctor_SGDClassifier.items() if v is not None}`;
    await this._py.ex`bridgeSGDClassifier[${this.id}] = SGDClassifier(**ctor_SGDClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_SGDClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_decision_function = {k: v for k, v in pms_SGDClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_decision_function = bridgeSGDClassifier[${this.id}].decision_function(**pms_SGDClassifier_decision_function)`;
    return this._py`res_SGDClassifier_decision_function.tolist() if hasattr(res_SGDClassifier_decision_function, 'tolist') else res_SGDClassifier_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before densify()");
    }
    await this._py.ex`pms_SGDClassifier_densify = {}

pms_SGDClassifier_densify = {k: v for k, v in pms_SGDClassifier_densify.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_densify = bridgeSGDClassifier[${this.id}].densify(**pms_SGDClassifier_densify)`;
    return this._py`res_SGDClassifier_densify.tolist() if hasattr(res_SGDClassifier_densify, 'tolist') else res_SGDClassifier_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before fit()");
    }
    await this._py.ex`pms_SGDClassifier_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_fit = {k: v for k, v in pms_SGDClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_fit = bridgeSGDClassifier[${this.id}].fit(**pms_SGDClassifier_fit)`;
    return this._py`res_SGDClassifier_fit.tolist() if hasattr(res_SGDClassifier_fit, 'tolist') else res_SGDClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDClassifier_get_metadata_routing = {k: v for k, v in pms_SGDClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_get_metadata_routing = bridgeSGDClassifier[${this.id}].get_metadata_routing(**pms_SGDClassifier_get_metadata_routing)`;
    return this._py`res_SGDClassifier_get_metadata_routing.tolist() if hasattr(res_SGDClassifier_get_metadata_routing, 'tolist') else res_SGDClassifier_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDClassifier_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_partial_fit = {k: v for k, v in pms_SGDClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_partial_fit = bridgeSGDClassifier[${this.id}].partial_fit(**pms_SGDClassifier_partial_fit)`;
    return this._py`res_SGDClassifier_partial_fit.tolist() if hasattr(res_SGDClassifier_partial_fit, 'tolist') else res_SGDClassifier_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before predict()");
    }
    await this._py.ex`pms_SGDClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_predict = {k: v for k, v in pms_SGDClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict = bridgeSGDClassifier[${this.id}].predict(**pms_SGDClassifier_predict)`;
    return this._py`res_SGDClassifier_predict.tolist() if hasattr(res_SGDClassifier_predict, 'tolist') else res_SGDClassifier_predict`;
  }
  /**
      Log of probability estimates.
  
      This method is only available for log loss and modified Huber loss.
  
      When loss=â€modified\_huberâ€, probability estimates may be hard zeros and ones, so taking the logarithm is not possible.
  
      See `predict\_proba` for details.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_SGDClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_predict_log_proba = {k: v for k, v in pms_SGDClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict_log_proba = bridgeSGDClassifier[${this.id}].predict_log_proba(**pms_SGDClassifier_predict_log_proba)`;
    return this._py`res_SGDClassifier_predict_log_proba.tolist() if hasattr(res_SGDClassifier_predict_log_proba, 'tolist') else res_SGDClassifier_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      This method is only available for log loss and modified Huber loss.
  
      Multiclass probability estimates are derived from binary (one-vs.-rest) estimates by simple normalization, as recommended by Zadrozny and Elkan.
  
      Binary probability estimates for loss=â€modified\_huberâ€ are given by (clip(decision\_function(X), -1, 1) + 1) / 2. For other loss functions it is necessary to perform proper probability calibration by wrapping the classifier with [`CalibratedClassifierCV`](sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV "sklearn.calibration.CalibratedClassifierCV") instead.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before predict_proba()");
    }
    await this._py.ex`pms_SGDClassifier_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_SGDClassifier_predict_proba = {k: v for k, v in pms_SGDClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict_proba = bridgeSGDClassifier[${this.id}].predict_proba(**pms_SGDClassifier_predict_proba)`;
    return this._py`res_SGDClassifier_predict_proba.tolist() if hasattr(res_SGDClassifier_predict_proba, 'tolist') else res_SGDClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before score()");
    }
    await this._py.ex`pms_SGDClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SGDClassifier_score = {k: v for k, v in pms_SGDClassifier_score.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_score = bridgeSGDClassifier[${this.id}].score(**pms_SGDClassifier_score)`;
    return this._py`res_SGDClassifier_score.tolist() if hasattr(res_SGDClassifier_score, 'tolist') else res_SGDClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SGDClassifier_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_fit_request = {k: v for k, v in pms_SGDClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_fit_request = bridgeSGDClassifier[${this.id}].set_fit_request(**pms_SGDClassifier_set_fit_request)`;
    return this._py`res_SGDClassifier_set_fit_request.tolist() if hasattr(res_SGDClassifier_set_fit_request, 'tolist') else res_SGDClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_partial_fit_request = {k: v for k, v in pms_SGDClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_partial_fit_request = bridgeSGDClassifier[${this.id}].set_partial_fit_request(**pms_SGDClassifier_set_partial_fit_request)`;
    return this._py`res_SGDClassifier_set_partial_fit_request.tolist() if hasattr(res_SGDClassifier_set_partial_fit_request, 'tolist') else res_SGDClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_SGDClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_score_request = {k: v for k, v in pms_SGDClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_score_request = bridgeSGDClassifier[${this.id}].set_score_request(**pms_SGDClassifier_set_score_request)`;
    return this._py`res_SGDClassifier_set_score_request.tolist() if hasattr(res_SGDClassifier_set_score_request, 'tolist') else res_SGDClassifier_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDClassifier_sparsify = {}

pms_SGDClassifier_sparsify = {k: v for k, v in pms_SGDClassifier_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_sparsify = bridgeSGDClassifier[${this.id}].sparsify(**pms_SGDClassifier_sparsify)`;
    return this._py`res_SGDClassifier_sparsify.tolist() if hasattr(res_SGDClassifier_sparsify, 'tolist') else res_SGDClassifier_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_coef_ = bridgeSGDClassifier[${this.id}].coef_`;
      return this._py`attr_SGDClassifier_coef_.tolist() if hasattr(attr_SGDClassifier_coef_, 'tolist') else attr_SGDClassifier_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_intercept_ = bridgeSGDClassifier[${this.id}].intercept_`;
      return this._py`attr_SGDClassifier_intercept_.tolist() if hasattr(attr_SGDClassifier_intercept_, 'tolist') else attr_SGDClassifier_intercept_`;
    })();
  }
  /**
    The actual number of iterations before reaching the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_n_iter_ = bridgeSGDClassifier[${this.id}].n_iter_`;
      return this._py`attr_SGDClassifier_n_iter_.tolist() if hasattr(attr_SGDClassifier_n_iter_, 'tolist') else attr_SGDClassifier_n_iter_`;
    })();
  }
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_loss_function_ = bridgeSGDClassifier[${this.id}].loss_function_`;
      return this._py`attr_SGDClassifier_loss_function_.tolist() if hasattr(attr_SGDClassifier_loss_function_, 'tolist') else attr_SGDClassifier_loss_function_`;
    })();
  }
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_classes_ = bridgeSGDClassifier[${this.id}].classes_`;
      return this._py`attr_SGDClassifier_classes_.tolist() if hasattr(attr_SGDClassifier_classes_, 'tolist') else attr_SGDClassifier_classes_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_t_ = bridgeSGDClassifier[${this.id}].t_`;
      return this._py`attr_SGDClassifier_t_.tolist() if hasattr(attr_SGDClassifier_t_, 'tolist') else attr_SGDClassifier_t_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_n_features_in_ = bridgeSGDClassifier[${this.id}].n_features_in_`;
      return this._py`attr_SGDClassifier_n_features_in_.tolist() if hasattr(attr_SGDClassifier_n_features_in_, 'tolist') else attr_SGDClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_feature_names_in_ = bridgeSGDClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_SGDClassifier_feature_names_in_.tolist() if hasattr(attr_SGDClassifier_feature_names_in_, 'tolist') else attr_SGDClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDOneClassSVM.ts
import crypto155 from "node:crypto";
var SGDOneClassSVM = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDOneClassSVM${crypto155.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDOneClassSVM.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDOneClassSVM
try: bridgeSGDOneClassSVM
except NameError: bridgeSGDOneClassSVM = {}
`;
    await this._py.ex`ctor_SGDOneClassSVM = {'nu': ${this.opts["nu"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDOneClassSVM = {k: v for k, v in ctor_SGDOneClassSVM.items() if v is not None}`;
    await this._py.ex`bridgeSGDOneClassSVM[${this.id}] = SGDOneClassSVM(**ctor_SGDOneClassSVM)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDOneClassSVM[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Signed distance to the separating hyperplane.
  
      Signed distance is positive for an inlier and negative for an outlier.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_decision_function = {k: v for k, v in pms_SGDOneClassSVM_decision_function.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_decision_function = bridgeSGDOneClassSVM[${this.id}].decision_function(**pms_SGDOneClassSVM_decision_function)`;
    return this._py`res_SGDOneClassSVM_decision_function.tolist() if hasattr(res_SGDOneClassSVM_decision_function, 'tolist') else res_SGDOneClassSVM_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before densify()");
    }
    await this._py.ex`pms_SGDOneClassSVM_densify = {}

pms_SGDOneClassSVM_densify = {k: v for k, v in pms_SGDOneClassSVM_densify.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_densify = bridgeSGDOneClassSVM[${this.id}].densify(**pms_SGDOneClassSVM_densify)`;
    return this._py`res_SGDOneClassSVM_densify.tolist() if hasattr(res_SGDOneClassSVM_densify, 'tolist') else res_SGDOneClassSVM_densify`;
  }
  /**
      Fit linear One-Class SVM with Stochastic Gradient Descent.
  
      This solves an equivalent optimization problem of the One-Class SVM primal optimization problem and returns a weight vector w and an offset rho such that the decision function is given by <w, x> - rho.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before fit()");
    }
    await this._py.ex`pms_SGDOneClassSVM_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'coef_init': ${opts["coef_init"] ?? void 0}, 'offset_init': ${opts["offset_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_fit = {k: v for k, v in pms_SGDOneClassSVM_fit.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_fit = bridgeSGDOneClassSVM[${this.id}].fit(**pms_SGDOneClassSVM_fit)`;
    return this._py`res_SGDOneClassSVM_fit.tolist() if hasattr(res_SGDOneClassSVM_fit, 'tolist') else res_SGDOneClassSVM_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before fit_predict()");
    }
    await this._py.ex`pms_SGDOneClassSVM_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SGDOneClassSVM_fit_predict = {k: v for k, v in pms_SGDOneClassSVM_fit_predict.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_fit_predict = bridgeSGDOneClassSVM[${this.id}].fit_predict(**pms_SGDOneClassSVM_fit_predict)`;
    return this._py`res_SGDOneClassSVM_fit_predict.tolist() if hasattr(res_SGDOneClassSVM_fit_predict, 'tolist') else res_SGDOneClassSVM_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDOneClassSVM_get_metadata_routing = {k: v for k, v in pms_SGDOneClassSVM_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_get_metadata_routing = bridgeSGDOneClassSVM[${this.id}].get_metadata_routing(**pms_SGDOneClassSVM_get_metadata_routing)`;
    return this._py`res_SGDOneClassSVM_get_metadata_routing.tolist() if hasattr(res_SGDOneClassSVM_get_metadata_routing, 'tolist') else res_SGDOneClassSVM_get_metadata_routing`;
  }
  /**
    Fit linear One-Class SVM with Stochastic Gradient Descent.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDOneClassSVM_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_partial_fit = {k: v for k, v in pms_SGDOneClassSVM_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_partial_fit = bridgeSGDOneClassSVM[${this.id}].partial_fit(**pms_SGDOneClassSVM_partial_fit)`;
    return this._py`res_SGDOneClassSVM_partial_fit.tolist() if hasattr(res_SGDOneClassSVM_partial_fit, 'tolist') else res_SGDOneClassSVM_partial_fit`;
  }
  /**
    Return labels (1 inlier, -1 outlier) of the samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before predict()");
    }
    await this._py.ex`pms_SGDOneClassSVM_predict = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_predict = {k: v for k, v in pms_SGDOneClassSVM_predict.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_predict = bridgeSGDOneClassSVM[${this.id}].predict(**pms_SGDOneClassSVM_predict)`;
    return this._py`res_SGDOneClassSVM_predict.tolist() if hasattr(res_SGDOneClassSVM_predict, 'tolist') else res_SGDOneClassSVM_predict`;
  }
  /**
    Raw scoring function of the samples.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before score_samples()");
    }
    await this._py.ex`pms_SGDOneClassSVM_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_score_samples = {k: v for k, v in pms_SGDOneClassSVM_score_samples.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_score_samples = bridgeSGDOneClassSVM[${this.id}].score_samples(**pms_SGDOneClassSVM_score_samples)`;
    return this._py`res_SGDOneClassSVM_score_samples.tolist() if hasattr(res_SGDOneClassSVM_score_samples, 'tolist') else res_SGDOneClassSVM_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'offset_init': ${opts["offset_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_set_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_set_fit_request = bridgeSGDOneClassSVM[${this.id}].set_fit_request(**pms_SGDOneClassSVM_set_fit_request)`;
    return this._py`res_SGDOneClassSVM_set_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_fit_request, 'tolist') else res_SGDOneClassSVM_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_set_partial_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_set_partial_fit_request = bridgeSGDOneClassSVM[${this.id}].set_partial_fit_request(**pms_SGDOneClassSVM_set_partial_fit_request)`;
    return this._py`res_SGDOneClassSVM_set_partial_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_partial_fit_request, 'tolist') else res_SGDOneClassSVM_set_partial_fit_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDOneClassSVM_sparsify = {}

pms_SGDOneClassSVM_sparsify = {k: v for k, v in pms_SGDOneClassSVM_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_sparsify = bridgeSGDOneClassSVM[${this.id}].sparsify(**pms_SGDOneClassSVM_sparsify)`;
    return this._py`res_SGDOneClassSVM_sparsify.tolist() if hasattr(res_SGDOneClassSVM_sparsify, 'tolist') else res_SGDOneClassSVM_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_coef_ = bridgeSGDOneClassSVM[${this.id}].coef_`;
      return this._py`attr_SGDOneClassSVM_coef_.tolist() if hasattr(attr_SGDOneClassSVM_coef_, 'tolist') else attr_SGDOneClassSVM_coef_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: decision\_function = score\_samples - offset.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_offset_ = bridgeSGDOneClassSVM[${this.id}].offset_`;
      return this._py`attr_SGDOneClassSVM_offset_.tolist() if hasattr(attr_SGDOneClassSVM_offset_, 'tolist') else attr_SGDOneClassSVM_offset_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_n_iter_ = bridgeSGDOneClassSVM[${this.id}].n_iter_`;
      return this._py`attr_SGDOneClassSVM_n_iter_.tolist() if hasattr(attr_SGDOneClassSVM_n_iter_, 'tolist') else attr_SGDOneClassSVM_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_t_ = bridgeSGDOneClassSVM[${this.id}].t_`;
      return this._py`attr_SGDOneClassSVM_t_.tolist() if hasattr(attr_SGDOneClassSVM_t_, 'tolist') else attr_SGDOneClassSVM_t_`;
    })();
  }
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_loss_function_ = bridgeSGDOneClassSVM[${this.id}].loss_function_`;
      return this._py`attr_SGDOneClassSVM_loss_function_.tolist() if hasattr(attr_SGDOneClassSVM_loss_function_, 'tolist') else attr_SGDOneClassSVM_loss_function_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_n_features_in_ = bridgeSGDOneClassSVM[${this.id}].n_features_in_`;
      return this._py`attr_SGDOneClassSVM_n_features_in_.tolist() if hasattr(attr_SGDOneClassSVM_n_features_in_, 'tolist') else attr_SGDOneClassSVM_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_feature_names_in_ = bridgeSGDOneClassSVM[${this.id}].feature_names_in_`;
      return this._py`attr_SGDOneClassSVM_feature_names_in_.tolist() if hasattr(attr_SGDOneClassSVM_feature_names_in_, 'tolist') else attr_SGDOneClassSVM_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDRegressor.ts
import crypto156 from "node:crypto";
var SGDRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDRegressor${crypto156.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDRegressor
try: bridgeSGDRegressor
except NameError: bridgeSGDRegressor = {}
`;
    await this._py.ex`ctor_SGDRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDRegressor = {k: v for k, v in ctor_SGDRegressor.items() if v is not None}`;
    await this._py.ex`bridgeSGDRegressor[${this.id}] = SGDRegressor(**ctor_SGDRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before densify()");
    }
    await this._py.ex`pms_SGDRegressor_densify = {}

pms_SGDRegressor_densify = {k: v for k, v in pms_SGDRegressor_densify.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_densify = bridgeSGDRegressor[${this.id}].densify(**pms_SGDRegressor_densify)`;
    return this._py`res_SGDRegressor_densify.tolist() if hasattr(res_SGDRegressor_densify, 'tolist') else res_SGDRegressor_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before fit()");
    }
    await this._py.ex`pms_SGDRegressor_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_fit = {k: v for k, v in pms_SGDRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_fit = bridgeSGDRegressor[${this.id}].fit(**pms_SGDRegressor_fit)`;
    return this._py`res_SGDRegressor_fit.tolist() if hasattr(res_SGDRegressor_fit, 'tolist') else res_SGDRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDRegressor_get_metadata_routing = {k: v for k, v in pms_SGDRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_get_metadata_routing = bridgeSGDRegressor[${this.id}].get_metadata_routing(**pms_SGDRegressor_get_metadata_routing)`;
    return this._py`res_SGDRegressor_get_metadata_routing.tolist() if hasattr(res_SGDRegressor_get_metadata_routing, 'tolist') else res_SGDRegressor_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence and early stopping should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDRegressor_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_partial_fit = {k: v for k, v in pms_SGDRegressor_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_partial_fit = bridgeSGDRegressor[${this.id}].partial_fit(**pms_SGDRegressor_partial_fit)`;
    return this._py`res_SGDRegressor_partial_fit.tolist() if hasattr(res_SGDRegressor_partial_fit, 'tolist') else res_SGDRegressor_partial_fit`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before predict()");
    }
    await this._py.ex`pms_SGDRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_SGDRegressor_predict = {k: v for k, v in pms_SGDRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_predict = bridgeSGDRegressor[${this.id}].predict(**pms_SGDRegressor_predict)`;
    return this._py`res_SGDRegressor_predict.tolist() if hasattr(res_SGDRegressor_predict, 'tolist') else res_SGDRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before score()");
    }
    await this._py.ex`pms_SGDRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SGDRegressor_score = {k: v for k, v in pms_SGDRegressor_score.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_score = bridgeSGDRegressor[${this.id}].score(**pms_SGDRegressor_score)`;
    return this._py`res_SGDRegressor_score.tolist() if hasattr(res_SGDRegressor_score, 'tolist') else res_SGDRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SGDRegressor_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_fit_request = {k: v for k, v in pms_SGDRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_fit_request = bridgeSGDRegressor[${this.id}].set_fit_request(**pms_SGDRegressor_set_fit_request)`;
    return this._py`res_SGDRegressor_set_fit_request.tolist() if hasattr(res_SGDRegressor_set_fit_request, 'tolist') else res_SGDRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDRegressor_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_partial_fit_request = {k: v for k, v in pms_SGDRegressor_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_partial_fit_request = bridgeSGDRegressor[${this.id}].set_partial_fit_request(**pms_SGDRegressor_set_partial_fit_request)`;
    return this._py`res_SGDRegressor_set_partial_fit_request.tolist() if hasattr(res_SGDRegressor_set_partial_fit_request, 'tolist') else res_SGDRegressor_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_SGDRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_score_request = {k: v for k, v in pms_SGDRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_score_request = bridgeSGDRegressor[${this.id}].set_score_request(**pms_SGDRegressor_set_score_request)`;
    return this._py`res_SGDRegressor_set_score_request.tolist() if hasattr(res_SGDRegressor_set_score_request, 'tolist') else res_SGDRegressor_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDRegressor_sparsify = {}

pms_SGDRegressor_sparsify = {k: v for k, v in pms_SGDRegressor_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_sparsify = bridgeSGDRegressor[${this.id}].sparsify(**pms_SGDRegressor_sparsify)`;
    return this._py`res_SGDRegressor_sparsify.tolist() if hasattr(res_SGDRegressor_sparsify, 'tolist') else res_SGDRegressor_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_coef_ = bridgeSGDRegressor[${this.id}].coef_`;
      return this._py`attr_SGDRegressor_coef_.tolist() if hasattr(attr_SGDRegressor_coef_, 'tolist') else attr_SGDRegressor_coef_`;
    })();
  }
  /**
    The intercept term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_intercept_ = bridgeSGDRegressor[${this.id}].intercept_`;
      return this._py`attr_SGDRegressor_intercept_.tolist() if hasattr(attr_SGDRegressor_intercept_, 'tolist') else attr_SGDRegressor_intercept_`;
    })();
  }
  /**
    The actual number of iterations before reaching the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_n_iter_ = bridgeSGDRegressor[${this.id}].n_iter_`;
      return this._py`attr_SGDRegressor_n_iter_.tolist() if hasattr(attr_SGDRegressor_n_iter_, 'tolist') else attr_SGDRegressor_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_t_ = bridgeSGDRegressor[${this.id}].t_`;
      return this._py`attr_SGDRegressor_t_.tolist() if hasattr(attr_SGDRegressor_t_, 'tolist') else attr_SGDRegressor_t_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_n_features_in_ = bridgeSGDRegressor[${this.id}].n_features_in_`;
      return this._py`attr_SGDRegressor_n_features_in_.tolist() if hasattr(attr_SGDRegressor_n_features_in_, 'tolist') else attr_SGDRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_feature_names_in_ = bridgeSGDRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_SGDRegressor_feature_names_in_.tolist() if hasattr(attr_SGDRegressor_feature_names_in_, 'tolist') else attr_SGDRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/TheilSenRegressor.ts
import crypto157 from "node:crypto";
var TheilSenRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TheilSenRegressor${crypto157.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TheilSenRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import TheilSenRegressor
try: bridgeTheilSenRegressor
except NameError: bridgeTheilSenRegressor = {}
`;
    await this._py.ex`ctor_TheilSenRegressor = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_subpopulation': ${this.opts["max_subpopulation"] ?? void 0}, 'n_subsamples': ${this.opts["n_subsamples"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_TheilSenRegressor = {k: v for k, v in ctor_TheilSenRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTheilSenRegressor[${this.id}] = TheilSenRegressor(**ctor_TheilSenRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTheilSenRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit linear model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before fit()");
    }
    await this._py.ex`pms_TheilSenRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TheilSenRegressor_fit = {k: v for k, v in pms_TheilSenRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_fit = bridgeTheilSenRegressor[${this.id}].fit(**pms_TheilSenRegressor_fit)`;
    return this._py`res_TheilSenRegressor_fit.tolist() if hasattr(res_TheilSenRegressor_fit, 'tolist') else res_TheilSenRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TheilSenRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TheilSenRegressor_get_metadata_routing = {k: v for k, v in pms_TheilSenRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_get_metadata_routing = bridgeTheilSenRegressor[${this.id}].get_metadata_routing(**pms_TheilSenRegressor_get_metadata_routing)`;
    return this._py`res_TheilSenRegressor_get_metadata_routing.tolist() if hasattr(res_TheilSenRegressor_get_metadata_routing, 'tolist') else res_TheilSenRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before predict()");
    }
    await this._py.ex`pms_TheilSenRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_TheilSenRegressor_predict = {k: v for k, v in pms_TheilSenRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_predict = bridgeTheilSenRegressor[${this.id}].predict(**pms_TheilSenRegressor_predict)`;
    return this._py`res_TheilSenRegressor_predict.tolist() if hasattr(res_TheilSenRegressor_predict, 'tolist') else res_TheilSenRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before score()");
    }
    await this._py.ex`pms_TheilSenRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TheilSenRegressor_score = {k: v for k, v in pms_TheilSenRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_score = bridgeTheilSenRegressor[${this.id}].score(**pms_TheilSenRegressor_score)`;
    return this._py`res_TheilSenRegressor_score.tolist() if hasattr(res_TheilSenRegressor_score, 'tolist') else res_TheilSenRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TheilSenRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TheilSenRegressor_set_score_request = {k: v for k, v in pms_TheilSenRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_set_score_request = bridgeTheilSenRegressor[${this.id}].set_score_request(**pms_TheilSenRegressor_set_score_request)`;
    return this._py`res_TheilSenRegressor_set_score_request.tolist() if hasattr(res_TheilSenRegressor_set_score_request, 'tolist') else res_TheilSenRegressor_set_score_request`;
  }
  /**
    Coefficients of the regression model (median of distribution).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_coef_ = bridgeTheilSenRegressor[${this.id}].coef_`;
      return this._py`attr_TheilSenRegressor_coef_.tolist() if hasattr(attr_TheilSenRegressor_coef_, 'tolist') else attr_TheilSenRegressor_coef_`;
    })();
  }
  /**
    Estimated intercept of regression model.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_intercept_ = bridgeTheilSenRegressor[${this.id}].intercept_`;
      return this._py`attr_TheilSenRegressor_intercept_.tolist() if hasattr(attr_TheilSenRegressor_intercept_, 'tolist') else attr_TheilSenRegressor_intercept_`;
    })();
  }
  /**
    Approximated breakdown point.
   */
  get breakdown_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing breakdown_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_breakdown_ = bridgeTheilSenRegressor[${this.id}].breakdown_`;
      return this._py`attr_TheilSenRegressor_breakdown_.tolist() if hasattr(attr_TheilSenRegressor_breakdown_, 'tolist') else attr_TheilSenRegressor_breakdown_`;
    })();
  }
  /**
    Number of iterations needed for the spatial median.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_iter_ = bridgeTheilSenRegressor[${this.id}].n_iter_`;
      return this._py`attr_TheilSenRegressor_n_iter_.tolist() if hasattr(attr_TheilSenRegressor_n_iter_, 'tolist') else attr_TheilSenRegressor_n_iter_`;
    })();
  }
  /**
    Number of combinations taken into account from â€˜n choose kâ€™, where n is the number of samples and k is the number of subsamples.
   */
  get n_subpopulation_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_subpopulation_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_subpopulation_ = bridgeTheilSenRegressor[${this.id}].n_subpopulation_`;
      return this._py`attr_TheilSenRegressor_n_subpopulation_.tolist() if hasattr(attr_TheilSenRegressor_n_subpopulation_, 'tolist') else attr_TheilSenRegressor_n_subpopulation_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_features_in_ = bridgeTheilSenRegressor[${this.id}].n_features_in_`;
      return this._py`attr_TheilSenRegressor_n_features_in_.tolist() if hasattr(attr_TheilSenRegressor_n_features_in_, 'tolist') else attr_TheilSenRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_feature_names_in_ = bridgeTheilSenRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TheilSenRegressor_feature_names_in_.tolist() if hasattr(attr_TheilSenRegressor_feature_names_in_, 'tolist') else attr_TheilSenRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/TweedieRegressor.ts
import crypto158 from "node:crypto";
var TweedieRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TweedieRegressor${crypto158.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TweedieRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import TweedieRegressor
try: bridgeTweedieRegressor
except NameError: bridgeTweedieRegressor = {}
`;
    await this._py.ex`ctor_TweedieRegressor = {'power': ${this.opts["power"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'link': ${this.opts["link"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_TweedieRegressor = {k: v for k, v in ctor_TweedieRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTweedieRegressor[${this.id}] = TweedieRegressor(**ctor_TweedieRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTweedieRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before fit()");
    }
    await this._py.ex`pms_TweedieRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TweedieRegressor_fit = {k: v for k, v in pms_TweedieRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_fit = bridgeTweedieRegressor[${this.id}].fit(**pms_TweedieRegressor_fit)`;
    return this._py`res_TweedieRegressor_fit.tolist() if hasattr(res_TweedieRegressor_fit, 'tolist') else res_TweedieRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TweedieRegressor_get_metadata_routing = {k: v for k, v in pms_TweedieRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_get_metadata_routing = bridgeTweedieRegressor[${this.id}].get_metadata_routing(**pms_TweedieRegressor_get_metadata_routing)`;
    return this._py`res_TweedieRegressor_get_metadata_routing.tolist() if hasattr(res_TweedieRegressor_get_metadata_routing, 'tolist') else res_TweedieRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before predict()");
    }
    await this._py.ex`pms_TweedieRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TweedieRegressor_predict = {k: v for k, v in pms_TweedieRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_predict = bridgeTweedieRegressor[${this.id}].predict(**pms_TweedieRegressor_predict)`;
    return this._py`res_TweedieRegressor_predict.tolist() if hasattr(res_TweedieRegressor_predict, 'tolist') else res_TweedieRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before score()");
    }
    await this._py.ex`pms_TweedieRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TweedieRegressor_score = {k: v for k, v in pms_TweedieRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_score = bridgeTweedieRegressor[${this.id}].score(**pms_TweedieRegressor_score)`;
    return this._py`res_TweedieRegressor_score.tolist() if hasattr(res_TweedieRegressor_score, 'tolist') else res_TweedieRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TweedieRegressor_set_fit_request = {k: v for k, v in pms_TweedieRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_set_fit_request = bridgeTweedieRegressor[${this.id}].set_fit_request(**pms_TweedieRegressor_set_fit_request)`;
    return this._py`res_TweedieRegressor_set_fit_request.tolist() if hasattr(res_TweedieRegressor_set_fit_request, 'tolist') else res_TweedieRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TweedieRegressor_set_score_request = {k: v for k, v in pms_TweedieRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_set_score_request = bridgeTweedieRegressor[${this.id}].set_score_request(**pms_TweedieRegressor_set_score_request)`;
    return this._py`res_TweedieRegressor_set_score_request.tolist() if hasattr(res_TweedieRegressor_set_score_request, 'tolist') else res_TweedieRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_coef_ = bridgeTweedieRegressor[${this.id}].coef_`;
      return this._py`attr_TweedieRegressor_coef_.tolist() if hasattr(attr_TweedieRegressor_coef_, 'tolist') else attr_TweedieRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_intercept_ = bridgeTweedieRegressor[${this.id}].intercept_`;
      return this._py`attr_TweedieRegressor_intercept_.tolist() if hasattr(attr_TweedieRegressor_intercept_, 'tolist') else attr_TweedieRegressor_intercept_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_n_iter_ = bridgeTweedieRegressor[${this.id}].n_iter_`;
      return this._py`attr_TweedieRegressor_n_iter_.tolist() if hasattr(attr_TweedieRegressor_n_iter_, 'tolist') else attr_TweedieRegressor_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_n_features_in_ = bridgeTweedieRegressor[${this.id}].n_features_in_`;
      return this._py`attr_TweedieRegressor_n_features_in_.tolist() if hasattr(attr_TweedieRegressor_n_features_in_, 'tolist') else attr_TweedieRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_feature_names_in_ = bridgeTweedieRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TweedieRegressor_feature_names_in_.tolist() if hasattr(attr_TweedieRegressor_feature_names_in_, 'tolist') else attr_TweedieRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/manifold/Isomap.ts
import crypto159 from "node:crypto";
var Isomap = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Isomap${crypto159.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Isomap.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.manifold import Isomap
try: bridgeIsomap
except NameError: bridgeIsomap = {}
`;
    await this._py.ex`ctor_Isomap = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'radius': ${this.opts["radius"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'path_method': ${this.opts["path_method"] ?? void 0}, 'neighbors_algorithm': ${this.opts["neighbors_algorithm"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}}

ctor_Isomap = {k: v for k, v in ctor_Isomap.items() if v is not None}`;
    await this._py.ex`bridgeIsomap[${this.id}] = Isomap(**ctor_Isomap)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIsomap[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the embedding vectors for data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before fit()");
    }
    await this._py.ex`pms_Isomap_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_Isomap_fit = {k: v for k, v in pms_Isomap_fit.items() if v is not None}`;
    await this._py.ex`res_Isomap_fit = bridgeIsomap[${this.id}].fit(**pms_Isomap_fit)`;
    return this._py`res_Isomap_fit.tolist() if hasattr(res_Isomap_fit, 'tolist') else res_Isomap_fit`;
  }
  /**
    Fit the model from data in X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before fit_transform()");
    }
    await this._py.ex`pms_Isomap_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_Isomap_fit_transform = {k: v for k, v in pms_Isomap_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Isomap_fit_transform = bridgeIsomap[${this.id}].fit_transform(**pms_Isomap_fit_transform)`;
    return this._py`res_Isomap_fit_transform.tolist() if hasattr(res_Isomap_fit_transform, 'tolist') else res_Isomap_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_Isomap_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Isomap_get_feature_names_out = {k: v for k, v in pms_Isomap_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Isomap_get_feature_names_out = bridgeIsomap[${this.id}].get_feature_names_out(**pms_Isomap_get_feature_names_out)`;
    return this._py`res_Isomap_get_feature_names_out.tolist() if hasattr(res_Isomap_get_feature_names_out, 'tolist') else res_Isomap_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Isomap_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Isomap_get_metadata_routing = {k: v for k, v in pms_Isomap_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Isomap_get_metadata_routing = bridgeIsomap[${this.id}].get_metadata_routing(**pms_Isomap_get_metadata_routing)`;
    return this._py`res_Isomap_get_metadata_routing.tolist() if hasattr(res_Isomap_get_metadata_routing, 'tolist') else res_Isomap_get_metadata_routing`;
  }
  /**
    Compute the reconstruction error for the embedding.
   */
  async reconstruction_error(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before reconstruction_error()");
    }
    await this._py.ex`pms_Isomap_reconstruction_error = {'reconstruction_error': ${opts["reconstruction_error"] ?? void 0}}

pms_Isomap_reconstruction_error = {k: v for k, v in pms_Isomap_reconstruction_error.items() if v is not None}`;
    await this._py.ex`res_Isomap_reconstruction_error = bridgeIsomap[${this.id}].reconstruction_error(**pms_Isomap_reconstruction_error)`;
    return this._py`res_Isomap_reconstruction_error.tolist() if hasattr(res_Isomap_reconstruction_error, 'tolist') else res_Isomap_reconstruction_error`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before set_output()");
    }
    await this._py.ex`pms_Isomap_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Isomap_set_output = {k: v for k, v in pms_Isomap_set_output.items() if v is not None}`;
    await this._py.ex`res_Isomap_set_output = bridgeIsomap[${this.id}].set_output(**pms_Isomap_set_output)`;
    return this._py`res_Isomap_set_output.tolist() if hasattr(res_Isomap_set_output, 'tolist') else res_Isomap_set_output`;
  }
  /**
      Transform X.
  
      This is implemented by linking the points X into the graph of geodesic distances of the training data. First the `n\_neighbors` nearest neighbors of X are found in the training data, and from these the shortest geodesic distances from each point in X to each point in the training data are computed in order to construct the kernel. The embedding of X is the projection of this kernel onto the embedding vectors of the training set.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before transform()");
    }
    await this._py.ex`pms_Isomap_transform = {'X': ${opts["X"] ?? void 0}}

pms_Isomap_transform = {k: v for k, v in pms_Isomap_transform.items() if v is not None}`;
    await this._py.ex`res_Isomap_transform = bridgeIsomap[${this.id}].transform(**pms_Isomap_transform)`;
    return this._py`res_Isomap_transform.tolist() if hasattr(res_Isomap_transform, 'tolist') else res_Isomap_transform`;
  }
  /**
    Stores the embedding vectors.
   */
  get embedding_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before accessing embedding_");
    }
    return (async () => {
      await this._py.ex`attr_Isomap_embedding_ = bridgeIsomap[${this.id}].embedding_`;
      return this._py`attr_Isomap_embedding_.tolist() if hasattr(attr_Isomap_embedding_, 'tolist') else attr_Isomap_embedding_`;
    })();
  }
  /**
    [`KernelPCA`](sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA "sklearn.decomposition.KernelPCA") object used to implement the embedding.
   */
  get kernel_pca_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before accessing kernel_pca_");
    }
    return (async () => {
      await this._py.ex`attr_Isomap_kernel_pca_ = bridgeIsomap[${this.id}].kernel_pca_`;
      return this._py`attr_Isomap_kernel_pca_.tolist() if hasattr(attr_Isomap_kernel_pca_, 'tolist') else attr_Isomap_kernel_pca_`;
    })();
  }
  /**
    Stores nearest neighbors instance, including BallTree or KDtree if applicable.
   */
  get nbrs_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before accessing nbrs_");
    }
    return (async () => {
      await this._py.ex`attr_Isomap_nbrs_ = bridgeIsomap[${this.id}].nbrs_`;
      return this._py`attr_Isomap_nbrs_.tolist() if hasattr(attr_Isomap_nbrs_, 'tolist') else attr_Isomap_nbrs_`;
    })();
  }
  /**
    Stores the geodesic distance matrix of training data.
   */
  get dist_matrix_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before accessing dist_matrix_");
    }
    return (async () => {
      await this._py.ex`attr_Isomap_dist_matrix_ = bridgeIsomap[${this.id}].dist_matrix_`;
      return this._py`attr_Isomap_dist_matrix_.tolist() if hasattr(attr_Isomap_dist_matrix_, 'tolist') else attr_Isomap_dist_matrix_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Isomap must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Isomap_n_features_in_ = bridgeIsomap[${this.id}].n_features_in_`;
      return this._py`attr_Isomap_n_features_in_.tolist() if hasattr(attr_Isomap_n_features_in_, 'tolist') else attr_Isomap_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Isomap instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Isomap must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Isomap_feature_names_in_ = bridgeIsomap[${this.id}].feature_names_in_`;
      return this._py`attr_Isomap_feature_names_in_.tolist() if hasattr(attr_Isomap_feature_names_in_, 'tolist') else attr_Isomap_feature_names_in_`;
    })();
  }
};

// src/generated/manifold/LocallyLinearEmbedding.ts
import crypto160 from "node:crypto";
var LocallyLinearEmbedding = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LocallyLinearEmbedding${crypto160.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LocallyLinearEmbedding.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.manifold import LocallyLinearEmbedding
try: bridgeLocallyLinearEmbedding
except NameError: bridgeLocallyLinearEmbedding = {}
`;
    await this._py.ex`ctor_LocallyLinearEmbedding = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'reg': ${this.opts["reg"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'hessian_tol': ${this.opts["hessian_tol"] ?? void 0}, 'modified_tol': ${this.opts["modified_tol"] ?? void 0}, 'neighbors_algorithm': ${this.opts["neighbors_algorithm"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_LocallyLinearEmbedding = {k: v for k, v in ctor_LocallyLinearEmbedding.items() if v is not None}`;
    await this._py.ex`bridgeLocallyLinearEmbedding[${this.id}] = LocallyLinearEmbedding(**ctor_LocallyLinearEmbedding)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLocallyLinearEmbedding[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the embedding vectors for data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocallyLinearEmbedding must call init() before fit()");
    }
    await this._py.ex`pms_LocallyLinearEmbedding_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocallyLinearEmbedding_fit = {k: v for k, v in pms_LocallyLinearEmbedding_fit.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_fit = bridgeLocallyLinearEmbedding[${this.id}].fit(**pms_LocallyLinearEmbedding_fit)`;
    return this._py`res_LocallyLinearEmbedding_fit.tolist() if hasattr(res_LocallyLinearEmbedding_fit, 'tolist') else res_LocallyLinearEmbedding_fit`;
  }
  /**
    Compute the embedding vectors for data X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LocallyLinearEmbedding_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocallyLinearEmbedding_fit_transform = {k: v for k, v in pms_LocallyLinearEmbedding_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_fit_transform = bridgeLocallyLinearEmbedding[${this.id}].fit_transform(**pms_LocallyLinearEmbedding_fit_transform)`;
    return this._py`res_LocallyLinearEmbedding_fit_transform.tolist() if hasattr(res_LocallyLinearEmbedding_fit_transform, 'tolist') else res_LocallyLinearEmbedding_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LocallyLinearEmbedding_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LocallyLinearEmbedding_get_feature_names_out = {k: v for k, v in pms_LocallyLinearEmbedding_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_get_feature_names_out = bridgeLocallyLinearEmbedding[${this.id}].get_feature_names_out(**pms_LocallyLinearEmbedding_get_feature_names_out)`;
    return this._py`res_LocallyLinearEmbedding_get_feature_names_out.tolist() if hasattr(res_LocallyLinearEmbedding_get_feature_names_out, 'tolist') else res_LocallyLinearEmbedding_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LocallyLinearEmbedding_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LocallyLinearEmbedding_get_metadata_routing = {k: v for k, v in pms_LocallyLinearEmbedding_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_get_metadata_routing = bridgeLocallyLinearEmbedding[${this.id}].get_metadata_routing(**pms_LocallyLinearEmbedding_get_metadata_routing)`;
    return this._py`res_LocallyLinearEmbedding_get_metadata_routing.tolist() if hasattr(res_LocallyLinearEmbedding_get_metadata_routing, 'tolist') else res_LocallyLinearEmbedding_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LocallyLinearEmbedding_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LocallyLinearEmbedding_set_output = {k: v for k, v in pms_LocallyLinearEmbedding_set_output.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_set_output = bridgeLocallyLinearEmbedding[${this.id}].set_output(**pms_LocallyLinearEmbedding_set_output)`;
    return this._py`res_LocallyLinearEmbedding_set_output.tolist() if hasattr(res_LocallyLinearEmbedding_set_output, 'tolist') else res_LocallyLinearEmbedding_set_output`;
  }
  /**
    Transform new points into embedding space.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before transform()"
      );
    }
    await this._py.ex`pms_LocallyLinearEmbedding_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocallyLinearEmbedding_transform = {k: v for k, v in pms_LocallyLinearEmbedding_transform.items() if v is not None}`;
    await this._py.ex`res_LocallyLinearEmbedding_transform = bridgeLocallyLinearEmbedding[${this.id}].transform(**pms_LocallyLinearEmbedding_transform)`;
    return this._py`res_LocallyLinearEmbedding_transform.tolist() if hasattr(res_LocallyLinearEmbedding_transform, 'tolist') else res_LocallyLinearEmbedding_transform`;
  }
  /**
    Stores the embedding vectors
   */
  get embedding_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before accessing embedding_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocallyLinearEmbedding_embedding_ = bridgeLocallyLinearEmbedding[${this.id}].embedding_`;
      return this._py`attr_LocallyLinearEmbedding_embedding_.tolist() if hasattr(attr_LocallyLinearEmbedding_embedding_, 'tolist') else attr_LocallyLinearEmbedding_embedding_`;
    })();
  }
  /**
    Reconstruction error associated with `embedding\_`
   */
  get reconstruction_error_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before accessing reconstruction_error_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocallyLinearEmbedding_reconstruction_error_ = bridgeLocallyLinearEmbedding[${this.id}].reconstruction_error_`;
      return this._py`attr_LocallyLinearEmbedding_reconstruction_error_.tolist() if hasattr(attr_LocallyLinearEmbedding_reconstruction_error_, 'tolist') else attr_LocallyLinearEmbedding_reconstruction_error_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocallyLinearEmbedding_n_features_in_ = bridgeLocallyLinearEmbedding[${this.id}].n_features_in_`;
      return this._py`attr_LocallyLinearEmbedding_n_features_in_.tolist() if hasattr(attr_LocallyLinearEmbedding_n_features_in_, 'tolist') else attr_LocallyLinearEmbedding_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocallyLinearEmbedding_feature_names_in_ = bridgeLocallyLinearEmbedding[${this.id}].feature_names_in_`;
      return this._py`attr_LocallyLinearEmbedding_feature_names_in_.tolist() if hasattr(attr_LocallyLinearEmbedding_feature_names_in_, 'tolist') else attr_LocallyLinearEmbedding_feature_names_in_`;
    })();
  }
  /**
    Stores nearest neighbors instance, including BallTree or KDtree if applicable.
   */
  get nbrs_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocallyLinearEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocallyLinearEmbedding must call init() before accessing nbrs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocallyLinearEmbedding_nbrs_ = bridgeLocallyLinearEmbedding[${this.id}].nbrs_`;
      return this._py`attr_LocallyLinearEmbedding_nbrs_.tolist() if hasattr(attr_LocallyLinearEmbedding_nbrs_, 'tolist') else attr_LocallyLinearEmbedding_nbrs_`;
    })();
  }
};

// src/generated/manifold/MDS.ts
import crypto161 from "node:crypto";
var MDS = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MDS${crypto161.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MDS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.manifold import MDS
try: bridgeMDS
except NameError: bridgeMDS = {}
`;
    await this._py.ex`ctor_MDS = {'n_components': ${this.opts["n_components"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'dissimilarity': ${this.opts["dissimilarity"] ?? void 0}, 'normalized_stress': ${this.opts["normalized_stress"] ?? void 0}}

ctor_MDS = {k: v for k, v in ctor_MDS.items() if v is not None}`;
    await this._py.ex`bridgeMDS[${this.id}] = MDS(**ctor_MDS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMDS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the position of the points in the embedding space.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before fit()");
    }
    await this._py.ex`pms_MDS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'init': np.array(${opts["init"] ?? void 0}) if ${opts["init"] !== void 0} else None}

pms_MDS_fit = {k: v for k, v in pms_MDS_fit.items() if v is not None}`;
    await this._py.ex`res_MDS_fit = bridgeMDS[${this.id}].fit(**pms_MDS_fit)`;
    return this._py`res_MDS_fit.tolist() if hasattr(res_MDS_fit, 'tolist') else res_MDS_fit`;
  }
  /**
    Fit the data from `X`, and returns the embedded coordinates.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before fit_transform()");
    }
    await this._py.ex`pms_MDS_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'init': np.array(${opts["init"] ?? void 0}) if ${opts["init"] !== void 0} else None}

pms_MDS_fit_transform = {k: v for k, v in pms_MDS_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MDS_fit_transform = bridgeMDS[${this.id}].fit_transform(**pms_MDS_fit_transform)`;
    return this._py`res_MDS_fit_transform.tolist() if hasattr(res_MDS_fit_transform, 'tolist') else res_MDS_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_MDS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MDS_get_metadata_routing = {k: v for k, v in pms_MDS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MDS_get_metadata_routing = bridgeMDS[${this.id}].get_metadata_routing(**pms_MDS_get_metadata_routing)`;
    return this._py`res_MDS_get_metadata_routing.tolist() if hasattr(res_MDS_get_metadata_routing, 'tolist') else res_MDS_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before set_fit_request()");
    }
    await this._py.ex`pms_MDS_set_fit_request = {'init': ${opts["init"] ?? void 0}}

pms_MDS_set_fit_request = {k: v for k, v in pms_MDS_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MDS_set_fit_request = bridgeMDS[${this.id}].set_fit_request(**pms_MDS_set_fit_request)`;
    return this._py`res_MDS_set_fit_request.tolist() if hasattr(res_MDS_set_fit_request, 'tolist') else res_MDS_set_fit_request`;
  }
  /**
    Stores the position of the dataset in the embedding space.
   */
  get embedding_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before accessing embedding_");
    }
    return (async () => {
      await this._py.ex`attr_MDS_embedding_ = bridgeMDS[${this.id}].embedding_`;
      return this._py`attr_MDS_embedding_.tolist() if hasattr(attr_MDS_embedding_, 'tolist') else attr_MDS_embedding_`;
    })();
  }
  /**
    The final value of the stress (sum of squared distance of the disparities and the distances for all constrained points). If `normalized\_stress=True`, and `metric=False` returns Stress-1. A value of 0 indicates â€œperfectâ€ fit, 0.025 excellent, 0.05 good, 0.1 fair, and 0.2 poor [\[1\]](#r77760563872b-1).
   */
  get stress_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before accessing stress_");
    }
    return (async () => {
      await this._py.ex`attr_MDS_stress_ = bridgeMDS[${this.id}].stress_`;
      return this._py`attr_MDS_stress_.tolist() if hasattr(attr_MDS_stress_, 'tolist') else attr_MDS_stress_`;
    })();
  }
  /**
    Pairwise dissimilarities between the points. Symmetric matrix that:
   */
  get dissimilarity_matrix_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MDS must call init() before accessing dissimilarity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MDS_dissimilarity_matrix_ = bridgeMDS[${this.id}].dissimilarity_matrix_`;
      return this._py`attr_MDS_dissimilarity_matrix_.tolist() if hasattr(attr_MDS_dissimilarity_matrix_, 'tolist') else attr_MDS_dissimilarity_matrix_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_MDS_n_features_in_ = bridgeMDS[${this.id}].n_features_in_`;
      return this._py`attr_MDS_n_features_in_.tolist() if hasattr(attr_MDS_n_features_in_, 'tolist') else attr_MDS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_MDS_feature_names_in_ = bridgeMDS[${this.id}].feature_names_in_`;
      return this._py`attr_MDS_feature_names_in_.tolist() if hasattr(attr_MDS_feature_names_in_, 'tolist') else attr_MDS_feature_names_in_`;
    })();
  }
  /**
    The number of iterations corresponding to the best stress.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MDS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MDS must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MDS_n_iter_ = bridgeMDS[${this.id}].n_iter_`;
      return this._py`attr_MDS_n_iter_.tolist() if hasattr(attr_MDS_n_iter_, 'tolist') else attr_MDS_n_iter_`;
    })();
  }
};

// src/generated/manifold/SpectralEmbedding.ts
import crypto162 from "node:crypto";
var SpectralEmbedding = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SpectralEmbedding${crypto162.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SpectralEmbedding.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.manifold import SpectralEmbedding
try: bridgeSpectralEmbedding
except NameError: bridgeSpectralEmbedding = {}
`;
    await this._py.ex`ctor_SpectralEmbedding = {'n_components': ${this.opts["n_components"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'eigen_tol': ${this.opts["eigen_tol"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_SpectralEmbedding = {k: v for k, v in ctor_SpectralEmbedding.items() if v is not None}`;
    await this._py.ex`bridgeSpectralEmbedding[${this.id}] = SpectralEmbedding(**ctor_SpectralEmbedding)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralEmbedding[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralEmbedding must call init() before fit()");
    }
    await this._py.ex`pms_SpectralEmbedding_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralEmbedding_fit = {k: v for k, v in pms_SpectralEmbedding_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralEmbedding_fit = bridgeSpectralEmbedding[${this.id}].fit(**pms_SpectralEmbedding_fit)`;
    return this._py`res_SpectralEmbedding_fit.tolist() if hasattr(res_SpectralEmbedding_fit, 'tolist') else res_SpectralEmbedding_fit`;
  }
  /**
    Fit the model from data in X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SpectralEmbedding_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralEmbedding_fit_transform = {k: v for k, v in pms_SpectralEmbedding_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SpectralEmbedding_fit_transform = bridgeSpectralEmbedding[${this.id}].fit_transform(**pms_SpectralEmbedding_fit_transform)`;
    return this._py`res_SpectralEmbedding_fit_transform.tolist() if hasattr(res_SpectralEmbedding_fit_transform, 'tolist') else res_SpectralEmbedding_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralEmbedding_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralEmbedding_get_metadata_routing = {k: v for k, v in pms_SpectralEmbedding_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralEmbedding_get_metadata_routing = bridgeSpectralEmbedding[${this.id}].get_metadata_routing(**pms_SpectralEmbedding_get_metadata_routing)`;
    return this._py`res_SpectralEmbedding_get_metadata_routing.tolist() if hasattr(res_SpectralEmbedding_get_metadata_routing, 'tolist') else res_SpectralEmbedding_get_metadata_routing`;
  }
  /**
    Spectral embedding of the training matrix.
   */
  get embedding_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before accessing embedding_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralEmbedding_embedding_ = bridgeSpectralEmbedding[${this.id}].embedding_`;
      return this._py`attr_SpectralEmbedding_embedding_.tolist() if hasattr(attr_SpectralEmbedding_embedding_, 'tolist') else attr_SpectralEmbedding_embedding_`;
    })();
  }
  /**
    Affinity\_matrix constructed from samples or precomputed.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralEmbedding_affinity_matrix_ = bridgeSpectralEmbedding[${this.id}].affinity_matrix_`;
      return this._py`attr_SpectralEmbedding_affinity_matrix_.tolist() if hasattr(attr_SpectralEmbedding_affinity_matrix_, 'tolist') else attr_SpectralEmbedding_affinity_matrix_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralEmbedding_n_features_in_ = bridgeSpectralEmbedding[${this.id}].n_features_in_`;
      return this._py`attr_SpectralEmbedding_n_features_in_.tolist() if hasattr(attr_SpectralEmbedding_n_features_in_, 'tolist') else attr_SpectralEmbedding_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralEmbedding_feature_names_in_ = bridgeSpectralEmbedding[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralEmbedding_feature_names_in_.tolist() if hasattr(attr_SpectralEmbedding_feature_names_in_, 'tolist') else attr_SpectralEmbedding_feature_names_in_`;
    })();
  }
  /**
    Number of nearest neighbors effectively used.
   */
  get n_neighbors_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralEmbedding instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralEmbedding must call init() before accessing n_neighbors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralEmbedding_n_neighbors_ = bridgeSpectralEmbedding[${this.id}].n_neighbors_`;
      return this._py`attr_SpectralEmbedding_n_neighbors_.tolist() if hasattr(attr_SpectralEmbedding_n_neighbors_, 'tolist') else attr_SpectralEmbedding_n_neighbors_`;
    })();
  }
};

// src/generated/manifold/TSNE.ts
import crypto163 from "node:crypto";
var TSNE = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TSNE${crypto163.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TSNE.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.manifold import TSNE
try: bridgeTSNE
except NameError: bridgeTSNE = {}
`;
    await this._py.ex`ctor_TSNE = {'n_components': ${this.opts["n_components"] ?? void 0}, 'perplexity': ${this.opts["perplexity"] ?? void 0}, 'early_exaggeration': ${this.opts["early_exaggeration"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'n_iter_without_progress': ${this.opts["n_iter_without_progress"] ?? void 0}, 'min_grad_norm': ${this.opts["min_grad_norm"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'angle': ${this.opts["angle"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_TSNE = {k: v for k, v in ctor_TSNE.items() if v is not None}`;
    await this._py.ex`bridgeTSNE[${this.id}] = TSNE(**ctor_TSNE)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTSNE[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit X into an embedded space.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before fit()");
    }
    await this._py.ex`pms_TSNE_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TSNE_fit = {k: v for k, v in pms_TSNE_fit.items() if v is not None}`;
    await this._py.ex`res_TSNE_fit = bridgeTSNE[${this.id}].fit(**pms_TSNE_fit)`;
    return this._py`res_TSNE_fit.tolist() if hasattr(res_TSNE_fit, 'tolist') else res_TSNE_fit`;
  }
  /**
    Fit X into an embedded space and return that transformed output.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before fit_transform()");
    }
    await this._py.ex`pms_TSNE_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TSNE_fit_transform = {k: v for k, v in pms_TSNE_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TSNE_fit_transform = bridgeTSNE[${this.id}].fit_transform(**pms_TSNE_fit_transform)`;
    return this._py`res_TSNE_fit_transform.tolist() if hasattr(res_TSNE_fit_transform, 'tolist') else res_TSNE_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_TSNE_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TSNE_get_feature_names_out = {k: v for k, v in pms_TSNE_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TSNE_get_feature_names_out = bridgeTSNE[${this.id}].get_feature_names_out(**pms_TSNE_get_feature_names_out)`;
    return this._py`res_TSNE_get_feature_names_out.tolist() if hasattr(res_TSNE_get_feature_names_out, 'tolist') else res_TSNE_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_TSNE_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TSNE_get_metadata_routing = {k: v for k, v in pms_TSNE_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TSNE_get_metadata_routing = bridgeTSNE[${this.id}].get_metadata_routing(**pms_TSNE_get_metadata_routing)`;
    return this._py`res_TSNE_get_metadata_routing.tolist() if hasattr(res_TSNE_get_metadata_routing, 'tolist') else res_TSNE_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before set_output()");
    }
    await this._py.ex`pms_TSNE_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TSNE_set_output = {k: v for k, v in pms_TSNE_set_output.items() if v is not None}`;
    await this._py.ex`res_TSNE_set_output = bridgeTSNE[${this.id}].set_output(**pms_TSNE_set_output)`;
    return this._py`res_TSNE_set_output.tolist() if hasattr(res_TSNE_set_output, 'tolist') else res_TSNE_set_output`;
  }
  /**
    Stores the embedding vectors.
   */
  get embedding_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before accessing embedding_");
    }
    return (async () => {
      await this._py.ex`attr_TSNE_embedding_ = bridgeTSNE[${this.id}].embedding_`;
      return this._py`attr_TSNE_embedding_.tolist() if hasattr(attr_TSNE_embedding_, 'tolist') else attr_TSNE_embedding_`;
    })();
  }
  /**
    Kullback-Leibler divergence after optimization.
   */
  get kl_divergence_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before accessing kl_divergence_");
    }
    return (async () => {
      await this._py.ex`attr_TSNE_kl_divergence_ = bridgeTSNE[${this.id}].kl_divergence_`;
      return this._py`attr_TSNE_kl_divergence_.tolist() if hasattr(attr_TSNE_kl_divergence_, 'tolist') else attr_TSNE_kl_divergence_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_TSNE_n_features_in_ = bridgeTSNE[${this.id}].n_features_in_`;
      return this._py`attr_TSNE_n_features_in_.tolist() if hasattr(attr_TSNE_n_features_in_, 'tolist') else attr_TSNE_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TSNE must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TSNE_feature_names_in_ = bridgeTSNE[${this.id}].feature_names_in_`;
      return this._py`attr_TSNE_feature_names_in_.tolist() if hasattr(attr_TSNE_feature_names_in_, 'tolist') else attr_TSNE_feature_names_in_`;
    })();
  }
  /**
    Effective learning rate.
   */
  get learning_rate_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before accessing learning_rate_");
    }
    return (async () => {
      await this._py.ex`attr_TSNE_learning_rate_ = bridgeTSNE[${this.id}].learning_rate_`;
      return this._py`attr_TSNE_learning_rate_.tolist() if hasattr(attr_TSNE_learning_rate_, 'tolist') else attr_TSNE_learning_rate_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This TSNE instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TSNE must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_TSNE_n_iter_ = bridgeTSNE[${this.id}].n_iter_`;
      return this._py`attr_TSNE_n_iter_.tolist() if hasattr(attr_TSNE_n_iter_, 'tolist') else attr_TSNE_n_iter_`;
    })();
  }
};

// src/generated/metrics/ConfusionMatrixDisplay.ts
import crypto164 from "node:crypto";
var ConfusionMatrixDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ConfusionMatrixDisplay${crypto164.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ConfusionMatrixDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import ConfusionMatrixDisplay
try: bridgeConfusionMatrixDisplay
except NameError: bridgeConfusionMatrixDisplay = {}
`;
    await this._py.ex`ctor_ConfusionMatrixDisplay = {'confusion_matrix': np.array(${this.opts["confusion_matrix"] ?? void 0}) if ${this.opts["confusion_matrix"] !== void 0} else None, 'display_labels': np.array(${this.opts["display_labels"] ?? void 0}) if ${this.opts["display_labels"] !== void 0} else None}

ctor_ConfusionMatrixDisplay = {k: v for k, v in ctor_ConfusionMatrixDisplay.items() if v is not None}`;
    await this._py.ex`bridgeConfusionMatrixDisplay[${this.id}] = ConfusionMatrixDisplay(**ctor_ConfusionMatrixDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeConfusionMatrixDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot Confusion Matrix given an estimator and some data.
  
      Read more in the [User Guide](../model_evaluation.html#confusion-matrix).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_ConfusionMatrixDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'labels': np.array(${opts["labels"] ?? void 0}) if ${opts["labels"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'normalize': ${opts["normalize"] ?? void 0}, 'display_labels': np.array(${opts["display_labels"] ?? void 0}) if ${opts["display_labels"] !== void 0} else None, 'include_values': ${opts["include_values"] ?? void 0}, 'xticks_rotation': ${opts["xticks_rotation"] ?? void 0}, 'values_format': ${opts["values_format"] ?? void 0}, 'cmap': ${opts["cmap"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'colorbar': ${opts["colorbar"] ?? void 0}, 'im_kw': ${opts["im_kw"] ?? void 0}, 'text_kw': ${opts["text_kw"] ?? void 0}}

pms_ConfusionMatrixDisplay_from_estimator = {k: v for k, v in pms_ConfusionMatrixDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_ConfusionMatrixDisplay_from_estimator = bridgeConfusionMatrixDisplay[${this.id}].from_estimator(**pms_ConfusionMatrixDisplay_from_estimator)`;
    return this._py`res_ConfusionMatrixDisplay_from_estimator.tolist() if hasattr(res_ConfusionMatrixDisplay_from_estimator, 'tolist') else res_ConfusionMatrixDisplay_from_estimator`;
  }
  /**
      Plot Confusion Matrix given true and predicted labels.
  
      Read more in the [User Guide](../model_evaluation.html#confusion-matrix).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_ConfusionMatrixDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_pred': np.array(${opts["y_pred"] ?? void 0}) if ${opts["y_pred"] !== void 0} else None, 'labels': np.array(${opts["labels"] ?? void 0}) if ${opts["labels"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'normalize': ${opts["normalize"] ?? void 0}, 'display_labels': np.array(${opts["display_labels"] ?? void 0}) if ${opts["display_labels"] !== void 0} else None, 'include_values': ${opts["include_values"] ?? void 0}, 'xticks_rotation': ${opts["xticks_rotation"] ?? void 0}, 'values_format': ${opts["values_format"] ?? void 0}, 'cmap': ${opts["cmap"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'colorbar': ${opts["colorbar"] ?? void 0}, 'im_kw': ${opts["im_kw"] ?? void 0}, 'text_kw': ${opts["text_kw"] ?? void 0}}

pms_ConfusionMatrixDisplay_from_predictions = {k: v for k, v in pms_ConfusionMatrixDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_ConfusionMatrixDisplay_from_predictions = bridgeConfusionMatrixDisplay[${this.id}].from_predictions(**pms_ConfusionMatrixDisplay_from_predictions)`;
    return this._py`res_ConfusionMatrixDisplay_from_predictions.tolist() if hasattr(res_ConfusionMatrixDisplay_from_predictions, 'tolist') else res_ConfusionMatrixDisplay_from_predictions`;
  }
  /**
    Plot visualization.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ConfusionMatrixDisplay must call init() before plot()");
    }
    await this._py.ex`pms_ConfusionMatrixDisplay_plot = {'include_values': ${opts["include_values"] ?? void 0}, 'cmap': ${opts["cmap"] ?? void 0}, 'xticks_rotation': ${opts["xticks_rotation"] ?? void 0}, 'values_format': ${opts["values_format"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'colorbar': ${opts["colorbar"] ?? void 0}, 'im_kw': ${opts["im_kw"] ?? void 0}, 'text_kw': ${opts["text_kw"] ?? void 0}}

pms_ConfusionMatrixDisplay_plot = {k: v for k, v in pms_ConfusionMatrixDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_ConfusionMatrixDisplay_plot = bridgeConfusionMatrixDisplay[${this.id}].plot(**pms_ConfusionMatrixDisplay_plot)`;
    return this._py`res_ConfusionMatrixDisplay_plot.tolist() if hasattr(res_ConfusionMatrixDisplay_plot, 'tolist') else res_ConfusionMatrixDisplay_plot`;
  }
  /**
    Image representing the confusion matrix.
   */
  get im_() {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before accessing im_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConfusionMatrixDisplay_im_ = bridgeConfusionMatrixDisplay[${this.id}].im_`;
      return this._py`attr_ConfusionMatrixDisplay_im_.tolist() if hasattr(attr_ConfusionMatrixDisplay_im_, 'tolist') else attr_ConfusionMatrixDisplay_im_`;
    })();
  }
  /**
    Array of matplotlib axes. `undefined` if `include\_values` is false.
   */
  get text_() {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before accessing text_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConfusionMatrixDisplay_text_ = bridgeConfusionMatrixDisplay[${this.id}].text_`;
      return this._py`attr_ConfusionMatrixDisplay_text_.tolist() if hasattr(attr_ConfusionMatrixDisplay_text_, 'tolist') else attr_ConfusionMatrixDisplay_text_`;
    })();
  }
  /**
    Axes with confusion matrix.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConfusionMatrixDisplay_ax_ = bridgeConfusionMatrixDisplay[${this.id}].ax_`;
      return this._py`attr_ConfusionMatrixDisplay_ax_.tolist() if hasattr(attr_ConfusionMatrixDisplay_ax_, 'tolist') else attr_ConfusionMatrixDisplay_ax_`;
    })();
  }
  /**
    Figure containing the confusion matrix.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This ConfusionMatrixDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConfusionMatrixDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConfusionMatrixDisplay_figure_ = bridgeConfusionMatrixDisplay[${this.id}].figure_`;
      return this._py`attr_ConfusionMatrixDisplay_figure_.tolist() if hasattr(attr_ConfusionMatrixDisplay_figure_, 'tolist') else attr_ConfusionMatrixDisplay_figure_`;
    })();
  }
};

// src/generated/metrics/DetCurveDisplay.ts
import crypto165 from "node:crypto";
var DetCurveDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DetCurveDisplay${crypto165.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DetCurveDisplay.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import DetCurveDisplay
try: bridgeDetCurveDisplay
except NameError: bridgeDetCurveDisplay = {}
`;
    await this._py.ex`ctor_DetCurveDisplay = {'fpr': np.array(${this.opts["fpr"] ?? void 0}) if ${this.opts["fpr"] !== void 0} else None, 'fnr': np.array(${this.opts["fnr"] ?? void 0}) if ${this.opts["fnr"] !== void 0} else None, 'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}}

ctor_DetCurveDisplay = {k: v for k, v in ctor_DetCurveDisplay.items() if v is not None}`;
    await this._py.ex`bridgeDetCurveDisplay[${this.id}] = DetCurveDisplay(**ctor_DetCurveDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDetCurveDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot DET curve given an estimator and data.
  
      Read more in the [User Guide](../../visualizations.html#visualizations).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DetCurveDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_DetCurveDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'response_method': ${opts["response_method"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DetCurveDisplay_from_estimator = {k: v for k, v in pms_DetCurveDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_DetCurveDisplay_from_estimator = bridgeDetCurveDisplay[${this.id}].from_estimator(**pms_DetCurveDisplay_from_estimator)`;
    return this._py`res_DetCurveDisplay_from_estimator.tolist() if hasattr(res_DetCurveDisplay_from_estimator, 'tolist') else res_DetCurveDisplay_from_estimator`;
  }
  /**
      Plot the DET curve given the true and predicted labels.
  
      Read more in the [User Guide](../../visualizations.html#visualizations).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DetCurveDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_DetCurveDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_pred': np.array(${opts["y_pred"] ?? void 0}) if ${opts["y_pred"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DetCurveDisplay_from_predictions = {k: v for k, v in pms_DetCurveDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_DetCurveDisplay_from_predictions = bridgeDetCurveDisplay[${this.id}].from_predictions(**pms_DetCurveDisplay_from_predictions)`;
    return this._py`res_DetCurveDisplay_from_predictions.tolist() if hasattr(res_DetCurveDisplay_from_predictions, 'tolist') else res_DetCurveDisplay_from_predictions`;
  }
  /**
    Plot visualization.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DetCurveDisplay must call init() before plot()");
    }
    await this._py.ex`pms_DetCurveDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DetCurveDisplay_plot = {k: v for k, v in pms_DetCurveDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_DetCurveDisplay_plot = bridgeDetCurveDisplay[${this.id}].plot(**pms_DetCurveDisplay_plot)`;
    return this._py`res_DetCurveDisplay_plot.tolist() if hasattr(res_DetCurveDisplay_plot, 'tolist') else res_DetCurveDisplay_plot`;
  }
  /**
    DET Curve.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DetCurveDisplay must call init() before accessing line_");
    }
    return (async () => {
      await this._py.ex`attr_DetCurveDisplay_line_ = bridgeDetCurveDisplay[${this.id}].line_`;
      return this._py`attr_DetCurveDisplay_line_.tolist() if hasattr(attr_DetCurveDisplay_line_, 'tolist') else attr_DetCurveDisplay_line_`;
    })();
  }
  /**
    Axes with DET Curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DetCurveDisplay must call init() before accessing ax_");
    }
    return (async () => {
      await this._py.ex`attr_DetCurveDisplay_ax_ = bridgeDetCurveDisplay[${this.id}].ax_`;
      return this._py`attr_DetCurveDisplay_ax_.tolist() if hasattr(attr_DetCurveDisplay_ax_, 'tolist') else attr_DetCurveDisplay_ax_`;
    })();
  }
  /**
    Figure containing the curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error("This DetCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DetCurveDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DetCurveDisplay_figure_ = bridgeDetCurveDisplay[${this.id}].figure_`;
      return this._py`attr_DetCurveDisplay_figure_.tolist() if hasattr(attr_DetCurveDisplay_figure_, 'tolist') else attr_DetCurveDisplay_figure_`;
    })();
  }
};

// src/generated/metrics/DistanceMetric.ts
import crypto166 from "node:crypto";
var DistanceMetric = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DistanceMetric${crypto166.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DistanceMetric instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DistanceMetric.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import DistanceMetric
try: bridgeDistanceMetric
except NameError: bridgeDistanceMetric = {}
`;
    await this._py.ex`ctor_DistanceMetric = {'metric': ${this.opts["metric"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'kwargs': ${this.opts["kwargs"] ?? void 0}}

ctor_DistanceMetric = {k: v for k, v in ctor_DistanceMetric.items() if v is not None}`;
    await this._py.ex`bridgeDistanceMetric[${this.id}] = DistanceMetric(**ctor_DistanceMetric)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDistanceMetric[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get the given distance metric from the string identifier.
  
      See the docstring of DistanceMetric for a list of available metrics.
     */
  async get_metric(opts) {
    if (this._isDisposed) {
      throw new Error("This DistanceMetric instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DistanceMetric must call init() before get_metric()");
    }
    await this._py.ex`pms_DistanceMetric_get_metric = {'metric': ${opts["metric"] ?? void 0}, 'dtype': ${opts["dtype"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_DistanceMetric_get_metric = {k: v for k, v in pms_DistanceMetric_get_metric.items() if v is not None}`;
    await this._py.ex`res_DistanceMetric_get_metric = bridgeDistanceMetric[${this.id}].get_metric(**pms_DistanceMetric_get_metric)`;
    return this._py`res_DistanceMetric_get_metric.tolist() if hasattr(res_DistanceMetric_get_metric, 'tolist') else res_DistanceMetric_get_metric`;
  }
  /**
    An instance of the requested distance metric class.
   */
  get metric_obj() {
    if (this._isDisposed) {
      throw new Error("This DistanceMetric instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DistanceMetric must call init() before accessing metric_obj"
      );
    }
    return (async () => {
      await this._py.ex`attr_DistanceMetric_metric_obj = bridgeDistanceMetric[${this.id}].metric_obj`;
      return this._py`attr_DistanceMetric_metric_obj.tolist() if hasattr(attr_DistanceMetric_metric_obj, 'tolist') else attr_DistanceMetric_metric_obj`;
    })();
  }
};

// src/generated/metrics/PrecisionRecallDisplay.ts
import crypto167 from "node:crypto";
var PrecisionRecallDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PrecisionRecallDisplay${crypto167.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PrecisionRecallDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import PrecisionRecallDisplay
try: bridgePrecisionRecallDisplay
except NameError: bridgePrecisionRecallDisplay = {}
`;
    await this._py.ex`ctor_PrecisionRecallDisplay = {'precision': np.array(${this.opts["precision"] ?? void 0}) if ${this.opts["precision"] !== void 0} else None, 'recall': np.array(${this.opts["recall"] ?? void 0}) if ${this.opts["recall"] !== void 0} else None, 'average_precision': ${this.opts["average_precision"] ?? void 0}, 'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}, 'prevalence_pos_label': ${this.opts["prevalence_pos_label"] ?? void 0}}

ctor_PrecisionRecallDisplay = {k: v for k, v in ctor_PrecisionRecallDisplay.items() if v is not None}`;
    await this._py.ex`bridgePrecisionRecallDisplay[${this.id}] = PrecisionRecallDisplay(**ctor_PrecisionRecallDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePrecisionRecallDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Plot precision-recall curve given an estimator and some data.
   */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_PrecisionRecallDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'pos_label': ${opts["pos_label"] ?? void 0}, 'drop_intermediate': ${opts["drop_intermediate"] ?? void 0}, 'response_method': ${opts["response_method"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_PrecisionRecallDisplay_from_estimator = {k: v for k, v in pms_PrecisionRecallDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_PrecisionRecallDisplay_from_estimator = bridgePrecisionRecallDisplay[${this.id}].from_estimator(**pms_PrecisionRecallDisplay_from_estimator)`;
    return this._py`res_PrecisionRecallDisplay_from_estimator.tolist() if hasattr(res_PrecisionRecallDisplay_from_estimator, 'tolist') else res_PrecisionRecallDisplay_from_estimator`;
  }
  /**
    Plot precision-recall curve given binary class predictions.
   */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_PrecisionRecallDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_pred': np.array(${opts["y_pred"] ?? void 0}) if ${opts["y_pred"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'pos_label': ${opts["pos_label"] ?? void 0}, 'drop_intermediate': ${opts["drop_intermediate"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_PrecisionRecallDisplay_from_predictions = {k: v for k, v in pms_PrecisionRecallDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_PrecisionRecallDisplay_from_predictions = bridgePrecisionRecallDisplay[${this.id}].from_predictions(**pms_PrecisionRecallDisplay_from_predictions)`;
    return this._py`res_PrecisionRecallDisplay_from_predictions.tolist() if hasattr(res_PrecisionRecallDisplay_from_predictions, 'tolist') else res_PrecisionRecallDisplay_from_predictions`;
  }
  /**
      Plot visualization.
  
      Extra keyword arguments will be passed to matplotlibâ€™s `plot`.
     */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PrecisionRecallDisplay must call init() before plot()");
    }
    await this._py.ex`pms_PrecisionRecallDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_PrecisionRecallDisplay_plot = {k: v for k, v in pms_PrecisionRecallDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_PrecisionRecallDisplay_plot = bridgePrecisionRecallDisplay[${this.id}].plot(**pms_PrecisionRecallDisplay_plot)`;
    return this._py`res_PrecisionRecallDisplay_plot.tolist() if hasattr(res_PrecisionRecallDisplay_plot, 'tolist') else res_PrecisionRecallDisplay_plot`;
  }
  /**
    Precision recall curve.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before accessing line_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PrecisionRecallDisplay_line_ = bridgePrecisionRecallDisplay[${this.id}].line_`;
      return this._py`attr_PrecisionRecallDisplay_line_.tolist() if hasattr(attr_PrecisionRecallDisplay_line_, 'tolist') else attr_PrecisionRecallDisplay_line_`;
    })();
  }
  /**
    The chance level line. It is `undefined` if the chance level is not plotted.
   */
  get chance_level_() {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before accessing chance_level_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PrecisionRecallDisplay_chance_level_ = bridgePrecisionRecallDisplay[${this.id}].chance_level_`;
      return this._py`attr_PrecisionRecallDisplay_chance_level_.tolist() if hasattr(attr_PrecisionRecallDisplay_chance_level_, 'tolist') else attr_PrecisionRecallDisplay_chance_level_`;
    })();
  }
  /**
    Axes with precision recall curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PrecisionRecallDisplay_ax_ = bridgePrecisionRecallDisplay[${this.id}].ax_`;
      return this._py`attr_PrecisionRecallDisplay_ax_.tolist() if hasattr(attr_PrecisionRecallDisplay_ax_, 'tolist') else attr_PrecisionRecallDisplay_ax_`;
    })();
  }
  /**
    Figure containing the curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This PrecisionRecallDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PrecisionRecallDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PrecisionRecallDisplay_figure_ = bridgePrecisionRecallDisplay[${this.id}].figure_`;
      return this._py`attr_PrecisionRecallDisplay_figure_.tolist() if hasattr(attr_PrecisionRecallDisplay_figure_, 'tolist') else attr_PrecisionRecallDisplay_figure_`;
    })();
  }
};

// src/generated/metrics/PredictionErrorDisplay.ts
import crypto168 from "node:crypto";
var PredictionErrorDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PredictionErrorDisplay${crypto168.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PredictionErrorDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import PredictionErrorDisplay
try: bridgePredictionErrorDisplay
except NameError: bridgePredictionErrorDisplay = {}
`;
    await this._py.ex`ctor_PredictionErrorDisplay = {'y_true': np.array(${this.opts["y_true"] ?? void 0}) if ${this.opts["y_true"] !== void 0} else None, 'y_pred': np.array(${this.opts["y_pred"] ?? void 0}) if ${this.opts["y_pred"] !== void 0} else None}

ctor_PredictionErrorDisplay = {k: v for k, v in ctor_PredictionErrorDisplay.items() if v is not None}`;
    await this._py.ex`bridgePredictionErrorDisplay[${this.id}] = PredictionErrorDisplay(**ctor_PredictionErrorDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePredictionErrorDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot the prediction error given a regressor and some data.
  
      For general information regarding `scikit-learn` visualization tools, read more in the [Visualization Guide](../../visualizations.html#visualizations). For details regarding interpreting these plots, refer to the [Model Evaluation Guide](../model_evaluation.html#visualization-regression-evaluation).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_PredictionErrorDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'kind': ${opts["kind"] ?? void 0}, 'subsample': ${opts["subsample"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'scatter_kwargs': ${opts["scatter_kwargs"] ?? void 0}, 'line_kwargs': ${opts["line_kwargs"] ?? void 0}}

pms_PredictionErrorDisplay_from_estimator = {k: v for k, v in pms_PredictionErrorDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_PredictionErrorDisplay_from_estimator = bridgePredictionErrorDisplay[${this.id}].from_estimator(**pms_PredictionErrorDisplay_from_estimator)`;
    return this._py`res_PredictionErrorDisplay_from_estimator.tolist() if hasattr(res_PredictionErrorDisplay_from_estimator, 'tolist') else res_PredictionErrorDisplay_from_estimator`;
  }
  /**
      Plot the prediction error given the true and predicted targets.
  
      For general information regarding `scikit-learn` visualization tools, read more in the [Visualization Guide](../../visualizations.html#visualizations). For details regarding interpreting these plots, refer to the [Model Evaluation Guide](../model_evaluation.html#visualization-regression-evaluation).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_PredictionErrorDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_pred': np.array(${opts["y_pred"] ?? void 0}) if ${opts["y_pred"] !== void 0} else None, 'kind': ${opts["kind"] ?? void 0}, 'subsample': ${opts["subsample"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'scatter_kwargs': ${opts["scatter_kwargs"] ?? void 0}, 'line_kwargs': ${opts["line_kwargs"] ?? void 0}}

pms_PredictionErrorDisplay_from_predictions = {k: v for k, v in pms_PredictionErrorDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_PredictionErrorDisplay_from_predictions = bridgePredictionErrorDisplay[${this.id}].from_predictions(**pms_PredictionErrorDisplay_from_predictions)`;
    return this._py`res_PredictionErrorDisplay_from_predictions.tolist() if hasattr(res_PredictionErrorDisplay_from_predictions, 'tolist') else res_PredictionErrorDisplay_from_predictions`;
  }
  /**
      Plot visualization.
  
      Extra keyword arguments will be passed to matplotlibâ€™s `plot`.
     */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PredictionErrorDisplay must call init() before plot()");
    }
    await this._py.ex`pms_PredictionErrorDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'kind': ${opts["kind"] ?? void 0}, 'scatter_kwargs': ${opts["scatter_kwargs"] ?? void 0}, 'line_kwargs': ${opts["line_kwargs"] ?? void 0}}

pms_PredictionErrorDisplay_plot = {k: v for k, v in pms_PredictionErrorDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_PredictionErrorDisplay_plot = bridgePredictionErrorDisplay[${this.id}].plot(**pms_PredictionErrorDisplay_plot)`;
    return this._py`res_PredictionErrorDisplay_plot.tolist() if hasattr(res_PredictionErrorDisplay_plot, 'tolist') else res_PredictionErrorDisplay_plot`;
  }
  /**
    Optimal line representing `y\_true \== y\_pred`. Therefore, it is a diagonal line for `kind="predictions"` and a horizontal line for `kind="residuals"`.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before accessing line_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PredictionErrorDisplay_line_ = bridgePredictionErrorDisplay[${this.id}].line_`;
      return this._py`attr_PredictionErrorDisplay_line_.tolist() if hasattr(attr_PredictionErrorDisplay_line_, 'tolist') else attr_PredictionErrorDisplay_line_`;
    })();
  }
  /**
    Residual lines. If `with\_errors=False`, then it is set to `undefined`.
   */
  get errors_lines_() {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before accessing errors_lines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PredictionErrorDisplay_errors_lines_ = bridgePredictionErrorDisplay[${this.id}].errors_lines_`;
      return this._py`attr_PredictionErrorDisplay_errors_lines_.tolist() if hasattr(attr_PredictionErrorDisplay_errors_lines_, 'tolist') else attr_PredictionErrorDisplay_errors_lines_`;
    })();
  }
  /**
    Scatter data points.
   */
  get scatter_() {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before accessing scatter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PredictionErrorDisplay_scatter_ = bridgePredictionErrorDisplay[${this.id}].scatter_`;
      return this._py`attr_PredictionErrorDisplay_scatter_.tolist() if hasattr(attr_PredictionErrorDisplay_scatter_, 'tolist') else attr_PredictionErrorDisplay_scatter_`;
    })();
  }
  /**
    Axes with the different matplotlib axis.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PredictionErrorDisplay_ax_ = bridgePredictionErrorDisplay[${this.id}].ax_`;
      return this._py`attr_PredictionErrorDisplay_ax_.tolist() if hasattr(attr_PredictionErrorDisplay_ax_, 'tolist') else attr_PredictionErrorDisplay_ax_`;
    })();
  }
  /**
    Figure containing the scatter and lines.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This PredictionErrorDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredictionErrorDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PredictionErrorDisplay_figure_ = bridgePredictionErrorDisplay[${this.id}].figure_`;
      return this._py`attr_PredictionErrorDisplay_figure_.tolist() if hasattr(attr_PredictionErrorDisplay_figure_, 'tolist') else attr_PredictionErrorDisplay_figure_`;
    })();
  }
};

// src/generated/metrics/RocCurveDisplay.ts
import crypto169 from "node:crypto";
var RocCurveDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RocCurveDisplay${crypto169.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RocCurveDisplay.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.metrics import RocCurveDisplay
try: bridgeRocCurveDisplay
except NameError: bridgeRocCurveDisplay = {}
`;
    await this._py.ex`ctor_RocCurveDisplay = {'fpr': np.array(${this.opts["fpr"] ?? void 0}) if ${this.opts["fpr"] !== void 0} else None, 'tpr': np.array(${this.opts["tpr"] ?? void 0}) if ${this.opts["tpr"] !== void 0} else None, 'roc_auc': ${this.opts["roc_auc"] ?? void 0}, 'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}}

ctor_RocCurveDisplay = {k: v for k, v in ctor_RocCurveDisplay.items() if v is not None}`;
    await this._py.ex`bridgeRocCurveDisplay[${this.id}] = RocCurveDisplay(**ctor_RocCurveDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRocCurveDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a ROC Curve display from an estimator.
   */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RocCurveDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_RocCurveDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'drop_intermediate': ${opts["drop_intermediate"] ?? void 0}, 'response_method': ${opts["response_method"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_RocCurveDisplay_from_estimator = {k: v for k, v in pms_RocCurveDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_RocCurveDisplay_from_estimator = bridgeRocCurveDisplay[${this.id}].from_estimator(**pms_RocCurveDisplay_from_estimator)`;
    return this._py`res_RocCurveDisplay_from_estimator.tolist() if hasattr(res_RocCurveDisplay_from_estimator, 'tolist') else res_RocCurveDisplay_from_estimator`;
  }
  /**
      Plot ROC curve given the true and predicted values.
  
      Read more in the [User Guide](../../visualizations.html#visualizations).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RocCurveDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_RocCurveDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_pred': np.array(${opts["y_pred"] ?? void 0}) if ${opts["y_pred"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'drop_intermediate': ${opts["drop_intermediate"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_RocCurveDisplay_from_predictions = {k: v for k, v in pms_RocCurveDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_RocCurveDisplay_from_predictions = bridgeRocCurveDisplay[${this.id}].from_predictions(**pms_RocCurveDisplay_from_predictions)`;
    return this._py`res_RocCurveDisplay_from_predictions.tolist() if hasattr(res_RocCurveDisplay_from_predictions, 'tolist') else res_RocCurveDisplay_from_predictions`;
  }
  /**
      Plot visualization.
  
      Extra keyword arguments will be passed to matplotlibâ€™s `plot`.
     */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RocCurveDisplay must call init() before plot()");
    }
    await this._py.ex`pms_RocCurveDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'plot_chance_level': ${opts["plot_chance_level"] ?? void 0}, 'chance_level_kw': ${opts["chance_level_kw"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_RocCurveDisplay_plot = {k: v for k, v in pms_RocCurveDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_RocCurveDisplay_plot = bridgeRocCurveDisplay[${this.id}].plot(**pms_RocCurveDisplay_plot)`;
    return this._py`res_RocCurveDisplay_plot.tolist() if hasattr(res_RocCurveDisplay_plot, 'tolist') else res_RocCurveDisplay_plot`;
  }
  /**
    ROC Curve.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RocCurveDisplay must call init() before accessing line_");
    }
    return (async () => {
      await this._py.ex`attr_RocCurveDisplay_line_ = bridgeRocCurveDisplay[${this.id}].line_`;
      return this._py`attr_RocCurveDisplay_line_.tolist() if hasattr(attr_RocCurveDisplay_line_, 'tolist') else attr_RocCurveDisplay_line_`;
    })();
  }
  /**
    The chance level line. It is `undefined` if the chance level is not plotted.
   */
  get chance_level_() {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RocCurveDisplay must call init() before accessing chance_level_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RocCurveDisplay_chance_level_ = bridgeRocCurveDisplay[${this.id}].chance_level_`;
      return this._py`attr_RocCurveDisplay_chance_level_.tolist() if hasattr(attr_RocCurveDisplay_chance_level_, 'tolist') else attr_RocCurveDisplay_chance_level_`;
    })();
  }
  /**
    Axes with ROC Curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RocCurveDisplay must call init() before accessing ax_");
    }
    return (async () => {
      await this._py.ex`attr_RocCurveDisplay_ax_ = bridgeRocCurveDisplay[${this.id}].ax_`;
      return this._py`attr_RocCurveDisplay_ax_.tolist() if hasattr(attr_RocCurveDisplay_ax_, 'tolist') else attr_RocCurveDisplay_ax_`;
    })();
  }
  /**
    Figure containing the curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error("This RocCurveDisplay instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RocCurveDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RocCurveDisplay_figure_ = bridgeRocCurveDisplay[${this.id}].figure_`;
      return this._py`attr_RocCurveDisplay_figure_.tolist() if hasattr(attr_RocCurveDisplay_figure_, 'tolist') else attr_RocCurveDisplay_figure_`;
    })();
  }
};

// src/generated/mixture/BayesianGaussianMixture.ts
import crypto170 from "node:crypto";
var BayesianGaussianMixture = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BayesianGaussianMixture${crypto170.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "BayesianGaussianMixture.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.mixture import BayesianGaussianMixture
try: bridgeBayesianGaussianMixture
except NameError: bridgeBayesianGaussianMixture = {}
`;
    await this._py.ex`ctor_BayesianGaussianMixture = {'n_components': ${this.opts["n_components"] ?? void 0}, 'covariance_type': ${this.opts["covariance_type"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'reg_covar': ${this.opts["reg_covar"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'init_params': ${this.opts["init_params"] ?? void 0}, 'weight_concentration_prior_type': ${this.opts["weight_concentration_prior_type"] ?? void 0}, 'weight_concentration_prior': ${this.opts["weight_concentration_prior"] ?? void 0}, 'mean_precision_prior': ${this.opts["mean_precision_prior"] ?? void 0}, 'mean_prior': ${this.opts["mean_prior"] ?? void 0}, 'degrees_of_freedom_prior': ${this.opts["degrees_of_freedom_prior"] ?? void 0}, 'covariance_prior': ${this.opts["covariance_prior"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_interval': ${this.opts["verbose_interval"] ?? void 0}}

ctor_BayesianGaussianMixture = {k: v for k, v in ctor_BayesianGaussianMixture.items() if v is not None}`;
    await this._py.ex`bridgeBayesianGaussianMixture[${this.id}] = BayesianGaussianMixture(**ctor_BayesianGaussianMixture)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBayesianGaussianMixture[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Estimate model parameters with the EM algorithm.
  
      The method fits the model `n\_init` times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a `ConvergenceWarning` is raised. If `warm\_start` is `true`, then `n\_init` is ignored and a single initialization is performed upon the first call. Upon consecutive calls, training starts where it left off.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BayesianGaussianMixture must call init() before fit()");
    }
    await this._py.ex`pms_BayesianGaussianMixture_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_fit = {k: v for k, v in pms_BayesianGaussianMixture_fit.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_fit = bridgeBayesianGaussianMixture[${this.id}].fit(**pms_BayesianGaussianMixture_fit)`;
    return this._py`res_BayesianGaussianMixture_fit.tolist() if hasattr(res_BayesianGaussianMixture_fit, 'tolist') else res_BayesianGaussianMixture_fit`;
  }
  /**
      Estimate model parameters using X and predict the labels for X.
  
      The method fits the model n\_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a [`ConvergenceWarning`](sklearn.exceptions.ConvergenceWarning.html#sklearn.exceptions.ConvergenceWarning "sklearn.exceptions.ConvergenceWarning") is raised. After fitting, it predicts the most probable label for the input data points.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_fit_predict = {k: v for k, v in pms_BayesianGaussianMixture_fit_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_fit_predict = bridgeBayesianGaussianMixture[${this.id}].fit_predict(**pms_BayesianGaussianMixture_fit_predict)`;
    return this._py`res_BayesianGaussianMixture_fit_predict.tolist() if hasattr(res_BayesianGaussianMixture_fit_predict, 'tolist') else res_BayesianGaussianMixture_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BayesianGaussianMixture_get_metadata_routing = {k: v for k, v in pms_BayesianGaussianMixture_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_get_metadata_routing = bridgeBayesianGaussianMixture[${this.id}].get_metadata_routing(**pms_BayesianGaussianMixture_get_metadata_routing)`;
    return this._py`res_BayesianGaussianMixture_get_metadata_routing.tolist() if hasattr(res_BayesianGaussianMixture_get_metadata_routing, 'tolist') else res_BayesianGaussianMixture_get_metadata_routing`;
  }
  /**
    Predict the labels for the data samples in X using trained model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before predict()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_predict = {k: v for k, v in pms_BayesianGaussianMixture_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_predict = bridgeBayesianGaussianMixture[${this.id}].predict(**pms_BayesianGaussianMixture_predict)`;
    return this._py`res_BayesianGaussianMixture_predict.tolist() if hasattr(res_BayesianGaussianMixture_predict, 'tolist') else res_BayesianGaussianMixture_predict`;
  }
  /**
    Evaluate the componentsâ€™ density for each sample.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_predict_proba = {k: v for k, v in pms_BayesianGaussianMixture_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_predict_proba = bridgeBayesianGaussianMixture[${this.id}].predict_proba(**pms_BayesianGaussianMixture_predict_proba)`;
    return this._py`res_BayesianGaussianMixture_predict_proba.tolist() if hasattr(res_BayesianGaussianMixture_predict_proba, 'tolist') else res_BayesianGaussianMixture_predict_proba`;
  }
  /**
    Generate random samples from the fitted Gaussian distribution.
   */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before sample()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_sample = {'n_samples': ${opts["n_samples"] ?? void 0}}

pms_BayesianGaussianMixture_sample = {k: v for k, v in pms_BayesianGaussianMixture_sample.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_sample = bridgeBayesianGaussianMixture[${this.id}].sample(**pms_BayesianGaussianMixture_sample)`;
    return this._py`res_BayesianGaussianMixture_sample.tolist() if hasattr(res_BayesianGaussianMixture_sample, 'tolist') else res_BayesianGaussianMixture_sample`;
  }
  /**
    Compute the per-sample average log-likelihood of the given data X.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BayesianGaussianMixture must call init() before score()");
    }
    await this._py.ex`pms_BayesianGaussianMixture_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_score = {k: v for k, v in pms_BayesianGaussianMixture_score.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_score = bridgeBayesianGaussianMixture[${this.id}].score(**pms_BayesianGaussianMixture_score)`;
    return this._py`res_BayesianGaussianMixture_score.tolist() if hasattr(res_BayesianGaussianMixture_score, 'tolist') else res_BayesianGaussianMixture_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_score_samples = {k: v for k, v in pms_BayesianGaussianMixture_score_samples.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_score_samples = bridgeBayesianGaussianMixture[${this.id}].score_samples(**pms_BayesianGaussianMixture_score_samples)`;
    return this._py`res_BayesianGaussianMixture_score_samples.tolist() if hasattr(res_BayesianGaussianMixture_score_samples, 'tolist') else res_BayesianGaussianMixture_score_samples`;
  }
  /**
    The weights of each mixture components.
   */
  get weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weights_ = bridgeBayesianGaussianMixture[${this.id}].weights_`;
      return this._py`attr_BayesianGaussianMixture_weights_.tolist() if hasattr(attr_BayesianGaussianMixture_weights_, 'tolist') else attr_BayesianGaussianMixture_weights_`;
    })();
  }
  /**
    The mean of each mixture component.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_means_ = bridgeBayesianGaussianMixture[${this.id}].means_`;
      return this._py`attr_BayesianGaussianMixture_means_.tolist() if hasattr(attr_BayesianGaussianMixture_means_, 'tolist') else attr_BayesianGaussianMixture_means_`;
    })();
  }
  /**
    The covariance of each mixture component. The shape depends on `covariance\_type`:
   */
  get covariances_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing covariances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_covariances_ = bridgeBayesianGaussianMixture[${this.id}].covariances_`;
      return this._py`attr_BayesianGaussianMixture_covariances_.tolist() if hasattr(attr_BayesianGaussianMixture_covariances_, 'tolist') else attr_BayesianGaussianMixture_covariances_`;
    })();
  }
  /**
    The precision matrices for each component in the mixture. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing precisions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_precisions_ = bridgeBayesianGaussianMixture[${this.id}].precisions_`;
      return this._py`attr_BayesianGaussianMixture_precisions_.tolist() if hasattr(attr_BayesianGaussianMixture_precisions_, 'tolist') else attr_BayesianGaussianMixture_precisions_`;
    })();
  }
  /**
    The cholesky decomposition of the precision matrices of each mixture component. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_cholesky_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing precisions_cholesky_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_precisions_cholesky_ = bridgeBayesianGaussianMixture[${this.id}].precisions_cholesky_`;
      return this._py`attr_BayesianGaussianMixture_precisions_cholesky_.tolist() if hasattr(attr_BayesianGaussianMixture_precisions_cholesky_, 'tolist') else attr_BayesianGaussianMixture_precisions_cholesky_`;
    })();
  }
  /**
    True when convergence was reached in fit(), `false` otherwise.
   */
  get converged_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing converged_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_converged_ = bridgeBayesianGaussianMixture[${this.id}].converged_`;
      return this._py`attr_BayesianGaussianMixture_converged_.tolist() if hasattr(attr_BayesianGaussianMixture_converged_, 'tolist') else attr_BayesianGaussianMixture_converged_`;
    })();
  }
  /**
    Number of step used by the best fit of inference to reach the convergence.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_n_iter_ = bridgeBayesianGaussianMixture[${this.id}].n_iter_`;
      return this._py`attr_BayesianGaussianMixture_n_iter_.tolist() if hasattr(attr_BayesianGaussianMixture_n_iter_, 'tolist') else attr_BayesianGaussianMixture_n_iter_`;
    })();
  }
  /**
    Lower bound value on the model evidence (of the training data) of the best fit of inference.
   */
  get lower_bound_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing lower_bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_lower_bound_ = bridgeBayesianGaussianMixture[${this.id}].lower_bound_`;
      return this._py`attr_BayesianGaussianMixture_lower_bound_.tolist() if hasattr(attr_BayesianGaussianMixture_lower_bound_, 'tolist') else attr_BayesianGaussianMixture_lower_bound_`;
    })();
  }
  /**
    The dirichlet concentration of each component on the weight distribution (Dirichlet). The type depends on `weight\_concentration\_prior\_type`:
   */
  get weight_concentration_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weight_concentration_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weight_concentration_prior_ = bridgeBayesianGaussianMixture[${this.id}].weight_concentration_prior_`;
      return this._py`attr_BayesianGaussianMixture_weight_concentration_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_weight_concentration_prior_, 'tolist') else attr_BayesianGaussianMixture_weight_concentration_prior_`;
    })();
  }
  /**
    The dirichlet concentration of each component on the weight distribution (Dirichlet).
   */
  get weight_concentration_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weight_concentration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weight_concentration_ = bridgeBayesianGaussianMixture[${this.id}].weight_concentration_`;
      return this._py`attr_BayesianGaussianMixture_weight_concentration_.tolist() if hasattr(attr_BayesianGaussianMixture_weight_concentration_, 'tolist') else attr_BayesianGaussianMixture_weight_concentration_`;
    })();
  }
  /**
    The precision prior on the mean distribution (Gaussian). Controls the extent of where means can be placed. Larger values concentrate the cluster means around `mean\_prior`. If mean\_precision\_prior is set to `undefined`, `mean\_precision\_prior\_` is set to 1.
   */
  get mean_precision_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_precision_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_precision_prior_ = bridgeBayesianGaussianMixture[${this.id}].mean_precision_prior_`;
      return this._py`attr_BayesianGaussianMixture_mean_precision_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_precision_prior_, 'tolist') else attr_BayesianGaussianMixture_mean_precision_prior_`;
    })();
  }
  /**
    The precision of each components on the mean distribution (Gaussian).
   */
  get mean_precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_precision_ = bridgeBayesianGaussianMixture[${this.id}].mean_precision_`;
      return this._py`attr_BayesianGaussianMixture_mean_precision_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_precision_, 'tolist') else attr_BayesianGaussianMixture_mean_precision_`;
    })();
  }
  /**
    The prior on the mean distribution (Gaussian).
   */
  get mean_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_prior_ = bridgeBayesianGaussianMixture[${this.id}].mean_prior_`;
      return this._py`attr_BayesianGaussianMixture_mean_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_prior_, 'tolist') else attr_BayesianGaussianMixture_mean_prior_`;
    })();
  }
  /**
    The prior of the number of degrees of freedom on the covariance distributions (Wishart).
   */
  get degrees_of_freedom_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing degrees_of_freedom_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_degrees_of_freedom_prior_ = bridgeBayesianGaussianMixture[${this.id}].degrees_of_freedom_prior_`;
      return this._py`attr_BayesianGaussianMixture_degrees_of_freedom_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_degrees_of_freedom_prior_, 'tolist') else attr_BayesianGaussianMixture_degrees_of_freedom_prior_`;
    })();
  }
  /**
    The number of degrees of freedom of each components in the model.
   */
  get degrees_of_freedom_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing degrees_of_freedom_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_degrees_of_freedom_ = bridgeBayesianGaussianMixture[${this.id}].degrees_of_freedom_`;
      return this._py`attr_BayesianGaussianMixture_degrees_of_freedom_.tolist() if hasattr(attr_BayesianGaussianMixture_degrees_of_freedom_, 'tolist') else attr_BayesianGaussianMixture_degrees_of_freedom_`;
    })();
  }
  /**
    The prior on the covariance distribution (Wishart). The shape depends on `covariance\_type`:
   */
  get covariance_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing covariance_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_covariance_prior_ = bridgeBayesianGaussianMixture[${this.id}].covariance_prior_`;
      return this._py`attr_BayesianGaussianMixture_covariance_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_covariance_prior_, 'tolist') else attr_BayesianGaussianMixture_covariance_prior_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_n_features_in_ = bridgeBayesianGaussianMixture[${this.id}].n_features_in_`;
      return this._py`attr_BayesianGaussianMixture_n_features_in_.tolist() if hasattr(attr_BayesianGaussianMixture_n_features_in_, 'tolist') else attr_BayesianGaussianMixture_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_feature_names_in_ = bridgeBayesianGaussianMixture[${this.id}].feature_names_in_`;
      return this._py`attr_BayesianGaussianMixture_feature_names_in_.tolist() if hasattr(attr_BayesianGaussianMixture_feature_names_in_, 'tolist') else attr_BayesianGaussianMixture_feature_names_in_`;
    })();
  }
};

// src/generated/mixture/GaussianMixture.ts
import crypto171 from "node:crypto";
var GaussianMixture = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianMixture${crypto171.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GaussianMixture.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.mixture import GaussianMixture
try: bridgeGaussianMixture
except NameError: bridgeGaussianMixture = {}
`;
    await this._py.ex`ctor_GaussianMixture = {'n_components': ${this.opts["n_components"] ?? void 0}, 'covariance_type': ${this.opts["covariance_type"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'reg_covar': ${this.opts["reg_covar"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'init_params': ${this.opts["init_params"] ?? void 0}, 'weights_init': np.array(${this.opts["weights_init"] ?? void 0}) if ${this.opts["weights_init"] !== void 0} else None, 'means_init': np.array(${this.opts["means_init"] ?? void 0}) if ${this.opts["means_init"] !== void 0} else None, 'precisions_init': ${this.opts["precisions_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_interval': ${this.opts["verbose_interval"] ?? void 0}}

ctor_GaussianMixture = {k: v for k, v in ctor_GaussianMixture.items() if v is not None}`;
    await this._py.ex`bridgeGaussianMixture[${this.id}] = GaussianMixture(**ctor_GaussianMixture)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianMixture[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Akaike information criterion for the current model on the input X.
  
      You can refer to this [mathematical section](../linear_model.html#aic-bic) for more details regarding the formulation of the AIC used.
     */
  async aic(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before aic()");
    }
    await this._py.ex`pms_GaussianMixture_aic = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_aic = {k: v for k, v in pms_GaussianMixture_aic.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_aic = bridgeGaussianMixture[${this.id}].aic(**pms_GaussianMixture_aic)`;
    return this._py`res_GaussianMixture_aic.tolist() if hasattr(res_GaussianMixture_aic, 'tolist') else res_GaussianMixture_aic`;
  }
  /**
      Bayesian information criterion for the current model on the input X.
  
      You can refer to this [mathematical section](../linear_model.html#aic-bic) for more details regarding the formulation of the BIC used.
     */
  async bic(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before bic()");
    }
    await this._py.ex`pms_GaussianMixture_bic = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_bic = {k: v for k, v in pms_GaussianMixture_bic.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_bic = bridgeGaussianMixture[${this.id}].bic(**pms_GaussianMixture_bic)`;
    return this._py`res_GaussianMixture_bic.tolist() if hasattr(res_GaussianMixture_bic, 'tolist') else res_GaussianMixture_bic`;
  }
  /**
      Estimate model parameters with the EM algorithm.
  
      The method fits the model `n\_init` times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a `ConvergenceWarning` is raised. If `warm\_start` is `true`, then `n\_init` is ignored and a single initialization is performed upon the first call. Upon consecutive calls, training starts where it left off.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before fit()");
    }
    await this._py.ex`pms_GaussianMixture_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_fit = {k: v for k, v in pms_GaussianMixture_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_fit = bridgeGaussianMixture[${this.id}].fit(**pms_GaussianMixture_fit)`;
    return this._py`res_GaussianMixture_fit.tolist() if hasattr(res_GaussianMixture_fit, 'tolist') else res_GaussianMixture_fit`;
  }
  /**
      Estimate model parameters using X and predict the labels for X.
  
      The method fits the model n\_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a [`ConvergenceWarning`](sklearn.exceptions.ConvergenceWarning.html#sklearn.exceptions.ConvergenceWarning "sklearn.exceptions.ConvergenceWarning") is raised. After fitting, it predicts the most probable label for the input data points.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before fit_predict()");
    }
    await this._py.ex`pms_GaussianMixture_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_fit_predict = {k: v for k, v in pms_GaussianMixture_fit_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_fit_predict = bridgeGaussianMixture[${this.id}].fit_predict(**pms_GaussianMixture_fit_predict)`;
    return this._py`res_GaussianMixture_fit_predict.tolist() if hasattr(res_GaussianMixture_fit_predict, 'tolist') else res_GaussianMixture_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GaussianMixture_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GaussianMixture_get_metadata_routing = {k: v for k, v in pms_GaussianMixture_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_get_metadata_routing = bridgeGaussianMixture[${this.id}].get_metadata_routing(**pms_GaussianMixture_get_metadata_routing)`;
    return this._py`res_GaussianMixture_get_metadata_routing.tolist() if hasattr(res_GaussianMixture_get_metadata_routing, 'tolist') else res_GaussianMixture_get_metadata_routing`;
  }
  /**
    Predict the labels for the data samples in X using trained model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before predict()");
    }
    await this._py.ex`pms_GaussianMixture_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_predict = {k: v for k, v in pms_GaussianMixture_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_predict = bridgeGaussianMixture[${this.id}].predict(**pms_GaussianMixture_predict)`;
    return this._py`res_GaussianMixture_predict.tolist() if hasattr(res_GaussianMixture_predict, 'tolist') else res_GaussianMixture_predict`;
  }
  /**
    Evaluate the componentsâ€™ density for each sample.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before predict_proba()");
    }
    await this._py.ex`pms_GaussianMixture_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_predict_proba = {k: v for k, v in pms_GaussianMixture_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_predict_proba = bridgeGaussianMixture[${this.id}].predict_proba(**pms_GaussianMixture_predict_proba)`;
    return this._py`res_GaussianMixture_predict_proba.tolist() if hasattr(res_GaussianMixture_predict_proba, 'tolist') else res_GaussianMixture_predict_proba`;
  }
  /**
    Generate random samples from the fitted Gaussian distribution.
   */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before sample()");
    }
    await this._py.ex`pms_GaussianMixture_sample = {'n_samples': ${opts["n_samples"] ?? void 0}}

pms_GaussianMixture_sample = {k: v for k, v in pms_GaussianMixture_sample.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_sample = bridgeGaussianMixture[${this.id}].sample(**pms_GaussianMixture_sample)`;
    return this._py`res_GaussianMixture_sample.tolist() if hasattr(res_GaussianMixture_sample, 'tolist') else res_GaussianMixture_sample`;
  }
  /**
    Compute the per-sample average log-likelihood of the given data X.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before score()");
    }
    await this._py.ex`pms_GaussianMixture_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_score = {k: v for k, v in pms_GaussianMixture_score.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_score = bridgeGaussianMixture[${this.id}].score(**pms_GaussianMixture_score)`;
    return this._py`res_GaussianMixture_score.tolist() if hasattr(res_GaussianMixture_score, 'tolist') else res_GaussianMixture_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before score_samples()");
    }
    await this._py.ex`pms_GaussianMixture_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_score_samples = {k: v for k, v in pms_GaussianMixture_score_samples.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_score_samples = bridgeGaussianMixture[${this.id}].score_samples(**pms_GaussianMixture_score_samples)`;
    return this._py`res_GaussianMixture_score_samples.tolist() if hasattr(res_GaussianMixture_score_samples, 'tolist') else res_GaussianMixture_score_samples`;
  }
  /**
    The weights of each mixture components.
   */
  get weights_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_weights_ = bridgeGaussianMixture[${this.id}].weights_`;
      return this._py`attr_GaussianMixture_weights_.tolist() if hasattr(attr_GaussianMixture_weights_, 'tolist') else attr_GaussianMixture_weights_`;
    })();
  }
  /**
    The mean of each mixture component.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_means_ = bridgeGaussianMixture[${this.id}].means_`;
      return this._py`attr_GaussianMixture_means_.tolist() if hasattr(attr_GaussianMixture_means_, 'tolist') else attr_GaussianMixture_means_`;
    })();
  }
  /**
    The covariance of each mixture component. The shape depends on `covariance\_type`:
   */
  get covariances_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing covariances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_covariances_ = bridgeGaussianMixture[${this.id}].covariances_`;
      return this._py`attr_GaussianMixture_covariances_.tolist() if hasattr(attr_GaussianMixture_covariances_, 'tolist') else attr_GaussianMixture_covariances_`;
    })();
  }
  /**
    The precision matrices for each component in the mixture. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing precisions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_precisions_ = bridgeGaussianMixture[${this.id}].precisions_`;
      return this._py`attr_GaussianMixture_precisions_.tolist() if hasattr(attr_GaussianMixture_precisions_, 'tolist') else attr_GaussianMixture_precisions_`;
    })();
  }
  /**
    The cholesky decomposition of the precision matrices of each mixture component. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_cholesky_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing precisions_cholesky_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_precisions_cholesky_ = bridgeGaussianMixture[${this.id}].precisions_cholesky_`;
      return this._py`attr_GaussianMixture_precisions_cholesky_.tolist() if hasattr(attr_GaussianMixture_precisions_cholesky_, 'tolist') else attr_GaussianMixture_precisions_cholesky_`;
    })();
  }
  /**
    True when convergence was reached in fit(), `false` otherwise.
   */
  get converged_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing converged_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_converged_ = bridgeGaussianMixture[${this.id}].converged_`;
      return this._py`attr_GaussianMixture_converged_.tolist() if hasattr(attr_GaussianMixture_converged_, 'tolist') else attr_GaussianMixture_converged_`;
    })();
  }
  /**
    Number of step used by the best fit of EM to reach the convergence.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_n_iter_ = bridgeGaussianMixture[${this.id}].n_iter_`;
      return this._py`attr_GaussianMixture_n_iter_.tolist() if hasattr(attr_GaussianMixture_n_iter_, 'tolist') else attr_GaussianMixture_n_iter_`;
    })();
  }
  /**
    Lower bound value on the log-likelihood (of the training data with respect to the model) of the best fit of EM.
   */
  get lower_bound_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing lower_bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_lower_bound_ = bridgeGaussianMixture[${this.id}].lower_bound_`;
      return this._py`attr_GaussianMixture_lower_bound_.tolist() if hasattr(attr_GaussianMixture_lower_bound_, 'tolist') else attr_GaussianMixture_lower_bound_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_n_features_in_ = bridgeGaussianMixture[${this.id}].n_features_in_`;
      return this._py`attr_GaussianMixture_n_features_in_.tolist() if hasattr(attr_GaussianMixture_n_features_in_, 'tolist') else attr_GaussianMixture_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_feature_names_in_ = bridgeGaussianMixture[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianMixture_feature_names_in_.tolist() if hasattr(attr_GaussianMixture_feature_names_in_, 'tolist') else attr_GaussianMixture_feature_names_in_`;
    })();
  }
};

// src/generated/model_selection/GridSearchCV.ts
import crypto172 from "node:crypto";
var GridSearchCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GridSearchCV${crypto172.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GridSearchCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import GridSearchCV
try: bridgeGridSearchCV
except NameError: bridgeGridSearchCV = {}
`;
    await this._py.ex`ctor_GridSearchCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'param_grid': ${this.opts["param_grid"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'pre_dispatch': ${this.opts["pre_dispatch"] ?? void 0}, 'error_score': ${this.opts["error_score"] ?? void 0}, 'return_train_score': ${this.opts["return_train_score"] ?? void 0}}

ctor_GridSearchCV = {k: v for k, v in ctor_GridSearchCV.items() if v is not None}`;
    await this._py.ex`bridgeGridSearchCV[${this.id}] = GridSearchCV(**ctor_GridSearchCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGridSearchCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Call decision\_function on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `decision\_function`.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_GridSearchCV_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_decision_function = {k: v for k, v in pms_GridSearchCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_decision_function = bridgeGridSearchCV[${this.id}].decision_function(**pms_GridSearchCV_decision_function)`;
    return this._py`res_GridSearchCV_decision_function.tolist() if hasattr(res_GridSearchCV_decision_function, 'tolist') else res_GridSearchCV_decision_function`;
  }
  /**
    Run fit with all sets of parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before fit()");
    }
    await this._py.ex`pms_GridSearchCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_GridSearchCV_fit = {k: v for k, v in pms_GridSearchCV_fit.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_fit = bridgeGridSearchCV[${this.id}].fit(**pms_GridSearchCV_fit)`;
    return this._py`res_GridSearchCV_fit.tolist() if hasattr(res_GridSearchCV_fit, 'tolist') else res_GridSearchCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GridSearchCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GridSearchCV_get_metadata_routing = {k: v for k, v in pms_GridSearchCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_get_metadata_routing = bridgeGridSearchCV[${this.id}].get_metadata_routing(**pms_GridSearchCV_get_metadata_routing)`;
    return this._py`res_GridSearchCV_get_metadata_routing.tolist() if hasattr(res_GridSearchCV_get_metadata_routing, 'tolist') else res_GridSearchCV_get_metadata_routing`;
  }
  /**
      Call inverse\_transform on the estimator with the best found params.
  
      Only available if the underlying estimator implements `inverse\_transform` and `refit=True`.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_GridSearchCV_inverse_transform = {'Xt': ${opts["Xt"] ?? void 0}}

pms_GridSearchCV_inverse_transform = {k: v for k, v in pms_GridSearchCV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_inverse_transform = bridgeGridSearchCV[${this.id}].inverse_transform(**pms_GridSearchCV_inverse_transform)`;
    return this._py`res_GridSearchCV_inverse_transform.tolist() if hasattr(res_GridSearchCV_inverse_transform, 'tolist') else res_GridSearchCV_inverse_transform`;
  }
  /**
      Call predict on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before predict()");
    }
    await this._py.ex`pms_GridSearchCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_predict = {k: v for k, v in pms_GridSearchCV_predict.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_predict = bridgeGridSearchCV[${this.id}].predict(**pms_GridSearchCV_predict)`;
    return this._py`res_GridSearchCV_predict.tolist() if hasattr(res_GridSearchCV_predict, 'tolist') else res_GridSearchCV_predict`;
  }
  /**
      Call predict\_log\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_log\_proba`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_GridSearchCV_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_predict_log_proba = {k: v for k, v in pms_GridSearchCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_predict_log_proba = bridgeGridSearchCV[${this.id}].predict_log_proba(**pms_GridSearchCV_predict_log_proba)`;
    return this._py`res_GridSearchCV_predict_log_proba.tolist() if hasattr(res_GridSearchCV_predict_log_proba, 'tolist') else res_GridSearchCV_predict_log_proba`;
  }
  /**
      Call predict\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before predict_proba()");
    }
    await this._py.ex`pms_GridSearchCV_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_predict_proba = {k: v for k, v in pms_GridSearchCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_predict_proba = bridgeGridSearchCV[${this.id}].predict_proba(**pms_GridSearchCV_predict_proba)`;
    return this._py`res_GridSearchCV_predict_proba.tolist() if hasattr(res_GridSearchCV_predict_proba, 'tolist') else res_GridSearchCV_predict_proba`;
  }
  /**
      Return the score on the given data, if the estimator has been refit.
  
      This uses the score defined by `scoring` where provided, and the `best\_estimator\_.score` method otherwise.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before score()");
    }
    await this._py.ex`pms_GridSearchCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GridSearchCV_score = {k: v for k, v in pms_GridSearchCV_score.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_score = bridgeGridSearchCV[${this.id}].score(**pms_GridSearchCV_score)`;
    return this._py`res_GridSearchCV_score.tolist() if hasattr(res_GridSearchCV_score, 'tolist') else res_GridSearchCV_score`;
  }
  /**
      Call score\_samples on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `score\_samples`.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before score_samples()");
    }
    await this._py.ex`pms_GridSearchCV_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_score_samples = {k: v for k, v in pms_GridSearchCV_score_samples.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_score_samples = bridgeGridSearchCV[${this.id}].score_samples(**pms_GridSearchCV_score_samples)`;
    return this._py`res_GridSearchCV_score_samples.tolist() if hasattr(res_GridSearchCV_score_samples, 'tolist') else res_GridSearchCV_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_GridSearchCV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_GridSearchCV_set_fit_request = {k: v for k, v in pms_GridSearchCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_set_fit_request = bridgeGridSearchCV[${this.id}].set_fit_request(**pms_GridSearchCV_set_fit_request)`;
    return this._py`res_GridSearchCV_set_fit_request.tolist() if hasattr(res_GridSearchCV_set_fit_request, 'tolist') else res_GridSearchCV_set_fit_request`;
  }
  /**
      Call transform on the estimator with the best found parameters.
  
      Only available if the underlying estimator supports `transform` and `refit=True`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before transform()");
    }
    await this._py.ex`pms_GridSearchCV_transform = {'X': ${opts["X"] ?? void 0}}

pms_GridSearchCV_transform = {k: v for k, v in pms_GridSearchCV_transform.items() if v is not None}`;
    await this._py.ex`res_GridSearchCV_transform = bridgeGridSearchCV[${this.id}].transform(**pms_GridSearchCV_transform)`;
    return this._py`res_GridSearchCV_transform.tolist() if hasattr(res_GridSearchCV_transform, 'tolist') else res_GridSearchCV_transform`;
  }
  /**
      A dict with keys as column headers and values as columns, that can be imported into a pandas `DataFrame`.
  
      For instance the below given table
     */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_cv_results_ = bridgeGridSearchCV[${this.id}].cv_results_`;
      return this._py`attr_GridSearchCV_cv_results_.tolist() if hasattr(attr_GridSearchCV_cv_results_, 'tolist') else attr_GridSearchCV_cv_results_`;
    })();
  }
  /**
      Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if `refit=False`.
  
      See `refit` parameter for more information on allowed values.
     */
  get best_estimator_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing best_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_best_estimator_ = bridgeGridSearchCV[${this.id}].best_estimator_`;
      return this._py`attr_GridSearchCV_best_estimator_.tolist() if hasattr(attr_GridSearchCV_best_estimator_, 'tolist') else attr_GridSearchCV_best_estimator_`;
    })();
  }
  /**
      Mean cross-validated score of the best\_estimator
  
      For multi-metric evaluation, this is present only if `refit` is specified.
  
      This attribute is not available if `refit` is a function.
     */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_best_score_ = bridgeGridSearchCV[${this.id}].best_score_`;
      return this._py`attr_GridSearchCV_best_score_.tolist() if hasattr(attr_GridSearchCV_best_score_, 'tolist') else attr_GridSearchCV_best_score_`;
    })();
  }
  /**
      Parameter setting that gave the best results on the hold out data.
  
      For multi-metric evaluation, this is present only if `refit` is specified.
     */
  get best_params_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing best_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_best_params_ = bridgeGridSearchCV[${this.id}].best_params_`;
      return this._py`attr_GridSearchCV_best_params_.tolist() if hasattr(attr_GridSearchCV_best_params_, 'tolist') else attr_GridSearchCV_best_params_`;
    })();
  }
  /**
      The index (of the `cv\_results\_` arrays) which corresponds to the best candidate parameter setting.
  
      The dict at `search.cv\_results\_\['params'\]\[search.best\_index\_\]` gives the parameter setting for the best model, that gives the highest mean score (`search.best\_score\_`).
  
      For multi-metric evaluation, this is present only if `refit` is specified.
     */
  get best_index_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing best_index_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_best_index_ = bridgeGridSearchCV[${this.id}].best_index_`;
      return this._py`attr_GridSearchCV_best_index_.tolist() if hasattr(attr_GridSearchCV_best_index_, 'tolist') else attr_GridSearchCV_best_index_`;
    })();
  }
  /**
      Scorer function used on the held out data to choose the best parameters for the model.
  
      For multi-metric evaluation, this attribute holds the validated `scoring` dict which maps the scorer key to the scorer callable.
     */
  get scorer_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GridSearchCV must call init() before accessing scorer_");
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_scorer_ = bridgeGridSearchCV[${this.id}].scorer_`;
      return this._py`attr_GridSearchCV_scorer_.tolist() if hasattr(attr_GridSearchCV_scorer_, 'tolist') else attr_GridSearchCV_scorer_`;
    })();
  }
  /**
    The number of cross-validation splits (folds/iterations).
   */
  get n_splits_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing n_splits_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_n_splits_ = bridgeGridSearchCV[${this.id}].n_splits_`;
      return this._py`attr_GridSearchCV_n_splits_.tolist() if hasattr(attr_GridSearchCV_n_splits_, 'tolist') else attr_GridSearchCV_n_splits_`;
    })();
  }
  /**
      Seconds used for refitting the best model on the whole dataset.
  
      This is present only if `refit` is not `false`.
     */
  get refit_time_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing refit_time_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_refit_time_ = bridgeGridSearchCV[${this.id}].refit_time_`;
      return this._py`attr_GridSearchCV_refit_time_.tolist() if hasattr(attr_GridSearchCV_refit_time_, 'tolist') else attr_GridSearchCV_refit_time_`;
    })();
  }
  /**
    Whether or not the scorers compute several metrics.
   */
  get multimetric_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing multimetric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_multimetric_ = bridgeGridSearchCV[${this.id}].multimetric_`;
      return this._py`attr_GridSearchCV_multimetric_.tolist() if hasattr(attr_GridSearchCV_multimetric_, 'tolist') else attr_GridSearchCV_multimetric_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if `best\_estimator\_` is defined (see the documentation for the `refit` parameter for more details) and that `best\_estimator\_` exposes `feature\_names\_in\_` when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GridSearchCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GridSearchCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GridSearchCV_feature_names_in_ = bridgeGridSearchCV[${this.id}].feature_names_in_`;
      return this._py`attr_GridSearchCV_feature_names_in_.tolist() if hasattr(attr_GridSearchCV_feature_names_in_, 'tolist') else attr_GridSearchCV_feature_names_in_`;
    })();
  }
};

// src/generated/model_selection/GroupKFold.ts
import crypto173 from "node:crypto";
var GroupKFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GroupKFold${crypto173.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GroupKFold instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GroupKFold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import GroupKFold
try: bridgeGroupKFold
except NameError: bridgeGroupKFold = {}
`;
    await this._py.ex`ctor_GroupKFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}}

ctor_GroupKFold = {k: v for k, v in ctor_GroupKFold.items() if v is not None}`;
    await this._py.ex`bridgeGroupKFold[${this.id}] = GroupKFold(**ctor_GroupKFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGroupKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GroupKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GroupKFold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GroupKFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GroupKFold_get_metadata_routing = {k: v for k, v in pms_GroupKFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GroupKFold_get_metadata_routing = bridgeGroupKFold[${this.id}].get_metadata_routing(**pms_GroupKFold_get_metadata_routing)`;
    return this._py`res_GroupKFold_get_metadata_routing.tolist() if hasattr(res_GroupKFold_get_metadata_routing, 'tolist') else res_GroupKFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This GroupKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GroupKFold must call init() before get_n_splits()");
    }
    await this._py.ex`pms_GroupKFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_GroupKFold_get_n_splits = {k: v for k, v in pms_GroupKFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_GroupKFold_get_n_splits = bridgeGroupKFold[${this.id}].get_n_splits(**pms_GroupKFold_get_n_splits)`;
    return this._py`res_GroupKFold_get_n_splits.tolist() if hasattr(res_GroupKFold_get_n_splits, 'tolist') else res_GroupKFold_get_n_splits`;
  }
  /**
      Request metadata passed to the `split` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_split_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GroupKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GroupKFold must call init() before set_split_request()");
    }
    await this._py.ex`pms_GroupKFold_set_split_request = {'groups': ${opts["groups"] ?? void 0}}

pms_GroupKFold_set_split_request = {k: v for k, v in pms_GroupKFold_set_split_request.items() if v is not None}`;
    await this._py.ex`res_GroupKFold_set_split_request = bridgeGroupKFold[${this.id}].set_split_request(**pms_GroupKFold_set_split_request)`;
    return this._py`res_GroupKFold_set_split_request.tolist() if hasattr(res_GroupKFold_set_split_request, 'tolist') else res_GroupKFold_set_split_request`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This GroupKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GroupKFold must call init() before split()");
    }
    await this._py.ex`pms_GroupKFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_GroupKFold_split = {k: v for k, v in pms_GroupKFold_split.items() if v is not None}`;
    await this._py.ex`res_GroupKFold_split = bridgeGroupKFold[${this.id}].split(**pms_GroupKFold_split)`;
    return this._py`res_GroupKFold_split.tolist() if hasattr(res_GroupKFold_split, 'tolist') else res_GroupKFold_split`;
  }
};

// src/generated/model_selection/GroupShuffleSplit.ts
import crypto174 from "node:crypto";
var GroupShuffleSplit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GroupShuffleSplit${crypto174.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GroupShuffleSplit instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GroupShuffleSplit.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import GroupShuffleSplit
try: bridgeGroupShuffleSplit
except NameError: bridgeGroupShuffleSplit = {}
`;
    await this._py.ex`ctor_GroupShuffleSplit = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'test_size': ${this.opts["test_size"] ?? void 0}, 'train_size': ${this.opts["train_size"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_GroupShuffleSplit = {k: v for k, v in ctor_GroupShuffleSplit.items() if v is not None}`;
    await this._py.ex`bridgeGroupShuffleSplit[${this.id}] = GroupShuffleSplit(**ctor_GroupShuffleSplit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGroupShuffleSplit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GroupShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GroupShuffleSplit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GroupShuffleSplit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GroupShuffleSplit_get_metadata_routing = {k: v for k, v in pms_GroupShuffleSplit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GroupShuffleSplit_get_metadata_routing = bridgeGroupShuffleSplit[${this.id}].get_metadata_routing(**pms_GroupShuffleSplit_get_metadata_routing)`;
    return this._py`res_GroupShuffleSplit_get_metadata_routing.tolist() if hasattr(res_GroupShuffleSplit_get_metadata_routing, 'tolist') else res_GroupShuffleSplit_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GroupShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GroupShuffleSplit must call init() before get_n_splits()"
      );
    }
    await this._py.ex`pms_GroupShuffleSplit_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_GroupShuffleSplit_get_n_splits = {k: v for k, v in pms_GroupShuffleSplit_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_GroupShuffleSplit_get_n_splits = bridgeGroupShuffleSplit[${this.id}].get_n_splits(**pms_GroupShuffleSplit_get_n_splits)`;
    return this._py`res_GroupShuffleSplit_get_n_splits.tolist() if hasattr(res_GroupShuffleSplit_get_n_splits, 'tolist') else res_GroupShuffleSplit_get_n_splits`;
  }
  /**
      Request metadata passed to the `split` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_split_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GroupShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GroupShuffleSplit must call init() before set_split_request()"
      );
    }
    await this._py.ex`pms_GroupShuffleSplit_set_split_request = {'groups': ${opts["groups"] ?? void 0}}

pms_GroupShuffleSplit_set_split_request = {k: v for k, v in pms_GroupShuffleSplit_set_split_request.items() if v is not None}`;
    await this._py.ex`res_GroupShuffleSplit_set_split_request = bridgeGroupShuffleSplit[${this.id}].set_split_request(**pms_GroupShuffleSplit_set_split_request)`;
    return this._py`res_GroupShuffleSplit_set_split_request.tolist() if hasattr(res_GroupShuffleSplit_set_split_request, 'tolist') else res_GroupShuffleSplit_set_split_request`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GroupShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GroupShuffleSplit must call init() before split()");
    }
    await this._py.ex`pms_GroupShuffleSplit_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_GroupShuffleSplit_split = {k: v for k, v in pms_GroupShuffleSplit_split.items() if v is not None}`;
    await this._py.ex`res_GroupShuffleSplit_split = bridgeGroupShuffleSplit[${this.id}].split(**pms_GroupShuffleSplit_split)`;
    return this._py`res_GroupShuffleSplit_split.tolist() if hasattr(res_GroupShuffleSplit_split, 'tolist') else res_GroupShuffleSplit_split`;
  }
};

// src/generated/model_selection/HalvingGridSearchCV.ts
import crypto175 from "node:crypto";
var HalvingGridSearchCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HalvingGridSearchCV${crypto175.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HalvingGridSearchCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import HalvingGridSearchCV
try: bridgeHalvingGridSearchCV
except NameError: bridgeHalvingGridSearchCV = {}
`;
    await this._py.ex`ctor_HalvingGridSearchCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'param_grid': ${this.opts["param_grid"] ?? void 0}, 'factor': ${this.opts["factor"] ?? void 0}, 'resource': ${this.opts["resource"] ?? void 0}, 'max_resources': ${this.opts["max_resources"] ?? void 0}, 'min_resources': ${this.opts["min_resources"] ?? void 0}, 'aggressive_elimination': ${this.opts["aggressive_elimination"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'error_score': ${this.opts["error_score"] ?? void 0}, 'return_train_score': ${this.opts["return_train_score"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_HalvingGridSearchCV = {k: v for k, v in ctor_HalvingGridSearchCV.items() if v is not None}`;
    await this._py.ex`bridgeHalvingGridSearchCV[${this.id}] = HalvingGridSearchCV(**ctor_HalvingGridSearchCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHalvingGridSearchCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Call decision\_function on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `decision\_function`.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_decision_function = {k: v for k, v in pms_HalvingGridSearchCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_decision_function = bridgeHalvingGridSearchCV[${this.id}].decision_function(**pms_HalvingGridSearchCV_decision_function)`;
    return this._py`res_HalvingGridSearchCV_decision_function.tolist() if hasattr(res_HalvingGridSearchCV_decision_function, 'tolist') else res_HalvingGridSearchCV_decision_function`;
  }
  /**
    Run fit with all sets of parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingGridSearchCV must call init() before fit()");
    }
    await this._py.ex`pms_HalvingGridSearchCV_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_HalvingGridSearchCV_fit = {k: v for k, v in pms_HalvingGridSearchCV_fit.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_fit = bridgeHalvingGridSearchCV[${this.id}].fit(**pms_HalvingGridSearchCV_fit)`;
    return this._py`res_HalvingGridSearchCV_fit.tolist() if hasattr(res_HalvingGridSearchCV_fit, 'tolist') else res_HalvingGridSearchCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HalvingGridSearchCV_get_metadata_routing = {k: v for k, v in pms_HalvingGridSearchCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_get_metadata_routing = bridgeHalvingGridSearchCV[${this.id}].get_metadata_routing(**pms_HalvingGridSearchCV_get_metadata_routing)`;
    return this._py`res_HalvingGridSearchCV_get_metadata_routing.tolist() if hasattr(res_HalvingGridSearchCV_get_metadata_routing, 'tolist') else res_HalvingGridSearchCV_get_metadata_routing`;
  }
  /**
      Call inverse\_transform on the estimator with the best found params.
  
      Only available if the underlying estimator implements `inverse\_transform` and `refit=True`.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_inverse_transform = {'Xt': ${opts["Xt"] ?? void 0}}

pms_HalvingGridSearchCV_inverse_transform = {k: v for k, v in pms_HalvingGridSearchCV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_inverse_transform = bridgeHalvingGridSearchCV[${this.id}].inverse_transform(**pms_HalvingGridSearchCV_inverse_transform)`;
    return this._py`res_HalvingGridSearchCV_inverse_transform.tolist() if hasattr(res_HalvingGridSearchCV_inverse_transform, 'tolist') else res_HalvingGridSearchCV_inverse_transform`;
  }
  /**
      Call predict on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingGridSearchCV must call init() before predict()");
    }
    await this._py.ex`pms_HalvingGridSearchCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_predict = {k: v for k, v in pms_HalvingGridSearchCV_predict.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_predict = bridgeHalvingGridSearchCV[${this.id}].predict(**pms_HalvingGridSearchCV_predict)`;
    return this._py`res_HalvingGridSearchCV_predict.tolist() if hasattr(res_HalvingGridSearchCV_predict, 'tolist') else res_HalvingGridSearchCV_predict`;
  }
  /**
      Call predict\_log\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_log\_proba`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_predict_log_proba = {k: v for k, v in pms_HalvingGridSearchCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_predict_log_proba = bridgeHalvingGridSearchCV[${this.id}].predict_log_proba(**pms_HalvingGridSearchCV_predict_log_proba)`;
    return this._py`res_HalvingGridSearchCV_predict_log_proba.tolist() if hasattr(res_HalvingGridSearchCV_predict_log_proba, 'tolist') else res_HalvingGridSearchCV_predict_log_proba`;
  }
  /**
      Call predict\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_predict_proba = {k: v for k, v in pms_HalvingGridSearchCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_predict_proba = bridgeHalvingGridSearchCV[${this.id}].predict_proba(**pms_HalvingGridSearchCV_predict_proba)`;
    return this._py`res_HalvingGridSearchCV_predict_proba.tolist() if hasattr(res_HalvingGridSearchCV_predict_proba, 'tolist') else res_HalvingGridSearchCV_predict_proba`;
  }
  /**
      Return the score on the given data, if the estimator has been refit.
  
      This uses the score defined by `scoring` where provided, and the `best\_estimator\_.score` method otherwise.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingGridSearchCV must call init() before score()");
    }
    await this._py.ex`pms_HalvingGridSearchCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_HalvingGridSearchCV_score = {k: v for k, v in pms_HalvingGridSearchCV_score.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_score = bridgeHalvingGridSearchCV[${this.id}].score(**pms_HalvingGridSearchCV_score)`;
    return this._py`res_HalvingGridSearchCV_score.tolist() if hasattr(res_HalvingGridSearchCV_score, 'tolist') else res_HalvingGridSearchCV_score`;
  }
  /**
      Call score\_samples on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `score\_samples`.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_score_samples = {k: v for k, v in pms_HalvingGridSearchCV_score_samples.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_score_samples = bridgeHalvingGridSearchCV[${this.id}].score_samples(**pms_HalvingGridSearchCV_score_samples)`;
    return this._py`res_HalvingGridSearchCV_score_samples.tolist() if hasattr(res_HalvingGridSearchCV_score_samples, 'tolist') else res_HalvingGridSearchCV_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HalvingGridSearchCV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_HalvingGridSearchCV_set_fit_request = {k: v for k, v in pms_HalvingGridSearchCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_set_fit_request = bridgeHalvingGridSearchCV[${this.id}].set_fit_request(**pms_HalvingGridSearchCV_set_fit_request)`;
    return this._py`res_HalvingGridSearchCV_set_fit_request.tolist() if hasattr(res_HalvingGridSearchCV_set_fit_request, 'tolist') else res_HalvingGridSearchCV_set_fit_request`;
  }
  /**
      Call transform on the estimator with the best found parameters.
  
      Only available if the underlying estimator supports `transform` and `refit=True`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingGridSearchCV must call init() before transform()");
    }
    await this._py.ex`pms_HalvingGridSearchCV_transform = {'X': ${opts["X"] ?? void 0}}

pms_HalvingGridSearchCV_transform = {k: v for k, v in pms_HalvingGridSearchCV_transform.items() if v is not None}`;
    await this._py.ex`res_HalvingGridSearchCV_transform = bridgeHalvingGridSearchCV[${this.id}].transform(**pms_HalvingGridSearchCV_transform)`;
    return this._py`res_HalvingGridSearchCV_transform.tolist() if hasattr(res_HalvingGridSearchCV_transform, 'tolist') else res_HalvingGridSearchCV_transform`;
  }
  /**
    The amount of resources used at each iteration.
   */
  get n_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_resources_ = bridgeHalvingGridSearchCV[${this.id}].n_resources_`;
      return this._py`attr_HalvingGridSearchCV_n_resources_.tolist() if hasattr(attr_HalvingGridSearchCV_n_resources_, 'tolist') else attr_HalvingGridSearchCV_n_resources_`;
    })();
  }
  /**
    The number of candidate parameters that were evaluated at each iteration.
   */
  get n_candidates_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_candidates_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_candidates_ = bridgeHalvingGridSearchCV[${this.id}].n_candidates_`;
      return this._py`attr_HalvingGridSearchCV_n_candidates_.tolist() if hasattr(attr_HalvingGridSearchCV_n_candidates_, 'tolist') else attr_HalvingGridSearchCV_n_candidates_`;
    })();
  }
  /**
    The number of candidate parameters that are left after the last iteration. It corresponds to `ceil(n\_candidates\[-1\] / factor)`
   */
  get n_remaining_candidates_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_remaining_candidates_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_remaining_candidates_ = bridgeHalvingGridSearchCV[${this.id}].n_remaining_candidates_`;
      return this._py`attr_HalvingGridSearchCV_n_remaining_candidates_.tolist() if hasattr(attr_HalvingGridSearchCV_n_remaining_candidates_, 'tolist') else attr_HalvingGridSearchCV_n_remaining_candidates_`;
    })();
  }
  /**
    The maximum number of resources that any candidate is allowed to use for a given iteration. Note that since the number of resources used at each iteration must be a multiple of `min\_resources\_`, the actual number of resources used at the last iteration may be smaller than `max\_resources\_`.
   */
  get max_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing max_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_max_resources_ = bridgeHalvingGridSearchCV[${this.id}].max_resources_`;
      return this._py`attr_HalvingGridSearchCV_max_resources_.tolist() if hasattr(attr_HalvingGridSearchCV_max_resources_, 'tolist') else attr_HalvingGridSearchCV_max_resources_`;
    })();
  }
  /**
    The amount of resources that are allocated for each candidate at the first iteration.
   */
  get min_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing min_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_min_resources_ = bridgeHalvingGridSearchCV[${this.id}].min_resources_`;
      return this._py`attr_HalvingGridSearchCV_min_resources_.tolist() if hasattr(attr_HalvingGridSearchCV_min_resources_, 'tolist') else attr_HalvingGridSearchCV_min_resources_`;
    })();
  }
  /**
    The actual number of iterations that were run. This is equal to `n\_required\_iterations\_` if `aggressive\_elimination` is `true`. Else, this is equal to `min(n\_possible\_iterations\_, n\_required\_iterations\_)`.
   */
  get n_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_iterations_ = bridgeHalvingGridSearchCV[${this.id}].n_iterations_`;
      return this._py`attr_HalvingGridSearchCV_n_iterations_.tolist() if hasattr(attr_HalvingGridSearchCV_n_iterations_, 'tolist') else attr_HalvingGridSearchCV_n_iterations_`;
    })();
  }
  /**
    The number of iterations that are possible starting with `min\_resources\_` resources and without exceeding `max\_resources\_`.
   */
  get n_possible_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_possible_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_possible_iterations_ = bridgeHalvingGridSearchCV[${this.id}].n_possible_iterations_`;
      return this._py`attr_HalvingGridSearchCV_n_possible_iterations_.tolist() if hasattr(attr_HalvingGridSearchCV_n_possible_iterations_, 'tolist') else attr_HalvingGridSearchCV_n_possible_iterations_`;
    })();
  }
  /**
    The number of iterations that are required to end up with less than `factor` candidates at the last iteration, starting with `min\_resources\_` resources. This will be smaller than `n\_possible\_iterations\_` when there isnâ€™t enough resources.
   */
  get n_required_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_required_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_required_iterations_ = bridgeHalvingGridSearchCV[${this.id}].n_required_iterations_`;
      return this._py`attr_HalvingGridSearchCV_n_required_iterations_.tolist() if hasattr(attr_HalvingGridSearchCV_n_required_iterations_, 'tolist') else attr_HalvingGridSearchCV_n_required_iterations_`;
    })();
  }
  /**
    A dict with keys as column headers and values as columns, that can be imported into a pandas `DataFrame`. It contains lots of information for analysing the results of a search. Please refer to the [User guide](../grid_search.html#successive-halving-cv-results) for details.
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_cv_results_ = bridgeHalvingGridSearchCV[${this.id}].cv_results_`;
      return this._py`attr_HalvingGridSearchCV_cv_results_.tolist() if hasattr(attr_HalvingGridSearchCV_cv_results_, 'tolist') else attr_HalvingGridSearchCV_cv_results_`;
    })();
  }
  /**
    Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if `refit=False`.
   */
  get best_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing best_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_best_estimator_ = bridgeHalvingGridSearchCV[${this.id}].best_estimator_`;
      return this._py`attr_HalvingGridSearchCV_best_estimator_.tolist() if hasattr(attr_HalvingGridSearchCV_best_estimator_, 'tolist') else attr_HalvingGridSearchCV_best_estimator_`;
    })();
  }
  /**
    Mean cross-validated score of the best\_estimator.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_best_score_ = bridgeHalvingGridSearchCV[${this.id}].best_score_`;
      return this._py`attr_HalvingGridSearchCV_best_score_.tolist() if hasattr(attr_HalvingGridSearchCV_best_score_, 'tolist') else attr_HalvingGridSearchCV_best_score_`;
    })();
  }
  /**
    Parameter setting that gave the best results on the hold out data.
   */
  get best_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing best_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_best_params_ = bridgeHalvingGridSearchCV[${this.id}].best_params_`;
      return this._py`attr_HalvingGridSearchCV_best_params_.tolist() if hasattr(attr_HalvingGridSearchCV_best_params_, 'tolist') else attr_HalvingGridSearchCV_best_params_`;
    })();
  }
  /**
      The index (of the `cv\_results\_` arrays) which corresponds to the best candidate parameter setting.
  
      The dict at `search.cv\_results\_\['params'\]\[search.best\_index\_\]` gives the parameter setting for the best model, that gives the highest mean score (`search.best\_score\_`).
     */
  get best_index_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing best_index_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_best_index_ = bridgeHalvingGridSearchCV[${this.id}].best_index_`;
      return this._py`attr_HalvingGridSearchCV_best_index_.tolist() if hasattr(attr_HalvingGridSearchCV_best_index_, 'tolist') else attr_HalvingGridSearchCV_best_index_`;
    })();
  }
  /**
    Scorer function used on the held out data to choose the best parameters for the model.
   */
  get scorer_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing scorer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_scorer_ = bridgeHalvingGridSearchCV[${this.id}].scorer_`;
      return this._py`attr_HalvingGridSearchCV_scorer_.tolist() if hasattr(attr_HalvingGridSearchCV_scorer_, 'tolist') else attr_HalvingGridSearchCV_scorer_`;
    })();
  }
  /**
    The number of cross-validation splits (folds/iterations).
   */
  get n_splits_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing n_splits_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_n_splits_ = bridgeHalvingGridSearchCV[${this.id}].n_splits_`;
      return this._py`attr_HalvingGridSearchCV_n_splits_.tolist() if hasattr(attr_HalvingGridSearchCV_n_splits_, 'tolist') else attr_HalvingGridSearchCV_n_splits_`;
    })();
  }
  /**
      Seconds used for refitting the best model on the whole dataset.
  
      This is present only if `refit` is not `false`.
     */
  get refit_time_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing refit_time_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_refit_time_ = bridgeHalvingGridSearchCV[${this.id}].refit_time_`;
      return this._py`attr_HalvingGridSearchCV_refit_time_.tolist() if hasattr(attr_HalvingGridSearchCV_refit_time_, 'tolist') else attr_HalvingGridSearchCV_refit_time_`;
    })();
  }
  /**
    Whether or not the scorers compute several metrics.
   */
  get multimetric_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing multimetric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_multimetric_ = bridgeHalvingGridSearchCV[${this.id}].multimetric_`;
      return this._py`attr_HalvingGridSearchCV_multimetric_.tolist() if hasattr(attr_HalvingGridSearchCV_multimetric_, 'tolist') else attr_HalvingGridSearchCV_multimetric_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if `best\_estimator\_` is defined (see the documentation for the `refit` parameter for more details) and that `best\_estimator\_` exposes `feature\_names\_in\_` when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingGridSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingGridSearchCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingGridSearchCV_feature_names_in_ = bridgeHalvingGridSearchCV[${this.id}].feature_names_in_`;
      return this._py`attr_HalvingGridSearchCV_feature_names_in_.tolist() if hasattr(attr_HalvingGridSearchCV_feature_names_in_, 'tolist') else attr_HalvingGridSearchCV_feature_names_in_`;
    })();
  }
};

// src/generated/model_selection/HalvingRandomSearchCV.ts
import crypto176 from "node:crypto";
var HalvingRandomSearchCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HalvingRandomSearchCV${crypto176.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HalvingRandomSearchCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import HalvingRandomSearchCV
try: bridgeHalvingRandomSearchCV
except NameError: bridgeHalvingRandomSearchCV = {}
`;
    await this._py.ex`ctor_HalvingRandomSearchCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'param_distributions': ${this.opts["param_distributions"] ?? void 0}, 'n_candidates': ${this.opts["n_candidates"] ?? void 0}, 'factor': ${this.opts["factor"] ?? void 0}, 'resource': ${this.opts["resource"] ?? void 0}, 'max_resources': ${this.opts["max_resources"] ?? void 0}, 'min_resources': ${this.opts["min_resources"] ?? void 0}, 'aggressive_elimination': ${this.opts["aggressive_elimination"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'error_score': ${this.opts["error_score"] ?? void 0}, 'return_train_score': ${this.opts["return_train_score"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_HalvingRandomSearchCV = {k: v for k, v in ctor_HalvingRandomSearchCV.items() if v is not None}`;
    await this._py.ex`bridgeHalvingRandomSearchCV[${this.id}] = HalvingRandomSearchCV(**ctor_HalvingRandomSearchCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHalvingRandomSearchCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Call decision\_function on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `decision\_function`.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_decision_function = {k: v for k, v in pms_HalvingRandomSearchCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_decision_function = bridgeHalvingRandomSearchCV[${this.id}].decision_function(**pms_HalvingRandomSearchCV_decision_function)`;
    return this._py`res_HalvingRandomSearchCV_decision_function.tolist() if hasattr(res_HalvingRandomSearchCV_decision_function, 'tolist') else res_HalvingRandomSearchCV_decision_function`;
  }
  /**
    Run fit with all sets of parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingRandomSearchCV must call init() before fit()");
    }
    await this._py.ex`pms_HalvingRandomSearchCV_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_HalvingRandomSearchCV_fit = {k: v for k, v in pms_HalvingRandomSearchCV_fit.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_fit = bridgeHalvingRandomSearchCV[${this.id}].fit(**pms_HalvingRandomSearchCV_fit)`;
    return this._py`res_HalvingRandomSearchCV_fit.tolist() if hasattr(res_HalvingRandomSearchCV_fit, 'tolist') else res_HalvingRandomSearchCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HalvingRandomSearchCV_get_metadata_routing = {k: v for k, v in pms_HalvingRandomSearchCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_get_metadata_routing = bridgeHalvingRandomSearchCV[${this.id}].get_metadata_routing(**pms_HalvingRandomSearchCV_get_metadata_routing)`;
    return this._py`res_HalvingRandomSearchCV_get_metadata_routing.tolist() if hasattr(res_HalvingRandomSearchCV_get_metadata_routing, 'tolist') else res_HalvingRandomSearchCV_get_metadata_routing`;
  }
  /**
      Call inverse\_transform on the estimator with the best found params.
  
      Only available if the underlying estimator implements `inverse\_transform` and `refit=True`.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_inverse_transform = {'Xt': ${opts["Xt"] ?? void 0}}

pms_HalvingRandomSearchCV_inverse_transform = {k: v for k, v in pms_HalvingRandomSearchCV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_inverse_transform = bridgeHalvingRandomSearchCV[${this.id}].inverse_transform(**pms_HalvingRandomSearchCV_inverse_transform)`;
    return this._py`res_HalvingRandomSearchCV_inverse_transform.tolist() if hasattr(res_HalvingRandomSearchCV_inverse_transform, 'tolist') else res_HalvingRandomSearchCV_inverse_transform`;
  }
  /**
      Call predict on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingRandomSearchCV must call init() before predict()");
    }
    await this._py.ex`pms_HalvingRandomSearchCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_predict = {k: v for k, v in pms_HalvingRandomSearchCV_predict.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_predict = bridgeHalvingRandomSearchCV[${this.id}].predict(**pms_HalvingRandomSearchCV_predict)`;
    return this._py`res_HalvingRandomSearchCV_predict.tolist() if hasattr(res_HalvingRandomSearchCV_predict, 'tolist') else res_HalvingRandomSearchCV_predict`;
  }
  /**
      Call predict\_log\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_log\_proba`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_predict_log_proba = {k: v for k, v in pms_HalvingRandomSearchCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_predict_log_proba = bridgeHalvingRandomSearchCV[${this.id}].predict_log_proba(**pms_HalvingRandomSearchCV_predict_log_proba)`;
    return this._py`res_HalvingRandomSearchCV_predict_log_proba.tolist() if hasattr(res_HalvingRandomSearchCV_predict_log_proba, 'tolist') else res_HalvingRandomSearchCV_predict_log_proba`;
  }
  /**
      Call predict\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_predict_proba = {k: v for k, v in pms_HalvingRandomSearchCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_predict_proba = bridgeHalvingRandomSearchCV[${this.id}].predict_proba(**pms_HalvingRandomSearchCV_predict_proba)`;
    return this._py`res_HalvingRandomSearchCV_predict_proba.tolist() if hasattr(res_HalvingRandomSearchCV_predict_proba, 'tolist') else res_HalvingRandomSearchCV_predict_proba`;
  }
  /**
      Return the score on the given data, if the estimator has been refit.
  
      This uses the score defined by `scoring` where provided, and the `best\_estimator\_.score` method otherwise.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("HalvingRandomSearchCV must call init() before score()");
    }
    await this._py.ex`pms_HalvingRandomSearchCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_HalvingRandomSearchCV_score = {k: v for k, v in pms_HalvingRandomSearchCV_score.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_score = bridgeHalvingRandomSearchCV[${this.id}].score(**pms_HalvingRandomSearchCV_score)`;
    return this._py`res_HalvingRandomSearchCV_score.tolist() if hasattr(res_HalvingRandomSearchCV_score, 'tolist') else res_HalvingRandomSearchCV_score`;
  }
  /**
      Call score\_samples on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `score\_samples`.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_score_samples = {k: v for k, v in pms_HalvingRandomSearchCV_score_samples.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_score_samples = bridgeHalvingRandomSearchCV[${this.id}].score_samples(**pms_HalvingRandomSearchCV_score_samples)`;
    return this._py`res_HalvingRandomSearchCV_score_samples.tolist() if hasattr(res_HalvingRandomSearchCV_score_samples, 'tolist') else res_HalvingRandomSearchCV_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_HalvingRandomSearchCV_set_fit_request = {k: v for k, v in pms_HalvingRandomSearchCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_set_fit_request = bridgeHalvingRandomSearchCV[${this.id}].set_fit_request(**pms_HalvingRandomSearchCV_set_fit_request)`;
    return this._py`res_HalvingRandomSearchCV_set_fit_request.tolist() if hasattr(res_HalvingRandomSearchCV_set_fit_request, 'tolist') else res_HalvingRandomSearchCV_set_fit_request`;
  }
  /**
      Call transform on the estimator with the best found parameters.
  
      Only available if the underlying estimator supports `transform` and `refit=True`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before transform()"
      );
    }
    await this._py.ex`pms_HalvingRandomSearchCV_transform = {'X': ${opts["X"] ?? void 0}}

pms_HalvingRandomSearchCV_transform = {k: v for k, v in pms_HalvingRandomSearchCV_transform.items() if v is not None}`;
    await this._py.ex`res_HalvingRandomSearchCV_transform = bridgeHalvingRandomSearchCV[${this.id}].transform(**pms_HalvingRandomSearchCV_transform)`;
    return this._py`res_HalvingRandomSearchCV_transform.tolist() if hasattr(res_HalvingRandomSearchCV_transform, 'tolist') else res_HalvingRandomSearchCV_transform`;
  }
  /**
    The amount of resources used at each iteration.
   */
  get n_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_resources_ = bridgeHalvingRandomSearchCV[${this.id}].n_resources_`;
      return this._py`attr_HalvingRandomSearchCV_n_resources_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_resources_, 'tolist') else attr_HalvingRandomSearchCV_n_resources_`;
    })();
  }
  /**
    The number of candidate parameters that were evaluated at each iteration.
   */
  get n_candidates_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_candidates_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_candidates_ = bridgeHalvingRandomSearchCV[${this.id}].n_candidates_`;
      return this._py`attr_HalvingRandomSearchCV_n_candidates_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_candidates_, 'tolist') else attr_HalvingRandomSearchCV_n_candidates_`;
    })();
  }
  /**
    The number of candidate parameters that are left after the last iteration. It corresponds to `ceil(n\_candidates\[-1\] / factor)`
   */
  get n_remaining_candidates_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_remaining_candidates_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_remaining_candidates_ = bridgeHalvingRandomSearchCV[${this.id}].n_remaining_candidates_`;
      return this._py`attr_HalvingRandomSearchCV_n_remaining_candidates_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_remaining_candidates_, 'tolist') else attr_HalvingRandomSearchCV_n_remaining_candidates_`;
    })();
  }
  /**
    The maximum number of resources that any candidate is allowed to use for a given iteration. Note that since the number of resources used at each iteration must be a multiple of `min\_resources\_`, the actual number of resources used at the last iteration may be smaller than `max\_resources\_`.
   */
  get max_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing max_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_max_resources_ = bridgeHalvingRandomSearchCV[${this.id}].max_resources_`;
      return this._py`attr_HalvingRandomSearchCV_max_resources_.tolist() if hasattr(attr_HalvingRandomSearchCV_max_resources_, 'tolist') else attr_HalvingRandomSearchCV_max_resources_`;
    })();
  }
  /**
    The amount of resources that are allocated for each candidate at the first iteration.
   */
  get min_resources_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing min_resources_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_min_resources_ = bridgeHalvingRandomSearchCV[${this.id}].min_resources_`;
      return this._py`attr_HalvingRandomSearchCV_min_resources_.tolist() if hasattr(attr_HalvingRandomSearchCV_min_resources_, 'tolist') else attr_HalvingRandomSearchCV_min_resources_`;
    })();
  }
  /**
    The actual number of iterations that were run. This is equal to `n\_required\_iterations\_` if `aggressive\_elimination` is `true`. Else, this is equal to `min(n\_possible\_iterations\_, n\_required\_iterations\_)`.
   */
  get n_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_iterations_ = bridgeHalvingRandomSearchCV[${this.id}].n_iterations_`;
      return this._py`attr_HalvingRandomSearchCV_n_iterations_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_iterations_, 'tolist') else attr_HalvingRandomSearchCV_n_iterations_`;
    })();
  }
  /**
    The number of iterations that are possible starting with `min\_resources\_` resources and without exceeding `max\_resources\_`.
   */
  get n_possible_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_possible_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_possible_iterations_ = bridgeHalvingRandomSearchCV[${this.id}].n_possible_iterations_`;
      return this._py`attr_HalvingRandomSearchCV_n_possible_iterations_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_possible_iterations_, 'tolist') else attr_HalvingRandomSearchCV_n_possible_iterations_`;
    })();
  }
  /**
    The number of iterations that are required to end up with less than `factor` candidates at the last iteration, starting with `min\_resources\_` resources. This will be smaller than `n\_possible\_iterations\_` when there isnâ€™t enough resources.
   */
  get n_required_iterations_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_required_iterations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_required_iterations_ = bridgeHalvingRandomSearchCV[${this.id}].n_required_iterations_`;
      return this._py`attr_HalvingRandomSearchCV_n_required_iterations_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_required_iterations_, 'tolist') else attr_HalvingRandomSearchCV_n_required_iterations_`;
    })();
  }
  /**
    A dict with keys as column headers and values as columns, that can be imported into a pandas `DataFrame`. It contains lots of information for analysing the results of a search. Please refer to the [User guide](../grid_search.html#successive-halving-cv-results) for details.
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_cv_results_ = bridgeHalvingRandomSearchCV[${this.id}].cv_results_`;
      return this._py`attr_HalvingRandomSearchCV_cv_results_.tolist() if hasattr(attr_HalvingRandomSearchCV_cv_results_, 'tolist') else attr_HalvingRandomSearchCV_cv_results_`;
    })();
  }
  /**
    Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if `refit=False`.
   */
  get best_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing best_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_best_estimator_ = bridgeHalvingRandomSearchCV[${this.id}].best_estimator_`;
      return this._py`attr_HalvingRandomSearchCV_best_estimator_.tolist() if hasattr(attr_HalvingRandomSearchCV_best_estimator_, 'tolist') else attr_HalvingRandomSearchCV_best_estimator_`;
    })();
  }
  /**
    Mean cross-validated score of the best\_estimator.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_best_score_ = bridgeHalvingRandomSearchCV[${this.id}].best_score_`;
      return this._py`attr_HalvingRandomSearchCV_best_score_.tolist() if hasattr(attr_HalvingRandomSearchCV_best_score_, 'tolist') else attr_HalvingRandomSearchCV_best_score_`;
    })();
  }
  /**
    Parameter setting that gave the best results on the hold out data.
   */
  get best_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing best_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_best_params_ = bridgeHalvingRandomSearchCV[${this.id}].best_params_`;
      return this._py`attr_HalvingRandomSearchCV_best_params_.tolist() if hasattr(attr_HalvingRandomSearchCV_best_params_, 'tolist') else attr_HalvingRandomSearchCV_best_params_`;
    })();
  }
  /**
      The index (of the `cv\_results\_` arrays) which corresponds to the best candidate parameter setting.
  
      The dict at `search.cv\_results\_\['params'\]\[search.best\_index\_\]` gives the parameter setting for the best model, that gives the highest mean score (`search.best\_score\_`).
     */
  get best_index_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing best_index_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_best_index_ = bridgeHalvingRandomSearchCV[${this.id}].best_index_`;
      return this._py`attr_HalvingRandomSearchCV_best_index_.tolist() if hasattr(attr_HalvingRandomSearchCV_best_index_, 'tolist') else attr_HalvingRandomSearchCV_best_index_`;
    })();
  }
  /**
    Scorer function used on the held out data to choose the best parameters for the model.
   */
  get scorer_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing scorer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_scorer_ = bridgeHalvingRandomSearchCV[${this.id}].scorer_`;
      return this._py`attr_HalvingRandomSearchCV_scorer_.tolist() if hasattr(attr_HalvingRandomSearchCV_scorer_, 'tolist') else attr_HalvingRandomSearchCV_scorer_`;
    })();
  }
  /**
    The number of cross-validation splits (folds/iterations).
   */
  get n_splits_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing n_splits_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_n_splits_ = bridgeHalvingRandomSearchCV[${this.id}].n_splits_`;
      return this._py`attr_HalvingRandomSearchCV_n_splits_.tolist() if hasattr(attr_HalvingRandomSearchCV_n_splits_, 'tolist') else attr_HalvingRandomSearchCV_n_splits_`;
    })();
  }
  /**
      Seconds used for refitting the best model on the whole dataset.
  
      This is present only if `refit` is not `false`.
     */
  get refit_time_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing refit_time_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_refit_time_ = bridgeHalvingRandomSearchCV[${this.id}].refit_time_`;
      return this._py`attr_HalvingRandomSearchCV_refit_time_.tolist() if hasattr(attr_HalvingRandomSearchCV_refit_time_, 'tolist') else attr_HalvingRandomSearchCV_refit_time_`;
    })();
  }
  /**
    Whether or not the scorers compute several metrics.
   */
  get multimetric_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing multimetric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_multimetric_ = bridgeHalvingRandomSearchCV[${this.id}].multimetric_`;
      return this._py`attr_HalvingRandomSearchCV_multimetric_.tolist() if hasattr(attr_HalvingRandomSearchCV_multimetric_, 'tolist') else attr_HalvingRandomSearchCV_multimetric_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if `best\_estimator\_` is defined (see the documentation for the `refit` parameter for more details) and that `best\_estimator\_` exposes `feature\_names\_in\_` when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HalvingRandomSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HalvingRandomSearchCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HalvingRandomSearchCV_feature_names_in_ = bridgeHalvingRandomSearchCV[${this.id}].feature_names_in_`;
      return this._py`attr_HalvingRandomSearchCV_feature_names_in_.tolist() if hasattr(attr_HalvingRandomSearchCV_feature_names_in_, 'tolist') else attr_HalvingRandomSearchCV_feature_names_in_`;
    })();
  }
};

// src/generated/model_selection/KFold.ts
import crypto177 from "node:crypto";
var KFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KFold${crypto177.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KFold instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KFold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import KFold
try: bridgeKFold
except NameError: bridgeKFold = {}
`;
    await this._py.ex`ctor_KFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_KFold = {k: v for k, v in ctor_KFold.items() if v is not None}`;
    await this._py.ex`bridgeKFold[${this.id}] = KFold(**ctor_KFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KFold must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_KFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KFold_get_metadata_routing = {k: v for k, v in pms_KFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KFold_get_metadata_routing = bridgeKFold[${this.id}].get_metadata_routing(**pms_KFold_get_metadata_routing)`;
    return this._py`res_KFold_get_metadata_routing.tolist() if hasattr(res_KFold_get_metadata_routing, 'tolist') else res_KFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This KFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KFold must call init() before get_n_splits()");
    }
    await this._py.ex`pms_KFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_KFold_get_n_splits = {k: v for k, v in pms_KFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_KFold_get_n_splits = bridgeKFold[${this.id}].get_n_splits(**pms_KFold_get_n_splits)`;
    return this._py`res_KFold_get_n_splits.tolist() if hasattr(res_KFold_get_n_splits, 'tolist') else res_KFold_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This KFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KFold must call init() before split()");
    }
    await this._py.ex`pms_KFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_KFold_split = {k: v for k, v in pms_KFold_split.items() if v is not None}`;
    await this._py.ex`res_KFold_split = bridgeKFold[${this.id}].split(**pms_KFold_split)`;
    return this._py`res_KFold_split.tolist() if hasattr(res_KFold_split, 'tolist') else res_KFold_split`;
  }
};

// src/generated/model_selection/LearningCurveDisplay.ts
import crypto178 from "node:crypto";
var LearningCurveDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LearningCurveDisplay${crypto178.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LearningCurveDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import LearningCurveDisplay
try: bridgeLearningCurveDisplay
except NameError: bridgeLearningCurveDisplay = {}
`;
    await this._py.ex`ctor_LearningCurveDisplay = {'train_sizes': np.array(${this.opts["train_sizes"] ?? void 0}) if ${this.opts["train_sizes"] !== void 0} else None, 'train_scores': np.array(${this.opts["train_scores"] ?? void 0}) if ${this.opts["train_scores"] !== void 0} else None, 'test_scores': np.array(${this.opts["test_scores"] ?? void 0}) if ${this.opts["test_scores"] !== void 0} else None, 'score_name': ${this.opts["score_name"] ?? void 0}}

ctor_LearningCurveDisplay = {k: v for k, v in ctor_LearningCurveDisplay.items() if v is not None}`;
    await this._py.ex`bridgeLearningCurveDisplay[${this.id}] = LearningCurveDisplay(**ctor_LearningCurveDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLearningCurveDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Create a learning curve display from an estimator.
  
      Read more in the [User Guide](../../visualizations.html#visualizations) for general information about the visualization API and [detailed documentation](../learning_curve.html#learning-curve) regarding the learning curve visualization.
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_LearningCurveDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'train_sizes': np.array(${opts["train_sizes"] ?? void 0}) if ${opts["train_sizes"] !== void 0} else None, 'cv': ${opts["cv"] ?? void 0}, 'scoring': ${opts["scoring"] ?? void 0}, 'exploit_incremental_learning': ${opts["exploit_incremental_learning"] ?? void 0}, 'n_jobs': ${opts["n_jobs"] ?? void 0}, 'pre_dispatch': ${opts["pre_dispatch"] ?? void 0}, 'verbose': ${opts["verbose"] ?? void 0}, 'shuffle': ${opts["shuffle"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}, 'error_score': ${opts["error_score"] ?? void 0}, 'fit_params': ${opts["fit_params"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'negate_score': ${opts["negate_score"] ?? void 0}, 'score_name': ${opts["score_name"] ?? void 0}, 'score_type': ${opts["score_type"] ?? void 0}, 'log_scale': ${opts["log_scale"] ?? void 0}, 'std_display_style': ${opts["std_display_style"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'fill_between_kw': ${opts["fill_between_kw"] ?? void 0}, 'errorbar_kw': ${opts["errorbar_kw"] ?? void 0}}

pms_LearningCurveDisplay_from_estimator = {k: v for k, v in pms_LearningCurveDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_LearningCurveDisplay_from_estimator = bridgeLearningCurveDisplay[${this.id}].from_estimator(**pms_LearningCurveDisplay_from_estimator)`;
    return this._py`res_LearningCurveDisplay_from_estimator.tolist() if hasattr(res_LearningCurveDisplay_from_estimator, 'tolist') else res_LearningCurveDisplay_from_estimator`;
  }
  /**
    Plot visualization.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LearningCurveDisplay must call init() before plot()");
    }
    await this._py.ex`pms_LearningCurveDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'negate_score': ${opts["negate_score"] ?? void 0}, 'score_name': ${opts["score_name"] ?? void 0}, 'score_type': ${opts["score_type"] ?? void 0}, 'log_scale': ${opts["log_scale"] ?? void 0}, 'std_display_style': ${opts["std_display_style"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'fill_between_kw': ${opts["fill_between_kw"] ?? void 0}, 'errorbar_kw': ${opts["errorbar_kw"] ?? void 0}}

pms_LearningCurveDisplay_plot = {k: v for k, v in pms_LearningCurveDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_LearningCurveDisplay_plot = bridgeLearningCurveDisplay[${this.id}].plot(**pms_LearningCurveDisplay_plot)`;
    return this._py`res_LearningCurveDisplay_plot.tolist() if hasattr(res_LearningCurveDisplay_plot, 'tolist') else res_LearningCurveDisplay_plot`;
  }
  /**
    Axes with the learning curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LearningCurveDisplay_ax_ = bridgeLearningCurveDisplay[${this.id}].ax_`;
      return this._py`attr_LearningCurveDisplay_ax_.tolist() if hasattr(attr_LearningCurveDisplay_ax_, 'tolist') else attr_LearningCurveDisplay_ax_`;
    })();
  }
  /**
    Figure containing the learning curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LearningCurveDisplay_figure_ = bridgeLearningCurveDisplay[${this.id}].figure_`;
      return this._py`attr_LearningCurveDisplay_figure_.tolist() if hasattr(attr_LearningCurveDisplay_figure_, 'tolist') else attr_LearningCurveDisplay_figure_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"errorbar"`, this is a list of `matplotlib.container.ErrorbarContainer` objects. If another style is used, `errorbar\_` is `undefined`.
   */
  get errorbar_() {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before accessing errorbar_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LearningCurveDisplay_errorbar_ = bridgeLearningCurveDisplay[${this.id}].errorbar_`;
      return this._py`attr_LearningCurveDisplay_errorbar_.tolist() if hasattr(attr_LearningCurveDisplay_errorbar_, 'tolist') else attr_LearningCurveDisplay_errorbar_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"fill\_between"`, this is a list of `matplotlib.lines.Line2D` objects corresponding to the mean train and test scores. If another style is used, `line\_` is `undefined`.
   */
  get lines_() {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before accessing lines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LearningCurveDisplay_lines_ = bridgeLearningCurveDisplay[${this.id}].lines_`;
      return this._py`attr_LearningCurveDisplay_lines_.tolist() if hasattr(attr_LearningCurveDisplay_lines_, 'tolist') else attr_LearningCurveDisplay_lines_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"fill\_between"`, this is a list of `matplotlib.collections.PolyCollection` objects. If another style is used, `fill\_between\_` is `undefined`.
   */
  get fill_between_() {
    if (this._isDisposed) {
      throw new Error(
        "This LearningCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LearningCurveDisplay must call init() before accessing fill_between_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LearningCurveDisplay_fill_between_ = bridgeLearningCurveDisplay[${this.id}].fill_between_`;
      return this._py`attr_LearningCurveDisplay_fill_between_.tolist() if hasattr(attr_LearningCurveDisplay_fill_between_, 'tolist') else attr_LearningCurveDisplay_fill_between_`;
    })();
  }
};

// src/generated/model_selection/LeaveOneGroupOut.ts
import crypto179 from "node:crypto";
var LeaveOneGroupOut = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LeaveOneGroupOut${crypto179.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LeaveOneGroupOut instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LeaveOneGroupOut.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import LeaveOneGroupOut
try: bridgeLeaveOneGroupOut
except NameError: bridgeLeaveOneGroupOut = {}
`;
    await this._py.ex`ctor_LeaveOneGroupOut = {'routing': ${this.opts["routing"] ?? void 0}}

ctor_LeaveOneGroupOut = {k: v for k, v in ctor_LeaveOneGroupOut.items() if v is not None}`;
    await this._py.ex`bridgeLeaveOneGroupOut[${this.id}] = LeaveOneGroupOut(**ctor_LeaveOneGroupOut)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLeaveOneGroupOut[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LeaveOneGroupOut instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeaveOneGroupOut must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LeaveOneGroupOut_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LeaveOneGroupOut_get_metadata_routing = {k: v for k, v in pms_LeaveOneGroupOut_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LeaveOneGroupOut_get_metadata_routing = bridgeLeaveOneGroupOut[${this.id}].get_metadata_routing(**pms_LeaveOneGroupOut_get_metadata_routing)`;
    return this._py`res_LeaveOneGroupOut_get_metadata_routing.tolist() if hasattr(res_LeaveOneGroupOut_get_metadata_routing, 'tolist') else res_LeaveOneGroupOut_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LeaveOneGroupOut instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LeaveOneGroupOut must call init() before get_n_splits()");
    }
    await this._py.ex`pms_LeaveOneGroupOut_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeaveOneGroupOut_get_n_splits = {k: v for k, v in pms_LeaveOneGroupOut_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_LeaveOneGroupOut_get_n_splits = bridgeLeaveOneGroupOut[${this.id}].get_n_splits(**pms_LeaveOneGroupOut_get_n_splits)`;
    return this._py`res_LeaveOneGroupOut_get_n_splits.tolist() if hasattr(res_LeaveOneGroupOut_get_n_splits, 'tolist') else res_LeaveOneGroupOut_get_n_splits`;
  }
  /**
      Request metadata passed to the `split` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_split_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LeaveOneGroupOut instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeaveOneGroupOut must call init() before set_split_request()"
      );
    }
    await this._py.ex`pms_LeaveOneGroupOut_set_split_request = {'groups': ${opts["groups"] ?? void 0}}

pms_LeaveOneGroupOut_set_split_request = {k: v for k, v in pms_LeaveOneGroupOut_set_split_request.items() if v is not None}`;
    await this._py.ex`res_LeaveOneGroupOut_set_split_request = bridgeLeaveOneGroupOut[${this.id}].set_split_request(**pms_LeaveOneGroupOut_set_split_request)`;
    return this._py`res_LeaveOneGroupOut_set_split_request.tolist() if hasattr(res_LeaveOneGroupOut_set_split_request, 'tolist') else res_LeaveOneGroupOut_set_split_request`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LeaveOneGroupOut instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LeaveOneGroupOut must call init() before split()");
    }
    await this._py.ex`pms_LeaveOneGroupOut_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeaveOneGroupOut_split = {k: v for k, v in pms_LeaveOneGroupOut_split.items() if v is not None}`;
    await this._py.ex`res_LeaveOneGroupOut_split = bridgeLeaveOneGroupOut[${this.id}].split(**pms_LeaveOneGroupOut_split)`;
    return this._py`res_LeaveOneGroupOut_split.tolist() if hasattr(res_LeaveOneGroupOut_split, 'tolist') else res_LeaveOneGroupOut_split`;
  }
};

// src/generated/model_selection/LeaveOneOut.ts
import crypto180 from "node:crypto";
var LeaveOneOut = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LeaveOneOut${crypto180.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LeaveOneOut instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LeaveOneOut.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import LeaveOneOut
try: bridgeLeaveOneOut
except NameError: bridgeLeaveOneOut = {}
`;
    await this._py.ex`ctor_LeaveOneOut = {'routing': ${this.opts["routing"] ?? void 0}}

ctor_LeaveOneOut = {k: v for k, v in ctor_LeaveOneOut.items() if v is not None}`;
    await this._py.ex`bridgeLeaveOneOut[${this.id}] = LeaveOneOut(**ctor_LeaveOneOut)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLeaveOneOut[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LeaveOneOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeaveOneOut must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LeaveOneOut_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LeaveOneOut_get_metadata_routing = {k: v for k, v in pms_LeaveOneOut_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LeaveOneOut_get_metadata_routing = bridgeLeaveOneOut[${this.id}].get_metadata_routing(**pms_LeaveOneOut_get_metadata_routing)`;
    return this._py`res_LeaveOneOut_get_metadata_routing.tolist() if hasattr(res_LeaveOneOut_get_metadata_routing, 'tolist') else res_LeaveOneOut_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This LeaveOneOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeaveOneOut must call init() before get_n_splits()");
    }
    await this._py.ex`pms_LeaveOneOut_get_n_splits = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_LeaveOneOut_get_n_splits = {k: v for k, v in pms_LeaveOneOut_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_LeaveOneOut_get_n_splits = bridgeLeaveOneOut[${this.id}].get_n_splits(**pms_LeaveOneOut_get_n_splits)`;
    return this._py`res_LeaveOneOut_get_n_splits.tolist() if hasattr(res_LeaveOneOut_get_n_splits, 'tolist') else res_LeaveOneOut_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This LeaveOneOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeaveOneOut must call init() before split()");
    }
    await this._py.ex`pms_LeaveOneOut_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeaveOneOut_split = {k: v for k, v in pms_LeaveOneOut_split.items() if v is not None}`;
    await this._py.ex`res_LeaveOneOut_split = bridgeLeaveOneOut[${this.id}].split(**pms_LeaveOneOut_split)`;
    return this._py`res_LeaveOneOut_split.tolist() if hasattr(res_LeaveOneOut_split, 'tolist') else res_LeaveOneOut_split`;
  }
};

// src/generated/model_selection/LeavePGroupsOut.ts
import crypto181 from "node:crypto";
var LeavePGroupsOut = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LeavePGroupsOut${crypto181.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LeavePGroupsOut instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LeavePGroupsOut.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import LeavePGroupsOut
try: bridgeLeavePGroupsOut
except NameError: bridgeLeavePGroupsOut = {}
`;
    await this._py.ex`ctor_LeavePGroupsOut = {'n_groups': ${this.opts["n_groups"] ?? void 0}}

ctor_LeavePGroupsOut = {k: v for k, v in ctor_LeavePGroupsOut.items() if v is not None}`;
    await this._py.ex`bridgeLeavePGroupsOut[${this.id}] = LeavePGroupsOut(**ctor_LeavePGroupsOut)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLeavePGroupsOut[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePGroupsOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeavePGroupsOut must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LeavePGroupsOut_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LeavePGroupsOut_get_metadata_routing = {k: v for k, v in pms_LeavePGroupsOut_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LeavePGroupsOut_get_metadata_routing = bridgeLeavePGroupsOut[${this.id}].get_metadata_routing(**pms_LeavePGroupsOut_get_metadata_routing)`;
    return this._py`res_LeavePGroupsOut_get_metadata_routing.tolist() if hasattr(res_LeavePGroupsOut_get_metadata_routing, 'tolist') else res_LeavePGroupsOut_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePGroupsOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeavePGroupsOut must call init() before get_n_splits()");
    }
    await this._py.ex`pms_LeavePGroupsOut_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeavePGroupsOut_get_n_splits = {k: v for k, v in pms_LeavePGroupsOut_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_LeavePGroupsOut_get_n_splits = bridgeLeavePGroupsOut[${this.id}].get_n_splits(**pms_LeavePGroupsOut_get_n_splits)`;
    return this._py`res_LeavePGroupsOut_get_n_splits.tolist() if hasattr(res_LeavePGroupsOut_get_n_splits, 'tolist') else res_LeavePGroupsOut_get_n_splits`;
  }
  /**
      Request metadata passed to the `split` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_split_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePGroupsOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeavePGroupsOut must call init() before set_split_request()"
      );
    }
    await this._py.ex`pms_LeavePGroupsOut_set_split_request = {'groups': ${opts["groups"] ?? void 0}}

pms_LeavePGroupsOut_set_split_request = {k: v for k, v in pms_LeavePGroupsOut_set_split_request.items() if v is not None}`;
    await this._py.ex`res_LeavePGroupsOut_set_split_request = bridgeLeavePGroupsOut[${this.id}].set_split_request(**pms_LeavePGroupsOut_set_split_request)`;
    return this._py`res_LeavePGroupsOut_set_split_request.tolist() if hasattr(res_LeavePGroupsOut_set_split_request, 'tolist') else res_LeavePGroupsOut_set_split_request`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePGroupsOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeavePGroupsOut must call init() before split()");
    }
    await this._py.ex`pms_LeavePGroupsOut_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeavePGroupsOut_split = {k: v for k, v in pms_LeavePGroupsOut_split.items() if v is not None}`;
    await this._py.ex`res_LeavePGroupsOut_split = bridgeLeavePGroupsOut[${this.id}].split(**pms_LeavePGroupsOut_split)`;
    return this._py`res_LeavePGroupsOut_split.tolist() if hasattr(res_LeavePGroupsOut_split, 'tolist') else res_LeavePGroupsOut_split`;
  }
};

// src/generated/model_selection/LeavePOut.ts
import crypto182 from "node:crypto";
var LeavePOut = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LeavePOut${crypto182.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LeavePOut instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LeavePOut.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import LeavePOut
try: bridgeLeavePOut
except NameError: bridgeLeavePOut = {}
`;
    await this._py.ex`ctor_LeavePOut = {'p': ${this.opts["p"] ?? void 0}}

ctor_LeavePOut = {k: v for k, v in ctor_LeavePOut.items() if v is not None}`;
    await this._py.ex`bridgeLeavePOut[${this.id}] = LeavePOut(**ctor_LeavePOut)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLeavePOut[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LeavePOut must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LeavePOut_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LeavePOut_get_metadata_routing = {k: v for k, v in pms_LeavePOut_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LeavePOut_get_metadata_routing = bridgeLeavePOut[${this.id}].get_metadata_routing(**pms_LeavePOut_get_metadata_routing)`;
    return this._py`res_LeavePOut_get_metadata_routing.tolist() if hasattr(res_LeavePOut_get_metadata_routing, 'tolist') else res_LeavePOut_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeavePOut must call init() before get_n_splits()");
    }
    await this._py.ex`pms_LeavePOut_get_n_splits = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_LeavePOut_get_n_splits = {k: v for k, v in pms_LeavePOut_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_LeavePOut_get_n_splits = bridgeLeavePOut[${this.id}].get_n_splits(**pms_LeavePOut_get_n_splits)`;
    return this._py`res_LeavePOut_get_n_splits.tolist() if hasattr(res_LeavePOut_get_n_splits, 'tolist') else res_LeavePOut_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This LeavePOut instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LeavePOut must call init() before split()");
    }
    await this._py.ex`pms_LeavePOut_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_LeavePOut_split = {k: v for k, v in pms_LeavePOut_split.items() if v is not None}`;
    await this._py.ex`res_LeavePOut_split = bridgeLeavePOut[${this.id}].split(**pms_LeavePOut_split)`;
    return this._py`res_LeavePOut_split.tolist() if hasattr(res_LeavePOut_split, 'tolist') else res_LeavePOut_split`;
  }
};

// src/generated/model_selection/ParameterGrid.ts
import crypto183 from "node:crypto";
var ParameterGrid = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ParameterGrid${crypto183.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ParameterGrid instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ParameterGrid.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import ParameterGrid
try: bridgeParameterGrid
except NameError: bridgeParameterGrid = {}
`;
    await this._py.ex`ctor_ParameterGrid = {'param_grid': ${this.opts["param_grid"] ?? void 0}}

ctor_ParameterGrid = {k: v for k, v in ctor_ParameterGrid.items() if v is not None}`;
    await this._py.ex`bridgeParameterGrid[${this.id}] = ParameterGrid(**ctor_ParameterGrid)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeParameterGrid[${this.id}]`;
    this._isDisposed = true;
  }
};

// src/generated/model_selection/ParameterSampler.ts
import crypto184 from "node:crypto";
var ParameterSampler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ParameterSampler${crypto184.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ParameterSampler instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ParameterSampler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import ParameterSampler
try: bridgeParameterSampler
except NameError: bridgeParameterSampler = {}
`;
    await this._py.ex`ctor_ParameterSampler = {'param_distributions': ${this.opts["param_distributions"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_ParameterSampler = {k: v for k, v in ctor_ParameterSampler.items() if v is not None}`;
    await this._py.ex`bridgeParameterSampler[${this.id}] = ParameterSampler(**ctor_ParameterSampler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeParameterSampler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
   **Yields** dictionaries mapping each estimator parameter to as sampled value.
   */
  get params() {
    if (this._isDisposed) {
      throw new Error(
        "This ParameterSampler instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ParameterSampler must call init() before accessing params"
      );
    }
    return (async () => {
      await this._py.ex`attr_ParameterSampler_params = bridgeParameterSampler[${this.id}].params`;
      return this._py`attr_ParameterSampler_params.tolist() if hasattr(attr_ParameterSampler_params, 'tolist') else attr_ParameterSampler_params`;
    })();
  }
};

// src/generated/model_selection/PredefinedSplit.ts
import crypto185 from "node:crypto";
var PredefinedSplit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PredefinedSplit${crypto185.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PredefinedSplit instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PredefinedSplit.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import PredefinedSplit
try: bridgePredefinedSplit
except NameError: bridgePredefinedSplit = {}
`;
    await this._py.ex`ctor_PredefinedSplit = {'test_fold': np.array(${this.opts["test_fold"] ?? void 0}) if ${this.opts["test_fold"] !== void 0} else None}

ctor_PredefinedSplit = {k: v for k, v in ctor_PredefinedSplit.items() if v is not None}`;
    await this._py.ex`bridgePredefinedSplit[${this.id}] = PredefinedSplit(**ctor_PredefinedSplit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePredefinedSplit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PredefinedSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PredefinedSplit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PredefinedSplit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PredefinedSplit_get_metadata_routing = {k: v for k, v in pms_PredefinedSplit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PredefinedSplit_get_metadata_routing = bridgePredefinedSplit[${this.id}].get_metadata_routing(**pms_PredefinedSplit_get_metadata_routing)`;
    return this._py`res_PredefinedSplit_get_metadata_routing.tolist() if hasattr(res_PredefinedSplit_get_metadata_routing, 'tolist') else res_PredefinedSplit_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This PredefinedSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PredefinedSplit must call init() before get_n_splits()");
    }
    await this._py.ex`pms_PredefinedSplit_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_PredefinedSplit_get_n_splits = {k: v for k, v in pms_PredefinedSplit_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_PredefinedSplit_get_n_splits = bridgePredefinedSplit[${this.id}].get_n_splits(**pms_PredefinedSplit_get_n_splits)`;
    return this._py`res_PredefinedSplit_get_n_splits.tolist() if hasattr(res_PredefinedSplit_get_n_splits, 'tolist') else res_PredefinedSplit_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This PredefinedSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PredefinedSplit must call init() before split()");
    }
    await this._py.ex`pms_PredefinedSplit_split = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_PredefinedSplit_split = {k: v for k, v in pms_PredefinedSplit_split.items() if v is not None}`;
    await this._py.ex`res_PredefinedSplit_split = bridgePredefinedSplit[${this.id}].split(**pms_PredefinedSplit_split)`;
    return this._py`res_PredefinedSplit_split.tolist() if hasattr(res_PredefinedSplit_split, 'tolist') else res_PredefinedSplit_split`;
  }
};

// src/generated/model_selection/RandomizedSearchCV.ts
import crypto186 from "node:crypto";
var RandomizedSearchCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RandomizedSearchCV${crypto186.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RandomizedSearchCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import RandomizedSearchCV
try: bridgeRandomizedSearchCV
except NameError: bridgeRandomizedSearchCV = {}
`;
    await this._py.ex`ctor_RandomizedSearchCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'param_distributions': ${this.opts["param_distributions"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'pre_dispatch': ${this.opts["pre_dispatch"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'error_score': ${this.opts["error_score"] ?? void 0}, 'return_train_score': ${this.opts["return_train_score"] ?? void 0}}

ctor_RandomizedSearchCV = {k: v for k, v in ctor_RandomizedSearchCV.items() if v is not None}`;
    await this._py.ex`bridgeRandomizedSearchCV[${this.id}] = RandomizedSearchCV(**ctor_RandomizedSearchCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRandomizedSearchCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Call decision\_function on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `decision\_function`.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_decision_function = {k: v for k, v in pms_RandomizedSearchCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_decision_function = bridgeRandomizedSearchCV[${this.id}].decision_function(**pms_RandomizedSearchCV_decision_function)`;
    return this._py`res_RandomizedSearchCV_decision_function.tolist() if hasattr(res_RandomizedSearchCV_decision_function, 'tolist') else res_RandomizedSearchCV_decision_function`;
  }
  /**
    Run fit with all sets of parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomizedSearchCV must call init() before fit()");
    }
    await this._py.ex`pms_RandomizedSearchCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RandomizedSearchCV_fit = {k: v for k, v in pms_RandomizedSearchCV_fit.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_fit = bridgeRandomizedSearchCV[${this.id}].fit(**pms_RandomizedSearchCV_fit)`;
    return this._py`res_RandomizedSearchCV_fit.tolist() if hasattr(res_RandomizedSearchCV_fit, 'tolist') else res_RandomizedSearchCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RandomizedSearchCV_get_metadata_routing = {k: v for k, v in pms_RandomizedSearchCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_get_metadata_routing = bridgeRandomizedSearchCV[${this.id}].get_metadata_routing(**pms_RandomizedSearchCV_get_metadata_routing)`;
    return this._py`res_RandomizedSearchCV_get_metadata_routing.tolist() if hasattr(res_RandomizedSearchCV_get_metadata_routing, 'tolist') else res_RandomizedSearchCV_get_metadata_routing`;
  }
  /**
      Call inverse\_transform on the estimator with the best found params.
  
      Only available if the underlying estimator implements `inverse\_transform` and `refit=True`.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_inverse_transform = {'Xt': ${opts["Xt"] ?? void 0}}

pms_RandomizedSearchCV_inverse_transform = {k: v for k, v in pms_RandomizedSearchCV_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_inverse_transform = bridgeRandomizedSearchCV[${this.id}].inverse_transform(**pms_RandomizedSearchCV_inverse_transform)`;
    return this._py`res_RandomizedSearchCV_inverse_transform.tolist() if hasattr(res_RandomizedSearchCV_inverse_transform, 'tolist') else res_RandomizedSearchCV_inverse_transform`;
  }
  /**
      Call predict on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomizedSearchCV must call init() before predict()");
    }
    await this._py.ex`pms_RandomizedSearchCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_predict = {k: v for k, v in pms_RandomizedSearchCV_predict.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_predict = bridgeRandomizedSearchCV[${this.id}].predict(**pms_RandomizedSearchCV_predict)`;
    return this._py`res_RandomizedSearchCV_predict.tolist() if hasattr(res_RandomizedSearchCV_predict, 'tolist') else res_RandomizedSearchCV_predict`;
  }
  /**
      Call predict\_log\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_log\_proba`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_predict_log_proba = {k: v for k, v in pms_RandomizedSearchCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_predict_log_proba = bridgeRandomizedSearchCV[${this.id}].predict_log_proba(**pms_RandomizedSearchCV_predict_log_proba)`;
    return this._py`res_RandomizedSearchCV_predict_log_proba.tolist() if hasattr(res_RandomizedSearchCV_predict_log_proba, 'tolist') else res_RandomizedSearchCV_predict_log_proba`;
  }
  /**
      Call predict\_proba on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_predict_proba = {k: v for k, v in pms_RandomizedSearchCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_predict_proba = bridgeRandomizedSearchCV[${this.id}].predict_proba(**pms_RandomizedSearchCV_predict_proba)`;
    return this._py`res_RandomizedSearchCV_predict_proba.tolist() if hasattr(res_RandomizedSearchCV_predict_proba, 'tolist') else res_RandomizedSearchCV_predict_proba`;
  }
  /**
      Return the score on the given data, if the estimator has been refit.
  
      This uses the score defined by `scoring` where provided, and the `best\_estimator\_.score` method otherwise.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomizedSearchCV must call init() before score()");
    }
    await this._py.ex`pms_RandomizedSearchCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RandomizedSearchCV_score = {k: v for k, v in pms_RandomizedSearchCV_score.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_score = bridgeRandomizedSearchCV[${this.id}].score(**pms_RandomizedSearchCV_score)`;
    return this._py`res_RandomizedSearchCV_score.tolist() if hasattr(res_RandomizedSearchCV_score, 'tolist') else res_RandomizedSearchCV_score`;
  }
  /**
      Call score\_samples on the estimator with the best found parameters.
  
      Only available if `refit=True` and the underlying estimator supports `score\_samples`.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_score_samples = {k: v for k, v in pms_RandomizedSearchCV_score_samples.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_score_samples = bridgeRandomizedSearchCV[${this.id}].score_samples(**pms_RandomizedSearchCV_score_samples)`;
    return this._py`res_RandomizedSearchCV_score_samples.tolist() if hasattr(res_RandomizedSearchCV_score_samples, 'tolist') else res_RandomizedSearchCV_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RandomizedSearchCV_set_fit_request = {'groups': ${opts["groups"] ?? void 0}}

pms_RandomizedSearchCV_set_fit_request = {k: v for k, v in pms_RandomizedSearchCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_set_fit_request = bridgeRandomizedSearchCV[${this.id}].set_fit_request(**pms_RandomizedSearchCV_set_fit_request)`;
    return this._py`res_RandomizedSearchCV_set_fit_request.tolist() if hasattr(res_RandomizedSearchCV_set_fit_request, 'tolist') else res_RandomizedSearchCV_set_fit_request`;
  }
  /**
      Call transform on the estimator with the best found parameters.
  
      Only available if the underlying estimator supports `transform` and `refit=True`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomizedSearchCV must call init() before transform()");
    }
    await this._py.ex`pms_RandomizedSearchCV_transform = {'X': ${opts["X"] ?? void 0}}

pms_RandomizedSearchCV_transform = {k: v for k, v in pms_RandomizedSearchCV_transform.items() if v is not None}`;
    await this._py.ex`res_RandomizedSearchCV_transform = bridgeRandomizedSearchCV[${this.id}].transform(**pms_RandomizedSearchCV_transform)`;
    return this._py`res_RandomizedSearchCV_transform.tolist() if hasattr(res_RandomizedSearchCV_transform, 'tolist') else res_RandomizedSearchCV_transform`;
  }
  /**
      A dict with keys as column headers and values as columns, that can be imported into a pandas `DataFrame`.
  
      For instance the below given table
     */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_cv_results_ = bridgeRandomizedSearchCV[${this.id}].cv_results_`;
      return this._py`attr_RandomizedSearchCV_cv_results_.tolist() if hasattr(attr_RandomizedSearchCV_cv_results_, 'tolist') else attr_RandomizedSearchCV_cv_results_`;
    })();
  }
  /**
      Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if `refit=False`.
  
      For multi-metric evaluation, this attribute is present only if `refit` is specified.
  
      See `refit` parameter for more information on allowed values.
     */
  get best_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing best_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_best_estimator_ = bridgeRandomizedSearchCV[${this.id}].best_estimator_`;
      return this._py`attr_RandomizedSearchCV_best_estimator_.tolist() if hasattr(attr_RandomizedSearchCV_best_estimator_, 'tolist') else attr_RandomizedSearchCV_best_estimator_`;
    })();
  }
  /**
      Mean cross-validated score of the best\_estimator.
  
      For multi-metric evaluation, this is not available if `refit` is `false`. See `refit` parameter for more information.
  
      This attribute is not available if `refit` is a function.
     */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_best_score_ = bridgeRandomizedSearchCV[${this.id}].best_score_`;
      return this._py`attr_RandomizedSearchCV_best_score_.tolist() if hasattr(attr_RandomizedSearchCV_best_score_, 'tolist') else attr_RandomizedSearchCV_best_score_`;
    })();
  }
  /**
      Parameter setting that gave the best results on the hold out data.
  
      For multi-metric evaluation, this is not available if `refit` is `false`. See `refit` parameter for more information.
     */
  get best_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing best_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_best_params_ = bridgeRandomizedSearchCV[${this.id}].best_params_`;
      return this._py`attr_RandomizedSearchCV_best_params_.tolist() if hasattr(attr_RandomizedSearchCV_best_params_, 'tolist') else attr_RandomizedSearchCV_best_params_`;
    })();
  }
  /**
      The index (of the `cv\_results\_` arrays) which corresponds to the best candidate parameter setting.
  
      The dict at `search.cv\_results\_\['params'\]\[search.best\_index\_\]` gives the parameter setting for the best model, that gives the highest mean score (`search.best\_score\_`).
  
      For multi-metric evaluation, this is not available if `refit` is `false`. See `refit` parameter for more information.
     */
  get best_index_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing best_index_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_best_index_ = bridgeRandomizedSearchCV[${this.id}].best_index_`;
      return this._py`attr_RandomizedSearchCV_best_index_.tolist() if hasattr(attr_RandomizedSearchCV_best_index_, 'tolist') else attr_RandomizedSearchCV_best_index_`;
    })();
  }
  /**
      Scorer function used on the held out data to choose the best parameters for the model.
  
      For multi-metric evaluation, this attribute holds the validated `scoring` dict which maps the scorer key to the scorer callable.
     */
  get scorer_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing scorer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_scorer_ = bridgeRandomizedSearchCV[${this.id}].scorer_`;
      return this._py`attr_RandomizedSearchCV_scorer_.tolist() if hasattr(attr_RandomizedSearchCV_scorer_, 'tolist') else attr_RandomizedSearchCV_scorer_`;
    })();
  }
  /**
    The number of cross-validation splits (folds/iterations).
   */
  get n_splits_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing n_splits_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_n_splits_ = bridgeRandomizedSearchCV[${this.id}].n_splits_`;
      return this._py`attr_RandomizedSearchCV_n_splits_.tolist() if hasattr(attr_RandomizedSearchCV_n_splits_, 'tolist') else attr_RandomizedSearchCV_n_splits_`;
    })();
  }
  /**
      Seconds used for refitting the best model on the whole dataset.
  
      This is present only if `refit` is not `false`.
     */
  get refit_time_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing refit_time_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_refit_time_ = bridgeRandomizedSearchCV[${this.id}].refit_time_`;
      return this._py`attr_RandomizedSearchCV_refit_time_.tolist() if hasattr(attr_RandomizedSearchCV_refit_time_, 'tolist') else attr_RandomizedSearchCV_refit_time_`;
    })();
  }
  /**
    Whether or not the scorers compute several metrics.
   */
  get multimetric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing multimetric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_multimetric_ = bridgeRandomizedSearchCV[${this.id}].multimetric_`;
      return this._py`attr_RandomizedSearchCV_multimetric_.tolist() if hasattr(attr_RandomizedSearchCV_multimetric_, 'tolist') else attr_RandomizedSearchCV_multimetric_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if `best\_estimator\_` is defined (see the documentation for the `refit` parameter for more details) and that `best\_estimator\_` exposes `feature\_names\_in\_` when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomizedSearchCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomizedSearchCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomizedSearchCV_feature_names_in_ = bridgeRandomizedSearchCV[${this.id}].feature_names_in_`;
      return this._py`attr_RandomizedSearchCV_feature_names_in_.tolist() if hasattr(attr_RandomizedSearchCV_feature_names_in_, 'tolist') else attr_RandomizedSearchCV_feature_names_in_`;
    })();
  }
};

// src/generated/model_selection/RepeatedKFold.ts
import crypto187 from "node:crypto";
var RepeatedKFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RepeatedKFold${crypto187.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RepeatedKFold instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RepeatedKFold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import RepeatedKFold
try: bridgeRepeatedKFold
except NameError: bridgeRepeatedKFold = {}
`;
    await this._py.ex`ctor_RepeatedKFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'n_repeats': ${this.opts["n_repeats"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RepeatedKFold = {k: v for k, v in ctor_RepeatedKFold.items() if v is not None}`;
    await this._py.ex`bridgeRepeatedKFold[${this.id}] = RepeatedKFold(**ctor_RepeatedKFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRepeatedKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RepeatedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RepeatedKFold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RepeatedKFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RepeatedKFold_get_metadata_routing = {k: v for k, v in pms_RepeatedKFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RepeatedKFold_get_metadata_routing = bridgeRepeatedKFold[${this.id}].get_metadata_routing(**pms_RepeatedKFold_get_metadata_routing)`;
    return this._py`res_RepeatedKFold_get_metadata_routing.tolist() if hasattr(res_RepeatedKFold_get_metadata_routing, 'tolist') else res_RepeatedKFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This RepeatedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RepeatedKFold must call init() before get_n_splits()");
    }
    await this._py.ex`pms_RepeatedKFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RepeatedKFold_get_n_splits = {k: v for k, v in pms_RepeatedKFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_RepeatedKFold_get_n_splits = bridgeRepeatedKFold[${this.id}].get_n_splits(**pms_RepeatedKFold_get_n_splits)`;
    return this._py`res_RepeatedKFold_get_n_splits.tolist() if hasattr(res_RepeatedKFold_get_n_splits, 'tolist') else res_RepeatedKFold_get_n_splits`;
  }
  /**
    Generates indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This RepeatedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RepeatedKFold must call init() before split()");
    }
    await this._py.ex`pms_RepeatedKFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RepeatedKFold_split = {k: v for k, v in pms_RepeatedKFold_split.items() if v is not None}`;
    await this._py.ex`res_RepeatedKFold_split = bridgeRepeatedKFold[${this.id}].split(**pms_RepeatedKFold_split)`;
    return this._py`res_RepeatedKFold_split.tolist() if hasattr(res_RepeatedKFold_split, 'tolist') else res_RepeatedKFold_split`;
  }
};

// src/generated/model_selection/RepeatedStratifiedKFold.ts
import crypto188 from "node:crypto";
var RepeatedStratifiedKFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RepeatedStratifiedKFold${crypto188.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RepeatedStratifiedKFold instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RepeatedStratifiedKFold.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import RepeatedStratifiedKFold
try: bridgeRepeatedStratifiedKFold
except NameError: bridgeRepeatedStratifiedKFold = {}
`;
    await this._py.ex`ctor_RepeatedStratifiedKFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'n_repeats': ${this.opts["n_repeats"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RepeatedStratifiedKFold = {k: v for k, v in ctor_RepeatedStratifiedKFold.items() if v is not None}`;
    await this._py.ex`bridgeRepeatedStratifiedKFold[${this.id}] = RepeatedStratifiedKFold(**ctor_RepeatedStratifiedKFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRepeatedStratifiedKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RepeatedStratifiedKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RepeatedStratifiedKFold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RepeatedStratifiedKFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RepeatedStratifiedKFold_get_metadata_routing = {k: v for k, v in pms_RepeatedStratifiedKFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RepeatedStratifiedKFold_get_metadata_routing = bridgeRepeatedStratifiedKFold[${this.id}].get_metadata_routing(**pms_RepeatedStratifiedKFold_get_metadata_routing)`;
    return this._py`res_RepeatedStratifiedKFold_get_metadata_routing.tolist() if hasattr(res_RepeatedStratifiedKFold_get_metadata_routing, 'tolist') else res_RepeatedStratifiedKFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RepeatedStratifiedKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RepeatedStratifiedKFold must call init() before get_n_splits()"
      );
    }
    await this._py.ex`pms_RepeatedStratifiedKFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RepeatedStratifiedKFold_get_n_splits = {k: v for k, v in pms_RepeatedStratifiedKFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_RepeatedStratifiedKFold_get_n_splits = bridgeRepeatedStratifiedKFold[${this.id}].get_n_splits(**pms_RepeatedStratifiedKFold_get_n_splits)`;
    return this._py`res_RepeatedStratifiedKFold_get_n_splits.tolist() if hasattr(res_RepeatedStratifiedKFold_get_n_splits, 'tolist') else res_RepeatedStratifiedKFold_get_n_splits`;
  }
  /**
    Generates indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RepeatedStratifiedKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RepeatedStratifiedKFold must call init() before split()");
    }
    await this._py.ex`pms_RepeatedStratifiedKFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_RepeatedStratifiedKFold_split = {k: v for k, v in pms_RepeatedStratifiedKFold_split.items() if v is not None}`;
    await this._py.ex`res_RepeatedStratifiedKFold_split = bridgeRepeatedStratifiedKFold[${this.id}].split(**pms_RepeatedStratifiedKFold_split)`;
    return this._py`res_RepeatedStratifiedKFold_split.tolist() if hasattr(res_RepeatedStratifiedKFold_split, 'tolist') else res_RepeatedStratifiedKFold_split`;
  }
};

// src/generated/model_selection/ShuffleSplit.ts
import crypto189 from "node:crypto";
var ShuffleSplit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ShuffleSplit${crypto189.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ShuffleSplit instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ShuffleSplit.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import ShuffleSplit
try: bridgeShuffleSplit
except NameError: bridgeShuffleSplit = {}
`;
    await this._py.ex`ctor_ShuffleSplit = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'test_size': ${this.opts["test_size"] ?? void 0}, 'train_size': ${this.opts["train_size"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_ShuffleSplit = {k: v for k, v in ctor_ShuffleSplit.items() if v is not None}`;
    await this._py.ex`bridgeShuffleSplit[${this.id}] = ShuffleSplit(**ctor_ShuffleSplit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeShuffleSplit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ShuffleSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShuffleSplit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ShuffleSplit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ShuffleSplit_get_metadata_routing = {k: v for k, v in pms_ShuffleSplit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ShuffleSplit_get_metadata_routing = bridgeShuffleSplit[${this.id}].get_metadata_routing(**pms_ShuffleSplit_get_metadata_routing)`;
    return this._py`res_ShuffleSplit_get_metadata_routing.tolist() if hasattr(res_ShuffleSplit_get_metadata_routing, 'tolist') else res_ShuffleSplit_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This ShuffleSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ShuffleSplit must call init() before get_n_splits()");
    }
    await this._py.ex`pms_ShuffleSplit_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_ShuffleSplit_get_n_splits = {k: v for k, v in pms_ShuffleSplit_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_ShuffleSplit_get_n_splits = bridgeShuffleSplit[${this.id}].get_n_splits(**pms_ShuffleSplit_get_n_splits)`;
    return this._py`res_ShuffleSplit_get_n_splits.tolist() if hasattr(res_ShuffleSplit_get_n_splits, 'tolist') else res_ShuffleSplit_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This ShuffleSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ShuffleSplit must call init() before split()");
    }
    await this._py.ex`pms_ShuffleSplit_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_ShuffleSplit_split = {k: v for k, v in pms_ShuffleSplit_split.items() if v is not None}`;
    await this._py.ex`res_ShuffleSplit_split = bridgeShuffleSplit[${this.id}].split(**pms_ShuffleSplit_split)`;
    return this._py`res_ShuffleSplit_split.tolist() if hasattr(res_ShuffleSplit_split, 'tolist') else res_ShuffleSplit_split`;
  }
};

// src/generated/model_selection/StratifiedGroupKFold.ts
import crypto190 from "node:crypto";
var StratifiedGroupKFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StratifiedGroupKFold${crypto190.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedGroupKFold instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "StratifiedGroupKFold.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import StratifiedGroupKFold
try: bridgeStratifiedGroupKFold
except NameError: bridgeStratifiedGroupKFold = {}
`;
    await this._py.ex`ctor_StratifiedGroupKFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_StratifiedGroupKFold = {k: v for k, v in ctor_StratifiedGroupKFold.items() if v is not None}`;
    await this._py.ex`bridgeStratifiedGroupKFold[${this.id}] = StratifiedGroupKFold(**ctor_StratifiedGroupKFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStratifiedGroupKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedGroupKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedGroupKFold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StratifiedGroupKFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StratifiedGroupKFold_get_metadata_routing = {k: v for k, v in pms_StratifiedGroupKFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StratifiedGroupKFold_get_metadata_routing = bridgeStratifiedGroupKFold[${this.id}].get_metadata_routing(**pms_StratifiedGroupKFold_get_metadata_routing)`;
    return this._py`res_StratifiedGroupKFold_get_metadata_routing.tolist() if hasattr(res_StratifiedGroupKFold_get_metadata_routing, 'tolist') else res_StratifiedGroupKFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedGroupKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedGroupKFold must call init() before get_n_splits()"
      );
    }
    await this._py.ex`pms_StratifiedGroupKFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedGroupKFold_get_n_splits = {k: v for k, v in pms_StratifiedGroupKFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_StratifiedGroupKFold_get_n_splits = bridgeStratifiedGroupKFold[${this.id}].get_n_splits(**pms_StratifiedGroupKFold_get_n_splits)`;
    return this._py`res_StratifiedGroupKFold_get_n_splits.tolist() if hasattr(res_StratifiedGroupKFold_get_n_splits, 'tolist') else res_StratifiedGroupKFold_get_n_splits`;
  }
  /**
      Request metadata passed to the `split` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_split_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedGroupKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedGroupKFold must call init() before set_split_request()"
      );
    }
    await this._py.ex`pms_StratifiedGroupKFold_set_split_request = {'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedGroupKFold_set_split_request = {k: v for k, v in pms_StratifiedGroupKFold_set_split_request.items() if v is not None}`;
    await this._py.ex`res_StratifiedGroupKFold_set_split_request = bridgeStratifiedGroupKFold[${this.id}].set_split_request(**pms_StratifiedGroupKFold_set_split_request)`;
    return this._py`res_StratifiedGroupKFold_set_split_request.tolist() if hasattr(res_StratifiedGroupKFold_set_split_request, 'tolist') else res_StratifiedGroupKFold_set_split_request`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedGroupKFold instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StratifiedGroupKFold must call init() before split()");
    }
    await this._py.ex`pms_StratifiedGroupKFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_StratifiedGroupKFold_split = {k: v for k, v in pms_StratifiedGroupKFold_split.items() if v is not None}`;
    await this._py.ex`res_StratifiedGroupKFold_split = bridgeStratifiedGroupKFold[${this.id}].split(**pms_StratifiedGroupKFold_split)`;
    return this._py`res_StratifiedGroupKFold_split.tolist() if hasattr(res_StratifiedGroupKFold_split, 'tolist') else res_StratifiedGroupKFold_split`;
  }
};

// src/generated/model_selection/StratifiedKFold.ts
import crypto191 from "node:crypto";
var StratifiedKFold = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StratifiedKFold${crypto191.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This StratifiedKFold instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("StratifiedKFold.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import StratifiedKFold
try: bridgeStratifiedKFold
except NameError: bridgeStratifiedKFold = {}
`;
    await this._py.ex`ctor_StratifiedKFold = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_StratifiedKFold = {k: v for k, v in ctor_StratifiedKFold.items() if v is not None}`;
    await this._py.ex`bridgeStratifiedKFold[${this.id}] = StratifiedKFold(**ctor_StratifiedKFold)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStratifiedKFold[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This StratifiedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedKFold must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StratifiedKFold_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StratifiedKFold_get_metadata_routing = {k: v for k, v in pms_StratifiedKFold_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StratifiedKFold_get_metadata_routing = bridgeStratifiedKFold[${this.id}].get_metadata_routing(**pms_StratifiedKFold_get_metadata_routing)`;
    return this._py`res_StratifiedKFold_get_metadata_routing.tolist() if hasattr(res_StratifiedKFold_get_metadata_routing, 'tolist') else res_StratifiedKFold_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This StratifiedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StratifiedKFold must call init() before get_n_splits()");
    }
    await this._py.ex`pms_StratifiedKFold_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedKFold_get_n_splits = {k: v for k, v in pms_StratifiedKFold_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_StratifiedKFold_get_n_splits = bridgeStratifiedKFold[${this.id}].get_n_splits(**pms_StratifiedKFold_get_n_splits)`;
    return this._py`res_StratifiedKFold_get_n_splits.tolist() if hasattr(res_StratifiedKFold_get_n_splits, 'tolist') else res_StratifiedKFold_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This StratifiedKFold instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StratifiedKFold must call init() before split()");
    }
    await this._py.ex`pms_StratifiedKFold_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedKFold_split = {k: v for k, v in pms_StratifiedKFold_split.items() if v is not None}`;
    await this._py.ex`res_StratifiedKFold_split = bridgeStratifiedKFold[${this.id}].split(**pms_StratifiedKFold_split)`;
    return this._py`res_StratifiedKFold_split.tolist() if hasattr(res_StratifiedKFold_split, 'tolist') else res_StratifiedKFold_split`;
  }
};

// src/generated/model_selection/StratifiedShuffleSplit.ts
import crypto192 from "node:crypto";
var StratifiedShuffleSplit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StratifiedShuffleSplit${crypto192.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedShuffleSplit instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "StratifiedShuffleSplit.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import StratifiedShuffleSplit
try: bridgeStratifiedShuffleSplit
except NameError: bridgeStratifiedShuffleSplit = {}
`;
    await this._py.ex`ctor_StratifiedShuffleSplit = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'test_size': ${this.opts["test_size"] ?? void 0}, 'train_size': ${this.opts["train_size"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_StratifiedShuffleSplit = {k: v for k, v in ctor_StratifiedShuffleSplit.items() if v is not None}`;
    await this._py.ex`bridgeStratifiedShuffleSplit[${this.id}] = StratifiedShuffleSplit(**ctor_StratifiedShuffleSplit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStratifiedShuffleSplit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedShuffleSplit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StratifiedShuffleSplit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StratifiedShuffleSplit_get_metadata_routing = {k: v for k, v in pms_StratifiedShuffleSplit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StratifiedShuffleSplit_get_metadata_routing = bridgeStratifiedShuffleSplit[${this.id}].get_metadata_routing(**pms_StratifiedShuffleSplit_get_metadata_routing)`;
    return this._py`res_StratifiedShuffleSplit_get_metadata_routing.tolist() if hasattr(res_StratifiedShuffleSplit_get_metadata_routing, 'tolist') else res_StratifiedShuffleSplit_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "StratifiedShuffleSplit must call init() before get_n_splits()"
      );
    }
    await this._py.ex`pms_StratifiedShuffleSplit_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedShuffleSplit_get_n_splits = {k: v for k, v in pms_StratifiedShuffleSplit_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_StratifiedShuffleSplit_get_n_splits = bridgeStratifiedShuffleSplit[${this.id}].get_n_splits(**pms_StratifiedShuffleSplit_get_n_splits)`;
    return this._py`res_StratifiedShuffleSplit_get_n_splits.tolist() if hasattr(res_StratifiedShuffleSplit_get_n_splits, 'tolist') else res_StratifiedShuffleSplit_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This StratifiedShuffleSplit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("StratifiedShuffleSplit must call init() before split()");
    }
    await this._py.ex`pms_StratifiedShuffleSplit_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': ${opts["groups"] ?? void 0}}

pms_StratifiedShuffleSplit_split = {k: v for k, v in pms_StratifiedShuffleSplit_split.items() if v is not None}`;
    await this._py.ex`res_StratifiedShuffleSplit_split = bridgeStratifiedShuffleSplit[${this.id}].split(**pms_StratifiedShuffleSplit_split)`;
    return this._py`res_StratifiedShuffleSplit_split.tolist() if hasattr(res_StratifiedShuffleSplit_split, 'tolist') else res_StratifiedShuffleSplit_split`;
  }
};

// src/generated/model_selection/TimeSeriesSplit.ts
import crypto193 from "node:crypto";
var TimeSeriesSplit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TimeSeriesSplit${crypto193.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TimeSeriesSplit instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TimeSeriesSplit.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import TimeSeriesSplit
try: bridgeTimeSeriesSplit
except NameError: bridgeTimeSeriesSplit = {}
`;
    await this._py.ex`ctor_TimeSeriesSplit = {'n_splits': ${this.opts["n_splits"] ?? void 0}, 'max_train_size': ${this.opts["max_train_size"] ?? void 0}, 'test_size': ${this.opts["test_size"] ?? void 0}, 'gap': ${this.opts["gap"] ?? void 0}}

ctor_TimeSeriesSplit = {k: v for k, v in ctor_TimeSeriesSplit.items() if v is not None}`;
    await this._py.ex`bridgeTimeSeriesSplit[${this.id}] = TimeSeriesSplit(**ctor_TimeSeriesSplit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTimeSeriesSplit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TimeSeriesSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TimeSeriesSplit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TimeSeriesSplit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TimeSeriesSplit_get_metadata_routing = {k: v for k, v in pms_TimeSeriesSplit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TimeSeriesSplit_get_metadata_routing = bridgeTimeSeriesSplit[${this.id}].get_metadata_routing(**pms_TimeSeriesSplit_get_metadata_routing)`;
    return this._py`res_TimeSeriesSplit_get_metadata_routing.tolist() if hasattr(res_TimeSeriesSplit_get_metadata_routing, 'tolist') else res_TimeSeriesSplit_get_metadata_routing`;
  }
  /**
    Returns the number of splitting iterations in the cross-validator
   */
  async get_n_splits(opts) {
    if (this._isDisposed) {
      throw new Error("This TimeSeriesSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TimeSeriesSplit must call init() before get_n_splits()");
    }
    await this._py.ex`pms_TimeSeriesSplit_get_n_splits = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'groups': ${opts["groups"] ?? void 0}}

pms_TimeSeriesSplit_get_n_splits = {k: v for k, v in pms_TimeSeriesSplit_get_n_splits.items() if v is not None}`;
    await this._py.ex`res_TimeSeriesSplit_get_n_splits = bridgeTimeSeriesSplit[${this.id}].get_n_splits(**pms_TimeSeriesSplit_get_n_splits)`;
    return this._py`res_TimeSeriesSplit_get_n_splits.tolist() if hasattr(res_TimeSeriesSplit_get_n_splits, 'tolist') else res_TimeSeriesSplit_get_n_splits`;
  }
  /**
    Generate indices to split data into training and test set.
   */
  async split(opts) {
    if (this._isDisposed) {
      throw new Error("This TimeSeriesSplit instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TimeSeriesSplit must call init() before split()");
    }
    await this._py.ex`pms_TimeSeriesSplit_split = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None}

pms_TimeSeriesSplit_split = {k: v for k, v in pms_TimeSeriesSplit_split.items() if v is not None}`;
    await this._py.ex`res_TimeSeriesSplit_split = bridgeTimeSeriesSplit[${this.id}].split(**pms_TimeSeriesSplit_split)`;
    return this._py`res_TimeSeriesSplit_split.tolist() if hasattr(res_TimeSeriesSplit_split, 'tolist') else res_TimeSeriesSplit_split`;
  }
};

// src/generated/model_selection/ValidationCurveDisplay.ts
import crypto194 from "node:crypto";
var ValidationCurveDisplay = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ValidationCurveDisplay${crypto194.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ValidationCurveDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.model_selection import ValidationCurveDisplay
try: bridgeValidationCurveDisplay
except NameError: bridgeValidationCurveDisplay = {}
`;
    await this._py.ex`ctor_ValidationCurveDisplay = {'param_name': ${this.opts["param_name"] ?? void 0}, 'param_range': np.array(${this.opts["param_range"] ?? void 0}) if ${this.opts["param_range"] !== void 0} else None, 'train_scores': np.array(${this.opts["train_scores"] ?? void 0}) if ${this.opts["train_scores"] !== void 0} else None, 'test_scores': np.array(${this.opts["test_scores"] ?? void 0}) if ${this.opts["test_scores"] !== void 0} else None, 'score_name': ${this.opts["score_name"] ?? void 0}}

ctor_ValidationCurveDisplay = {k: v for k, v in ctor_ValidationCurveDisplay.items() if v is not None}`;
    await this._py.ex`bridgeValidationCurveDisplay[${this.id}] = ValidationCurveDisplay(**ctor_ValidationCurveDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeValidationCurveDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Create a validation curve display from an estimator.
  
      Read more in the [User Guide](../../visualizations.html#visualizations) for general information about the visualization API and [detailed documentation](../learning_curve.html#validation-curve) regarding the validation curve visualization.
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_ValidationCurveDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'param_name': ${opts["param_name"] ?? void 0}, 'param_range': np.array(${opts["param_range"] ?? void 0}) if ${opts["param_range"] !== void 0} else None, 'groups': np.array(${opts["groups"] ?? void 0}) if ${opts["groups"] !== void 0} else None, 'cv': ${opts["cv"] ?? void 0}, 'scoring': ${opts["scoring"] ?? void 0}, 'n_jobs': ${opts["n_jobs"] ?? void 0}, 'pre_dispatch': ${opts["pre_dispatch"] ?? void 0}, 'verbose': ${opts["verbose"] ?? void 0}, 'error_score': ${opts["error_score"] ?? void 0}, 'fit_params': ${opts["fit_params"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'negate_score': ${opts["negate_score"] ?? void 0}, 'score_name': ${opts["score_name"] ?? void 0}, 'score_type': ${opts["score_type"] ?? void 0}, 'std_display_style': ${opts["std_display_style"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'fill_between_kw': ${opts["fill_between_kw"] ?? void 0}, 'errorbar_kw': ${opts["errorbar_kw"] ?? void 0}}

pms_ValidationCurveDisplay_from_estimator = {k: v for k, v in pms_ValidationCurveDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_ValidationCurveDisplay_from_estimator = bridgeValidationCurveDisplay[${this.id}].from_estimator(**pms_ValidationCurveDisplay_from_estimator)`;
    return this._py`res_ValidationCurveDisplay_from_estimator.tolist() if hasattr(res_ValidationCurveDisplay_from_estimator, 'tolist') else res_ValidationCurveDisplay_from_estimator`;
  }
  /**
    Plot visualization.
   */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ValidationCurveDisplay must call init() before plot()");
    }
    await this._py.ex`pms_ValidationCurveDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'negate_score': ${opts["negate_score"] ?? void 0}, 'score_name': ${opts["score_name"] ?? void 0}, 'score_type': ${opts["score_type"] ?? void 0}, 'std_display_style': ${opts["std_display_style"] ?? void 0}, 'line_kw': ${opts["line_kw"] ?? void 0}, 'fill_between_kw': ${opts["fill_between_kw"] ?? void 0}, 'errorbar_kw': ${opts["errorbar_kw"] ?? void 0}}

pms_ValidationCurveDisplay_plot = {k: v for k, v in pms_ValidationCurveDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_ValidationCurveDisplay_plot = bridgeValidationCurveDisplay[${this.id}].plot(**pms_ValidationCurveDisplay_plot)`;
    return this._py`res_ValidationCurveDisplay_plot.tolist() if hasattr(res_ValidationCurveDisplay_plot, 'tolist') else res_ValidationCurveDisplay_plot`;
  }
  /**
    Axes with the validation curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ValidationCurveDisplay_ax_ = bridgeValidationCurveDisplay[${this.id}].ax_`;
      return this._py`attr_ValidationCurveDisplay_ax_.tolist() if hasattr(attr_ValidationCurveDisplay_ax_, 'tolist') else attr_ValidationCurveDisplay_ax_`;
    })();
  }
  /**
    Figure containing the validation curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ValidationCurveDisplay_figure_ = bridgeValidationCurveDisplay[${this.id}].figure_`;
      return this._py`attr_ValidationCurveDisplay_figure_.tolist() if hasattr(attr_ValidationCurveDisplay_figure_, 'tolist') else attr_ValidationCurveDisplay_figure_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"errorbar"`, this is a list of `matplotlib.container.ErrorbarContainer` objects. If another style is used, `errorbar\_` is `undefined`.
   */
  get errorbar_() {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before accessing errorbar_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ValidationCurveDisplay_errorbar_ = bridgeValidationCurveDisplay[${this.id}].errorbar_`;
      return this._py`attr_ValidationCurveDisplay_errorbar_.tolist() if hasattr(attr_ValidationCurveDisplay_errorbar_, 'tolist') else attr_ValidationCurveDisplay_errorbar_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"fill\_between"`, this is a list of `matplotlib.lines.Line2D` objects corresponding to the mean train and test scores. If another style is used, `line\_` is `undefined`.
   */
  get lines_() {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before accessing lines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ValidationCurveDisplay_lines_ = bridgeValidationCurveDisplay[${this.id}].lines_`;
      return this._py`attr_ValidationCurveDisplay_lines_.tolist() if hasattr(attr_ValidationCurveDisplay_lines_, 'tolist') else attr_ValidationCurveDisplay_lines_`;
    })();
  }
  /**
    When the `std\_display\_style` is `"fill\_between"`, this is a list of `matplotlib.collections.PolyCollection` objects. If another style is used, `fill\_between\_` is `undefined`.
   */
  get fill_between_() {
    if (this._isDisposed) {
      throw new Error(
        "This ValidationCurveDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ValidationCurveDisplay must call init() before accessing fill_between_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ValidationCurveDisplay_fill_between_ = bridgeValidationCurveDisplay[${this.id}].fill_between_`;
      return this._py`attr_ValidationCurveDisplay_fill_between_.tolist() if hasattr(attr_ValidationCurveDisplay_fill_between_, 'tolist') else attr_ValidationCurveDisplay_fill_between_`;
    })();
  }
};

// src/generated/multiclass/OneVsOneClassifier.ts
import crypto195 from "node:crypto";
var OneVsOneClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneVsOneClassifier${crypto195.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OneVsOneClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OneVsOneClassifier
try: bridgeOneVsOneClassifier
except NameError: bridgeOneVsOneClassifier = {}
`;
    await this._py.ex`ctor_OneVsOneClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OneVsOneClassifier = {k: v for k, v in ctor_OneVsOneClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOneVsOneClassifier[${this.id}] = OneVsOneClassifier(**ctor_OneVsOneClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneVsOneClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Decision function for the OneVsOneClassifier.
  
      The decision values for the samples are computed by adding the normalized sum of pair-wise classification confidence levels to the votes in order to disambiguate between the decision values when the votes for all the classes are equal leading to a tie.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsOneClassifier_decision_function = {k: v for k, v in pms_OneVsOneClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_decision_function = bridgeOneVsOneClassifier[${this.id}].decision_function(**pms_OneVsOneClassifier_decision_function)`;
    return this._py`res_OneVsOneClassifier_decision_function.tolist() if hasattr(res_OneVsOneClassifier_decision_function, 'tolist') else res_OneVsOneClassifier_decision_function`;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OneVsOneClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OneVsOneClassifier_fit = {k: v for k, v in pms_OneVsOneClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_fit = bridgeOneVsOneClassifier[${this.id}].fit(**pms_OneVsOneClassifier_fit)`;
    return this._py`res_OneVsOneClassifier_fit.tolist() if hasattr(res_OneVsOneClassifier_fit, 'tolist') else res_OneVsOneClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OneVsOneClassifier_get_metadata_routing = {k: v for k, v in pms_OneVsOneClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_get_metadata_routing = bridgeOneVsOneClassifier[${this.id}].get_metadata_routing(**pms_OneVsOneClassifier_get_metadata_routing)`;
    return this._py`res_OneVsOneClassifier_get_metadata_routing.tolist() if hasattr(res_OneVsOneClassifier_get_metadata_routing, 'tolist') else res_OneVsOneClassifier_get_metadata_routing`;
  }
  /**
      Partially fit underlying estimators.
  
      Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration, where the first call should have an array of all target variables.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': ${opts["classes"] ?? void 0}}

pms_OneVsOneClassifier_partial_fit = {k: v for k, v in pms_OneVsOneClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_partial_fit = bridgeOneVsOneClassifier[${this.id}].partial_fit(**pms_OneVsOneClassifier_partial_fit)`;
    return this._py`res_OneVsOneClassifier_partial_fit.tolist() if hasattr(res_OneVsOneClassifier_partial_fit, 'tolist') else res_OneVsOneClassifier_partial_fit`;
  }
  /**
      Estimate the best class label for each sample in X.
  
      This is implemented as `argmax(decision\_function(X), axis=1)` which will return the label of the class with most votes by estimators predicting the outcome of a decision for each possible class pair.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OneVsOneClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsOneClassifier_predict = {k: v for k, v in pms_OneVsOneClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_predict = bridgeOneVsOneClassifier[${this.id}].predict(**pms_OneVsOneClassifier_predict)`;
    return this._py`res_OneVsOneClassifier_predict.tolist() if hasattr(res_OneVsOneClassifier_predict, 'tolist') else res_OneVsOneClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before score()");
    }
    await this._py.ex`pms_OneVsOneClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneVsOneClassifier_score = {k: v for k, v in pms_OneVsOneClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_score = bridgeOneVsOneClassifier[${this.id}].score(**pms_OneVsOneClassifier_score)`;
    return this._py`res_OneVsOneClassifier_score.tolist() if hasattr(res_OneVsOneClassifier_score, 'tolist') else res_OneVsOneClassifier_score`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}}

pms_OneVsOneClassifier_set_partial_fit_request = {k: v for k, v in pms_OneVsOneClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_set_partial_fit_request = bridgeOneVsOneClassifier[${this.id}].set_partial_fit_request(**pms_OneVsOneClassifier_set_partial_fit_request)`;
    return this._py`res_OneVsOneClassifier_set_partial_fit_request.tolist() if hasattr(res_OneVsOneClassifier_set_partial_fit_request, 'tolist') else res_OneVsOneClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OneVsOneClassifier_set_score_request = {k: v for k, v in pms_OneVsOneClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_set_score_request = bridgeOneVsOneClassifier[${this.id}].set_score_request(**pms_OneVsOneClassifier_set_score_request)`;
    return this._py`res_OneVsOneClassifier_set_score_request.tolist() if hasattr(res_OneVsOneClassifier_set_score_request, 'tolist') else res_OneVsOneClassifier_set_score_request`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_estimators_ = bridgeOneVsOneClassifier[${this.id}].estimators_`;
      return this._py`attr_OneVsOneClassifier_estimators_.tolist() if hasattr(attr_OneVsOneClassifier_estimators_, 'tolist') else attr_OneVsOneClassifier_estimators_`;
    })();
  }
  /**
    Array containing labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_classes_ = bridgeOneVsOneClassifier[${this.id}].classes_`;
      return this._py`attr_OneVsOneClassifier_classes_.tolist() if hasattr(attr_OneVsOneClassifier_classes_, 'tolist') else attr_OneVsOneClassifier_classes_`;
    })();
  }
  /**
    Indices of samples used when training the estimators. `undefined` when `estimator`â€™s `pairwise` tag is `false`.
   */
  get pairwise_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing pairwise_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_pairwise_indices_ = bridgeOneVsOneClassifier[${this.id}].pairwise_indices_`;
      return this._py`attr_OneVsOneClassifier_pairwise_indices_.tolist() if hasattr(attr_OneVsOneClassifier_pairwise_indices_, 'tolist') else attr_OneVsOneClassifier_pairwise_indices_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_n_features_in_ = bridgeOneVsOneClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OneVsOneClassifier_n_features_in_.tolist() if hasattr(attr_OneVsOneClassifier_n_features_in_, 'tolist') else attr_OneVsOneClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_feature_names_in_ = bridgeOneVsOneClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OneVsOneClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsOneClassifier_feature_names_in_, 'tolist') else attr_OneVsOneClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multiclass/OneVsRestClassifier.ts
import crypto196 from "node:crypto";
var OneVsRestClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneVsRestClassifier${crypto196.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OneVsRestClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OneVsRestClassifier
try: bridgeOneVsRestClassifier
except NameError: bridgeOneVsRestClassifier = {}
`;
    await this._py.ex`ctor_OneVsRestClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_OneVsRestClassifier = {k: v for k, v in ctor_OneVsRestClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOneVsRestClassifier[${this.id}] = OneVsRestClassifier(**ctor_OneVsRestClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneVsRestClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Decision function for the OneVsRestClassifier.
  
      Return the distance of each sample from the decision boundary for each class. This can only be used with estimators which implement the `decision\_function` method.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_decision_function = {k: v for k, v in pms_OneVsRestClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_decision_function = bridgeOneVsRestClassifier[${this.id}].decision_function(**pms_OneVsRestClassifier_decision_function)`;
    return this._py`res_OneVsRestClassifier_decision_function.tolist() if hasattr(res_OneVsRestClassifier_decision_function, 'tolist') else res_OneVsRestClassifier_decision_function`;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OneVsRestClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OneVsRestClassifier_fit = {k: v for k, v in pms_OneVsRestClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_fit = bridgeOneVsRestClassifier[${this.id}].fit(**pms_OneVsRestClassifier_fit)`;
    return this._py`res_OneVsRestClassifier_fit.tolist() if hasattr(res_OneVsRestClassifier_fit, 'tolist') else res_OneVsRestClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OneVsRestClassifier_get_metadata_routing = {k: v for k, v in pms_OneVsRestClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_get_metadata_routing = bridgeOneVsRestClassifier[${this.id}].get_metadata_routing(**pms_OneVsRestClassifier_get_metadata_routing)`;
    return this._py`res_OneVsRestClassifier_get_metadata_routing.tolist() if hasattr(res_OneVsRestClassifier_get_metadata_routing, 'tolist') else res_OneVsRestClassifier_get_metadata_routing`;
  }
  /**
      Partially fit underlying estimators.
  
      Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': ${opts["classes"] ?? void 0}}

pms_OneVsRestClassifier_partial_fit = {k: v for k, v in pms_OneVsRestClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_partial_fit = bridgeOneVsRestClassifier[${this.id}].partial_fit(**pms_OneVsRestClassifier_partial_fit)`;
    return this._py`res_OneVsRestClassifier_partial_fit.tolist() if hasattr(res_OneVsRestClassifier_partial_fit, 'tolist') else res_OneVsRestClassifier_partial_fit`;
  }
  /**
    Predict multi-class targets using underlying estimators.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OneVsRestClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_predict = {k: v for k, v in pms_OneVsRestClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_predict = bridgeOneVsRestClassifier[${this.id}].predict(**pms_OneVsRestClassifier_predict)`;
    return this._py`res_OneVsRestClassifier_predict.tolist() if hasattr(res_OneVsRestClassifier_predict, 'tolist') else res_OneVsRestClassifier_predict`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by label of classes.
  
      Note that in the multilabel case, each sample can have any number of labels. This returns the marginal probability that the given sample has the label in question. For example, it is entirely consistent that two labels both have a 90% probability of applying to a given sample.
  
      In the single label multiclass case, the rows of the returned matrix sum to 1.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_predict_proba = {k: v for k, v in pms_OneVsRestClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_predict_proba = bridgeOneVsRestClassifier[${this.id}].predict_proba(**pms_OneVsRestClassifier_predict_proba)`;
    return this._py`res_OneVsRestClassifier_predict_proba.tolist() if hasattr(res_OneVsRestClassifier_predict_proba, 'tolist') else res_OneVsRestClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before score()");
    }
    await this._py.ex`pms_OneVsRestClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneVsRestClassifier_score = {k: v for k, v in pms_OneVsRestClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_score = bridgeOneVsRestClassifier[${this.id}].score(**pms_OneVsRestClassifier_score)`;
    return this._py`res_OneVsRestClassifier_score.tolist() if hasattr(res_OneVsRestClassifier_score, 'tolist') else res_OneVsRestClassifier_score`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}}

pms_OneVsRestClassifier_set_partial_fit_request = {k: v for k, v in pms_OneVsRestClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_set_partial_fit_request = bridgeOneVsRestClassifier[${this.id}].set_partial_fit_request(**pms_OneVsRestClassifier_set_partial_fit_request)`;
    return this._py`res_OneVsRestClassifier_set_partial_fit_request.tolist() if hasattr(res_OneVsRestClassifier_set_partial_fit_request, 'tolist') else res_OneVsRestClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OneVsRestClassifier_set_score_request = {k: v for k, v in pms_OneVsRestClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_set_score_request = bridgeOneVsRestClassifier[${this.id}].set_score_request(**pms_OneVsRestClassifier_set_score_request)`;
    return this._py`res_OneVsRestClassifier_set_score_request.tolist() if hasattr(res_OneVsRestClassifier_set_score_request, 'tolist') else res_OneVsRestClassifier_set_score_request`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_estimators_ = bridgeOneVsRestClassifier[${this.id}].estimators_`;
      return this._py`attr_OneVsRestClassifier_estimators_.tolist() if hasattr(attr_OneVsRestClassifier_estimators_, 'tolist') else attr_OneVsRestClassifier_estimators_`;
    })();
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_classes_ = bridgeOneVsRestClassifier[${this.id}].classes_`;
      return this._py`attr_OneVsRestClassifier_classes_.tolist() if hasattr(attr_OneVsRestClassifier_classes_, 'tolist') else attr_OneVsRestClassifier_classes_`;
    })();
  }
  /**
    Object used to transform multiclass labels to binary labels and vice-versa.
   */
  get label_binarizer_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing label_binarizer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_label_binarizer_ = bridgeOneVsRestClassifier[${this.id}].label_binarizer_`;
      return this._py`attr_OneVsRestClassifier_label_binarizer_.tolist() if hasattr(attr_OneVsRestClassifier_label_binarizer_, 'tolist') else attr_OneVsRestClassifier_label_binarizer_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_n_features_in_ = bridgeOneVsRestClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OneVsRestClassifier_n_features_in_.tolist() if hasattr(attr_OneVsRestClassifier_n_features_in_, 'tolist') else attr_OneVsRestClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_feature_names_in_ = bridgeOneVsRestClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OneVsRestClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsRestClassifier_feature_names_in_, 'tolist') else attr_OneVsRestClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multiclass/OutputCodeClassifier.ts
import crypto197 from "node:crypto";
var OutputCodeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OutputCodeClassifier${crypto197.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OutputCodeClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OutputCodeClassifier
try: bridgeOutputCodeClassifier
except NameError: bridgeOutputCodeClassifier = {}
`;
    await this._py.ex`ctor_OutputCodeClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'code_size': ${this.opts["code_size"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OutputCodeClassifier = {k: v for k, v in ctor_OutputCodeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOutputCodeClassifier[${this.id}] = OutputCodeClassifier(**ctor_OutputCodeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOutputCodeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OutputCodeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OutputCodeClassifier_fit = {k: v for k, v in pms_OutputCodeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_fit = bridgeOutputCodeClassifier[${this.id}].fit(**pms_OutputCodeClassifier_fit)`;
    return this._py`res_OutputCodeClassifier_fit.tolist() if hasattr(res_OutputCodeClassifier_fit, 'tolist') else res_OutputCodeClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OutputCodeClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OutputCodeClassifier_get_metadata_routing = {k: v for k, v in pms_OutputCodeClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_get_metadata_routing = bridgeOutputCodeClassifier[${this.id}].get_metadata_routing(**pms_OutputCodeClassifier_get_metadata_routing)`;
    return this._py`res_OutputCodeClassifier_get_metadata_routing.tolist() if hasattr(res_OutputCodeClassifier_get_metadata_routing, 'tolist') else res_OutputCodeClassifier_get_metadata_routing`;
  }
  /**
    Predict multi-class targets using underlying estimators.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OutputCodeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OutputCodeClassifier_predict = {k: v for k, v in pms_OutputCodeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_predict = bridgeOutputCodeClassifier[${this.id}].predict(**pms_OutputCodeClassifier_predict)`;
    return this._py`res_OutputCodeClassifier_predict.tolist() if hasattr(res_OutputCodeClassifier_predict, 'tolist') else res_OutputCodeClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before score()");
    }
    await this._py.ex`pms_OutputCodeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OutputCodeClassifier_score = {k: v for k, v in pms_OutputCodeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_score = bridgeOutputCodeClassifier[${this.id}].score(**pms_OutputCodeClassifier_score)`;
    return this._py`res_OutputCodeClassifier_score.tolist() if hasattr(res_OutputCodeClassifier_score, 'tolist') else res_OutputCodeClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OutputCodeClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OutputCodeClassifier_set_score_request = {k: v for k, v in pms_OutputCodeClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_set_score_request = bridgeOutputCodeClassifier[${this.id}].set_score_request(**pms_OutputCodeClassifier_set_score_request)`;
    return this._py`res_OutputCodeClassifier_set_score_request.tolist() if hasattr(res_OutputCodeClassifier_set_score_request, 'tolist') else res_OutputCodeClassifier_set_score_request`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_estimators_ = bridgeOutputCodeClassifier[${this.id}].estimators_`;
      return this._py`attr_OutputCodeClassifier_estimators_.tolist() if hasattr(attr_OutputCodeClassifier_estimators_, 'tolist') else attr_OutputCodeClassifier_estimators_`;
    })();
  }
  /**
    Array containing labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_classes_ = bridgeOutputCodeClassifier[${this.id}].classes_`;
      return this._py`attr_OutputCodeClassifier_classes_.tolist() if hasattr(attr_OutputCodeClassifier_classes_, 'tolist') else attr_OutputCodeClassifier_classes_`;
    })();
  }
  /**
    Binary array containing the code of each class.
   */
  get code_book_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing code_book_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_code_book_ = bridgeOutputCodeClassifier[${this.id}].code_book_`;
      return this._py`attr_OutputCodeClassifier_code_book_.tolist() if hasattr(attr_OutputCodeClassifier_code_book_, 'tolist') else attr_OutputCodeClassifier_code_book_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_n_features_in_ = bridgeOutputCodeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OutputCodeClassifier_n_features_in_.tolist() if hasattr(attr_OutputCodeClassifier_n_features_in_, 'tolist') else attr_OutputCodeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_feature_names_in_ = bridgeOutputCodeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OutputCodeClassifier_feature_names_in_.tolist() if hasattr(attr_OutputCodeClassifier_feature_names_in_, 'tolist') else attr_OutputCodeClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multioutput/ClassifierChain.ts
import crypto198 from "node:crypto";
var ClassifierChain = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ClassifierChain${crypto198.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ClassifierChain.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multioutput import ClassifierChain
try: bridgeClassifierChain
except NameError: bridgeClassifierChain = {}
`;
    await this._py.ex`ctor_ClassifierChain = {'base_estimator': ${this.opts["base_estimator"] ?? void 0}, 'order': np.array(${this.opts["order"] ?? void 0}) if ${this.opts["order"] !== void 0} else None, 'cv': ${this.opts["cv"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_ClassifierChain = {k: v for k, v in ctor_ClassifierChain.items() if v is not None}`;
    await this._py.ex`bridgeClassifierChain[${this.id}] = ClassifierChain(**ctor_ClassifierChain)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeClassifierChain[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision\_function of the models in the chain.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_ClassifierChain_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ClassifierChain_decision_function = {k: v for k, v in pms_ClassifierChain_decision_function.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_decision_function = bridgeClassifierChain[${this.id}].decision_function(**pms_ClassifierChain_decision_function)`;
    return this._py`res_ClassifierChain_decision_function.tolist() if hasattr(res_ClassifierChain_decision_function, 'tolist') else res_ClassifierChain_decision_function`;
  }
  /**
    Fit the model to data matrix X and targets Y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ClassifierChain must call init() before fit()");
    }
    await this._py.ex`pms_ClassifierChain_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_ClassifierChain_fit = {k: v for k, v in pms_ClassifierChain_fit.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_fit = bridgeClassifierChain[${this.id}].fit(**pms_ClassifierChain_fit)`;
    return this._py`res_ClassifierChain_fit.tolist() if hasattr(res_ClassifierChain_fit, 'tolist') else res_ClassifierChain_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ClassifierChain_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ClassifierChain_get_metadata_routing = {k: v for k, v in pms_ClassifierChain_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_get_metadata_routing = bridgeClassifierChain[${this.id}].get_metadata_routing(**pms_ClassifierChain_get_metadata_routing)`;
    return this._py`res_ClassifierChain_get_metadata_routing.tolist() if hasattr(res_ClassifierChain_get_metadata_routing, 'tolist') else res_ClassifierChain_get_metadata_routing`;
  }
  /**
    Predict on the data matrix X using the ClassifierChain model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ClassifierChain must call init() before predict()");
    }
    await this._py.ex`pms_ClassifierChain_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ClassifierChain_predict = {k: v for k, v in pms_ClassifierChain_predict.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_predict = bridgeClassifierChain[${this.id}].predict(**pms_ClassifierChain_predict)`;
    return this._py`res_ClassifierChain_predict.tolist() if hasattr(res_ClassifierChain_predict, 'tolist') else res_ClassifierChain_predict`;
  }
  /**
    Predict probability estimates.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ClassifierChain must call init() before predict_proba()");
    }
    await this._py.ex`pms_ClassifierChain_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ClassifierChain_predict_proba = {k: v for k, v in pms_ClassifierChain_predict_proba.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_predict_proba = bridgeClassifierChain[${this.id}].predict_proba(**pms_ClassifierChain_predict_proba)`;
    return this._py`res_ClassifierChain_predict_proba.tolist() if hasattr(res_ClassifierChain_predict_proba, 'tolist') else res_ClassifierChain_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ClassifierChain must call init() before score()");
    }
    await this._py.ex`pms_ClassifierChain_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ClassifierChain_score = {k: v for k, v in pms_ClassifierChain_score.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_score = bridgeClassifierChain[${this.id}].score(**pms_ClassifierChain_score)`;
    return this._py`res_ClassifierChain_score.tolist() if hasattr(res_ClassifierChain_score, 'tolist') else res_ClassifierChain_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ClassifierChain_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ClassifierChain_set_score_request = {k: v for k, v in pms_ClassifierChain_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ClassifierChain_set_score_request = bridgeClassifierChain[${this.id}].set_score_request(**pms_ClassifierChain_set_score_request)`;
    return this._py`res_ClassifierChain_set_score_request.tolist() if hasattr(res_ClassifierChain_set_score_request, 'tolist') else res_ClassifierChain_set_score_request`;
  }
  /**
    A list of arrays of length `len(estimators\_)` containing the class labels for each estimator in the chain.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ClassifierChain_classes_ = bridgeClassifierChain[${this.id}].classes_`;
      return this._py`attr_ClassifierChain_classes_.tolist() if hasattr(attr_ClassifierChain_classes_, 'tolist') else attr_ClassifierChain_classes_`;
    })();
  }
  /**
    A list of clones of base\_estimator.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ClassifierChain_estimators_ = bridgeClassifierChain[${this.id}].estimators_`;
      return this._py`attr_ClassifierChain_estimators_.tolist() if hasattr(attr_ClassifierChain_estimators_, 'tolist') else attr_ClassifierChain_estimators_`;
    })();
  }
  /**
    The order of labels in the classifier chain.
   */
  get order_() {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before accessing order_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ClassifierChain_order_ = bridgeClassifierChain[${this.id}].order_`;
      return this._py`attr_ClassifierChain_order_.tolist() if hasattr(attr_ClassifierChain_order_, 'tolist') else attr_ClassifierChain_order_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying `base\_estimator` exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ClassifierChain_n_features_in_ = bridgeClassifierChain[${this.id}].n_features_in_`;
      return this._py`attr_ClassifierChain_n_features_in_.tolist() if hasattr(attr_ClassifierChain_n_features_in_, 'tolist') else attr_ClassifierChain_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ClassifierChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ClassifierChain must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ClassifierChain_feature_names_in_ = bridgeClassifierChain[${this.id}].feature_names_in_`;
      return this._py`attr_ClassifierChain_feature_names_in_.tolist() if hasattr(attr_ClassifierChain_feature_names_in_, 'tolist') else attr_ClassifierChain_feature_names_in_`;
    })();
  }
};

// src/generated/multioutput/MultiOutputClassifier.ts
import crypto199 from "node:crypto";
var MultiOutputClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiOutputClassifier${crypto199.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiOutputClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multioutput import MultiOutputClassifier
try: bridgeMultiOutputClassifier
except NameError: bridgeMultiOutputClassifier = {}
`;
    await this._py.ex`ctor_MultiOutputClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_MultiOutputClassifier = {k: v for k, v in ctor_MultiOutputClassifier.items() if v is not None}`;
    await this._py.ex`bridgeMultiOutputClassifier[${this.id}] = MultiOutputClassifier(**ctor_MultiOutputClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiOutputClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to data matrix X and targets Y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputClassifier must call init() before fit()");
    }
    await this._py.ex`pms_MultiOutputClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MultiOutputClassifier_fit = {k: v for k, v in pms_MultiOutputClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_fit = bridgeMultiOutputClassifier[${this.id}].fit(**pms_MultiOutputClassifier_fit)`;
    return this._py`res_MultiOutputClassifier_fit.tolist() if hasattr(res_MultiOutputClassifier_fit, 'tolist') else res_MultiOutputClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiOutputClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiOutputClassifier_get_metadata_routing = {k: v for k, v in pms_MultiOutputClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_get_metadata_routing = bridgeMultiOutputClassifier[${this.id}].get_metadata_routing(**pms_MultiOutputClassifier_get_metadata_routing)`;
    return this._py`res_MultiOutputClassifier_get_metadata_routing.tolist() if hasattr(res_MultiOutputClassifier_get_metadata_routing, 'tolist') else res_MultiOutputClassifier_get_metadata_routing`;
  }
  /**
    Incrementally fit a separate model for each class output.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_MultiOutputClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'partial_fit_params': ${opts["partial_fit_params"] ?? void 0}}

pms_MultiOutputClassifier_partial_fit = {k: v for k, v in pms_MultiOutputClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_partial_fit = bridgeMultiOutputClassifier[${this.id}].partial_fit(**pms_MultiOutputClassifier_partial_fit)`;
    return this._py`res_MultiOutputClassifier_partial_fit.tolist() if hasattr(res_MultiOutputClassifier_partial_fit, 'tolist') else res_MultiOutputClassifier_partial_fit`;
  }
  /**
    Predict multi-output variable using model for each target variable.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputClassifier must call init() before predict()");
    }
    await this._py.ex`pms_MultiOutputClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultiOutputClassifier_predict = {k: v for k, v in pms_MultiOutputClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_predict = bridgeMultiOutputClassifier[${this.id}].predict(**pms_MultiOutputClassifier_predict)`;
    return this._py`res_MultiOutputClassifier_predict.tolist() if hasattr(res_MultiOutputClassifier_predict, 'tolist') else res_MultiOutputClassifier_predict`;
  }
  /**
      Return prediction probabilities for each class of each output.
  
      This method will raise a `ValueError` if any of the estimators do not have `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_MultiOutputClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultiOutputClassifier_predict_proba = {k: v for k, v in pms_MultiOutputClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_predict_proba = bridgeMultiOutputClassifier[${this.id}].predict_proba(**pms_MultiOutputClassifier_predict_proba)`;
    return this._py`res_MultiOutputClassifier_predict_proba.tolist() if hasattr(res_MultiOutputClassifier_predict_proba, 'tolist') else res_MultiOutputClassifier_predict_proba`;
  }
  /**
    Return the mean accuracy on the given test data and labels.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputClassifier must call init() before score()");
    }
    await this._py.ex`pms_MultiOutputClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiOutputClassifier_score = {k: v for k, v in pms_MultiOutputClassifier_score.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_score = bridgeMultiOutputClassifier[${this.id}].score(**pms_MultiOutputClassifier_score)`;
    return this._py`res_MultiOutputClassifier_score.tolist() if hasattr(res_MultiOutputClassifier_score, 'tolist') else res_MultiOutputClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiOutputClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiOutputClassifier_set_fit_request = {k: v for k, v in pms_MultiOutputClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_set_fit_request = bridgeMultiOutputClassifier[${this.id}].set_fit_request(**pms_MultiOutputClassifier_set_fit_request)`;
    return this._py`res_MultiOutputClassifier_set_fit_request.tolist() if hasattr(res_MultiOutputClassifier_set_fit_request, 'tolist') else res_MultiOutputClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MultiOutputClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiOutputClassifier_set_partial_fit_request = {k: v for k, v in pms_MultiOutputClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiOutputClassifier_set_partial_fit_request = bridgeMultiOutputClassifier[${this.id}].set_partial_fit_request(**pms_MultiOutputClassifier_set_partial_fit_request)`;
    return this._py`res_MultiOutputClassifier_set_partial_fit_request.tolist() if hasattr(res_MultiOutputClassifier_set_partial_fit_request, 'tolist') else res_MultiOutputClassifier_set_partial_fit_request`;
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputClassifier_classes_ = bridgeMultiOutputClassifier[${this.id}].classes_`;
      return this._py`attr_MultiOutputClassifier_classes_.tolist() if hasattr(attr_MultiOutputClassifier_classes_, 'tolist') else attr_MultiOutputClassifier_classes_`;
    })();
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputClassifier_estimators_ = bridgeMultiOutputClassifier[${this.id}].estimators_`;
      return this._py`attr_MultiOutputClassifier_estimators_.tolist() if hasattr(attr_MultiOutputClassifier_estimators_, 'tolist') else attr_MultiOutputClassifier_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying `estimator` exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputClassifier_n_features_in_ = bridgeMultiOutputClassifier[${this.id}].n_features_in_`;
      return this._py`attr_MultiOutputClassifier_n_features_in_.tolist() if hasattr(attr_MultiOutputClassifier_n_features_in_, 'tolist') else attr_MultiOutputClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputClassifier_feature_names_in_ = bridgeMultiOutputClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_MultiOutputClassifier_feature_names_in_.tolist() if hasattr(attr_MultiOutputClassifier_feature_names_in_, 'tolist') else attr_MultiOutputClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multioutput/MultiOutputRegressor.ts
import crypto200 from "node:crypto";
var MultiOutputRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiOutputRegressor${crypto200.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiOutputRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multioutput import MultiOutputRegressor
try: bridgeMultiOutputRegressor
except NameError: bridgeMultiOutputRegressor = {}
`;
    await this._py.ex`ctor_MultiOutputRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_MultiOutputRegressor = {k: v for k, v in ctor_MultiOutputRegressor.items() if v is not None}`;
    await this._py.ex`bridgeMultiOutputRegressor[${this.id}] = MultiOutputRegressor(**ctor_MultiOutputRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiOutputRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to data, separately for each output variable.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputRegressor must call init() before fit()");
    }
    await this._py.ex`pms_MultiOutputRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MultiOutputRegressor_fit = {k: v for k, v in pms_MultiOutputRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_fit = bridgeMultiOutputRegressor[${this.id}].fit(**pms_MultiOutputRegressor_fit)`;
    return this._py`res_MultiOutputRegressor_fit.tolist() if hasattr(res_MultiOutputRegressor_fit, 'tolist') else res_MultiOutputRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiOutputRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiOutputRegressor_get_metadata_routing = {k: v for k, v in pms_MultiOutputRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_get_metadata_routing = bridgeMultiOutputRegressor[${this.id}].get_metadata_routing(**pms_MultiOutputRegressor_get_metadata_routing)`;
    return this._py`res_MultiOutputRegressor_get_metadata_routing.tolist() if hasattr(res_MultiOutputRegressor_get_metadata_routing, 'tolist') else res_MultiOutputRegressor_get_metadata_routing`;
  }
  /**
    Incrementally fit the model to data, for each output variable.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_MultiOutputRegressor_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'partial_fit_params': ${opts["partial_fit_params"] ?? void 0}}

pms_MultiOutputRegressor_partial_fit = {k: v for k, v in pms_MultiOutputRegressor_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_partial_fit = bridgeMultiOutputRegressor[${this.id}].partial_fit(**pms_MultiOutputRegressor_partial_fit)`;
    return this._py`res_MultiOutputRegressor_partial_fit.tolist() if hasattr(res_MultiOutputRegressor_partial_fit, 'tolist') else res_MultiOutputRegressor_partial_fit`;
  }
  /**
    Predict multi-output variable using model for each target variable.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputRegressor must call init() before predict()");
    }
    await this._py.ex`pms_MultiOutputRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultiOutputRegressor_predict = {k: v for k, v in pms_MultiOutputRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_predict = bridgeMultiOutputRegressor[${this.id}].predict(**pms_MultiOutputRegressor_predict)`;
    return this._py`res_MultiOutputRegressor_predict.tolist() if hasattr(res_MultiOutputRegressor_predict, 'tolist') else res_MultiOutputRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiOutputRegressor must call init() before score()");
    }
    await this._py.ex`pms_MultiOutputRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiOutputRegressor_score = {k: v for k, v in pms_MultiOutputRegressor_score.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_score = bridgeMultiOutputRegressor[${this.id}].score(**pms_MultiOutputRegressor_score)`;
    return this._py`res_MultiOutputRegressor_score.tolist() if hasattr(res_MultiOutputRegressor_score, 'tolist') else res_MultiOutputRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiOutputRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiOutputRegressor_set_fit_request = {k: v for k, v in pms_MultiOutputRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_set_fit_request = bridgeMultiOutputRegressor[${this.id}].set_fit_request(**pms_MultiOutputRegressor_set_fit_request)`;
    return this._py`res_MultiOutputRegressor_set_fit_request.tolist() if hasattr(res_MultiOutputRegressor_set_fit_request, 'tolist') else res_MultiOutputRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MultiOutputRegressor_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiOutputRegressor_set_partial_fit_request = {k: v for k, v in pms_MultiOutputRegressor_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_set_partial_fit_request = bridgeMultiOutputRegressor[${this.id}].set_partial_fit_request(**pms_MultiOutputRegressor_set_partial_fit_request)`;
    return this._py`res_MultiOutputRegressor_set_partial_fit_request.tolist() if hasattr(res_MultiOutputRegressor_set_partial_fit_request, 'tolist') else res_MultiOutputRegressor_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiOutputRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiOutputRegressor_set_score_request = {k: v for k, v in pms_MultiOutputRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiOutputRegressor_set_score_request = bridgeMultiOutputRegressor[${this.id}].set_score_request(**pms_MultiOutputRegressor_set_score_request)`;
    return this._py`res_MultiOutputRegressor_set_score_request.tolist() if hasattr(res_MultiOutputRegressor_set_score_request, 'tolist') else res_MultiOutputRegressor_set_score_request`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputRegressor_estimators_ = bridgeMultiOutputRegressor[${this.id}].estimators_`;
      return this._py`attr_MultiOutputRegressor_estimators_.tolist() if hasattr(attr_MultiOutputRegressor_estimators_, 'tolist') else attr_MultiOutputRegressor_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying `estimator` exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputRegressor_n_features_in_ = bridgeMultiOutputRegressor[${this.id}].n_features_in_`;
      return this._py`attr_MultiOutputRegressor_n_features_in_.tolist() if hasattr(attr_MultiOutputRegressor_n_features_in_, 'tolist') else attr_MultiOutputRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimators expose such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiOutputRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiOutputRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiOutputRegressor_feature_names_in_ = bridgeMultiOutputRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_MultiOutputRegressor_feature_names_in_.tolist() if hasattr(attr_MultiOutputRegressor_feature_names_in_, 'tolist') else attr_MultiOutputRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/multioutput/RegressorChain.ts
import crypto201 from "node:crypto";
var RegressorChain = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RegressorChain${crypto201.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RegressorChain.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multioutput import RegressorChain
try: bridgeRegressorChain
except NameError: bridgeRegressorChain = {}
`;
    await this._py.ex`ctor_RegressorChain = {'base_estimator': ${this.opts["base_estimator"] ?? void 0}, 'order': np.array(${this.opts["order"] ?? void 0}) if ${this.opts["order"] !== void 0} else None, 'cv': ${this.opts["cv"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_RegressorChain = {k: v for k, v in ctor_RegressorChain.items() if v is not None}`;
    await this._py.ex`bridgeRegressorChain[${this.id}] = RegressorChain(**ctor_RegressorChain)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRegressorChain[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to data matrix X and targets Y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RegressorChain must call init() before fit()");
    }
    await this._py.ex`pms_RegressorChain_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RegressorChain_fit = {k: v for k, v in pms_RegressorChain_fit.items() if v is not None}`;
    await this._py.ex`res_RegressorChain_fit = bridgeRegressorChain[${this.id}].fit(**pms_RegressorChain_fit)`;
    return this._py`res_RegressorChain_fit.tolist() if hasattr(res_RegressorChain_fit, 'tolist') else res_RegressorChain_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RegressorChain must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RegressorChain_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RegressorChain_get_metadata_routing = {k: v for k, v in pms_RegressorChain_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RegressorChain_get_metadata_routing = bridgeRegressorChain[${this.id}].get_metadata_routing(**pms_RegressorChain_get_metadata_routing)`;
    return this._py`res_RegressorChain_get_metadata_routing.tolist() if hasattr(res_RegressorChain_get_metadata_routing, 'tolist') else res_RegressorChain_get_metadata_routing`;
  }
  /**
    Predict on the data matrix X using the ClassifierChain model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RegressorChain must call init() before predict()");
    }
    await this._py.ex`pms_RegressorChain_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RegressorChain_predict = {k: v for k, v in pms_RegressorChain_predict.items() if v is not None}`;
    await this._py.ex`res_RegressorChain_predict = bridgeRegressorChain[${this.id}].predict(**pms_RegressorChain_predict)`;
    return this._py`res_RegressorChain_predict.tolist() if hasattr(res_RegressorChain_predict, 'tolist') else res_RegressorChain_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RegressorChain must call init() before score()");
    }
    await this._py.ex`pms_RegressorChain_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RegressorChain_score = {k: v for k, v in pms_RegressorChain_score.items() if v is not None}`;
    await this._py.ex`res_RegressorChain_score = bridgeRegressorChain[${this.id}].score(**pms_RegressorChain_score)`;
    return this._py`res_RegressorChain_score.tolist() if hasattr(res_RegressorChain_score, 'tolist') else res_RegressorChain_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RegressorChain must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RegressorChain_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RegressorChain_set_score_request = {k: v for k, v in pms_RegressorChain_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RegressorChain_set_score_request = bridgeRegressorChain[${this.id}].set_score_request(**pms_RegressorChain_set_score_request)`;
    return this._py`res_RegressorChain_set_score_request.tolist() if hasattr(res_RegressorChain_set_score_request, 'tolist') else res_RegressorChain_set_score_request`;
  }
  /**
    A list of clones of base\_estimator.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RegressorChain must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RegressorChain_estimators_ = bridgeRegressorChain[${this.id}].estimators_`;
      return this._py`attr_RegressorChain_estimators_.tolist() if hasattr(attr_RegressorChain_estimators_, 'tolist') else attr_RegressorChain_estimators_`;
    })();
  }
  /**
    The order of labels in the classifier chain.
   */
  get order_() {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RegressorChain must call init() before accessing order_");
    }
    return (async () => {
      await this._py.ex`attr_RegressorChain_order_ = bridgeRegressorChain[${this.id}].order_`;
      return this._py`attr_RegressorChain_order_.tolist() if hasattr(attr_RegressorChain_order_, 'tolist') else attr_RegressorChain_order_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying `base\_estimator` exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RegressorChain must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RegressorChain_n_features_in_ = bridgeRegressorChain[${this.id}].n_features_in_`;
      return this._py`attr_RegressorChain_n_features_in_.tolist() if hasattr(attr_RegressorChain_n_features_in_, 'tolist') else attr_RegressorChain_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RegressorChain instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RegressorChain must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RegressorChain_feature_names_in_ = bridgeRegressorChain[${this.id}].feature_names_in_`;
      return this._py`attr_RegressorChain_feature_names_in_.tolist() if hasattr(attr_RegressorChain_feature_names_in_, 'tolist') else attr_RegressorChain_feature_names_in_`;
    })();
  }
};

// src/generated/naive_bayes/BernoulliNB.ts
import crypto202 from "node:crypto";
var BernoulliNB = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BernoulliNB${crypto202.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BernoulliNB.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.naive_bayes import BernoulliNB
try: bridgeBernoulliNB
except NameError: bridgeBernoulliNB = {}
`;
    await this._py.ex`ctor_BernoulliNB = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'force_alpha': ${this.opts["force_alpha"] ?? void 0}, 'binarize': ${this.opts["binarize"] ?? void 0}, 'fit_prior': ${this.opts["fit_prior"] ?? void 0}, 'class_prior': np.array(${this.opts["class_prior"] ?? void 0}) if ${this.opts["class_prior"] !== void 0} else None}

ctor_BernoulliNB = {k: v for k, v in ctor_BernoulliNB.items() if v is not None}`;
    await this._py.ex`bridgeBernoulliNB[${this.id}] = BernoulliNB(**ctor_BernoulliNB)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBernoulliNB[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Naive Bayes classifier according to X, y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before fit()");
    }
    await this._py.ex`pms_BernoulliNB_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BernoulliNB_fit = {k: v for k, v in pms_BernoulliNB_fit.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_fit = bridgeBernoulliNB[${this.id}].fit(**pms_BernoulliNB_fit)`;
    return this._py`res_BernoulliNB_fit.tolist() if hasattr(res_BernoulliNB_fit, 'tolist') else res_BernoulliNB_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BernoulliNB_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BernoulliNB_get_metadata_routing = {k: v for k, v in pms_BernoulliNB_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_get_metadata_routing = bridgeBernoulliNB[${this.id}].get_metadata_routing(**pms_BernoulliNB_get_metadata_routing)`;
    return this._py`res_BernoulliNB_get_metadata_routing.tolist() if hasattr(res_BernoulliNB_get_metadata_routing, 'tolist') else res_BernoulliNB_get_metadata_routing`;
  }
  /**
      Incremental fit on a batch of samples.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once.
  
      This method has some performance overhead hence it is better to call partial\_fit on chunks of data that are as large as possible (as long as fitting in the memory budget) to hide the overhead.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before partial_fit()");
    }
    await this._py.ex`pms_BernoulliNB_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BernoulliNB_partial_fit = {k: v for k, v in pms_BernoulliNB_partial_fit.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_partial_fit = bridgeBernoulliNB[${this.id}].partial_fit(**pms_BernoulliNB_partial_fit)`;
    return this._py`res_BernoulliNB_partial_fit.tolist() if hasattr(res_BernoulliNB_partial_fit, 'tolist') else res_BernoulliNB_partial_fit`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before predict()");
    }
    await this._py.ex`pms_BernoulliNB_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliNB_predict = {k: v for k, v in pms_BernoulliNB_predict.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_predict = bridgeBernoulliNB[${this.id}].predict(**pms_BernoulliNB_predict)`;
    return this._py`res_BernoulliNB_predict.tolist() if hasattr(res_BernoulliNB_predict, 'tolist') else res_BernoulliNB_predict`;
  }
  /**
      Return joint log probability estimates for the test vector X.
  
      For each row x of X and class y, the joint log probability is given by `log P(x, y) \= log P(y) + log P(x|y),` where `log P(y)` is the class prior probability and `log P(x|y)` is the class-conditional probability.
     */
  async predict_joint_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before predict_joint_log_proba()"
      );
    }
    await this._py.ex`pms_BernoulliNB_predict_joint_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliNB_predict_joint_log_proba = {k: v for k, v in pms_BernoulliNB_predict_joint_log_proba.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_predict_joint_log_proba = bridgeBernoulliNB[${this.id}].predict_joint_log_proba(**pms_BernoulliNB_predict_joint_log_proba)`;
    return this._py`res_BernoulliNB_predict_joint_log_proba.tolist() if hasattr(res_BernoulliNB_predict_joint_log_proba, 'tolist') else res_BernoulliNB_predict_joint_log_proba`;
  }
  /**
    Return log-probability estimates for the test vector X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_BernoulliNB_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliNB_predict_log_proba = {k: v for k, v in pms_BernoulliNB_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_predict_log_proba = bridgeBernoulliNB[${this.id}].predict_log_proba(**pms_BernoulliNB_predict_log_proba)`;
    return this._py`res_BernoulliNB_predict_log_proba.tolist() if hasattr(res_BernoulliNB_predict_log_proba, 'tolist') else res_BernoulliNB_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before predict_proba()");
    }
    await this._py.ex`pms_BernoulliNB_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliNB_predict_proba = {k: v for k, v in pms_BernoulliNB_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_predict_proba = bridgeBernoulliNB[${this.id}].predict_proba(**pms_BernoulliNB_predict_proba)`;
    return this._py`res_BernoulliNB_predict_proba.tolist() if hasattr(res_BernoulliNB_predict_proba, 'tolist') else res_BernoulliNB_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before score()");
    }
    await this._py.ex`pms_BernoulliNB_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BernoulliNB_score = {k: v for k, v in pms_BernoulliNB_score.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_score = bridgeBernoulliNB[${this.id}].score(**pms_BernoulliNB_score)`;
    return this._py`res_BernoulliNB_score.tolist() if hasattr(res_BernoulliNB_score, 'tolist') else res_BernoulliNB_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before set_fit_request()");
    }
    await this._py.ex`pms_BernoulliNB_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BernoulliNB_set_fit_request = {k: v for k, v in pms_BernoulliNB_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_set_fit_request = bridgeBernoulliNB[${this.id}].set_fit_request(**pms_BernoulliNB_set_fit_request)`;
    return this._py`res_BernoulliNB_set_fit_request.tolist() if hasattr(res_BernoulliNB_set_fit_request, 'tolist') else res_BernoulliNB_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_BernoulliNB_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BernoulliNB_set_partial_fit_request = {k: v for k, v in pms_BernoulliNB_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_set_partial_fit_request = bridgeBernoulliNB[${this.id}].set_partial_fit_request(**pms_BernoulliNB_set_partial_fit_request)`;
    return this._py`res_BernoulliNB_set_partial_fit_request.tolist() if hasattr(res_BernoulliNB_set_partial_fit_request, 'tolist') else res_BernoulliNB_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before set_score_request()");
    }
    await this._py.ex`pms_BernoulliNB_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BernoulliNB_set_score_request = {k: v for k, v in pms_BernoulliNB_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BernoulliNB_set_score_request = bridgeBernoulliNB[${this.id}].set_score_request(**pms_BernoulliNB_set_score_request)`;
    return this._py`res_BernoulliNB_set_score_request.tolist() if hasattr(res_BernoulliNB_set_score_request, 'tolist') else res_BernoulliNB_set_score_request`;
  }
  /**
    Number of samples encountered for each class during fitting. This value is weighted by the sample weight when provided.
   */
  get class_count_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing class_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_class_count_ = bridgeBernoulliNB[${this.id}].class_count_`;
      return this._py`attr_BernoulliNB_class_count_.tolist() if hasattr(attr_BernoulliNB_class_count_, 'tolist') else attr_BernoulliNB_class_count_`;
    })();
  }
  /**
    Log probability of each class (smoothed).
   */
  get class_log_prior_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing class_log_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_class_log_prior_ = bridgeBernoulliNB[${this.id}].class_log_prior_`;
      return this._py`attr_BernoulliNB_class_log_prior_.tolist() if hasattr(attr_BernoulliNB_class_log_prior_, 'tolist') else attr_BernoulliNB_class_log_prior_`;
    })();
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliNB must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_classes_ = bridgeBernoulliNB[${this.id}].classes_`;
      return this._py`attr_BernoulliNB_classes_.tolist() if hasattr(attr_BernoulliNB_classes_, 'tolist') else attr_BernoulliNB_classes_`;
    })();
  }
  /**
    Number of samples encountered for each (class, feature) during fitting. This value is weighted by the sample weight when provided.
   */
  get feature_count_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing feature_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_feature_count_ = bridgeBernoulliNB[${this.id}].feature_count_`;
      return this._py`attr_BernoulliNB_feature_count_.tolist() if hasattr(attr_BernoulliNB_feature_count_, 'tolist') else attr_BernoulliNB_feature_count_`;
    })();
  }
  /**
    Empirical log probability of features given a class, P(x\_i|y).
   */
  get feature_log_prob_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing feature_log_prob_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_feature_log_prob_ = bridgeBernoulliNB[${this.id}].feature_log_prob_`;
      return this._py`attr_BernoulliNB_feature_log_prob_.tolist() if hasattr(attr_BernoulliNB_feature_log_prob_, 'tolist') else attr_BernoulliNB_feature_log_prob_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_n_features_in_ = bridgeBernoulliNB[${this.id}].n_features_in_`;
      return this._py`attr_BernoulliNB_n_features_in_.tolist() if hasattr(attr_BernoulliNB_n_features_in_, 'tolist') else attr_BernoulliNB_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliNB must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliNB_feature_names_in_ = bridgeBernoulliNB[${this.id}].feature_names_in_`;
      return this._py`attr_BernoulliNB_feature_names_in_.tolist() if hasattr(attr_BernoulliNB_feature_names_in_, 'tolist') else attr_BernoulliNB_feature_names_in_`;
    })();
  }
};

// src/generated/naive_bayes/CategoricalNB.ts
import crypto203 from "node:crypto";
var CategoricalNB = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CategoricalNB${crypto203.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CategoricalNB.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.naive_bayes import CategoricalNB
try: bridgeCategoricalNB
except NameError: bridgeCategoricalNB = {}
`;
    await this._py.ex`ctor_CategoricalNB = {'alpha': ${this.opts["alpha"] ?? void 0}, 'force_alpha': ${this.opts["force_alpha"] ?? void 0}, 'fit_prior': ${this.opts["fit_prior"] ?? void 0}, 'class_prior': np.array(${this.opts["class_prior"] ?? void 0}) if ${this.opts["class_prior"] !== void 0} else None, 'min_categories': np.array(${this.opts["min_categories"] ?? void 0}) if ${this.opts["min_categories"] !== void 0} else None}

ctor_CategoricalNB = {k: v for k, v in ctor_CategoricalNB.items() if v is not None}`;
    await this._py.ex`bridgeCategoricalNB[${this.id}] = CategoricalNB(**ctor_CategoricalNB)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCategoricalNB[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Naive Bayes classifier according to X, y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before fit()");
    }
    await this._py.ex`pms_CategoricalNB_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CategoricalNB_fit = {k: v for k, v in pms_CategoricalNB_fit.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_fit = bridgeCategoricalNB[${this.id}].fit(**pms_CategoricalNB_fit)`;
    return this._py`res_CategoricalNB_fit.tolist() if hasattr(res_CategoricalNB_fit, 'tolist') else res_CategoricalNB_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_CategoricalNB_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CategoricalNB_get_metadata_routing = {k: v for k, v in pms_CategoricalNB_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_get_metadata_routing = bridgeCategoricalNB[${this.id}].get_metadata_routing(**pms_CategoricalNB_get_metadata_routing)`;
    return this._py`res_CategoricalNB_get_metadata_routing.tolist() if hasattr(res_CategoricalNB_get_metadata_routing, 'tolist') else res_CategoricalNB_get_metadata_routing`;
  }
  /**
      Incremental fit on a batch of samples.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once.
  
      This method has some performance overhead hence it is better to call partial\_fit on chunks of data that are as large as possible (as long as fitting in the memory budget) to hide the overhead.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before partial_fit()");
    }
    await this._py.ex`pms_CategoricalNB_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CategoricalNB_partial_fit = {k: v for k, v in pms_CategoricalNB_partial_fit.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_partial_fit = bridgeCategoricalNB[${this.id}].partial_fit(**pms_CategoricalNB_partial_fit)`;
    return this._py`res_CategoricalNB_partial_fit.tolist() if hasattr(res_CategoricalNB_partial_fit, 'tolist') else res_CategoricalNB_partial_fit`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before predict()");
    }
    await this._py.ex`pms_CategoricalNB_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CategoricalNB_predict = {k: v for k, v in pms_CategoricalNB_predict.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_predict = bridgeCategoricalNB[${this.id}].predict(**pms_CategoricalNB_predict)`;
    return this._py`res_CategoricalNB_predict.tolist() if hasattr(res_CategoricalNB_predict, 'tolist') else res_CategoricalNB_predict`;
  }
  /**
      Return joint log probability estimates for the test vector X.
  
      For each row x of X and class y, the joint log probability is given by `log P(x, y) \= log P(y) + log P(x|y),` where `log P(y)` is the class prior probability and `log P(x|y)` is the class-conditional probability.
     */
  async predict_joint_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before predict_joint_log_proba()"
      );
    }
    await this._py.ex`pms_CategoricalNB_predict_joint_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CategoricalNB_predict_joint_log_proba = {k: v for k, v in pms_CategoricalNB_predict_joint_log_proba.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_predict_joint_log_proba = bridgeCategoricalNB[${this.id}].predict_joint_log_proba(**pms_CategoricalNB_predict_joint_log_proba)`;
    return this._py`res_CategoricalNB_predict_joint_log_proba.tolist() if hasattr(res_CategoricalNB_predict_joint_log_proba, 'tolist') else res_CategoricalNB_predict_joint_log_proba`;
  }
  /**
    Return log-probability estimates for the test vector X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_CategoricalNB_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CategoricalNB_predict_log_proba = {k: v for k, v in pms_CategoricalNB_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_predict_log_proba = bridgeCategoricalNB[${this.id}].predict_log_proba(**pms_CategoricalNB_predict_log_proba)`;
    return this._py`res_CategoricalNB_predict_log_proba.tolist() if hasattr(res_CategoricalNB_predict_log_proba, 'tolist') else res_CategoricalNB_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before predict_proba()");
    }
    await this._py.ex`pms_CategoricalNB_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CategoricalNB_predict_proba = {k: v for k, v in pms_CategoricalNB_predict_proba.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_predict_proba = bridgeCategoricalNB[${this.id}].predict_proba(**pms_CategoricalNB_predict_proba)`;
    return this._py`res_CategoricalNB_predict_proba.tolist() if hasattr(res_CategoricalNB_predict_proba, 'tolist') else res_CategoricalNB_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before score()");
    }
    await this._py.ex`pms_CategoricalNB_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CategoricalNB_score = {k: v for k, v in pms_CategoricalNB_score.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_score = bridgeCategoricalNB[${this.id}].score(**pms_CategoricalNB_score)`;
    return this._py`res_CategoricalNB_score.tolist() if hasattr(res_CategoricalNB_score, 'tolist') else res_CategoricalNB_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CategoricalNB must call init() before set_fit_request()");
    }
    await this._py.ex`pms_CategoricalNB_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CategoricalNB_set_fit_request = {k: v for k, v in pms_CategoricalNB_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_set_fit_request = bridgeCategoricalNB[${this.id}].set_fit_request(**pms_CategoricalNB_set_fit_request)`;
    return this._py`res_CategoricalNB_set_fit_request.tolist() if hasattr(res_CategoricalNB_set_fit_request, 'tolist') else res_CategoricalNB_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_CategoricalNB_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CategoricalNB_set_partial_fit_request = {k: v for k, v in pms_CategoricalNB_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_set_partial_fit_request = bridgeCategoricalNB[${this.id}].set_partial_fit_request(**pms_CategoricalNB_set_partial_fit_request)`;
    return this._py`res_CategoricalNB_set_partial_fit_request.tolist() if hasattr(res_CategoricalNB_set_partial_fit_request, 'tolist') else res_CategoricalNB_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_CategoricalNB_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CategoricalNB_set_score_request = {k: v for k, v in pms_CategoricalNB_set_score_request.items() if v is not None}`;
    await this._py.ex`res_CategoricalNB_set_score_request = bridgeCategoricalNB[${this.id}].set_score_request(**pms_CategoricalNB_set_score_request)`;
    return this._py`res_CategoricalNB_set_score_request.tolist() if hasattr(res_CategoricalNB_set_score_request, 'tolist') else res_CategoricalNB_set_score_request`;
  }
  /**
    Holds arrays of shape (n\_classes, n\_categories of respective feature) for each feature. Each array provides the number of samples encountered for each class and category of the specific feature.
   */
  get category_count_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing category_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_category_count_ = bridgeCategoricalNB[${this.id}].category_count_`;
      return this._py`attr_CategoricalNB_category_count_.tolist() if hasattr(attr_CategoricalNB_category_count_, 'tolist') else attr_CategoricalNB_category_count_`;
    })();
  }
  /**
    Number of samples encountered for each class during fitting. This value is weighted by the sample weight when provided.
   */
  get class_count_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing class_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_class_count_ = bridgeCategoricalNB[${this.id}].class_count_`;
      return this._py`attr_CategoricalNB_class_count_.tolist() if hasattr(attr_CategoricalNB_class_count_, 'tolist') else attr_CategoricalNB_class_count_`;
    })();
  }
  /**
    Smoothed empirical log probability for each class.
   */
  get class_log_prior_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing class_log_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_class_log_prior_ = bridgeCategoricalNB[${this.id}].class_log_prior_`;
      return this._py`attr_CategoricalNB_class_log_prior_.tolist() if hasattr(attr_CategoricalNB_class_log_prior_, 'tolist') else attr_CategoricalNB_class_log_prior_`;
    })();
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_classes_ = bridgeCategoricalNB[${this.id}].classes_`;
      return this._py`attr_CategoricalNB_classes_.tolist() if hasattr(attr_CategoricalNB_classes_, 'tolist') else attr_CategoricalNB_classes_`;
    })();
  }
  /**
    Holds arrays of shape (n\_classes, n\_categories of respective feature) for each feature. Each array provides the empirical log probability of categories given the respective feature and class, `P(x\_i|y)`.
   */
  get feature_log_prob_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing feature_log_prob_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_feature_log_prob_ = bridgeCategoricalNB[${this.id}].feature_log_prob_`;
      return this._py`attr_CategoricalNB_feature_log_prob_.tolist() if hasattr(attr_CategoricalNB_feature_log_prob_, 'tolist') else attr_CategoricalNB_feature_log_prob_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_n_features_in_ = bridgeCategoricalNB[${this.id}].n_features_in_`;
      return this._py`attr_CategoricalNB_n_features_in_.tolist() if hasattr(attr_CategoricalNB_n_features_in_, 'tolist') else attr_CategoricalNB_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_feature_names_in_ = bridgeCategoricalNB[${this.id}].feature_names_in_`;
      return this._py`attr_CategoricalNB_feature_names_in_.tolist() if hasattr(attr_CategoricalNB_feature_names_in_, 'tolist') else attr_CategoricalNB_feature_names_in_`;
    })();
  }
  /**
    Number of categories for each feature. This value is inferred from the data or set by the minimum number of categories.
   */
  get n_categories_() {
    if (this._isDisposed) {
      throw new Error("This CategoricalNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CategoricalNB must call init() before accessing n_categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CategoricalNB_n_categories_ = bridgeCategoricalNB[${this.id}].n_categories_`;
      return this._py`attr_CategoricalNB_n_categories_.tolist() if hasattr(attr_CategoricalNB_n_categories_, 'tolist') else attr_CategoricalNB_n_categories_`;
    })();
  }
};

// src/generated/naive_bayes/ComplementNB.ts
import crypto204 from "node:crypto";
var ComplementNB = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ComplementNB${crypto204.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ComplementNB.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.naive_bayes import ComplementNB
try: bridgeComplementNB
except NameError: bridgeComplementNB = {}
`;
    await this._py.ex`ctor_ComplementNB = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'force_alpha': ${this.opts["force_alpha"] ?? void 0}, 'fit_prior': ${this.opts["fit_prior"] ?? void 0}, 'class_prior': np.array(${this.opts["class_prior"] ?? void 0}) if ${this.opts["class_prior"] !== void 0} else None, 'norm': ${this.opts["norm"] ?? void 0}}

ctor_ComplementNB = {k: v for k, v in ctor_ComplementNB.items() if v is not None}`;
    await this._py.ex`bridgeComplementNB[${this.id}] = ComplementNB(**ctor_ComplementNB)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeComplementNB[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Naive Bayes classifier according to X, y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before fit()");
    }
    await this._py.ex`pms_ComplementNB_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ComplementNB_fit = {k: v for k, v in pms_ComplementNB_fit.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_fit = bridgeComplementNB[${this.id}].fit(**pms_ComplementNB_fit)`;
    return this._py`res_ComplementNB_fit.tolist() if hasattr(res_ComplementNB_fit, 'tolist') else res_ComplementNB_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ComplementNB_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ComplementNB_get_metadata_routing = {k: v for k, v in pms_ComplementNB_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_get_metadata_routing = bridgeComplementNB[${this.id}].get_metadata_routing(**pms_ComplementNB_get_metadata_routing)`;
    return this._py`res_ComplementNB_get_metadata_routing.tolist() if hasattr(res_ComplementNB_get_metadata_routing, 'tolist') else res_ComplementNB_get_metadata_routing`;
  }
  /**
      Incremental fit on a batch of samples.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once.
  
      This method has some performance overhead hence it is better to call partial\_fit on chunks of data that are as large as possible (as long as fitting in the memory budget) to hide the overhead.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before partial_fit()");
    }
    await this._py.ex`pms_ComplementNB_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ComplementNB_partial_fit = {k: v for k, v in pms_ComplementNB_partial_fit.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_partial_fit = bridgeComplementNB[${this.id}].partial_fit(**pms_ComplementNB_partial_fit)`;
    return this._py`res_ComplementNB_partial_fit.tolist() if hasattr(res_ComplementNB_partial_fit, 'tolist') else res_ComplementNB_partial_fit`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before predict()");
    }
    await this._py.ex`pms_ComplementNB_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ComplementNB_predict = {k: v for k, v in pms_ComplementNB_predict.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_predict = bridgeComplementNB[${this.id}].predict(**pms_ComplementNB_predict)`;
    return this._py`res_ComplementNB_predict.tolist() if hasattr(res_ComplementNB_predict, 'tolist') else res_ComplementNB_predict`;
  }
  /**
      Return joint log probability estimates for the test vector X.
  
      For each row x of X and class y, the joint log probability is given by `log P(x, y) \= log P(y) + log P(x|y),` where `log P(y)` is the class prior probability and `log P(x|y)` is the class-conditional probability.
     */
  async predict_joint_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before predict_joint_log_proba()"
      );
    }
    await this._py.ex`pms_ComplementNB_predict_joint_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ComplementNB_predict_joint_log_proba = {k: v for k, v in pms_ComplementNB_predict_joint_log_proba.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_predict_joint_log_proba = bridgeComplementNB[${this.id}].predict_joint_log_proba(**pms_ComplementNB_predict_joint_log_proba)`;
    return this._py`res_ComplementNB_predict_joint_log_proba.tolist() if hasattr(res_ComplementNB_predict_joint_log_proba, 'tolist') else res_ComplementNB_predict_joint_log_proba`;
  }
  /**
    Return log-probability estimates for the test vector X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_ComplementNB_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ComplementNB_predict_log_proba = {k: v for k, v in pms_ComplementNB_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_predict_log_proba = bridgeComplementNB[${this.id}].predict_log_proba(**pms_ComplementNB_predict_log_proba)`;
    return this._py`res_ComplementNB_predict_log_proba.tolist() if hasattr(res_ComplementNB_predict_log_proba, 'tolist') else res_ComplementNB_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before predict_proba()");
    }
    await this._py.ex`pms_ComplementNB_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ComplementNB_predict_proba = {k: v for k, v in pms_ComplementNB_predict_proba.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_predict_proba = bridgeComplementNB[${this.id}].predict_proba(**pms_ComplementNB_predict_proba)`;
    return this._py`res_ComplementNB_predict_proba.tolist() if hasattr(res_ComplementNB_predict_proba, 'tolist') else res_ComplementNB_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before score()");
    }
    await this._py.ex`pms_ComplementNB_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ComplementNB_score = {k: v for k, v in pms_ComplementNB_score.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_score = bridgeComplementNB[${this.id}].score(**pms_ComplementNB_score)`;
    return this._py`res_ComplementNB_score.tolist() if hasattr(res_ComplementNB_score, 'tolist') else res_ComplementNB_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before set_fit_request()");
    }
    await this._py.ex`pms_ComplementNB_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ComplementNB_set_fit_request = {k: v for k, v in pms_ComplementNB_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_set_fit_request = bridgeComplementNB[${this.id}].set_fit_request(**pms_ComplementNB_set_fit_request)`;
    return this._py`res_ComplementNB_set_fit_request.tolist() if hasattr(res_ComplementNB_set_fit_request, 'tolist') else res_ComplementNB_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_ComplementNB_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ComplementNB_set_partial_fit_request = {k: v for k, v in pms_ComplementNB_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_set_partial_fit_request = bridgeComplementNB[${this.id}].set_partial_fit_request(**pms_ComplementNB_set_partial_fit_request)`;
    return this._py`res_ComplementNB_set_partial_fit_request.tolist() if hasattr(res_ComplementNB_set_partial_fit_request, 'tolist') else res_ComplementNB_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ComplementNB_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ComplementNB_set_score_request = {k: v for k, v in pms_ComplementNB_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ComplementNB_set_score_request = bridgeComplementNB[${this.id}].set_score_request(**pms_ComplementNB_set_score_request)`;
    return this._py`res_ComplementNB_set_score_request.tolist() if hasattr(res_ComplementNB_set_score_request, 'tolist') else res_ComplementNB_set_score_request`;
  }
  /**
    Number of samples encountered for each class during fitting. This value is weighted by the sample weight when provided.
   */
  get class_count_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing class_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_class_count_ = bridgeComplementNB[${this.id}].class_count_`;
      return this._py`attr_ComplementNB_class_count_.tolist() if hasattr(attr_ComplementNB_class_count_, 'tolist') else attr_ComplementNB_class_count_`;
    })();
  }
  /**
    Smoothed empirical log probability for each class. Only used in edge case with a single class in the training set.
   */
  get class_log_prior_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing class_log_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_class_log_prior_ = bridgeComplementNB[${this.id}].class_log_prior_`;
      return this._py`attr_ComplementNB_class_log_prior_.tolist() if hasattr(attr_ComplementNB_class_log_prior_, 'tolist') else attr_ComplementNB_class_log_prior_`;
    })();
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ComplementNB must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_classes_ = bridgeComplementNB[${this.id}].classes_`;
      return this._py`attr_ComplementNB_classes_.tolist() if hasattr(attr_ComplementNB_classes_, 'tolist') else attr_ComplementNB_classes_`;
    })();
  }
  /**
    Number of samples encountered for each feature during fitting. This value is weighted by the sample weight when provided.
   */
  get feature_all_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing feature_all_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_feature_all_ = bridgeComplementNB[${this.id}].feature_all_`;
      return this._py`attr_ComplementNB_feature_all_.tolist() if hasattr(attr_ComplementNB_feature_all_, 'tolist') else attr_ComplementNB_feature_all_`;
    })();
  }
  /**
    Number of samples encountered for each (class, feature) during fitting. This value is weighted by the sample weight when provided.
   */
  get feature_count_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing feature_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_feature_count_ = bridgeComplementNB[${this.id}].feature_count_`;
      return this._py`attr_ComplementNB_feature_count_.tolist() if hasattr(attr_ComplementNB_feature_count_, 'tolist') else attr_ComplementNB_feature_count_`;
    })();
  }
  /**
    Empirical weights for class complements.
   */
  get feature_log_prob_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing feature_log_prob_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_feature_log_prob_ = bridgeComplementNB[${this.id}].feature_log_prob_`;
      return this._py`attr_ComplementNB_feature_log_prob_.tolist() if hasattr(attr_ComplementNB_feature_log_prob_, 'tolist') else attr_ComplementNB_feature_log_prob_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_n_features_in_ = bridgeComplementNB[${this.id}].n_features_in_`;
      return this._py`attr_ComplementNB_n_features_in_.tolist() if hasattr(attr_ComplementNB_n_features_in_, 'tolist') else attr_ComplementNB_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ComplementNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ComplementNB must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ComplementNB_feature_names_in_ = bridgeComplementNB[${this.id}].feature_names_in_`;
      return this._py`attr_ComplementNB_feature_names_in_.tolist() if hasattr(attr_ComplementNB_feature_names_in_, 'tolist') else attr_ComplementNB_feature_names_in_`;
    })();
  }
};

// src/generated/naive_bayes/GaussianNB.ts
import crypto205 from "node:crypto";
var GaussianNB = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianNB${crypto205.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GaussianNB.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.naive_bayes import GaussianNB
try: bridgeGaussianNB
except NameError: bridgeGaussianNB = {}
`;
    await this._py.ex`ctor_GaussianNB = {'priors': np.array(${this.opts["priors"] ?? void 0}) if ${this.opts["priors"] !== void 0} else None, 'var_smoothing': ${this.opts["var_smoothing"] ?? void 0}}

ctor_GaussianNB = {k: v for k, v in ctor_GaussianNB.items() if v is not None}`;
    await this._py.ex`bridgeGaussianNB[${this.id}] = GaussianNB(**ctor_GaussianNB)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianNB[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian Naive Bayes according to X, y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before fit()");
    }
    await this._py.ex`pms_GaussianNB_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianNB_fit = {k: v for k, v in pms_GaussianNB_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_fit = bridgeGaussianNB[${this.id}].fit(**pms_GaussianNB_fit)`;
    return this._py`res_GaussianNB_fit.tolist() if hasattr(res_GaussianNB_fit, 'tolist') else res_GaussianNB_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GaussianNB_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GaussianNB_get_metadata_routing = {k: v for k, v in pms_GaussianNB_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_get_metadata_routing = bridgeGaussianNB[${this.id}].get_metadata_routing(**pms_GaussianNB_get_metadata_routing)`;
    return this._py`res_GaussianNB_get_metadata_routing.tolist() if hasattr(res_GaussianNB_get_metadata_routing, 'tolist') else res_GaussianNB_get_metadata_routing`;
  }
  /**
      Incremental fit on a batch of samples.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once.
  
      This method has some performance and numerical stability overhead, hence it is better to call partial\_fit on chunks of data that are as large as possible (as long as fitting in the memory budget) to hide the overhead.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before partial_fit()");
    }
    await this._py.ex`pms_GaussianNB_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianNB_partial_fit = {k: v for k, v in pms_GaussianNB_partial_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_partial_fit = bridgeGaussianNB[${this.id}].partial_fit(**pms_GaussianNB_partial_fit)`;
    return this._py`res_GaussianNB_partial_fit.tolist() if hasattr(res_GaussianNB_partial_fit, 'tolist') else res_GaussianNB_partial_fit`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before predict()");
    }
    await this._py.ex`pms_GaussianNB_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianNB_predict = {k: v for k, v in pms_GaussianNB_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_predict = bridgeGaussianNB[${this.id}].predict(**pms_GaussianNB_predict)`;
    return this._py`res_GaussianNB_predict.tolist() if hasattr(res_GaussianNB_predict, 'tolist') else res_GaussianNB_predict`;
  }
  /**
      Return joint log probability estimates for the test vector X.
  
      For each row x of X and class y, the joint log probability is given by `log P(x, y) \= log P(y) + log P(x|y),` where `log P(y)` is the class prior probability and `log P(x|y)` is the class-conditional probability.
     */
  async predict_joint_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before predict_joint_log_proba()"
      );
    }
    await this._py.ex`pms_GaussianNB_predict_joint_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianNB_predict_joint_log_proba = {k: v for k, v in pms_GaussianNB_predict_joint_log_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_predict_joint_log_proba = bridgeGaussianNB[${this.id}].predict_joint_log_proba(**pms_GaussianNB_predict_joint_log_proba)`;
    return this._py`res_GaussianNB_predict_joint_log_proba.tolist() if hasattr(res_GaussianNB_predict_joint_log_proba, 'tolist') else res_GaussianNB_predict_joint_log_proba`;
  }
  /**
    Return log-probability estimates for the test vector X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_GaussianNB_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianNB_predict_log_proba = {k: v for k, v in pms_GaussianNB_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_predict_log_proba = bridgeGaussianNB[${this.id}].predict_log_proba(**pms_GaussianNB_predict_log_proba)`;
    return this._py`res_GaussianNB_predict_log_proba.tolist() if hasattr(res_GaussianNB_predict_log_proba, 'tolist') else res_GaussianNB_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before predict_proba()");
    }
    await this._py.ex`pms_GaussianNB_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianNB_predict_proba = {k: v for k, v in pms_GaussianNB_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_predict_proba = bridgeGaussianNB[${this.id}].predict_proba(**pms_GaussianNB_predict_proba)`;
    return this._py`res_GaussianNB_predict_proba.tolist() if hasattr(res_GaussianNB_predict_proba, 'tolist') else res_GaussianNB_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before score()");
    }
    await this._py.ex`pms_GaussianNB_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianNB_score = {k: v for k, v in pms_GaussianNB_score.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_score = bridgeGaussianNB[${this.id}].score(**pms_GaussianNB_score)`;
    return this._py`res_GaussianNB_score.tolist() if hasattr(res_GaussianNB_score, 'tolist') else res_GaussianNB_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before set_fit_request()");
    }
    await this._py.ex`pms_GaussianNB_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GaussianNB_set_fit_request = {k: v for k, v in pms_GaussianNB_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_set_fit_request = bridgeGaussianNB[${this.id}].set_fit_request(**pms_GaussianNB_set_fit_request)`;
    return this._py`res_GaussianNB_set_fit_request.tolist() if hasattr(res_GaussianNB_set_fit_request, 'tolist') else res_GaussianNB_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_GaussianNB_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GaussianNB_set_partial_fit_request = {k: v for k, v in pms_GaussianNB_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_set_partial_fit_request = bridgeGaussianNB[${this.id}].set_partial_fit_request(**pms_GaussianNB_set_partial_fit_request)`;
    return this._py`res_GaussianNB_set_partial_fit_request.tolist() if hasattr(res_GaussianNB_set_partial_fit_request, 'tolist') else res_GaussianNB_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before set_score_request()");
    }
    await this._py.ex`pms_GaussianNB_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GaussianNB_set_score_request = {k: v for k, v in pms_GaussianNB_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GaussianNB_set_score_request = bridgeGaussianNB[${this.id}].set_score_request(**pms_GaussianNB_set_score_request)`;
    return this._py`res_GaussianNB_set_score_request.tolist() if hasattr(res_GaussianNB_set_score_request, 'tolist') else res_GaussianNB_set_score_request`;
  }
  /**
    number of training samples observed in each class.
   */
  get class_count_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before accessing class_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_class_count_ = bridgeGaussianNB[${this.id}].class_count_`;
      return this._py`attr_GaussianNB_class_count_.tolist() if hasattr(attr_GaussianNB_class_count_, 'tolist') else attr_GaussianNB_class_count_`;
    })();
  }
  /**
    probability of each class.
   */
  get class_prior_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before accessing class_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_class_prior_ = bridgeGaussianNB[${this.id}].class_prior_`;
      return this._py`attr_GaussianNB_class_prior_.tolist() if hasattr(attr_GaussianNB_class_prior_, 'tolist') else attr_GaussianNB_class_prior_`;
    })();
  }
  /**
    class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_classes_ = bridgeGaussianNB[${this.id}].classes_`;
      return this._py`attr_GaussianNB_classes_.tolist() if hasattr(attr_GaussianNB_classes_, 'tolist') else attr_GaussianNB_classes_`;
    })();
  }
  /**
    absolute additive value to variances.
   */
  get epsilon_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before accessing epsilon_");
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_epsilon_ = bridgeGaussianNB[${this.id}].epsilon_`;
      return this._py`attr_GaussianNB_epsilon_.tolist() if hasattr(attr_GaussianNB_epsilon_, 'tolist') else attr_GaussianNB_epsilon_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_n_features_in_ = bridgeGaussianNB[${this.id}].n_features_in_`;
      return this._py`attr_GaussianNB_n_features_in_.tolist() if hasattr(attr_GaussianNB_n_features_in_, 'tolist') else attr_GaussianNB_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianNB must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_feature_names_in_ = bridgeGaussianNB[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianNB_feature_names_in_.tolist() if hasattr(attr_GaussianNB_feature_names_in_, 'tolist') else attr_GaussianNB_feature_names_in_`;
    })();
  }
  /**
    Variance of each feature per class.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_var_ = bridgeGaussianNB[${this.id}].var_`;
      return this._py`attr_GaussianNB_var_.tolist() if hasattr(attr_GaussianNB_var_, 'tolist') else attr_GaussianNB_var_`;
    })();
  }
  /**
    mean of each feature per class.
   */
  get theta_() {
    if (this._isDisposed) {
      throw new Error("This GaussianNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianNB must call init() before accessing theta_");
    }
    return (async () => {
      await this._py.ex`attr_GaussianNB_theta_ = bridgeGaussianNB[${this.id}].theta_`;
      return this._py`attr_GaussianNB_theta_.tolist() if hasattr(attr_GaussianNB_theta_, 'tolist') else attr_GaussianNB_theta_`;
    })();
  }
};

// src/generated/naive_bayes/MultinomialNB.ts
import crypto206 from "node:crypto";
var MultinomialNB = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultinomialNB${crypto206.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MultinomialNB.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.naive_bayes import MultinomialNB
try: bridgeMultinomialNB
except NameError: bridgeMultinomialNB = {}
`;
    await this._py.ex`ctor_MultinomialNB = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'force_alpha': ${this.opts["force_alpha"] ?? void 0}, 'fit_prior': ${this.opts["fit_prior"] ?? void 0}, 'class_prior': np.array(${this.opts["class_prior"] ?? void 0}) if ${this.opts["class_prior"] !== void 0} else None}

ctor_MultinomialNB = {k: v for k, v in ctor_MultinomialNB.items() if v is not None}`;
    await this._py.ex`bridgeMultinomialNB[${this.id}] = MultinomialNB(**ctor_MultinomialNB)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultinomialNB[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Naive Bayes classifier according to X, y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before fit()");
    }
    await this._py.ex`pms_MultinomialNB_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultinomialNB_fit = {k: v for k, v in pms_MultinomialNB_fit.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_fit = bridgeMultinomialNB[${this.id}].fit(**pms_MultinomialNB_fit)`;
    return this._py`res_MultinomialNB_fit.tolist() if hasattr(res_MultinomialNB_fit, 'tolist') else res_MultinomialNB_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultinomialNB_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultinomialNB_get_metadata_routing = {k: v for k, v in pms_MultinomialNB_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_get_metadata_routing = bridgeMultinomialNB[${this.id}].get_metadata_routing(**pms_MultinomialNB_get_metadata_routing)`;
    return this._py`res_MultinomialNB_get_metadata_routing.tolist() if hasattr(res_MultinomialNB_get_metadata_routing, 'tolist') else res_MultinomialNB_get_metadata_routing`;
  }
  /**
      Incremental fit on a batch of samples.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once.
  
      This method has some performance overhead hence it is better to call partial\_fit on chunks of data that are as large as possible (as long as fitting in the memory budget) to hide the overhead.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before partial_fit()");
    }
    await this._py.ex`pms_MultinomialNB_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultinomialNB_partial_fit = {k: v for k, v in pms_MultinomialNB_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_partial_fit = bridgeMultinomialNB[${this.id}].partial_fit(**pms_MultinomialNB_partial_fit)`;
    return this._py`res_MultinomialNB_partial_fit.tolist() if hasattr(res_MultinomialNB_partial_fit, 'tolist') else res_MultinomialNB_partial_fit`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before predict()");
    }
    await this._py.ex`pms_MultinomialNB_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultinomialNB_predict = {k: v for k, v in pms_MultinomialNB_predict.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_predict = bridgeMultinomialNB[${this.id}].predict(**pms_MultinomialNB_predict)`;
    return this._py`res_MultinomialNB_predict.tolist() if hasattr(res_MultinomialNB_predict, 'tolist') else res_MultinomialNB_predict`;
  }
  /**
      Return joint log probability estimates for the test vector X.
  
      For each row x of X and class y, the joint log probability is given by `log P(x, y) \= log P(y) + log P(x|y),` where `log P(y)` is the class prior probability and `log P(x|y)` is the class-conditional probability.
     */
  async predict_joint_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before predict_joint_log_proba()"
      );
    }
    await this._py.ex`pms_MultinomialNB_predict_joint_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultinomialNB_predict_joint_log_proba = {k: v for k, v in pms_MultinomialNB_predict_joint_log_proba.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_predict_joint_log_proba = bridgeMultinomialNB[${this.id}].predict_joint_log_proba(**pms_MultinomialNB_predict_joint_log_proba)`;
    return this._py`res_MultinomialNB_predict_joint_log_proba.tolist() if hasattr(res_MultinomialNB_predict_joint_log_proba, 'tolist') else res_MultinomialNB_predict_joint_log_proba`;
  }
  /**
    Return log-probability estimates for the test vector X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_MultinomialNB_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultinomialNB_predict_log_proba = {k: v for k, v in pms_MultinomialNB_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_predict_log_proba = bridgeMultinomialNB[${this.id}].predict_log_proba(**pms_MultinomialNB_predict_log_proba)`;
    return this._py`res_MultinomialNB_predict_log_proba.tolist() if hasattr(res_MultinomialNB_predict_log_proba, 'tolist') else res_MultinomialNB_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before predict_proba()");
    }
    await this._py.ex`pms_MultinomialNB_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MultinomialNB_predict_proba = {k: v for k, v in pms_MultinomialNB_predict_proba.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_predict_proba = bridgeMultinomialNB[${this.id}].predict_proba(**pms_MultinomialNB_predict_proba)`;
    return this._py`res_MultinomialNB_predict_proba.tolist() if hasattr(res_MultinomialNB_predict_proba, 'tolist') else res_MultinomialNB_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before score()");
    }
    await this._py.ex`pms_MultinomialNB_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultinomialNB_score = {k: v for k, v in pms_MultinomialNB_score.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_score = bridgeMultinomialNB[${this.id}].score(**pms_MultinomialNB_score)`;
    return this._py`res_MultinomialNB_score.tolist() if hasattr(res_MultinomialNB_score, 'tolist') else res_MultinomialNB_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultinomialNB must call init() before set_fit_request()");
    }
    await this._py.ex`pms_MultinomialNB_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultinomialNB_set_fit_request = {k: v for k, v in pms_MultinomialNB_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_set_fit_request = bridgeMultinomialNB[${this.id}].set_fit_request(**pms_MultinomialNB_set_fit_request)`;
    return this._py`res_MultinomialNB_set_fit_request.tolist() if hasattr(res_MultinomialNB_set_fit_request, 'tolist') else res_MultinomialNB_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MultinomialNB_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultinomialNB_set_partial_fit_request = {k: v for k, v in pms_MultinomialNB_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_set_partial_fit_request = bridgeMultinomialNB[${this.id}].set_partial_fit_request(**pms_MultinomialNB_set_partial_fit_request)`;
    return this._py`res_MultinomialNB_set_partial_fit_request.tolist() if hasattr(res_MultinomialNB_set_partial_fit_request, 'tolist') else res_MultinomialNB_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultinomialNB_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultinomialNB_set_score_request = {k: v for k, v in pms_MultinomialNB_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultinomialNB_set_score_request = bridgeMultinomialNB[${this.id}].set_score_request(**pms_MultinomialNB_set_score_request)`;
    return this._py`res_MultinomialNB_set_score_request.tolist() if hasattr(res_MultinomialNB_set_score_request, 'tolist') else res_MultinomialNB_set_score_request`;
  }
  /**
    Number of samples encountered for each class during fitting. This value is weighted by the sample weight when provided.
   */
  get class_count_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing class_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_class_count_ = bridgeMultinomialNB[${this.id}].class_count_`;
      return this._py`attr_MultinomialNB_class_count_.tolist() if hasattr(attr_MultinomialNB_class_count_, 'tolist') else attr_MultinomialNB_class_count_`;
    })();
  }
  /**
    Smoothed empirical log probability for each class.
   */
  get class_log_prior_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing class_log_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_class_log_prior_ = bridgeMultinomialNB[${this.id}].class_log_prior_`;
      return this._py`attr_MultinomialNB_class_log_prior_.tolist() if hasattr(attr_MultinomialNB_class_log_prior_, 'tolist') else attr_MultinomialNB_class_log_prior_`;
    })();
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_classes_ = bridgeMultinomialNB[${this.id}].classes_`;
      return this._py`attr_MultinomialNB_classes_.tolist() if hasattr(attr_MultinomialNB_classes_, 'tolist') else attr_MultinomialNB_classes_`;
    })();
  }
  /**
    Number of samples encountered for each (class, feature) during fitting. This value is weighted by the sample weight when provided.
   */
  get feature_count_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing feature_count_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_feature_count_ = bridgeMultinomialNB[${this.id}].feature_count_`;
      return this._py`attr_MultinomialNB_feature_count_.tolist() if hasattr(attr_MultinomialNB_feature_count_, 'tolist') else attr_MultinomialNB_feature_count_`;
    })();
  }
  /**
    Empirical log probability of features given a class, `P(x\_i|y)`.
   */
  get feature_log_prob_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing feature_log_prob_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_feature_log_prob_ = bridgeMultinomialNB[${this.id}].feature_log_prob_`;
      return this._py`attr_MultinomialNB_feature_log_prob_.tolist() if hasattr(attr_MultinomialNB_feature_log_prob_, 'tolist') else attr_MultinomialNB_feature_log_prob_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_n_features_in_ = bridgeMultinomialNB[${this.id}].n_features_in_`;
      return this._py`attr_MultinomialNB_n_features_in_.tolist() if hasattr(attr_MultinomialNB_n_features_in_, 'tolist') else attr_MultinomialNB_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MultinomialNB instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultinomialNB must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultinomialNB_feature_names_in_ = bridgeMultinomialNB[${this.id}].feature_names_in_`;
      return this._py`attr_MultinomialNB_feature_names_in_.tolist() if hasattr(attr_MultinomialNB_feature_names_in_, 'tolist') else attr_MultinomialNB_feature_names_in_`;
    })();
  }
};

// src/generated/neighbors/BallTree.ts
import crypto207 from "node:crypto";
var BallTree = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BallTree${crypto207.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BallTree.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import BallTree
try: bridgeBallTree
except NameError: bridgeBallTree = {}
`;
    await this._py.ex`ctor_BallTree = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}}

ctor_BallTree = {k: v for k, v in ctor_BallTree.items() if v is not None}`;
    await this._py.ex`bridgeBallTree[${this.id}] = BallTree(**ctor_BallTree)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBallTree[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Get data and node arrays.
   */
  async get_arrays(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_arrays()");
    }
    await this._py.ex`pms_BallTree_get_arrays = {}

pms_BallTree_get_arrays = {k: v for k, v in pms_BallTree_get_arrays.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_arrays = bridgeBallTree[${this.id}].get_arrays(**pms_BallTree_get_arrays)`;
    return this._py`res_BallTree_get_arrays.tolist() if hasattr(res_BallTree_get_arrays, 'tolist') else res_BallTree_get_arrays`;
  }
  /**
    Get number of calls.
   */
  async get_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_n_calls()");
    }
    await this._py.ex`pms_BallTree_get_n_calls = {}

pms_BallTree_get_n_calls = {k: v for k, v in pms_BallTree_get_n_calls.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_n_calls = bridgeBallTree[${this.id}].get_n_calls(**pms_BallTree_get_n_calls)`;
    return this._py`res_BallTree_get_n_calls.tolist() if hasattr(res_BallTree_get_n_calls, 'tolist') else res_BallTree_get_n_calls`;
  }
  /**
    Get tree status.
   */
  async get_tree_stats(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_tree_stats()");
    }
    await this._py.ex`pms_BallTree_get_tree_stats = {}

pms_BallTree_get_tree_stats = {k: v for k, v in pms_BallTree_get_tree_stats.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_tree_stats = bridgeBallTree[${this.id}].get_tree_stats(**pms_BallTree_get_tree_stats)`;
    return this._py`res_BallTree_get_tree_stats.tolist() if hasattr(res_BallTree_get_tree_stats, 'tolist') else res_BallTree_get_tree_stats`;
  }
  /**
    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.
   */
  async kernel_density(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before kernel_density()");
    }
    await this._py.ex`pms_BallTree_kernel_density = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'h': ${opts["h"] ?? void 0}, 'kernel': ${opts["kernel"] ?? void 0}, 'atol': ${opts["atol"] ?? void 0}, 'rtol': ${opts["rtol"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'return_log': ${opts["return_log"] ?? void 0}}

pms_BallTree_kernel_density = {k: v for k, v in pms_BallTree_kernel_density.items() if v is not None}`;
    await this._py.ex`res_BallTree_kernel_density = bridgeBallTree[${this.id}].kernel_density(**pms_BallTree_kernel_density)`;
    return this._py`res_BallTree_kernel_density.tolist() if hasattr(res_BallTree_kernel_density, 'tolist') else res_BallTree_kernel_density`;
  }
  /**
    query the tree for the k nearest neighbors
   */
  async query(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before query()");
    }
    await this._py.ex`pms_BallTree_query = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'k': ${opts["k"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_BallTree_query = {k: v for k, v in pms_BallTree_query.items() if v is not None}`;
    await this._py.ex`res_BallTree_query = bridgeBallTree[${this.id}].query(**pms_BallTree_query)`;
    return this._py`res_BallTree_query.tolist() if hasattr(res_BallTree_query, 'tolist') else res_BallTree_query`;
  }
  /**
    query the tree for neighbors within a radius r
   */
  async query_radius(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before query_radius()");
    }
    await this._py.ex`pms_BallTree_query_radius = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'count_only': ${opts["count_only"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_BallTree_query_radius = {k: v for k, v in pms_BallTree_query_radius.items() if v is not None}`;
    await this._py.ex`res_BallTree_query_radius = bridgeBallTree[${this.id}].query_radius(**pms_BallTree_query_radius)`;
    return this._py`res_BallTree_query_radius.tolist() if hasattr(res_BallTree_query_radius, 'tolist') else res_BallTree_query_radius`;
  }
  /**
    Reset number of calls to 0.
   */
  async reset_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before reset_n_calls()");
    }
    await this._py.ex`pms_BallTree_reset_n_calls = {}

pms_BallTree_reset_n_calls = {k: v for k, v in pms_BallTree_reset_n_calls.items() if v is not None}`;
    await this._py.ex`res_BallTree_reset_n_calls = bridgeBallTree[${this.id}].reset_n_calls(**pms_BallTree_reset_n_calls)`;
    return this._py`res_BallTree_reset_n_calls.tolist() if hasattr(res_BallTree_reset_n_calls, 'tolist') else res_BallTree_reset_n_calls`;
  }
  /**
    Compute the two-point correlation function
   */
  async two_point_correlation(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BallTree must call init() before two_point_correlation()"
      );
    }
    await this._py.ex`pms_BallTree_two_point_correlation = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}}

pms_BallTree_two_point_correlation = {k: v for k, v in pms_BallTree_two_point_correlation.items() if v is not None}`;
    await this._py.ex`res_BallTree_two_point_correlation = bridgeBallTree[${this.id}].two_point_correlation(**pms_BallTree_two_point_correlation)`;
    return this._py`res_BallTree_two_point_correlation.tolist() if hasattr(res_BallTree_two_point_correlation, 'tolist') else res_BallTree_two_point_correlation`;
  }
  /**
    The training data
   */
  get data() {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before accessing data");
    }
    return (async () => {
      await this._py.ex`attr_BallTree_data = bridgeBallTree[${this.id}].data`;
      return this._py`attr_BallTree_data.tolist() if hasattr(attr_BallTree_data, 'tolist') else attr_BallTree_data`;
    })();
  }
};

// src/generated/neighbors/KDTree.ts
import crypto208 from "node:crypto";
var KDTree = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KDTree${crypto208.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KDTree.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KDTree
try: bridgeKDTree
except NameError: bridgeKDTree = {}
`;
    await this._py.ex`ctor_KDTree = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}}

ctor_KDTree = {k: v for k, v in ctor_KDTree.items() if v is not None}`;
    await this._py.ex`bridgeKDTree[${this.id}] = KDTree(**ctor_KDTree)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKDTree[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Get data and node arrays.
   */
  async get_arrays(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_arrays()");
    }
    await this._py.ex`pms_KDTree_get_arrays = {}

pms_KDTree_get_arrays = {k: v for k, v in pms_KDTree_get_arrays.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_arrays = bridgeKDTree[${this.id}].get_arrays(**pms_KDTree_get_arrays)`;
    return this._py`res_KDTree_get_arrays.tolist() if hasattr(res_KDTree_get_arrays, 'tolist') else res_KDTree_get_arrays`;
  }
  /**
    Get number of calls.
   */
  async get_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_n_calls()");
    }
    await this._py.ex`pms_KDTree_get_n_calls = {}

pms_KDTree_get_n_calls = {k: v for k, v in pms_KDTree_get_n_calls.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_n_calls = bridgeKDTree[${this.id}].get_n_calls(**pms_KDTree_get_n_calls)`;
    return this._py`res_KDTree_get_n_calls.tolist() if hasattr(res_KDTree_get_n_calls, 'tolist') else res_KDTree_get_n_calls`;
  }
  /**
    Get tree status.
   */
  async get_tree_stats(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_tree_stats()");
    }
    await this._py.ex`pms_KDTree_get_tree_stats = {}

pms_KDTree_get_tree_stats = {k: v for k, v in pms_KDTree_get_tree_stats.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_tree_stats = bridgeKDTree[${this.id}].get_tree_stats(**pms_KDTree_get_tree_stats)`;
    return this._py`res_KDTree_get_tree_stats.tolist() if hasattr(res_KDTree_get_tree_stats, 'tolist') else res_KDTree_get_tree_stats`;
  }
  /**
    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.
   */
  async kernel_density(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before kernel_density()");
    }
    await this._py.ex`pms_KDTree_kernel_density = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'h': ${opts["h"] ?? void 0}, 'kernel': ${opts["kernel"] ?? void 0}, 'atol': ${opts["atol"] ?? void 0}, 'rtol': ${opts["rtol"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'return_log': ${opts["return_log"] ?? void 0}}

pms_KDTree_kernel_density = {k: v for k, v in pms_KDTree_kernel_density.items() if v is not None}`;
    await this._py.ex`res_KDTree_kernel_density = bridgeKDTree[${this.id}].kernel_density(**pms_KDTree_kernel_density)`;
    return this._py`res_KDTree_kernel_density.tolist() if hasattr(res_KDTree_kernel_density, 'tolist') else res_KDTree_kernel_density`;
  }
  /**
    query the tree for the k nearest neighbors
   */
  async query(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before query()");
    }
    await this._py.ex`pms_KDTree_query = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'k': ${opts["k"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_KDTree_query = {k: v for k, v in pms_KDTree_query.items() if v is not None}`;
    await this._py.ex`res_KDTree_query = bridgeKDTree[${this.id}].query(**pms_KDTree_query)`;
    return this._py`res_KDTree_query.tolist() if hasattr(res_KDTree_query, 'tolist') else res_KDTree_query`;
  }
  /**
    query the tree for neighbors within a radius r
   */
  async query_radius(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before query_radius()");
    }
    await this._py.ex`pms_KDTree_query_radius = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'count_only': ${opts["count_only"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_KDTree_query_radius = {k: v for k, v in pms_KDTree_query_radius.items() if v is not None}`;
    await this._py.ex`res_KDTree_query_radius = bridgeKDTree[${this.id}].query_radius(**pms_KDTree_query_radius)`;
    return this._py`res_KDTree_query_radius.tolist() if hasattr(res_KDTree_query_radius, 'tolist') else res_KDTree_query_radius`;
  }
  /**
    Reset number of calls to 0.
   */
  async reset_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before reset_n_calls()");
    }
    await this._py.ex`pms_KDTree_reset_n_calls = {}

pms_KDTree_reset_n_calls = {k: v for k, v in pms_KDTree_reset_n_calls.items() if v is not None}`;
    await this._py.ex`res_KDTree_reset_n_calls = bridgeKDTree[${this.id}].reset_n_calls(**pms_KDTree_reset_n_calls)`;
    return this._py`res_KDTree_reset_n_calls.tolist() if hasattr(res_KDTree_reset_n_calls, 'tolist') else res_KDTree_reset_n_calls`;
  }
  /**
    Compute the two-point correlation function
   */
  async two_point_correlation(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before two_point_correlation()");
    }
    await this._py.ex`pms_KDTree_two_point_correlation = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}}

pms_KDTree_two_point_correlation = {k: v for k, v in pms_KDTree_two_point_correlation.items() if v is not None}`;
    await this._py.ex`res_KDTree_two_point_correlation = bridgeKDTree[${this.id}].two_point_correlation(**pms_KDTree_two_point_correlation)`;
    return this._py`res_KDTree_two_point_correlation.tolist() if hasattr(res_KDTree_two_point_correlation, 'tolist') else res_KDTree_two_point_correlation`;
  }
  /**
    The training data
   */
  get data() {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before accessing data");
    }
    return (async () => {
      await this._py.ex`attr_KDTree_data = bridgeKDTree[${this.id}].data`;
      return this._py`attr_KDTree_data.tolist() if hasattr(attr_KDTree_data, 'tolist') else attr_KDTree_data`;
    })();
  }
};

// src/generated/neighbors/KernelDensity.ts
import crypto209 from "node:crypto";
var KernelDensity = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelDensity${crypto209.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelDensity.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KernelDensity
try: bridgeKernelDensity
except NameError: bridgeKernelDensity = {}
`;
    await this._py.ex`ctor_KernelDensity = {'bandwidth': ${this.opts["bandwidth"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'atol': ${this.opts["atol"] ?? void 0}, 'rtol': ${this.opts["rtol"] ?? void 0}, 'breadth_first': ${this.opts["breadth_first"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}}

ctor_KernelDensity = {k: v for k, v in ctor_KernelDensity.items() if v is not None}`;
    await this._py.ex`bridgeKernelDensity[${this.id}] = KernelDensity(**ctor_KernelDensity)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelDensity[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the Kernel Density model on the data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before fit()");
    }
    await this._py.ex`pms_KernelDensity_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KernelDensity_fit = {k: v for k, v in pms_KernelDensity_fit.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_fit = bridgeKernelDensity[${this.id}].fit(**pms_KernelDensity_fit)`;
    return this._py`res_KernelDensity_fit.tolist() if hasattr(res_KernelDensity_fit, 'tolist') else res_KernelDensity_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelDensity_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelDensity_get_metadata_routing = {k: v for k, v in pms_KernelDensity_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_get_metadata_routing = bridgeKernelDensity[${this.id}].get_metadata_routing(**pms_KernelDensity_get_metadata_routing)`;
    return this._py`res_KernelDensity_get_metadata_routing.tolist() if hasattr(res_KernelDensity_get_metadata_routing, 'tolist') else res_KernelDensity_get_metadata_routing`;
  }
  /**
      Generate random samples from the model.
  
      Currently, this is implemented only for gaussian and tophat kernels.
     */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before sample()");
    }
    await this._py.ex`pms_KernelDensity_sample = {'n_samples': ${opts["n_samples"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_KernelDensity_sample = {k: v for k, v in pms_KernelDensity_sample.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_sample = bridgeKernelDensity[${this.id}].sample(**pms_KernelDensity_sample)`;
    return this._py`res_KernelDensity_sample.tolist() if hasattr(res_KernelDensity_sample, 'tolist') else res_KernelDensity_sample`;
  }
  /**
    Compute the total log-likelihood under the model.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before score()");
    }
    await this._py.ex`pms_KernelDensity_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelDensity_score = {k: v for k, v in pms_KernelDensity_score.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_score = bridgeKernelDensity[${this.id}].score(**pms_KernelDensity_score)`;
    return this._py`res_KernelDensity_score.tolist() if hasattr(res_KernelDensity_score, 'tolist') else res_KernelDensity_score`;
  }
  /**
    Compute the log-likelihood of each sample under the model.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before score_samples()");
    }
    await this._py.ex`pms_KernelDensity_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelDensity_score_samples = {k: v for k, v in pms_KernelDensity_score_samples.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_score_samples = bridgeKernelDensity[${this.id}].score_samples(**pms_KernelDensity_score_samples)`;
    return this._py`res_KernelDensity_score_samples.tolist() if hasattr(res_KernelDensity_score_samples, 'tolist') else res_KernelDensity_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KernelDensity_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KernelDensity_set_fit_request = {k: v for k, v in pms_KernelDensity_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_set_fit_request = bridgeKernelDensity[${this.id}].set_fit_request(**pms_KernelDensity_set_fit_request)`;
    return this._py`res_KernelDensity_set_fit_request.tolist() if hasattr(res_KernelDensity_set_fit_request, 'tolist') else res_KernelDensity_set_fit_request`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_n_features_in_ = bridgeKernelDensity[${this.id}].n_features_in_`;
      return this._py`attr_KernelDensity_n_features_in_.tolist() if hasattr(attr_KernelDensity_n_features_in_, 'tolist') else attr_KernelDensity_n_features_in_`;
    })();
  }
  /**
    The tree algorithm for fast generalized N-point problems.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before accessing tree_");
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_tree_ = bridgeKernelDensity[${this.id}].tree_`;
      return this._py`attr_KernelDensity_tree_.tolist() if hasattr(attr_KernelDensity_tree_, 'tolist') else attr_KernelDensity_tree_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_feature_names_in_ = bridgeKernelDensity[${this.id}].feature_names_in_`;
      return this._py`attr_KernelDensity_feature_names_in_.tolist() if hasattr(attr_KernelDensity_feature_names_in_, 'tolist') else attr_KernelDensity_feature_names_in_`;
    })();
  }
  /**
    Value of the bandwidth, given directly by the bandwidth parameter or estimated using the â€˜scottâ€™ or â€˜silvermanâ€™ method.
   */
  get bandwidth_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing bandwidth_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_bandwidth_ = bridgeKernelDensity[${this.id}].bandwidth_`;
      return this._py`attr_KernelDensity_bandwidth_.tolist() if hasattr(attr_KernelDensity_bandwidth_, 'tolist') else attr_KernelDensity_bandwidth_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsClassifier.ts
import crypto210 from "node:crypto";
var KNeighborsClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsClassifier${crypto210.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsClassifier
try: bridgeKNeighborsClassifier
except NameError: bridgeKNeighborsClassifier = {}
`;
    await this._py.ex`ctor_KNeighborsClassifier = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsClassifier = {k: v for k, v in ctor_KNeighborsClassifier.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsClassifier[${this.id}] = KNeighborsClassifier(**ctor_KNeighborsClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors classifier from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_KNeighborsClassifier_fit = {k: v for k, v in pms_KNeighborsClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_fit = bridgeKNeighborsClassifier[${this.id}].fit(**pms_KNeighborsClassifier_fit)`;
    return this._py`res_KNeighborsClassifier_fit.tolist() if hasattr(res_KNeighborsClassifier_fit, 'tolist') else res_KNeighborsClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_KNeighborsClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_get_metadata_routing = bridgeKNeighborsClassifier[${this.id}].get_metadata_routing(**pms_KNeighborsClassifier_get_metadata_routing)`;
    return this._py`res_KNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_KNeighborsClassifier_get_metadata_routing, 'tolist') else res_KNeighborsClassifier_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsClassifier_kneighbors = {k: v for k, v in pms_KNeighborsClassifier_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_kneighbors = bridgeKNeighborsClassifier[${this.id}].kneighbors(**pms_KNeighborsClassifier_kneighbors)`;
    return this._py`res_KNeighborsClassifier_kneighbors.tolist() if hasattr(res_KNeighborsClassifier_kneighbors, 'tolist') else res_KNeighborsClassifier_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsClassifier_kneighbors_graph = {k: v for k, v in pms_KNeighborsClassifier_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_kneighbors_graph = bridgeKNeighborsClassifier[${this.id}].kneighbors_graph(**pms_KNeighborsClassifier_kneighbors_graph)`;
    return this._py`res_KNeighborsClassifier_kneighbors_graph.tolist() if hasattr(res_KNeighborsClassifier_kneighbors_graph, 'tolist') else res_KNeighborsClassifier_kneighbors_graph`;
  }
  /**
    Predict the class labels for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before predict()");
    }
    await this._py.ex`pms_KNeighborsClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsClassifier_predict = {k: v for k, v in pms_KNeighborsClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_predict = bridgeKNeighborsClassifier[${this.id}].predict(**pms_KNeighborsClassifier_predict)`;
    return this._py`res_KNeighborsClassifier_predict.tolist() if hasattr(res_KNeighborsClassifier_predict, 'tolist') else res_KNeighborsClassifier_predict`;
  }
  /**
    Return probability estimates for the test data X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsClassifier_predict_proba = {k: v for k, v in pms_KNeighborsClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_predict_proba = bridgeKNeighborsClassifier[${this.id}].predict_proba(**pms_KNeighborsClassifier_predict_proba)`;
    return this._py`res_KNeighborsClassifier_predict_proba.tolist() if hasattr(res_KNeighborsClassifier_predict_proba, 'tolist') else res_KNeighborsClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before score()");
    }
    await this._py.ex`pms_KNeighborsClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KNeighborsClassifier_score = {k: v for k, v in pms_KNeighborsClassifier_score.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_score = bridgeKNeighborsClassifier[${this.id}].score(**pms_KNeighborsClassifier_score)`;
    return this._py`res_KNeighborsClassifier_score.tolist() if hasattr(res_KNeighborsClassifier_score, 'tolist') else res_KNeighborsClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KNeighborsClassifier_set_score_request = {k: v for k, v in pms_KNeighborsClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_set_score_request = bridgeKNeighborsClassifier[${this.id}].set_score_request(**pms_KNeighborsClassifier_set_score_request)`;
    return this._py`res_KNeighborsClassifier_set_score_request.tolist() if hasattr(res_KNeighborsClassifier_set_score_request, 'tolist') else res_KNeighborsClassifier_set_score_request`;
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_classes_ = bridgeKNeighborsClassifier[${this.id}].classes_`;
      return this._py`attr_KNeighborsClassifier_classes_.tolist() if hasattr(attr_KNeighborsClassifier_classes_, 'tolist') else attr_KNeighborsClassifier_classes_`;
    })();
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_effective_metric_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_, 'tolist') else attr_KNeighborsClassifier_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_effective_metric_params_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_params_, 'tolist') else attr_KNeighborsClassifier_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_n_features_in_ = bridgeKNeighborsClassifier[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_KNeighborsClassifier_n_features_in_, 'tolist') else attr_KNeighborsClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_feature_names_in_ = bridgeKNeighborsClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_KNeighborsClassifier_feature_names_in_, 'tolist') else attr_KNeighborsClassifier_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_n_samples_fit_ = bridgeKNeighborsClassifier[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_KNeighborsClassifier_n_samples_fit_, 'tolist') else attr_KNeighborsClassifier_n_samples_fit_`;
    })();
  }
  /**
    False when `y`â€™s shape is (n\_samples, ) or (n\_samples, 1) during fit otherwise `true`.
   */
  get outputs_2d_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing outputs_2d_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_outputs_2d_ = bridgeKNeighborsClassifier[${this.id}].outputs_2d_`;
      return this._py`attr_KNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_KNeighborsClassifier_outputs_2d_, 'tolist') else attr_KNeighborsClassifier_outputs_2d_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsRegressor.ts
import crypto211 from "node:crypto";
var KNeighborsRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsRegressor${crypto211.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsRegressor
try: bridgeKNeighborsRegressor
except NameError: bridgeKNeighborsRegressor = {}
`;
    await this._py.ex`ctor_KNeighborsRegressor = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsRegressor = {k: v for k, v in ctor_KNeighborsRegressor.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsRegressor[${this.id}] = KNeighborsRegressor(**ctor_KNeighborsRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors regressor from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_KNeighborsRegressor_fit = {k: v for k, v in pms_KNeighborsRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_fit = bridgeKNeighborsRegressor[${this.id}].fit(**pms_KNeighborsRegressor_fit)`;
    return this._py`res_KNeighborsRegressor_fit.tolist() if hasattr(res_KNeighborsRegressor_fit, 'tolist') else res_KNeighborsRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_KNeighborsRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_get_metadata_routing = bridgeKNeighborsRegressor[${this.id}].get_metadata_routing(**pms_KNeighborsRegressor_get_metadata_routing)`;
    return this._py`res_KNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_KNeighborsRegressor_get_metadata_routing, 'tolist') else res_KNeighborsRegressor_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsRegressor_kneighbors = {k: v for k, v in pms_KNeighborsRegressor_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_kneighbors = bridgeKNeighborsRegressor[${this.id}].kneighbors(**pms_KNeighborsRegressor_kneighbors)`;
    return this._py`res_KNeighborsRegressor_kneighbors.tolist() if hasattr(res_KNeighborsRegressor_kneighbors, 'tolist') else res_KNeighborsRegressor_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsRegressor_kneighbors_graph = {k: v for k, v in pms_KNeighborsRegressor_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_kneighbors_graph = bridgeKNeighborsRegressor[${this.id}].kneighbors_graph(**pms_KNeighborsRegressor_kneighbors_graph)`;
    return this._py`res_KNeighborsRegressor_kneighbors_graph.tolist() if hasattr(res_KNeighborsRegressor_kneighbors_graph, 'tolist') else res_KNeighborsRegressor_kneighbors_graph`;
  }
  /**
    Predict the target for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before predict()");
    }
    await this._py.ex`pms_KNeighborsRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsRegressor_predict = {k: v for k, v in pms_KNeighborsRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_predict = bridgeKNeighborsRegressor[${this.id}].predict(**pms_KNeighborsRegressor_predict)`;
    return this._py`res_KNeighborsRegressor_predict.tolist() if hasattr(res_KNeighborsRegressor_predict, 'tolist') else res_KNeighborsRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before score()");
    }
    await this._py.ex`pms_KNeighborsRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KNeighborsRegressor_score = {k: v for k, v in pms_KNeighborsRegressor_score.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_score = bridgeKNeighborsRegressor[${this.id}].score(**pms_KNeighborsRegressor_score)`;
    return this._py`res_KNeighborsRegressor_score.tolist() if hasattr(res_KNeighborsRegressor_score, 'tolist') else res_KNeighborsRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KNeighborsRegressor_set_score_request = {k: v for k, v in pms_KNeighborsRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_set_score_request = bridgeKNeighborsRegressor[${this.id}].set_score_request(**pms_KNeighborsRegressor_set_score_request)`;
    return this._py`res_KNeighborsRegressor_set_score_request.tolist() if hasattr(res_KNeighborsRegressor_set_score_request, 'tolist') else res_KNeighborsRegressor_set_score_request`;
  }
  /**
    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_effective_metric_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_, 'tolist') else attr_KNeighborsRegressor_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_effective_metric_params_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_params_, 'tolist') else attr_KNeighborsRegressor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_n_features_in_ = bridgeKNeighborsRegressor[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_KNeighborsRegressor_n_features_in_, 'tolist') else attr_KNeighborsRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_feature_names_in_ = bridgeKNeighborsRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_KNeighborsRegressor_feature_names_in_, 'tolist') else attr_KNeighborsRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_n_samples_fit_ = bridgeKNeighborsRegressor[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_KNeighborsRegressor_n_samples_fit_, 'tolist') else attr_KNeighborsRegressor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsTransformer.ts
import crypto212 from "node:crypto";
var KNeighborsTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsTransformer${crypto212.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsTransformer
try: bridgeKNeighborsTransformer
except NameError: bridgeKNeighborsTransformer = {}
`;
    await this._py.ex`ctor_KNeighborsTransformer = {'mode': ${this.opts["mode"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsTransformer = {k: v for k, v in ctor_KNeighborsTransformer.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsTransformer[${this.id}] = KNeighborsTransformer(**ctor_KNeighborsTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors transformer from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsTransformer must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KNeighborsTransformer_fit = {k: v for k, v in pms_KNeighborsTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_fit = bridgeKNeighborsTransformer[${this.id}].fit(**pms_KNeighborsTransformer_fit)`;
    return this._py`res_KNeighborsTransformer_fit.tolist() if hasattr(res_KNeighborsTransformer_fit, 'tolist') else res_KNeighborsTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit\_params and returns a transformed version of X.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KNeighborsTransformer_fit_transform = {k: v for k, v in pms_KNeighborsTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_fit_transform = bridgeKNeighborsTransformer[${this.id}].fit_transform(**pms_KNeighborsTransformer_fit_transform)`;
    return this._py`res_KNeighborsTransformer_fit_transform.tolist() if hasattr(res_KNeighborsTransformer_fit_transform, 'tolist') else res_KNeighborsTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_KNeighborsTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_get_feature_names_out = bridgeKNeighborsTransformer[${this.id}].get_feature_names_out(**pms_KNeighborsTransformer_get_feature_names_out)`;
    return this._py`res_KNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_KNeighborsTransformer_get_feature_names_out, 'tolist') else res_KNeighborsTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_KNeighborsTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_get_metadata_routing = bridgeKNeighborsTransformer[${this.id}].get_metadata_routing(**pms_KNeighborsTransformer_get_metadata_routing)`;
    return this._py`res_KNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_KNeighborsTransformer_get_metadata_routing, 'tolist') else res_KNeighborsTransformer_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsTransformer_kneighbors = {k: v for k, v in pms_KNeighborsTransformer_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_kneighbors = bridgeKNeighborsTransformer[${this.id}].kneighbors(**pms_KNeighborsTransformer_kneighbors)`;
    return this._py`res_KNeighborsTransformer_kneighbors.tolist() if hasattr(res_KNeighborsTransformer_kneighbors, 'tolist') else res_KNeighborsTransformer_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsTransformer_kneighbors_graph = {k: v for k, v in pms_KNeighborsTransformer_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_kneighbors_graph = bridgeKNeighborsTransformer[${this.id}].kneighbors_graph(**pms_KNeighborsTransformer_kneighbors_graph)`;
    return this._py`res_KNeighborsTransformer_kneighbors_graph.tolist() if hasattr(res_KNeighborsTransformer_kneighbors_graph, 'tolist') else res_KNeighborsTransformer_kneighbors_graph`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KNeighborsTransformer_set_output = {k: v for k, v in pms_KNeighborsTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_set_output = bridgeKNeighborsTransformer[${this.id}].set_output(**pms_KNeighborsTransformer_set_output)`;
    return this._py`res_KNeighborsTransformer_set_output.tolist() if hasattr(res_KNeighborsTransformer_set_output, 'tolist') else res_KNeighborsTransformer_set_output`;
  }
  /**
    Compute the (weighted) graph of Neighbors for points in X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before transform()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsTransformer_transform = {k: v for k, v in pms_KNeighborsTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_transform = bridgeKNeighborsTransformer[${this.id}].transform(**pms_KNeighborsTransformer_transform)`;
    return this._py`res_KNeighborsTransformer_transform.tolist() if hasattr(res_KNeighborsTransformer_transform, 'tolist') else res_KNeighborsTransformer_transform`;
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_effective_metric_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_, 'tolist') else attr_KNeighborsTransformer_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_effective_metric_params_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_params_, 'tolist') else attr_KNeighborsTransformer_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_n_features_in_ = bridgeKNeighborsTransformer[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_KNeighborsTransformer_n_features_in_, 'tolist') else attr_KNeighborsTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_feature_names_in_ = bridgeKNeighborsTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_KNeighborsTransformer_feature_names_in_, 'tolist') else attr_KNeighborsTransformer_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_n_samples_fit_ = bridgeKNeighborsTransformer[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_KNeighborsTransformer_n_samples_fit_, 'tolist') else attr_KNeighborsTransformer_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/LocalOutlierFactor.ts
import crypto213 from "node:crypto";
var LocalOutlierFactor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LocalOutlierFactor${crypto213.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LocalOutlierFactor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import LocalOutlierFactor
try: bridgeLocalOutlierFactor
except NameError: bridgeLocalOutlierFactor = {}
`;
    await this._py.ex`ctor_LocalOutlierFactor = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'novelty': ${this.opts["novelty"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_LocalOutlierFactor = {k: v for k, v in ctor_LocalOutlierFactor.items() if v is not None}`;
    await this._py.ex`bridgeLocalOutlierFactor[${this.id}] = LocalOutlierFactor(**ctor_LocalOutlierFactor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLocalOutlierFactor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Shifted opposite of the Local Outlier Factor of X.
  
      Bigger is better, i.e. large values correspond to inliers.
  
      **Only available for novelty detection (when novelty is set to `true`).** The shift offset allows a zero threshold for being an outlier. The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_decision_function = {k: v for k, v in pms_LocalOutlierFactor_decision_function.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_decision_function = bridgeLocalOutlierFactor[${this.id}].decision_function(**pms_LocalOutlierFactor_decision_function)`;
    return this._py`res_LocalOutlierFactor_decision_function.tolist() if hasattr(res_LocalOutlierFactor_decision_function, 'tolist') else res_LocalOutlierFactor_decision_function`;
  }
  /**
    Fit the local outlier factor detector from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before fit()");
    }
    await this._py.ex`pms_LocalOutlierFactor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocalOutlierFactor_fit = {k: v for k, v in pms_LocalOutlierFactor_fit.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_fit = bridgeLocalOutlierFactor[${this.id}].fit(**pms_LocalOutlierFactor_fit)`;
    return this._py`res_LocalOutlierFactor_fit.tolist() if hasattr(res_LocalOutlierFactor_fit, 'tolist') else res_LocalOutlierFactor_fit`;
  }
  /**
      Fit the model to the training set X and return the labels.
  
      **Not available for novelty detection (when novelty is set to `true`).** Label is 1 for an inlier and -1 for an outlier according to the LOF score and the contamination parameter.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocalOutlierFactor_fit_predict = {k: v for k, v in pms_LocalOutlierFactor_fit_predict.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_fit_predict = bridgeLocalOutlierFactor[${this.id}].fit_predict(**pms_LocalOutlierFactor_fit_predict)`;
    return this._py`res_LocalOutlierFactor_fit_predict.tolist() if hasattr(res_LocalOutlierFactor_fit_predict, 'tolist') else res_LocalOutlierFactor_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LocalOutlierFactor_get_metadata_routing = {k: v for k, v in pms_LocalOutlierFactor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_get_metadata_routing = bridgeLocalOutlierFactor[${this.id}].get_metadata_routing(**pms_LocalOutlierFactor_get_metadata_routing)`;
    return this._py`res_LocalOutlierFactor_get_metadata_routing.tolist() if hasattr(res_LocalOutlierFactor_get_metadata_routing, 'tolist') else res_LocalOutlierFactor_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before kneighbors()");
    }
    await this._py.ex`pms_LocalOutlierFactor_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_LocalOutlierFactor_kneighbors = {k: v for k, v in pms_LocalOutlierFactor_kneighbors.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_kneighbors = bridgeLocalOutlierFactor[${this.id}].kneighbors(**pms_LocalOutlierFactor_kneighbors)`;
    return this._py`res_LocalOutlierFactor_kneighbors.tolist() if hasattr(res_LocalOutlierFactor_kneighbors, 'tolist') else res_LocalOutlierFactor_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_LocalOutlierFactor_kneighbors_graph = {k: v for k, v in pms_LocalOutlierFactor_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_kneighbors_graph = bridgeLocalOutlierFactor[${this.id}].kneighbors_graph(**pms_LocalOutlierFactor_kneighbors_graph)`;
    return this._py`res_LocalOutlierFactor_kneighbors_graph.tolist() if hasattr(res_LocalOutlierFactor_kneighbors_graph, 'tolist') else res_LocalOutlierFactor_kneighbors_graph`;
  }
  /**
      Predict the labels (1 inlier, -1 outlier) of X according to LOF.
  
      **Only available for novelty detection (when novelty is set to `true`).** This method allows to generalize prediction to *new observations* (not in the training set). Note that the result of `clf.fit(X)` then `clf.predict(X)` with `novelty=True` may differ from the result obtained by `clf.fit\_predict(X)` with `novelty=False`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before predict()");
    }
    await this._py.ex`pms_LocalOutlierFactor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_predict = {k: v for k, v in pms_LocalOutlierFactor_predict.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_predict = bridgeLocalOutlierFactor[${this.id}].predict(**pms_LocalOutlierFactor_predict)`;
    return this._py`res_LocalOutlierFactor_predict.tolist() if hasattr(res_LocalOutlierFactor_predict, 'tolist') else res_LocalOutlierFactor_predict`;
  }
  /**
      Opposite of the Local Outlier Factor of X.
  
      It is the opposite as bigger is better, i.e. large values correspond to inliers.
  
      **Only available for novelty detection (when novelty is set to `true`).** The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point. Because of this, the scores obtained via `score\_samples` may differ from the standard LOF scores. The standard LOF scores for the training data is available via the `negative\_outlier\_factor\_` attribute.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_score_samples = {k: v for k, v in pms_LocalOutlierFactor_score_samples.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_score_samples = bridgeLocalOutlierFactor[${this.id}].score_samples(**pms_LocalOutlierFactor_score_samples)`;
    return this._py`res_LocalOutlierFactor_score_samples.tolist() if hasattr(res_LocalOutlierFactor_score_samples, 'tolist') else res_LocalOutlierFactor_score_samples`;
  }
  /**
      The opposite LOF of the training samples. The higher, the more normal. Inliers tend to have a LOF score close to 1 (`negative\_outlier\_factor\_` close to -1), while outliers tend to have a larger LOF score.
  
      The local outlier factor (LOF) of a sample captures its supposed â€˜degree of abnormalityâ€™. It is the average of the ratio of the local reachability density of a sample and those of its k-nearest neighbors.
     */
  get negative_outlier_factor_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing negative_outlier_factor_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_negative_outlier_factor_ = bridgeLocalOutlierFactor[${this.id}].negative_outlier_factor_`;
      return this._py`attr_LocalOutlierFactor_negative_outlier_factor_.tolist() if hasattr(attr_LocalOutlierFactor_negative_outlier_factor_, 'tolist') else attr_LocalOutlierFactor_negative_outlier_factor_`;
    })();
  }
  /**
    The actual number of neighbors used for [`kneighbors`](#sklearn.neighbors.LocalOutlierFactor.kneighbors "sklearn.neighbors.LocalOutlierFactor.kneighbors") queries.
   */
  get n_neighbors_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_neighbors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_neighbors_ = bridgeLocalOutlierFactor[${this.id}].n_neighbors_`;
      return this._py`attr_LocalOutlierFactor_n_neighbors_.tolist() if hasattr(attr_LocalOutlierFactor_n_neighbors_, 'tolist') else attr_LocalOutlierFactor_n_neighbors_`;
    })();
  }
  /**
    Offset used to obtain binary labels from the raw scores. Observations having a negative\_outlier\_factor smaller than `offset\_` are detected as abnormal. The offset is set to -1.5 (inliers score around -1), except when a contamination parameter different than â€œautoâ€ is provided. In that case, the offset is defined in such a way we obtain the expected number of outliers in training.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_offset_ = bridgeLocalOutlierFactor[${this.id}].offset_`;
      return this._py`attr_LocalOutlierFactor_offset_.tolist() if hasattr(attr_LocalOutlierFactor_offset_, 'tolist') else attr_LocalOutlierFactor_offset_`;
    })();
  }
  /**
    The effective metric used for the distance computation.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_effective_metric_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_`;
      return this._py`attr_LocalOutlierFactor_effective_metric_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_, 'tolist') else attr_LocalOutlierFactor_effective_metric_`;
    })();
  }
  /**
    The effective additional keyword arguments for the metric function.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_effective_metric_params_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_params_`;
      return this._py`attr_LocalOutlierFactor_effective_metric_params_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_params_, 'tolist') else attr_LocalOutlierFactor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_features_in_ = bridgeLocalOutlierFactor[${this.id}].n_features_in_`;
      return this._py`attr_LocalOutlierFactor_n_features_in_.tolist() if hasattr(attr_LocalOutlierFactor_n_features_in_, 'tolist') else attr_LocalOutlierFactor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_feature_names_in_ = bridgeLocalOutlierFactor[${this.id}].feature_names_in_`;
      return this._py`attr_LocalOutlierFactor_feature_names_in_.tolist() if hasattr(attr_LocalOutlierFactor_feature_names_in_, 'tolist') else attr_LocalOutlierFactor_feature_names_in_`;
    })();
  }
  /**
    It is the number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_samples_fit_ = bridgeLocalOutlierFactor[${this.id}].n_samples_fit_`;
      return this._py`attr_LocalOutlierFactor_n_samples_fit_.tolist() if hasattr(attr_LocalOutlierFactor_n_samples_fit_, 'tolist') else attr_LocalOutlierFactor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/NearestCentroid.ts
import crypto214 from "node:crypto";
var NearestCentroid = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NearestCentroid${crypto214.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NearestCentroid.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NearestCentroid
try: bridgeNearestCentroid
except NameError: bridgeNearestCentroid = {}
`;
    await this._py.ex`ctor_NearestCentroid = {'metric': ${this.opts["metric"] ?? void 0}, 'shrink_threshold': ${this.opts["shrink_threshold"] ?? void 0}}

ctor_NearestCentroid = {k: v for k, v in ctor_NearestCentroid.items() if v is not None}`;
    await this._py.ex`bridgeNearestCentroid[${this.id}] = NearestCentroid(**ctor_NearestCentroid)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNearestCentroid[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the NearestCentroid model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before fit()");
    }
    await this._py.ex`pms_NearestCentroid_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_NearestCentroid_fit = {k: v for k, v in pms_NearestCentroid_fit.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_fit = bridgeNearestCentroid[${this.id}].fit(**pms_NearestCentroid_fit)`;
    return this._py`res_NearestCentroid_fit.tolist() if hasattr(res_NearestCentroid_fit, 'tolist') else res_NearestCentroid_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NearestCentroid_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NearestCentroid_get_metadata_routing = {k: v for k, v in pms_NearestCentroid_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_get_metadata_routing = bridgeNearestCentroid[${this.id}].get_metadata_routing(**pms_NearestCentroid_get_metadata_routing)`;
    return this._py`res_NearestCentroid_get_metadata_routing.tolist() if hasattr(res_NearestCentroid_get_metadata_routing, 'tolist') else res_NearestCentroid_get_metadata_routing`;
  }
  /**
      Perform classification on an array of test vectors `X`.
  
      The predicted class `C` for each sample in `X` is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before predict()");
    }
    await this._py.ex`pms_NearestCentroid_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NearestCentroid_predict = {k: v for k, v in pms_NearestCentroid_predict.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_predict = bridgeNearestCentroid[${this.id}].predict(**pms_NearestCentroid_predict)`;
    return this._py`res_NearestCentroid_predict.tolist() if hasattr(res_NearestCentroid_predict, 'tolist') else res_NearestCentroid_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before score()");
    }
    await this._py.ex`pms_NearestCentroid_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NearestCentroid_score = {k: v for k, v in pms_NearestCentroid_score.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_score = bridgeNearestCentroid[${this.id}].score(**pms_NearestCentroid_score)`;
    return this._py`res_NearestCentroid_score.tolist() if hasattr(res_NearestCentroid_score, 'tolist') else res_NearestCentroid_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_NearestCentroid_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NearestCentroid_set_score_request = {k: v for k, v in pms_NearestCentroid_set_score_request.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_set_score_request = bridgeNearestCentroid[${this.id}].set_score_request(**pms_NearestCentroid_set_score_request)`;
    return this._py`res_NearestCentroid_set_score_request.tolist() if hasattr(res_NearestCentroid_set_score_request, 'tolist') else res_NearestCentroid_set_score_request`;
  }
  /**
    Centroid of each class.
   */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing centroids_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_centroids_ = bridgeNearestCentroid[${this.id}].centroids_`;
      return this._py`attr_NearestCentroid_centroids_.tolist() if hasattr(attr_NearestCentroid_centroids_, 'tolist') else attr_NearestCentroid_centroids_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_classes_ = bridgeNearestCentroid[${this.id}].classes_`;
      return this._py`attr_NearestCentroid_classes_.tolist() if hasattr(attr_NearestCentroid_classes_, 'tolist') else attr_NearestCentroid_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_n_features_in_ = bridgeNearestCentroid[${this.id}].n_features_in_`;
      return this._py`attr_NearestCentroid_n_features_in_.tolist() if hasattr(attr_NearestCentroid_n_features_in_, 'tolist') else attr_NearestCentroid_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_feature_names_in_ = bridgeNearestCentroid[${this.id}].feature_names_in_`;
      return this._py`attr_NearestCentroid_feature_names_in_.tolist() if hasattr(attr_NearestCentroid_feature_names_in_, 'tolist') else attr_NearestCentroid_feature_names_in_`;
    })();
  }
};

// src/generated/neighbors/NearestNeighbors.ts
import crypto215 from "node:crypto";
var NearestNeighbors = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NearestNeighbors${crypto215.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NearestNeighbors.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NearestNeighbors
try: bridgeNearestNeighbors
except NameError: bridgeNearestNeighbors = {}
`;
    await this._py.ex`ctor_NearestNeighbors = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'radius': ${this.opts["radius"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_NearestNeighbors = {k: v for k, v in ctor_NearestNeighbors.items() if v is not None}`;
    await this._py.ex`bridgeNearestNeighbors[${this.id}] = NearestNeighbors(**ctor_NearestNeighbors)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNearestNeighbors[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the nearest neighbors estimator from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("NearestNeighbors must call init() before fit()");
    }
    await this._py.ex`pms_NearestNeighbors_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_NearestNeighbors_fit = {k: v for k, v in pms_NearestNeighbors_fit.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_fit = bridgeNearestNeighbors[${this.id}].fit(**pms_NearestNeighbors_fit)`;
    return this._py`res_NearestNeighbors_fit.tolist() if hasattr(res_NearestNeighbors_fit, 'tolist') else res_NearestNeighbors_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NearestNeighbors_get_metadata_routing = {k: v for k, v in pms_NearestNeighbors_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_get_metadata_routing = bridgeNearestNeighbors[${this.id}].get_metadata_routing(**pms_NearestNeighbors_get_metadata_routing)`;
    return this._py`res_NearestNeighbors_get_metadata_routing.tolist() if hasattr(res_NearestNeighbors_get_metadata_routing, 'tolist') else res_NearestNeighbors_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("NearestNeighbors must call init() before kneighbors()");
    }
    await this._py.ex`pms_NearestNeighbors_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_NearestNeighbors_kneighbors = {k: v for k, v in pms_NearestNeighbors_kneighbors.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_kneighbors = bridgeNearestNeighbors[${this.id}].kneighbors(**pms_NearestNeighbors_kneighbors)`;
    return this._py`res_NearestNeighbors_kneighbors.tolist() if hasattr(res_NearestNeighbors_kneighbors, 'tolist') else res_NearestNeighbors_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_NearestNeighbors_kneighbors_graph = {k: v for k, v in pms_NearestNeighbors_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_kneighbors_graph = bridgeNearestNeighbors[${this.id}].kneighbors_graph(**pms_NearestNeighbors_kneighbors_graph)`;
    return this._py`res_NearestNeighbors_kneighbors_graph.tolist() if hasattr(res_NearestNeighbors_kneighbors_graph, 'tolist') else res_NearestNeighbors_kneighbors_graph`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_NearestNeighbors_radius_neighbors = {k: v for k, v in pms_NearestNeighbors_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_radius_neighbors = bridgeNearestNeighbors[${this.id}].radius_neighbors(**pms_NearestNeighbors_radius_neighbors)`;
    return this._py`res_NearestNeighbors_radius_neighbors.tolist() if hasattr(res_NearestNeighbors_radius_neighbors, 'tolist') else res_NearestNeighbors_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_NearestNeighbors_radius_neighbors_graph = {k: v for k, v in pms_NearestNeighbors_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_radius_neighbors_graph = bridgeNearestNeighbors[${this.id}].radius_neighbors_graph(**pms_NearestNeighbors_radius_neighbors_graph)`;
    return this._py`res_NearestNeighbors_radius_neighbors_graph.tolist() if hasattr(res_NearestNeighbors_radius_neighbors_graph, 'tolist') else res_NearestNeighbors_radius_neighbors_graph`;
  }
  /**
    Metric used to compute distances to neighbors.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_effective_metric_ = bridgeNearestNeighbors[${this.id}].effective_metric_`;
      return this._py`attr_NearestNeighbors_effective_metric_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_, 'tolist') else attr_NearestNeighbors_effective_metric_`;
    })();
  }
  /**
    Parameters for the metric used to compute distances to neighbors.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_effective_metric_params_ = bridgeNearestNeighbors[${this.id}].effective_metric_params_`;
      return this._py`attr_NearestNeighbors_effective_metric_params_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_params_, 'tolist') else attr_NearestNeighbors_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_n_features_in_ = bridgeNearestNeighbors[${this.id}].n_features_in_`;
      return this._py`attr_NearestNeighbors_n_features_in_.tolist() if hasattr(attr_NearestNeighbors_n_features_in_, 'tolist') else attr_NearestNeighbors_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_feature_names_in_ = bridgeNearestNeighbors[${this.id}].feature_names_in_`;
      return this._py`attr_NearestNeighbors_feature_names_in_.tolist() if hasattr(attr_NearestNeighbors_feature_names_in_, 'tolist') else attr_NearestNeighbors_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_n_samples_fit_ = bridgeNearestNeighbors[${this.id}].n_samples_fit_`;
      return this._py`attr_NearestNeighbors_n_samples_fit_.tolist() if hasattr(attr_NearestNeighbors_n_samples_fit_, 'tolist') else attr_NearestNeighbors_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/NeighborhoodComponentsAnalysis.ts
import crypto216 from "node:crypto";
var NeighborhoodComponentsAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NeighborhoodComponentsAnalysis${crypto216.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "NeighborhoodComponentsAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NeighborhoodComponentsAnalysis
try: bridgeNeighborhoodComponentsAnalysis
except NameError: bridgeNeighborhoodComponentsAnalysis = {}
`;
    await this._py.ex`ctor_NeighborhoodComponentsAnalysis = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_NeighborhoodComponentsAnalysis = {k: v for k, v in ctor_NeighborhoodComponentsAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeNeighborhoodComponentsAnalysis[${this.id}] = NeighborhoodComponentsAnalysis(**ctor_NeighborhoodComponentsAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNeighborhoodComponentsAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_NeighborhoodComponentsAnalysis_fit = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_fit = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit(**pms_NeighborhoodComponentsAnalysis_fit)`;
    return this._py`res_NeighborhoodComponentsAnalysis_fit.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit, 'tolist') else res_NeighborhoodComponentsAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_fit_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_fit_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit_transform(**pms_NeighborhoodComponentsAnalysis_fit_transform)`;
    return this._py`res_NeighborhoodComponentsAnalysis_fit_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_get_feature_names_out = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_get_feature_names_out = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_feature_names_out(**pms_NeighborhoodComponentsAnalysis_get_feature_names_out)`;
    return this._py`res_NeighborhoodComponentsAnalysis_get_feature_names_out.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_feature_names_out, 'tolist') else res_NeighborhoodComponentsAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_get_metadata_routing = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_get_metadata_routing = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_metadata_routing(**pms_NeighborhoodComponentsAnalysis_get_metadata_routing)`;
    return this._py`res_NeighborhoodComponentsAnalysis_get_metadata_routing.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_metadata_routing, 'tolist') else res_NeighborhoodComponentsAnalysis_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before set_output()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_set_output = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_set_output = bridgeNeighborhoodComponentsAnalysis[${this.id}].set_output(**pms_NeighborhoodComponentsAnalysis_set_output)`;
    return this._py`res_NeighborhoodComponentsAnalysis_set_output.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_set_output, 'tolist') else res_NeighborhoodComponentsAnalysis_set_output`;
  }
  /**
    Apply the learned transformation to the given data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before transform()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NeighborhoodComponentsAnalysis_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].transform(**pms_NeighborhoodComponentsAnalysis_transform)`;
    return this._py`res_NeighborhoodComponentsAnalysis_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_transform`;
  }
  /**
    The linear transformation learned during fitting.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_components_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].components_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_components_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_components_, 'tolist') else attr_NeighborhoodComponentsAnalysis_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_n_features_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_n_features_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_features_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_features_in_`;
    })();
  }
  /**
    Counts the number of iterations performed by the optimizer.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_n_iter_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_iter_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_n_iter_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_iter_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_iter_`;
    })();
  }
  /**
    Pseudo random number generator object used during initialization.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_random_state_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].random_state_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_random_state_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_random_state_, 'tolist') else attr_NeighborhoodComponentsAnalysis_random_state_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_feature_names_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_feature_names_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_feature_names_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsClassifier.ts
import crypto217 from "node:crypto";
var RadiusNeighborsClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsClassifier${crypto217.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsClassifier
try: bridgeRadiusNeighborsClassifier
except NameError: bridgeRadiusNeighborsClassifier = {}
`;
    await this._py.ex`ctor_RadiusNeighborsClassifier = {'radius': ${this.opts["radius"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'outlier_label': ${this.opts["outlier_label"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsClassifier = {k: v for k, v in ctor_RadiusNeighborsClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsClassifier[${this.id}] = RadiusNeighborsClassifier(**ctor_RadiusNeighborsClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors classifier from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RadiusNeighborsClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RadiusNeighborsClassifier_fit = {k: v for k, v in pms_RadiusNeighborsClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_fit = bridgeRadiusNeighborsClassifier[${this.id}].fit(**pms_RadiusNeighborsClassifier_fit)`;
    return this._py`res_RadiusNeighborsClassifier_fit.tolist() if hasattr(res_RadiusNeighborsClassifier_fit, 'tolist') else res_RadiusNeighborsClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_get_metadata_routing = bridgeRadiusNeighborsClassifier[${this.id}].get_metadata_routing(**pms_RadiusNeighborsClassifier_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsClassifier_get_metadata_routing, 'tolist') else res_RadiusNeighborsClassifier_get_metadata_routing`;
  }
  /**
    Predict the class labels for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsClassifier_predict = {k: v for k, v in pms_RadiusNeighborsClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_predict = bridgeRadiusNeighborsClassifier[${this.id}].predict(**pms_RadiusNeighborsClassifier_predict)`;
    return this._py`res_RadiusNeighborsClassifier_predict.tolist() if hasattr(res_RadiusNeighborsClassifier_predict, 'tolist') else res_RadiusNeighborsClassifier_predict`;
  }
  /**
    Return probability estimates for the test data X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsClassifier_predict_proba = {k: v for k, v in pms_RadiusNeighborsClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_predict_proba = bridgeRadiusNeighborsClassifier[${this.id}].predict_proba(**pms_RadiusNeighborsClassifier_predict_proba)`;
    return this._py`res_RadiusNeighborsClassifier_predict_proba.tolist() if hasattr(res_RadiusNeighborsClassifier_predict_proba, 'tolist') else res_RadiusNeighborsClassifier_predict_proba`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsClassifier_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_radius_neighbors = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors(**pms_RadiusNeighborsClassifier_radius_neighbors)`;
    return this._py`res_RadiusNeighborsClassifier_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsClassifier_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_radius_neighbors_graph = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsClassifier_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsClassifier_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors_graph`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RadiusNeighborsClassifier_score = {k: v for k, v in pms_RadiusNeighborsClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_score = bridgeRadiusNeighborsClassifier[${this.id}].score(**pms_RadiusNeighborsClassifier_score)`;
    return this._py`res_RadiusNeighborsClassifier_score.tolist() if hasattr(res_RadiusNeighborsClassifier_score, 'tolist') else res_RadiusNeighborsClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RadiusNeighborsClassifier_set_score_request = {k: v for k, v in pms_RadiusNeighborsClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_set_score_request = bridgeRadiusNeighborsClassifier[${this.id}].set_score_request(**pms_RadiusNeighborsClassifier_set_score_request)`;
    return this._py`res_RadiusNeighborsClassifier_set_score_request.tolist() if hasattr(res_RadiusNeighborsClassifier_set_score_request, 'tolist') else res_RadiusNeighborsClassifier_set_score_request`;
  }
  /**
    Class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_classes_ = bridgeRadiusNeighborsClassifier[${this.id}].classes_`;
      return this._py`attr_RadiusNeighborsClassifier_classes_.tolist() if hasattr(attr_RadiusNeighborsClassifier_classes_, 'tolist') else attr_RadiusNeighborsClassifier_classes_`;
    })();
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_effective_metric_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_effective_metric_params_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_params_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_n_features_in_ = bridgeRadiusNeighborsClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_features_in_, 'tolist') else attr_RadiusNeighborsClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_feature_names_in_ = bridgeRadiusNeighborsClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_feature_names_in_, 'tolist') else attr_RadiusNeighborsClassifier_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_n_samples_fit_ = bridgeRadiusNeighborsClassifier[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_samples_fit_, 'tolist') else attr_RadiusNeighborsClassifier_n_samples_fit_`;
    })();
  }
  /**
    Label which is given for outlier samples (samples with no neighbors on given radius).
   */
  get outlier_label_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing outlier_label_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_outlier_label_ = bridgeRadiusNeighborsClassifier[${this.id}].outlier_label_`;
      return this._py`attr_RadiusNeighborsClassifier_outlier_label_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outlier_label_, 'tolist') else attr_RadiusNeighborsClassifier_outlier_label_`;
    })();
  }
  /**
    False when `y`â€™s shape is (n\_samples, ) or (n\_samples, 1) during fit otherwise `true`.
   */
  get outputs_2d_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing outputs_2d_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_outputs_2d_ = bridgeRadiusNeighborsClassifier[${this.id}].outputs_2d_`;
      return this._py`attr_RadiusNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outputs_2d_, 'tolist') else attr_RadiusNeighborsClassifier_outputs_2d_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsRegressor.ts
import crypto218 from "node:crypto";
var RadiusNeighborsRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsRegressor${crypto218.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsRegressor
try: bridgeRadiusNeighborsRegressor
except NameError: bridgeRadiusNeighborsRegressor = {}
`;
    await this._py.ex`ctor_RadiusNeighborsRegressor = {'radius': ${this.opts["radius"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsRegressor = {k: v for k, v in ctor_RadiusNeighborsRegressor.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsRegressor[${this.id}] = RadiusNeighborsRegressor(**ctor_RadiusNeighborsRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors regressor from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RadiusNeighborsRegressor must call init() before fit()");
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RadiusNeighborsRegressor_fit = {k: v for k, v in pms_RadiusNeighborsRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_fit = bridgeRadiusNeighborsRegressor[${this.id}].fit(**pms_RadiusNeighborsRegressor_fit)`;
    return this._py`res_RadiusNeighborsRegressor_fit.tolist() if hasattr(res_RadiusNeighborsRegressor_fit, 'tolist') else res_RadiusNeighborsRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_get_metadata_routing = bridgeRadiusNeighborsRegressor[${this.id}].get_metadata_routing(**pms_RadiusNeighborsRegressor_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsRegressor_get_metadata_routing, 'tolist') else res_RadiusNeighborsRegressor_get_metadata_routing`;
  }
  /**
    Predict the target for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsRegressor_predict = {k: v for k, v in pms_RadiusNeighborsRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_predict = bridgeRadiusNeighborsRegressor[${this.id}].predict(**pms_RadiusNeighborsRegressor_predict)`;
    return this._py`res_RadiusNeighborsRegressor_predict.tolist() if hasattr(res_RadiusNeighborsRegressor_predict, 'tolist') else res_RadiusNeighborsRegressor_predict`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsRegressor_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_radius_neighbors = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors(**pms_RadiusNeighborsRegressor_radius_neighbors)`;
    return this._py`res_RadiusNeighborsRegressor_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsRegressor_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_radius_neighbors_graph = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsRegressor_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsRegressor_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors_graph`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RadiusNeighborsRegressor_score = {k: v for k, v in pms_RadiusNeighborsRegressor_score.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_score = bridgeRadiusNeighborsRegressor[${this.id}].score(**pms_RadiusNeighborsRegressor_score)`;
    return this._py`res_RadiusNeighborsRegressor_score.tolist() if hasattr(res_RadiusNeighborsRegressor_score, 'tolist') else res_RadiusNeighborsRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RadiusNeighborsRegressor_set_score_request = {k: v for k, v in pms_RadiusNeighborsRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_set_score_request = bridgeRadiusNeighborsRegressor[${this.id}].set_score_request(**pms_RadiusNeighborsRegressor_set_score_request)`;
    return this._py`res_RadiusNeighborsRegressor_set_score_request.tolist() if hasattr(res_RadiusNeighborsRegressor_set_score_request, 'tolist') else res_RadiusNeighborsRegressor_set_score_request`;
  }
  /**
    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_effective_metric_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_effective_metric_params_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_params_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_n_features_in_ = bridgeRadiusNeighborsRegressor[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_features_in_, 'tolist') else attr_RadiusNeighborsRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_feature_names_in_ = bridgeRadiusNeighborsRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_feature_names_in_, 'tolist') else attr_RadiusNeighborsRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_n_samples_fit_ = bridgeRadiusNeighborsRegressor[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_samples_fit_, 'tolist') else attr_RadiusNeighborsRegressor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsTransformer.ts
import crypto219 from "node:crypto";
var RadiusNeighborsTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsTransformer${crypto219.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsTransformer
try: bridgeRadiusNeighborsTransformer
except NameError: bridgeRadiusNeighborsTransformer = {}
`;
    await this._py.ex`ctor_RadiusNeighborsTransformer = {'mode': ${this.opts["mode"] ?? void 0}, 'radius': ${this.opts["radius"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsTransformer = {k: v for k, v in ctor_RadiusNeighborsTransformer.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsTransformer[${this.id}] = RadiusNeighborsTransformer(**ctor_RadiusNeighborsTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors transformer from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before fit()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RadiusNeighborsTransformer_fit = {k: v for k, v in pms_RadiusNeighborsTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_fit = bridgeRadiusNeighborsTransformer[${this.id}].fit(**pms_RadiusNeighborsTransformer_fit)`;
    return this._py`res_RadiusNeighborsTransformer_fit.tolist() if hasattr(res_RadiusNeighborsTransformer_fit, 'tolist') else res_RadiusNeighborsTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit\_params and returns a transformed version of X.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RadiusNeighborsTransformer_fit_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_fit_transform = bridgeRadiusNeighborsTransformer[${this.id}].fit_transform(**pms_RadiusNeighborsTransformer_fit_transform)`;
    return this._py`res_RadiusNeighborsTransformer_fit_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_fit_transform, 'tolist') else res_RadiusNeighborsTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RadiusNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_RadiusNeighborsTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_get_feature_names_out = bridgeRadiusNeighborsTransformer[${this.id}].get_feature_names_out(**pms_RadiusNeighborsTransformer_get_feature_names_out)`;
    return this._py`res_RadiusNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_RadiusNeighborsTransformer_get_feature_names_out, 'tolist') else res_RadiusNeighborsTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_get_metadata_routing = bridgeRadiusNeighborsTransformer[${this.id}].get_metadata_routing(**pms_RadiusNeighborsTransformer_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsTransformer_get_metadata_routing, 'tolist') else res_RadiusNeighborsTransformer_get_metadata_routing`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsTransformer_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_radius_neighbors = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors(**pms_RadiusNeighborsTransformer_radius_neighbors)`;
    return this._py`res_RadiusNeighborsTransformer_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsTransformer_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_radius_neighbors_graph = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsTransformer_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsTransformer_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors_graph`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RadiusNeighborsTransformer_set_output = {k: v for k, v in pms_RadiusNeighborsTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_set_output = bridgeRadiusNeighborsTransformer[${this.id}].set_output(**pms_RadiusNeighborsTransformer_set_output)`;
    return this._py`res_RadiusNeighborsTransformer_set_output.tolist() if hasattr(res_RadiusNeighborsTransformer_set_output, 'tolist') else res_RadiusNeighborsTransformer_set_output`;
  }
  /**
    Compute the (weighted) graph of Neighbors for points in X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before transform()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsTransformer_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_transform = bridgeRadiusNeighborsTransformer[${this.id}].transform(**pms_RadiusNeighborsTransformer_transform)`;
    return this._py`res_RadiusNeighborsTransformer_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_transform, 'tolist') else res_RadiusNeighborsTransformer_transform`;
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. â€˜euclideanâ€™ if the `metric` parameter set to â€˜minkowskiâ€™ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_effective_metric_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to â€˜minkowskiâ€™.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_effective_metric_params_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_params_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_n_features_in_ = bridgeRadiusNeighborsTransformer[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_features_in_, 'tolist') else attr_RadiusNeighborsTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_feature_names_in_ = bridgeRadiusNeighborsTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_feature_names_in_, 'tolist') else attr_RadiusNeighborsTransformer_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_n_samples_fit_ = bridgeRadiusNeighborsTransformer[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_samples_fit_, 'tolist') else attr_RadiusNeighborsTransformer_n_samples_fit_`;
    })();
  }
};

// src/generated/neural_network/BernoulliRBM.ts
import crypto220 from "node:crypto";
var BernoulliRBM = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BernoulliRBM${crypto220.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BernoulliRBM.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neural_network import BernoulliRBM
try: bridgeBernoulliRBM
except NameError: bridgeBernoulliRBM = {}
`;
    await this._py.ex`ctor_BernoulliRBM = {'n_components': ${this.opts["n_components"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_BernoulliRBM = {k: v for k, v in ctor_BernoulliRBM.items() if v is not None}`;
    await this._py.ex`bridgeBernoulliRBM[${this.id}] = BernoulliRBM(**ctor_BernoulliRBM)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBernoulliRBM[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before fit()");
    }
    await this._py.ex`pms_BernoulliRBM_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_BernoulliRBM_fit = {k: v for k, v in pms_BernoulliRBM_fit.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_fit = bridgeBernoulliRBM[${this.id}].fit(**pms_BernoulliRBM_fit)`;
    return this._py`res_BernoulliRBM_fit.tolist() if hasattr(res_BernoulliRBM_fit, 'tolist') else res_BernoulliRBM_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before fit_transform()");
    }
    await this._py.ex`pms_BernoulliRBM_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_BernoulliRBM_fit_transform = {k: v for k, v in pms_BernoulliRBM_fit_transform.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_fit_transform = bridgeBernoulliRBM[${this.id}].fit_transform(**pms_BernoulliRBM_fit_transform)`;
    return this._py`res_BernoulliRBM_fit_transform.tolist() if hasattr(res_BernoulliRBM_fit_transform, 'tolist') else res_BernoulliRBM_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_BernoulliRBM_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_BernoulliRBM_get_feature_names_out = {k: v for k, v in pms_BernoulliRBM_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_get_feature_names_out = bridgeBernoulliRBM[${this.id}].get_feature_names_out(**pms_BernoulliRBM_get_feature_names_out)`;
    return this._py`res_BernoulliRBM_get_feature_names_out.tolist() if hasattr(res_BernoulliRBM_get_feature_names_out, 'tolist') else res_BernoulliRBM_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BernoulliRBM_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BernoulliRBM_get_metadata_routing = {k: v for k, v in pms_BernoulliRBM_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_get_metadata_routing = bridgeBernoulliRBM[${this.id}].get_metadata_routing(**pms_BernoulliRBM_get_metadata_routing)`;
    return this._py`res_BernoulliRBM_get_metadata_routing.tolist() if hasattr(res_BernoulliRBM_get_metadata_routing, 'tolist') else res_BernoulliRBM_get_metadata_routing`;
  }
  /**
    Perform one Gibbs sampling step.
   */
  async gibbs(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before gibbs()");
    }
    await this._py.ex`pms_BernoulliRBM_gibbs = {'v': np.array(${opts["v"] ?? void 0}) if ${opts["v"] !== void 0} else None}

pms_BernoulliRBM_gibbs = {k: v for k, v in pms_BernoulliRBM_gibbs.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_gibbs = bridgeBernoulliRBM[${this.id}].gibbs(**pms_BernoulliRBM_gibbs)`;
    return this._py`res_BernoulliRBM_gibbs.tolist() if hasattr(res_BernoulliRBM_gibbs, 'tolist') else res_BernoulliRBM_gibbs`;
  }
  /**
    Fit the model to the partial segment of the data X.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before partial_fit()");
    }
    await this._py.ex`pms_BernoulliRBM_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_BernoulliRBM_partial_fit = {k: v for k, v in pms_BernoulliRBM_partial_fit.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_partial_fit = bridgeBernoulliRBM[${this.id}].partial_fit(**pms_BernoulliRBM_partial_fit)`;
    return this._py`res_BernoulliRBM_partial_fit.tolist() if hasattr(res_BernoulliRBM_partial_fit, 'tolist') else res_BernoulliRBM_partial_fit`;
  }
  /**
    Compute the pseudo-likelihood of X.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before score_samples()");
    }
    await this._py.ex`pms_BernoulliRBM_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliRBM_score_samples = {k: v for k, v in pms_BernoulliRBM_score_samples.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_score_samples = bridgeBernoulliRBM[${this.id}].score_samples(**pms_BernoulliRBM_score_samples)`;
    return this._py`res_BernoulliRBM_score_samples.tolist() if hasattr(res_BernoulliRBM_score_samples, 'tolist') else res_BernoulliRBM_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before set_output()");
    }
    await this._py.ex`pms_BernoulliRBM_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_BernoulliRBM_set_output = {k: v for k, v in pms_BernoulliRBM_set_output.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_set_output = bridgeBernoulliRBM[${this.id}].set_output(**pms_BernoulliRBM_set_output)`;
    return this._py`res_BernoulliRBM_set_output.tolist() if hasattr(res_BernoulliRBM_set_output, 'tolist') else res_BernoulliRBM_set_output`;
  }
  /**
    Compute the hidden layer activation probabilities, P(h=1|v=X).
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BernoulliRBM must call init() before transform()");
    }
    await this._py.ex`pms_BernoulliRBM_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BernoulliRBM_transform = {k: v for k, v in pms_BernoulliRBM_transform.items() if v is not None}`;
    await this._py.ex`res_BernoulliRBM_transform = bridgeBernoulliRBM[${this.id}].transform(**pms_BernoulliRBM_transform)`;
    return this._py`res_BernoulliRBM_transform.tolist() if hasattr(res_BernoulliRBM_transform, 'tolist') else res_BernoulliRBM_transform`;
  }
  /**
    Biases of the hidden units.
   */
  get intercept_hidden_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing intercept_hidden_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_intercept_hidden_ = bridgeBernoulliRBM[${this.id}].intercept_hidden_`;
      return this._py`attr_BernoulliRBM_intercept_hidden_.tolist() if hasattr(attr_BernoulliRBM_intercept_hidden_, 'tolist') else attr_BernoulliRBM_intercept_hidden_`;
    })();
  }
  /**
    Biases of the visible units.
   */
  get intercept_visible_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing intercept_visible_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_intercept_visible_ = bridgeBernoulliRBM[${this.id}].intercept_visible_`;
      return this._py`attr_BernoulliRBM_intercept_visible_.tolist() if hasattr(attr_BernoulliRBM_intercept_visible_, 'tolist') else attr_BernoulliRBM_intercept_visible_`;
    })();
  }
  /**
    Weight matrix, where `n\_features` is the number of visible units and `n\_components` is the number of hidden units.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_components_ = bridgeBernoulliRBM[${this.id}].components_`;
      return this._py`attr_BernoulliRBM_components_.tolist() if hasattr(attr_BernoulliRBM_components_, 'tolist') else attr_BernoulliRBM_components_`;
    })();
  }
  /**
    Hidden Activation sampled from the model distribution, where `batch\_size` is the number of examples per minibatch and `n\_components` is the number of hidden units.
   */
  get h_samples_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing h_samples_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_h_samples_ = bridgeBernoulliRBM[${this.id}].h_samples_`;
      return this._py`attr_BernoulliRBM_h_samples_.tolist() if hasattr(attr_BernoulliRBM_h_samples_, 'tolist') else attr_BernoulliRBM_h_samples_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_n_features_in_ = bridgeBernoulliRBM[${this.id}].n_features_in_`;
      return this._py`attr_BernoulliRBM_n_features_in_.tolist() if hasattr(attr_BernoulliRBM_n_features_in_, 'tolist') else attr_BernoulliRBM_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BernoulliRBM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BernoulliRBM must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BernoulliRBM_feature_names_in_ = bridgeBernoulliRBM[${this.id}].feature_names_in_`;
      return this._py`attr_BernoulliRBM_feature_names_in_.tolist() if hasattr(attr_BernoulliRBM_feature_names_in_, 'tolist') else attr_BernoulliRBM_feature_names_in_`;
    })();
  }
};

// src/generated/neural_network/MLPClassifier.ts
import crypto221 from "node:crypto";
var MLPClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MLPClassifier${crypto221.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MLPClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neural_network import MLPClassifier
try: bridgeMLPClassifier
except NameError: bridgeMLPClassifier = {}
`;
    await this._py.ex`ctor_MLPClassifier = {'hidden_layer_sizes': np.array(${this.opts["hidden_layer_sizes"] ?? void 0}) if ${this.opts["hidden_layer_sizes"] !== void 0} else None, 'activation': ${this.opts["activation"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'learning_rate_init': ${this.opts["learning_rate_init"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'momentum': ${this.opts["momentum"] ?? void 0}, 'nesterovs_momentum': ${this.opts["nesterovs_momentum"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'beta_1': ${this.opts["beta_1"] ?? void 0}, 'beta_2': ${this.opts["beta_2"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'max_fun': ${this.opts["max_fun"] ?? void 0}}

ctor_MLPClassifier = {k: v for k, v in ctor_MLPClassifier.items() if v is not None}`;
    await this._py.ex`bridgeMLPClassifier[${this.id}] = MLPClassifier(**ctor_MLPClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMLPClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to data matrix X and target(s) y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before fit()");
    }
    await this._py.ex`pms_MLPClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MLPClassifier_fit = {k: v for k, v in pms_MLPClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_fit = bridgeMLPClassifier[${this.id}].fit(**pms_MLPClassifier_fit)`;
    return this._py`res_MLPClassifier_fit.tolist() if hasattr(res_MLPClassifier_fit, 'tolist') else res_MLPClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MLPClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MLPClassifier_get_metadata_routing = {k: v for k, v in pms_MLPClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_get_metadata_routing = bridgeMLPClassifier[${this.id}].get_metadata_routing(**pms_MLPClassifier_get_metadata_routing)`;
    return this._py`res_MLPClassifier_get_metadata_routing.tolist() if hasattr(res_MLPClassifier_get_metadata_routing, 'tolist') else res_MLPClassifier_get_metadata_routing`;
  }
  /**
    Update the model with a single iteration over the given data.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before partial_fit()");
    }
    await this._py.ex`pms_MLPClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None}

pms_MLPClassifier_partial_fit = {k: v for k, v in pms_MLPClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_partial_fit = bridgeMLPClassifier[${this.id}].partial_fit(**pms_MLPClassifier_partial_fit)`;
    return this._py`res_MLPClassifier_partial_fit.tolist() if hasattr(res_MLPClassifier_partial_fit, 'tolist') else res_MLPClassifier_partial_fit`;
  }
  /**
    Predict using the multi-layer perceptron classifier.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before predict()");
    }
    await this._py.ex`pms_MLPClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MLPClassifier_predict = {k: v for k, v in pms_MLPClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_predict = bridgeMLPClassifier[${this.id}].predict(**pms_MLPClassifier_predict)`;
    return this._py`res_MLPClassifier_predict.tolist() if hasattr(res_MLPClassifier_predict, 'tolist') else res_MLPClassifier_predict`;
  }
  /**
    Return the log of probability estimates.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_MLPClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MLPClassifier_predict_log_proba = {k: v for k, v in pms_MLPClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_predict_log_proba = bridgeMLPClassifier[${this.id}].predict_log_proba(**pms_MLPClassifier_predict_log_proba)`;
    return this._py`res_MLPClassifier_predict_log_proba.tolist() if hasattr(res_MLPClassifier_predict_log_proba, 'tolist') else res_MLPClassifier_predict_log_proba`;
  }
  /**
    Probability estimates.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before predict_proba()");
    }
    await this._py.ex`pms_MLPClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MLPClassifier_predict_proba = {k: v for k, v in pms_MLPClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_predict_proba = bridgeMLPClassifier[${this.id}].predict_proba(**pms_MLPClassifier_predict_proba)`;
    return this._py`res_MLPClassifier_predict_proba.tolist() if hasattr(res_MLPClassifier_predict_proba, 'tolist') else res_MLPClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before score()");
    }
    await this._py.ex`pms_MLPClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MLPClassifier_score = {k: v for k, v in pms_MLPClassifier_score.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_score = bridgeMLPClassifier[${this.id}].score(**pms_MLPClassifier_score)`;
    return this._py`res_MLPClassifier_score.tolist() if hasattr(res_MLPClassifier_score, 'tolist') else res_MLPClassifier_score`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MLPClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}}

pms_MLPClassifier_set_partial_fit_request = {k: v for k, v in pms_MLPClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_set_partial_fit_request = bridgeMLPClassifier[${this.id}].set_partial_fit_request(**pms_MLPClassifier_set_partial_fit_request)`;
    return this._py`res_MLPClassifier_set_partial_fit_request.tolist() if hasattr(res_MLPClassifier_set_partial_fit_request, 'tolist') else res_MLPClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MLPClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MLPClassifier_set_score_request = {k: v for k, v in pms_MLPClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MLPClassifier_set_score_request = bridgeMLPClassifier[${this.id}].set_score_request(**pms_MLPClassifier_set_score_request)`;
    return this._py`res_MLPClassifier_set_score_request.tolist() if hasattr(res_MLPClassifier_set_score_request, 'tolist') else res_MLPClassifier_set_score_request`;
  }
  /**
    Class labels for each output.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_classes_ = bridgeMLPClassifier[${this.id}].classes_`;
      return this._py`attr_MLPClassifier_classes_.tolist() if hasattr(attr_MLPClassifier_classes_, 'tolist') else attr_MLPClassifier_classes_`;
    })();
  }
  /**
    The current loss computed with the loss function.
   */
  get loss_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before accessing loss_");
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_loss_ = bridgeMLPClassifier[${this.id}].loss_`;
      return this._py`attr_MLPClassifier_loss_.tolist() if hasattr(attr_MLPClassifier_loss_, 'tolist') else attr_MLPClassifier_loss_`;
    })();
  }
  /**
    The minimum loss reached by the solver throughout fitting. If `early\_stopping=True`, this attribute is set to `undefined`. Refer to the `best\_validation\_score\_` fitted attribute instead.
   */
  get best_loss_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing best_loss_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_best_loss_ = bridgeMLPClassifier[${this.id}].best_loss_`;
      return this._py`attr_MLPClassifier_best_loss_.tolist() if hasattr(attr_MLPClassifier_best_loss_, 'tolist') else attr_MLPClassifier_best_loss_`;
    })();
  }
  /**
    The ith element in the list represents the loss at the ith iteration.
   */
  get loss_curve_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing loss_curve_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_loss_curve_ = bridgeMLPClassifier[${this.id}].loss_curve_`;
      return this._py`attr_MLPClassifier_loss_curve_.tolist() if hasattr(attr_MLPClassifier_loss_curve_, 'tolist') else attr_MLPClassifier_loss_curve_`;
    })();
  }
  /**
    The score at each iteration on a held-out validation set. The score reported is the accuracy score. Only available if `early\_stopping=True`, otherwise the attribute is set to `undefined`.
   */
  get validation_scores_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing validation_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_validation_scores_ = bridgeMLPClassifier[${this.id}].validation_scores_`;
      return this._py`attr_MLPClassifier_validation_scores_.tolist() if hasattr(attr_MLPClassifier_validation_scores_, 'tolist') else attr_MLPClassifier_validation_scores_`;
    })();
  }
  /**
    The best validation score (i.e. accuracy score) that triggered the early stopping. Only available if `early\_stopping=True`, otherwise the attribute is set to `undefined`.
   */
  get best_validation_score_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing best_validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_best_validation_score_ = bridgeMLPClassifier[${this.id}].best_validation_score_`;
      return this._py`attr_MLPClassifier_best_validation_score_.tolist() if hasattr(attr_MLPClassifier_best_validation_score_, 'tolist') else attr_MLPClassifier_best_validation_score_`;
    })();
  }
  /**
    The number of training samples seen by the solver during fitting.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_t_ = bridgeMLPClassifier[${this.id}].t_`;
      return this._py`attr_MLPClassifier_t_.tolist() if hasattr(attr_MLPClassifier_t_, 'tolist') else attr_MLPClassifier_t_`;
    })();
  }
  /**
    The ith element in the list represents the weight matrix corresponding to layer i.
   */
  get coefs_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before accessing coefs_");
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_coefs_ = bridgeMLPClassifier[${this.id}].coefs_`;
      return this._py`attr_MLPClassifier_coefs_.tolist() if hasattr(attr_MLPClassifier_coefs_, 'tolist') else attr_MLPClassifier_coefs_`;
    })();
  }
  /**
    The ith element in the list represents the bias vector corresponding to layer i + 1.
   */
  get intercepts_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing intercepts_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_intercepts_ = bridgeMLPClassifier[${this.id}].intercepts_`;
      return this._py`attr_MLPClassifier_intercepts_.tolist() if hasattr(attr_MLPClassifier_intercepts_, 'tolist') else attr_MLPClassifier_intercepts_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_n_features_in_ = bridgeMLPClassifier[${this.id}].n_features_in_`;
      return this._py`attr_MLPClassifier_n_features_in_.tolist() if hasattr(attr_MLPClassifier_n_features_in_, 'tolist') else attr_MLPClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_feature_names_in_ = bridgeMLPClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_MLPClassifier_feature_names_in_.tolist() if hasattr(attr_MLPClassifier_feature_names_in_, 'tolist') else attr_MLPClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of iterations the solver has run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPClassifier must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_n_iter_ = bridgeMLPClassifier[${this.id}].n_iter_`;
      return this._py`attr_MLPClassifier_n_iter_.tolist() if hasattr(attr_MLPClassifier_n_iter_, 'tolist') else attr_MLPClassifier_n_iter_`;
    })();
  }
  /**
    Number of layers.
   */
  get n_layers_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing n_layers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_n_layers_ = bridgeMLPClassifier[${this.id}].n_layers_`;
      return this._py`attr_MLPClassifier_n_layers_.tolist() if hasattr(attr_MLPClassifier_n_layers_, 'tolist') else attr_MLPClassifier_n_layers_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_n_outputs_ = bridgeMLPClassifier[${this.id}].n_outputs_`;
      return this._py`attr_MLPClassifier_n_outputs_.tolist() if hasattr(attr_MLPClassifier_n_outputs_, 'tolist') else attr_MLPClassifier_n_outputs_`;
    })();
  }
  /**
    Name of the output activation function.
   */
  get out_activation_() {
    if (this._isDisposed) {
      throw new Error("This MLPClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPClassifier must call init() before accessing out_activation_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPClassifier_out_activation_ = bridgeMLPClassifier[${this.id}].out_activation_`;
      return this._py`attr_MLPClassifier_out_activation_.tolist() if hasattr(attr_MLPClassifier_out_activation_, 'tolist') else attr_MLPClassifier_out_activation_`;
    })();
  }
};

// src/generated/neural_network/MLPRegressor.ts
import crypto222 from "node:crypto";
var MLPRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MLPRegressor${crypto222.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MLPRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neural_network import MLPRegressor
try: bridgeMLPRegressor
except NameError: bridgeMLPRegressor = {}
`;
    await this._py.ex`ctor_MLPRegressor = {'hidden_layer_sizes': np.array(${this.opts["hidden_layer_sizes"] ?? void 0}) if ${this.opts["hidden_layer_sizes"] !== void 0} else None, 'activation': ${this.opts["activation"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'learning_rate_init': ${this.opts["learning_rate_init"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'momentum': ${this.opts["momentum"] ?? void 0}, 'nesterovs_momentum': ${this.opts["nesterovs_momentum"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'beta_1': ${this.opts["beta_1"] ?? void 0}, 'beta_2': ${this.opts["beta_2"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'max_fun': ${this.opts["max_fun"] ?? void 0}}

ctor_MLPRegressor = {k: v for k, v in ctor_MLPRegressor.items() if v is not None}`;
    await this._py.ex`bridgeMLPRegressor[${this.id}] = MLPRegressor(**ctor_MLPRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMLPRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to data matrix X and target(s) y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before fit()");
    }
    await this._py.ex`pms_MLPRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MLPRegressor_fit = {k: v for k, v in pms_MLPRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_fit = bridgeMLPRegressor[${this.id}].fit(**pms_MLPRegressor_fit)`;
    return this._py`res_MLPRegressor_fit.tolist() if hasattr(res_MLPRegressor_fit, 'tolist') else res_MLPRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MLPRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MLPRegressor_get_metadata_routing = {k: v for k, v in pms_MLPRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_get_metadata_routing = bridgeMLPRegressor[${this.id}].get_metadata_routing(**pms_MLPRegressor_get_metadata_routing)`;
    return this._py`res_MLPRegressor_get_metadata_routing.tolist() if hasattr(res_MLPRegressor_get_metadata_routing, 'tolist') else res_MLPRegressor_get_metadata_routing`;
  }
  /**
    Update the model with a single iteration over the given data.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before partial_fit()");
    }
    await this._py.ex`pms_MLPRegressor_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MLPRegressor_partial_fit = {k: v for k, v in pms_MLPRegressor_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_partial_fit = bridgeMLPRegressor[${this.id}].partial_fit(**pms_MLPRegressor_partial_fit)`;
    return this._py`res_MLPRegressor_partial_fit.tolist() if hasattr(res_MLPRegressor_partial_fit, 'tolist') else res_MLPRegressor_partial_fit`;
  }
  /**
    Predict using the multi-layer perceptron model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before predict()");
    }
    await this._py.ex`pms_MLPRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MLPRegressor_predict = {k: v for k, v in pms_MLPRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_predict = bridgeMLPRegressor[${this.id}].predict(**pms_MLPRegressor_predict)`;
    return this._py`res_MLPRegressor_predict.tolist() if hasattr(res_MLPRegressor_predict, 'tolist') else res_MLPRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before score()");
    }
    await this._py.ex`pms_MLPRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MLPRegressor_score = {k: v for k, v in pms_MLPRegressor_score.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_score = bridgeMLPRegressor[${this.id}].score(**pms_MLPRegressor_score)`;
    return this._py`res_MLPRegressor_score.tolist() if hasattr(res_MLPRegressor_score, 'tolist') else res_MLPRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MLPRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MLPRegressor_set_score_request = {k: v for k, v in pms_MLPRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MLPRegressor_set_score_request = bridgeMLPRegressor[${this.id}].set_score_request(**pms_MLPRegressor_set_score_request)`;
    return this._py`res_MLPRegressor_set_score_request.tolist() if hasattr(res_MLPRegressor_set_score_request, 'tolist') else res_MLPRegressor_set_score_request`;
  }
  /**
    The current loss computed with the loss function.
   */
  get loss_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before accessing loss_");
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_loss_ = bridgeMLPRegressor[${this.id}].loss_`;
      return this._py`attr_MLPRegressor_loss_.tolist() if hasattr(attr_MLPRegressor_loss_, 'tolist') else attr_MLPRegressor_loss_`;
    })();
  }
  /**
    The minimum loss reached by the solver throughout fitting. If `early\_stopping=True`, this attribute is set to `undefined`. Refer to the `best\_validation\_score\_` fitted attribute instead. Only accessible when solver=â€™sgdâ€™ or â€˜adamâ€™.
   */
  get best_loss_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing best_loss_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_best_loss_ = bridgeMLPRegressor[${this.id}].best_loss_`;
      return this._py`attr_MLPRegressor_best_loss_.tolist() if hasattr(attr_MLPRegressor_best_loss_, 'tolist') else attr_MLPRegressor_best_loss_`;
    })();
  }
  /**
    Loss value evaluated at the end of each training step. The ith element in the list represents the loss at the ith iteration. Only accessible when solver=â€™sgdâ€™ or â€˜adamâ€™.
   */
  get loss_curve_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing loss_curve_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_loss_curve_ = bridgeMLPRegressor[${this.id}].loss_curve_`;
      return this._py`attr_MLPRegressor_loss_curve_.tolist() if hasattr(attr_MLPRegressor_loss_curve_, 'tolist') else attr_MLPRegressor_loss_curve_`;
    })();
  }
  /**
    The score at each iteration on a held-out validation set. The score reported is the R2 score. Only available if `early\_stopping=True`, otherwise the attribute is set to `undefined`. Only accessible when solver=â€™sgdâ€™ or â€˜adamâ€™.
   */
  get validation_scores_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing validation_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_validation_scores_ = bridgeMLPRegressor[${this.id}].validation_scores_`;
      return this._py`attr_MLPRegressor_validation_scores_.tolist() if hasattr(attr_MLPRegressor_validation_scores_, 'tolist') else attr_MLPRegressor_validation_scores_`;
    })();
  }
  /**
    The best validation score (i.e. R2 score) that triggered the early stopping. Only available if `early\_stopping=True`, otherwise the attribute is set to `undefined`. Only accessible when solver=â€™sgdâ€™ or â€˜adamâ€™.
   */
  get best_validation_score_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing best_validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_best_validation_score_ = bridgeMLPRegressor[${this.id}].best_validation_score_`;
      return this._py`attr_MLPRegressor_best_validation_score_.tolist() if hasattr(attr_MLPRegressor_best_validation_score_, 'tolist') else attr_MLPRegressor_best_validation_score_`;
    })();
  }
  /**
    The number of training samples seen by the solver during fitting. Mathematically equals `n\_iters \* X.shape\[0\]`, it means `time\_step` and it is used by optimizerâ€™s learning rate scheduler.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_t_ = bridgeMLPRegressor[${this.id}].t_`;
      return this._py`attr_MLPRegressor_t_.tolist() if hasattr(attr_MLPRegressor_t_, 'tolist') else attr_MLPRegressor_t_`;
    })();
  }
  /**
    The ith element in the list represents the weight matrix corresponding to layer i.
   */
  get coefs_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before accessing coefs_");
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_coefs_ = bridgeMLPRegressor[${this.id}].coefs_`;
      return this._py`attr_MLPRegressor_coefs_.tolist() if hasattr(attr_MLPRegressor_coefs_, 'tolist') else attr_MLPRegressor_coefs_`;
    })();
  }
  /**
    The ith element in the list represents the bias vector corresponding to layer i + 1.
   */
  get intercepts_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing intercepts_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_intercepts_ = bridgeMLPRegressor[${this.id}].intercepts_`;
      return this._py`attr_MLPRegressor_intercepts_.tolist() if hasattr(attr_MLPRegressor_intercepts_, 'tolist') else attr_MLPRegressor_intercepts_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_n_features_in_ = bridgeMLPRegressor[${this.id}].n_features_in_`;
      return this._py`attr_MLPRegressor_n_features_in_.tolist() if hasattr(attr_MLPRegressor_n_features_in_, 'tolist') else attr_MLPRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_feature_names_in_ = bridgeMLPRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_MLPRegressor_feature_names_in_.tolist() if hasattr(attr_MLPRegressor_feature_names_in_, 'tolist') else attr_MLPRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of iterations the solver has run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MLPRegressor must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_n_iter_ = bridgeMLPRegressor[${this.id}].n_iter_`;
      return this._py`attr_MLPRegressor_n_iter_.tolist() if hasattr(attr_MLPRegressor_n_iter_, 'tolist') else attr_MLPRegressor_n_iter_`;
    })();
  }
  /**
    Number of layers.
   */
  get n_layers_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing n_layers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_n_layers_ = bridgeMLPRegressor[${this.id}].n_layers_`;
      return this._py`attr_MLPRegressor_n_layers_.tolist() if hasattr(attr_MLPRegressor_n_layers_, 'tolist') else attr_MLPRegressor_n_layers_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_n_outputs_ = bridgeMLPRegressor[${this.id}].n_outputs_`;
      return this._py`attr_MLPRegressor_n_outputs_.tolist() if hasattr(attr_MLPRegressor_n_outputs_, 'tolist') else attr_MLPRegressor_n_outputs_`;
    })();
  }
  /**
    Name of the output activation function.
   */
  get out_activation_() {
    if (this._isDisposed) {
      throw new Error("This MLPRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MLPRegressor must call init() before accessing out_activation_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MLPRegressor_out_activation_ = bridgeMLPRegressor[${this.id}].out_activation_`;
      return this._py`attr_MLPRegressor_out_activation_.tolist() if hasattr(attr_MLPRegressor_out_activation_, 'tolist') else attr_MLPRegressor_out_activation_`;
    })();
  }
};

// src/generated/pipeline/FeatureUnion.ts
import crypto223 from "node:crypto";
var FeatureUnion = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FeatureUnion${crypto223.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FeatureUnion.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.pipeline import FeatureUnion
try: bridgeFeatureUnion
except NameError: bridgeFeatureUnion = {}
`;
    await this._py.ex`ctor_FeatureUnion = {'transformer_list': ${this.opts["transformer_list"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'transformer_weights': ${this.opts["transformer_weights"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_FeatureUnion = {k: v for k, v in ctor_FeatureUnion.items() if v is not None}`;
    await this._py.ex`bridgeFeatureUnion[${this.id}] = FeatureUnion(**ctor_FeatureUnion)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFeatureUnion[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit all transformers using X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureUnion must call init() before fit()");
    }
    await this._py.ex`pms_FeatureUnion_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureUnion_fit = {k: v for k, v in pms_FeatureUnion_fit.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_fit = bridgeFeatureUnion[${this.id}].fit(**pms_FeatureUnion_fit)`;
    return this._py`res_FeatureUnion_fit.tolist() if hasattr(res_FeatureUnion_fit, 'tolist') else res_FeatureUnion_fit`;
  }
  /**
    Fit all transformers, transform the data and concatenate results.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureUnion must call init() before fit_transform()");
    }
    await this._py.ex`pms_FeatureUnion_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureUnion_fit_transform = {k: v for k, v in pms_FeatureUnion_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_fit_transform = bridgeFeatureUnion[${this.id}].fit_transform(**pms_FeatureUnion_fit_transform)`;
    return this._py`res_FeatureUnion_fit_transform.tolist() if hasattr(res_FeatureUnion_fit_transform, 'tolist') else res_FeatureUnion_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureUnion must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FeatureUnion_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FeatureUnion_get_feature_names_out = {k: v for k, v in pms_FeatureUnion_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_get_feature_names_out = bridgeFeatureUnion[${this.id}].get_feature_names_out(**pms_FeatureUnion_get_feature_names_out)`;
    return this._py`res_FeatureUnion_get_feature_names_out.tolist() if hasattr(res_FeatureUnion_get_feature_names_out, 'tolist') else res_FeatureUnion_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureUnion must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FeatureUnion_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FeatureUnion_get_metadata_routing = {k: v for k, v in pms_FeatureUnion_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_get_metadata_routing = bridgeFeatureUnion[${this.id}].get_metadata_routing(**pms_FeatureUnion_get_metadata_routing)`;
    return this._py`res_FeatureUnion_get_metadata_routing.tolist() if hasattr(res_FeatureUnion_get_metadata_routing, 'tolist') else res_FeatureUnion_get_metadata_routing`;
  }
  /**
      Set the output container when `"transform"` and `"fit\_transform"` are called.
  
      `set\_output` will set the output of all estimators in `transformer\_list`.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureUnion must call init() before set_output()");
    }
    await this._py.ex`pms_FeatureUnion_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FeatureUnion_set_output = {k: v for k, v in pms_FeatureUnion_set_output.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_set_output = bridgeFeatureUnion[${this.id}].set_output(**pms_FeatureUnion_set_output)`;
    return this._py`res_FeatureUnion_set_output.tolist() if hasattr(res_FeatureUnion_set_output, 'tolist') else res_FeatureUnion_set_output`;
  }
  /**
    Transform X separately by each transformer, concatenate results.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FeatureUnion must call init() before transform()");
    }
    await this._py.ex`pms_FeatureUnion_transform = {'X': ${opts["X"] ?? void 0}}

pms_FeatureUnion_transform = {k: v for k, v in pms_FeatureUnion_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureUnion_transform = bridgeFeatureUnion[${this.id}].transform(**pms_FeatureUnion_transform)`;
    return this._py`res_FeatureUnion_transform.tolist() if hasattr(res_FeatureUnion_transform, 'tolist') else res_FeatureUnion_transform`;
  }
  /**
    Dictionary-like object, with the following attributes. Read-only attribute to access any transformer parameter by user given name. Keys are transformer names and values are transformer parameters.
   */
  get named_transformers() {
    if (this._isDisposed) {
      throw new Error("This FeatureUnion instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureUnion must call init() before accessing named_transformers"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureUnion_named_transformers = bridgeFeatureUnion[${this.id}].named_transformers`;
      return this._py`attr_FeatureUnion_named_transformers.tolist() if hasattr(attr_FeatureUnion_named_transformers, 'tolist') else attr_FeatureUnion_named_transformers`;
    })();
  }
};

// src/generated/pipeline/Pipeline.ts
import crypto224 from "node:crypto";
var Pipeline = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Pipeline${crypto224.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Pipeline.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.pipeline import Pipeline
try: bridgePipeline
except NameError: bridgePipeline = {}
`;
    await this._py.ex`ctor_Pipeline = {'steps': ${this.opts["steps"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_Pipeline = {k: v for k, v in ctor_Pipeline.items() if v is not None}`;
    await this._py.ex`bridgePipeline[${this.id}] = Pipeline(**ctor_Pipeline)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePipeline[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Transform the data, and apply `decision\_function` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `decision\_function` method. Only valid if the final estimator implements `decision\_function`.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before decision_function()");
    }
    await this._py.ex`pms_Pipeline_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_Pipeline_decision_function = {k: v for k, v in pms_Pipeline_decision_function.items() if v is not None}`;
    await this._py.ex`res_Pipeline_decision_function = bridgePipeline[${this.id}].decision_function(**pms_Pipeline_decision_function)`;
    return this._py`res_Pipeline_decision_function.tolist() if hasattr(res_Pipeline_decision_function, 'tolist') else res_Pipeline_decision_function`;
  }
  /**
      Fit the model.
  
      Fit all the transformers one after the other and transform the data. Finally, fit the transformed data using the final estimator.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before fit()");
    }
    await this._py.ex`pms_Pipeline_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Pipeline_fit = {k: v for k, v in pms_Pipeline_fit.items() if v is not None}`;
    await this._py.ex`res_Pipeline_fit = bridgePipeline[${this.id}].fit(**pms_Pipeline_fit)`;
    return this._py`res_Pipeline_fit.tolist() if hasattr(res_Pipeline_fit, 'tolist') else res_Pipeline_fit`;
  }
  /**
      Transform the data, and apply `fit\_predict` with the final estimator.
  
      Call `fit\_transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `fit\_predict` method. Only valid if the final estimator implements `fit\_predict`.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before fit_predict()");
    }
    await this._py.ex`pms_Pipeline_fit_predict = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Pipeline_fit_predict = {k: v for k, v in pms_Pipeline_fit_predict.items() if v is not None}`;
    await this._py.ex`res_Pipeline_fit_predict = bridgePipeline[${this.id}].fit_predict(**pms_Pipeline_fit_predict)`;
    return this._py`res_Pipeline_fit_predict.tolist() if hasattr(res_Pipeline_fit_predict, 'tolist') else res_Pipeline_fit_predict`;
  }
  /**
      Fit the model and transform with the final estimator.
  
      Fits all the transformers one after the other and transform the data. Then uses `fit\_transform` on transformed data with the final estimator.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before fit_transform()");
    }
    await this._py.ex`pms_Pipeline_fit_transform = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Pipeline_fit_transform = {k: v for k, v in pms_Pipeline_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Pipeline_fit_transform = bridgePipeline[${this.id}].fit_transform(**pms_Pipeline_fit_transform)`;
    return this._py`res_Pipeline_fit_transform.tolist() if hasattr(res_Pipeline_fit_transform, 'tolist') else res_Pipeline_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      Transform input features using the pipeline.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Pipeline must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Pipeline_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Pipeline_get_feature_names_out = {k: v for k, v in pms_Pipeline_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Pipeline_get_feature_names_out = bridgePipeline[${this.id}].get_feature_names_out(**pms_Pipeline_get_feature_names_out)`;
    return this._py`res_Pipeline_get_feature_names_out.tolist() if hasattr(res_Pipeline_get_feature_names_out, 'tolist') else res_Pipeline_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Pipeline_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Pipeline_get_metadata_routing = {k: v for k, v in pms_Pipeline_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Pipeline_get_metadata_routing = bridgePipeline[${this.id}].get_metadata_routing(**pms_Pipeline_get_metadata_routing)`;
    return this._py`res_Pipeline_get_metadata_routing.tolist() if hasattr(res_Pipeline_get_metadata_routing, 'tolist') else res_Pipeline_get_metadata_routing`;
  }
  /**
      Apply `inverse\_transform` for each step in a reverse order.
  
      All estimators in the pipeline must support `inverse\_transform`.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before inverse_transform()");
    }
    await this._py.ex`pms_Pipeline_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_Pipeline_inverse_transform = {k: v for k, v in pms_Pipeline_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_Pipeline_inverse_transform = bridgePipeline[${this.id}].inverse_transform(**pms_Pipeline_inverse_transform)`;
    return this._py`res_Pipeline_inverse_transform.tolist() if hasattr(res_Pipeline_inverse_transform, 'tolist') else res_Pipeline_inverse_transform`;
  }
  /**
      Transform the data, and apply `predict` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict` method. Only valid if the final estimator implements `predict`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before predict()");
    }
    await this._py.ex`pms_Pipeline_predict = {'X': ${opts["X"] ?? void 0}, 'predict_params': ${opts["predict_params"] ?? void 0}}

pms_Pipeline_predict = {k: v for k, v in pms_Pipeline_predict.items() if v is not None}`;
    await this._py.ex`res_Pipeline_predict = bridgePipeline[${this.id}].predict(**pms_Pipeline_predict)`;
    return this._py`res_Pipeline_predict.tolist() if hasattr(res_Pipeline_predict, 'tolist') else res_Pipeline_predict`;
  }
  /**
      Transform the data, and apply `predict\_log\_proba` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict\_log\_proba` method. Only valid if the final estimator implements `predict\_log\_proba`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_Pipeline_predict_log_proba = {'X': ${opts["X"] ?? void 0}, 'predict_log_proba_params': ${opts["predict_log_proba_params"] ?? void 0}}

pms_Pipeline_predict_log_proba = {k: v for k, v in pms_Pipeline_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_Pipeline_predict_log_proba = bridgePipeline[${this.id}].predict_log_proba(**pms_Pipeline_predict_log_proba)`;
    return this._py`res_Pipeline_predict_log_proba.tolist() if hasattr(res_Pipeline_predict_log_proba, 'tolist') else res_Pipeline_predict_log_proba`;
  }
  /**
      Transform the data, and apply `predict\_proba` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict\_proba` method. Only valid if the final estimator implements `predict\_proba`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before predict_proba()");
    }
    await this._py.ex`pms_Pipeline_predict_proba = {'X': ${opts["X"] ?? void 0}, 'predict_proba_params': ${opts["predict_proba_params"] ?? void 0}}

pms_Pipeline_predict_proba = {k: v for k, v in pms_Pipeline_predict_proba.items() if v is not None}`;
    await this._py.ex`res_Pipeline_predict_proba = bridgePipeline[${this.id}].predict_proba(**pms_Pipeline_predict_proba)`;
    return this._py`res_Pipeline_predict_proba.tolist() if hasattr(res_Pipeline_predict_proba, 'tolist') else res_Pipeline_predict_proba`;
  }
  /**
      Transform the data, and apply `score` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `score` method. Only valid if the final estimator implements `score`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before score()");
    }
    await this._py.ex`pms_Pipeline_score = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Pipeline_score = {k: v for k, v in pms_Pipeline_score.items() if v is not None}`;
    await this._py.ex`res_Pipeline_score = bridgePipeline[${this.id}].score(**pms_Pipeline_score)`;
    return this._py`res_Pipeline_score.tolist() if hasattr(res_Pipeline_score, 'tolist') else res_Pipeline_score`;
  }
  /**
      Transform the data, and apply `score\_samples` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `score\_samples` method. Only valid if the final estimator implements `score\_samples`.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before score_samples()");
    }
    await this._py.ex`pms_Pipeline_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_Pipeline_score_samples = {k: v for k, v in pms_Pipeline_score_samples.items() if v is not None}`;
    await this._py.ex`res_Pipeline_score_samples = bridgePipeline[${this.id}].score_samples(**pms_Pipeline_score_samples)`;
    return this._py`res_Pipeline_score_samples.tolist() if hasattr(res_Pipeline_score_samples, 'tolist') else res_Pipeline_score_samples`;
  }
  /**
      Set the output container when `"transform"` and `"fit\_transform"` are called.
  
      Calling `set\_output` will set the output of all estimators in `steps`.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before set_output()");
    }
    await this._py.ex`pms_Pipeline_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Pipeline_set_output = {k: v for k, v in pms_Pipeline_set_output.items() if v is not None}`;
    await this._py.ex`res_Pipeline_set_output = bridgePipeline[${this.id}].set_output(**pms_Pipeline_set_output)`;
    return this._py`res_Pipeline_set_output.tolist() if hasattr(res_Pipeline_set_output, 'tolist') else res_Pipeline_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before set_score_request()");
    }
    await this._py.ex`pms_Pipeline_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Pipeline_set_score_request = {k: v for k, v in pms_Pipeline_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Pipeline_set_score_request = bridgePipeline[${this.id}].set_score_request(**pms_Pipeline_set_score_request)`;
    return this._py`res_Pipeline_set_score_request.tolist() if hasattr(res_Pipeline_set_score_request, 'tolist') else res_Pipeline_set_score_request`;
  }
  /**
      Transform the data, and apply `transform` with the final estimator.
  
      Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `transform` method. Only valid if the final estimator implements `transform`.
  
      This also works where final estimator is `undefined` in which case all prior transformations are applied.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Pipeline instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Pipeline must call init() before transform()");
    }
    await this._py.ex`pms_Pipeline_transform = {'X': ${opts["X"] ?? void 0}}

pms_Pipeline_transform = {k: v for k, v in pms_Pipeline_transform.items() if v is not None}`;
    await this._py.ex`res_Pipeline_transform = bridgePipeline[${this.id}].transform(**pms_Pipeline_transform)`;
    return this._py`res_Pipeline_transform.tolist() if hasattr(res_Pipeline_transform, 'tolist') else res_Pipeline_transform`;
  }
};

// src/generated/preprocessing/Binarizer.ts
import crypto225 from "node:crypto";
var Binarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Binarizer${crypto225.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Binarizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import Binarizer
try: bridgeBinarizer
except NameError: bridgeBinarizer = {}
`;
    await this._py.ex`ctor_Binarizer = {'threshold': ${this.opts["threshold"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Binarizer = {k: v for k, v in ctor_Binarizer.items() if v is not None}`;
    await this._py.ex`bridgeBinarizer[${this.id}] = Binarizer(**ctor_Binarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before fit()");
    }
    await this._py.ex`pms_Binarizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Binarizer_fit = {k: v for k, v in pms_Binarizer_fit.items() if v is not None}`;
    await this._py.ex`res_Binarizer_fit = bridgeBinarizer[${this.id}].fit(**pms_Binarizer_fit)`;
    return this._py`res_Binarizer_fit.tolist() if hasattr(res_Binarizer_fit, 'tolist') else res_Binarizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_Binarizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Binarizer_fit_transform = {k: v for k, v in pms_Binarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Binarizer_fit_transform = bridgeBinarizer[${this.id}].fit_transform(**pms_Binarizer_fit_transform)`;
    return this._py`res_Binarizer_fit_transform.tolist() if hasattr(res_Binarizer_fit_transform, 'tolist') else res_Binarizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Binarizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Binarizer_get_feature_names_out = {k: v for k, v in pms_Binarizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Binarizer_get_feature_names_out = bridgeBinarizer[${this.id}].get_feature_names_out(**pms_Binarizer_get_feature_names_out)`;
    return this._py`res_Binarizer_get_feature_names_out.tolist() if hasattr(res_Binarizer_get_feature_names_out, 'tolist') else res_Binarizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Binarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Binarizer_get_metadata_routing = {k: v for k, v in pms_Binarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Binarizer_get_metadata_routing = bridgeBinarizer[${this.id}].get_metadata_routing(**pms_Binarizer_get_metadata_routing)`;
    return this._py`res_Binarizer_get_metadata_routing.tolist() if hasattr(res_Binarizer_get_metadata_routing, 'tolist') else res_Binarizer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before set_output()");
    }
    await this._py.ex`pms_Binarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Binarizer_set_output = {k: v for k, v in pms_Binarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_Binarizer_set_output = bridgeBinarizer[${this.id}].set_output(**pms_Binarizer_set_output)`;
    return this._py`res_Binarizer_set_output.tolist() if hasattr(res_Binarizer_set_output, 'tolist') else res_Binarizer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_Binarizer_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_Binarizer_set_transform_request = {k: v for k, v in pms_Binarizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_Binarizer_set_transform_request = bridgeBinarizer[${this.id}].set_transform_request(**pms_Binarizer_set_transform_request)`;
    return this._py`res_Binarizer_set_transform_request.tolist() if hasattr(res_Binarizer_set_transform_request, 'tolist') else res_Binarizer_set_transform_request`;
  }
  /**
    Binarize each element of X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Binarizer must call init() before transform()");
    }
    await this._py.ex`pms_Binarizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_Binarizer_transform = {k: v for k, v in pms_Binarizer_transform.items() if v is not None}`;
    await this._py.ex`res_Binarizer_transform = bridgeBinarizer[${this.id}].transform(**pms_Binarizer_transform)`;
    return this._py`res_Binarizer_transform.tolist() if hasattr(res_Binarizer_transform, 'tolist') else res_Binarizer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Binarizer_n_features_in_ = bridgeBinarizer[${this.id}].n_features_in_`;
      return this._py`attr_Binarizer_n_features_in_.tolist() if hasattr(attr_Binarizer_n_features_in_, 'tolist') else attr_Binarizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Binarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Binarizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Binarizer_feature_names_in_ = bridgeBinarizer[${this.id}].feature_names_in_`;
      return this._py`attr_Binarizer_feature_names_in_.tolist() if hasattr(attr_Binarizer_feature_names_in_, 'tolist') else attr_Binarizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/FunctionTransformer.ts
import crypto226 from "node:crypto";
var FunctionTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `FunctionTransformer${crypto226.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "FunctionTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import FunctionTransformer
try: bridgeFunctionTransformer
except NameError: bridgeFunctionTransformer = {}
`;
    await this._py.ex`ctor_FunctionTransformer = {'func': ${this.opts["func"] ?? void 0}, 'inverse_func': ${this.opts["inverse_func"] ?? void 0}, 'validate': ${this.opts["validate"] ?? void 0}, 'accept_sparse': ${this.opts["accept_sparse"] ?? void 0}, 'check_inverse': ${this.opts["check_inverse"] ?? void 0}, 'feature_names_out': ${this.opts["feature_names_out"] ?? void 0}, 'kw_args': ${this.opts["kw_args"] ?? void 0}, 'inv_kw_args': ${this.opts["inv_kw_args"] ?? void 0}}

ctor_FunctionTransformer = {k: v for k, v in ctor_FunctionTransformer.items() if v is not None}`;
    await this._py.ex`bridgeFunctionTransformer[${this.id}] = FunctionTransformer(**ctor_FunctionTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFunctionTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit transformer by checking X.
  
      If `validate` is `true`, `X` will be checked.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FunctionTransformer must call init() before fit()");
    }
    await this._py.ex`pms_FunctionTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FunctionTransformer_fit = {k: v for k, v in pms_FunctionTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_fit = bridgeFunctionTransformer[${this.id}].fit(**pms_FunctionTransformer_fit)`;
    return this._py`res_FunctionTransformer_fit.tolist() if hasattr(res_FunctionTransformer_fit, 'tolist') else res_FunctionTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FunctionTransformer_fit_transform = {k: v for k, v in pms_FunctionTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_fit_transform = bridgeFunctionTransformer[${this.id}].fit_transform(**pms_FunctionTransformer_fit_transform)`;
    return this._py`res_FunctionTransformer_fit_transform.tolist() if hasattr(res_FunctionTransformer_fit_transform, 'tolist') else res_FunctionTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      This method is only defined if `feature\_names\_out` is not `undefined`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FunctionTransformer_get_feature_names_out = {k: v for k, v in pms_FunctionTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_get_feature_names_out = bridgeFunctionTransformer[${this.id}].get_feature_names_out(**pms_FunctionTransformer_get_feature_names_out)`;
    return this._py`res_FunctionTransformer_get_feature_names_out.tolist() if hasattr(res_FunctionTransformer_get_feature_names_out, 'tolist') else res_FunctionTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FunctionTransformer_get_metadata_routing = {k: v for k, v in pms_FunctionTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_get_metadata_routing = bridgeFunctionTransformer[${this.id}].get_metadata_routing(**pms_FunctionTransformer_get_metadata_routing)`;
    return this._py`res_FunctionTransformer_get_metadata_routing.tolist() if hasattr(res_FunctionTransformer_get_metadata_routing, 'tolist') else res_FunctionTransformer_get_metadata_routing`;
  }
  /**
    Transform X using the inverse function.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FunctionTransformer_inverse_transform = {k: v for k, v in pms_FunctionTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_inverse_transform = bridgeFunctionTransformer[${this.id}].inverse_transform(**pms_FunctionTransformer_inverse_transform)`;
    return this._py`res_FunctionTransformer_inverse_transform.tolist() if hasattr(res_FunctionTransformer_inverse_transform, 'tolist') else res_FunctionTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_FunctionTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FunctionTransformer_set_output = {k: v for k, v in pms_FunctionTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_set_output = bridgeFunctionTransformer[${this.id}].set_output(**pms_FunctionTransformer_set_output)`;
    return this._py`res_FunctionTransformer_set_output.tolist() if hasattr(res_FunctionTransformer_set_output, 'tolist') else res_FunctionTransformer_set_output`;
  }
  /**
    Transform X using the forward function.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FunctionTransformer must call init() before transform()");
    }
    await this._py.ex`pms_FunctionTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FunctionTransformer_transform = {k: v for k, v in pms_FunctionTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_FunctionTransformer_transform = bridgeFunctionTransformer[${this.id}].transform(**pms_FunctionTransformer_transform)`;
    return this._py`res_FunctionTransformer_transform.tolist() if hasattr(res_FunctionTransformer_transform, 'tolist') else res_FunctionTransformer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FunctionTransformer_n_features_in_ = bridgeFunctionTransformer[${this.id}].n_features_in_`;
      return this._py`attr_FunctionTransformer_n_features_in_.tolist() if hasattr(attr_FunctionTransformer_n_features_in_, 'tolist') else attr_FunctionTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FunctionTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FunctionTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FunctionTransformer_feature_names_in_ = bridgeFunctionTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_FunctionTransformer_feature_names_in_.tolist() if hasattr(attr_FunctionTransformer_feature_names_in_, 'tolist') else attr_FunctionTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/KBinsDiscretizer.ts
import crypto227 from "node:crypto";
var KBinsDiscretizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KBinsDiscretizer${crypto227.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KBinsDiscretizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import KBinsDiscretizer
try: bridgeKBinsDiscretizer
except NameError: bridgeKBinsDiscretizer = {}
`;
    await this._py.ex`ctor_KBinsDiscretizer = {'n_bins': np.array(${this.opts["n_bins"] ?? void 0}) if ${this.opts["n_bins"] !== void 0} else None, 'encode': ${this.opts["encode"] ?? void 0}, 'strategy': ${this.opts["strategy"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_KBinsDiscretizer = {k: v for k, v in ctor_KBinsDiscretizer.items() if v is not None}`;
    await this._py.ex`bridgeKBinsDiscretizer[${this.id}] = KBinsDiscretizer(**ctor_KBinsDiscretizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKBinsDiscretizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the estimator.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before fit()");
    }
    await this._py.ex`pms_KBinsDiscretizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KBinsDiscretizer_fit = {k: v for k, v in pms_KBinsDiscretizer_fit.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_fit = bridgeKBinsDiscretizer[${this.id}].fit(**pms_KBinsDiscretizer_fit)`;
    return this._py`res_KBinsDiscretizer_fit.tolist() if hasattr(res_KBinsDiscretizer_fit, 'tolist') else res_KBinsDiscretizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_KBinsDiscretizer_fit_transform = {k: v for k, v in pms_KBinsDiscretizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_fit_transform = bridgeKBinsDiscretizer[${this.id}].fit_transform(**pms_KBinsDiscretizer_fit_transform)`;
    return this._py`res_KBinsDiscretizer_fit_transform.tolist() if hasattr(res_KBinsDiscretizer_fit_transform, 'tolist') else res_KBinsDiscretizer_fit_transform`;
  }
  /**
    Get output feature names.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KBinsDiscretizer_get_feature_names_out = {k: v for k, v in pms_KBinsDiscretizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_get_feature_names_out = bridgeKBinsDiscretizer[${this.id}].get_feature_names_out(**pms_KBinsDiscretizer_get_feature_names_out)`;
    return this._py`res_KBinsDiscretizer_get_feature_names_out.tolist() if hasattr(res_KBinsDiscretizer_get_feature_names_out, 'tolist') else res_KBinsDiscretizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KBinsDiscretizer_get_metadata_routing = {k: v for k, v in pms_KBinsDiscretizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_get_metadata_routing = bridgeKBinsDiscretizer[${this.id}].get_metadata_routing(**pms_KBinsDiscretizer_get_metadata_routing)`;
    return this._py`res_KBinsDiscretizer_get_metadata_routing.tolist() if hasattr(res_KBinsDiscretizer_get_metadata_routing, 'tolist') else res_KBinsDiscretizer_get_metadata_routing`;
  }
  /**
      Transform discretized data back to original feature space.
  
      Note that this function does not regenerate the original data due to discretization rounding.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_inverse_transform = {'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_KBinsDiscretizer_inverse_transform = {k: v for k, v in pms_KBinsDiscretizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_inverse_transform = bridgeKBinsDiscretizer[${this.id}].inverse_transform(**pms_KBinsDiscretizer_inverse_transform)`;
    return this._py`res_KBinsDiscretizer_inverse_transform.tolist() if hasattr(res_KBinsDiscretizer_inverse_transform, 'tolist') else res_KBinsDiscretizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_KBinsDiscretizer_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KBinsDiscretizer_set_fit_request = {k: v for k, v in pms_KBinsDiscretizer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_set_fit_request = bridgeKBinsDiscretizer[${this.id}].set_fit_request(**pms_KBinsDiscretizer_set_fit_request)`;
    return this._py`res_KBinsDiscretizer_set_fit_request.tolist() if hasattr(res_KBinsDiscretizer_set_fit_request, 'tolist') else res_KBinsDiscretizer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before set_output()");
    }
    await this._py.ex`pms_KBinsDiscretizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KBinsDiscretizer_set_output = {k: v for k, v in pms_KBinsDiscretizer_set_output.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_set_output = bridgeKBinsDiscretizer[${this.id}].set_output(**pms_KBinsDiscretizer_set_output)`;
    return this._py`res_KBinsDiscretizer_set_output.tolist() if hasattr(res_KBinsDiscretizer_set_output, 'tolist') else res_KBinsDiscretizer_set_output`;
  }
  /**
    Discretize the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KBinsDiscretizer must call init() before transform()");
    }
    await this._py.ex`pms_KBinsDiscretizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KBinsDiscretizer_transform = {k: v for k, v in pms_KBinsDiscretizer_transform.items() if v is not None}`;
    await this._py.ex`res_KBinsDiscretizer_transform = bridgeKBinsDiscretizer[${this.id}].transform(**pms_KBinsDiscretizer_transform)`;
    return this._py`res_KBinsDiscretizer_transform.tolist() if hasattr(res_KBinsDiscretizer_transform, 'tolist') else res_KBinsDiscretizer_transform`;
  }
  /**
    The edges of each bin. Contain arrays of varying shapes `(n\_bins\_, )` Ignored features will have empty arrays.
   */
  get bin_edges_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing bin_edges_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_bin_edges_ = bridgeKBinsDiscretizer[${this.id}].bin_edges_`;
      return this._py`attr_KBinsDiscretizer_bin_edges_.tolist() if hasattr(attr_KBinsDiscretizer_bin_edges_, 'tolist') else attr_KBinsDiscretizer_bin_edges_`;
    })();
  }
  /**
    Number of bins per feature. Bins whose width are too small (i.e., <= 1e-8) are removed with a warning.
   */
  get n_bins_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing n_bins_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_n_bins_ = bridgeKBinsDiscretizer[${this.id}].n_bins_`;
      return this._py`attr_KBinsDiscretizer_n_bins_.tolist() if hasattr(attr_KBinsDiscretizer_n_bins_, 'tolist') else attr_KBinsDiscretizer_n_bins_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_n_features_in_ = bridgeKBinsDiscretizer[${this.id}].n_features_in_`;
      return this._py`attr_KBinsDiscretizer_n_features_in_.tolist() if hasattr(attr_KBinsDiscretizer_n_features_in_, 'tolist') else attr_KBinsDiscretizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KBinsDiscretizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KBinsDiscretizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KBinsDiscretizer_feature_names_in_ = bridgeKBinsDiscretizer[${this.id}].feature_names_in_`;
      return this._py`attr_KBinsDiscretizer_feature_names_in_.tolist() if hasattr(attr_KBinsDiscretizer_feature_names_in_, 'tolist') else attr_KBinsDiscretizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/KernelCenterer.ts
import crypto228 from "node:crypto";
var KernelCenterer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelCenterer${crypto228.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelCenterer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import KernelCenterer
try: bridgeKernelCenterer
except NameError: bridgeKernelCenterer = {}
`;
    await this._py.ex`ctor_KernelCenterer = {'K_fit_rows_': np.array(${this.opts["K_fit_rows_"] ?? void 0}) if ${this.opts["K_fit_rows_"] !== void 0} else None, 'K_fit_all_': ${this.opts["K_fit_all_"] ?? void 0}, 'n_features_in_': ${this.opts["n_features_in_"] ?? void 0}, 'feature_names_in_': np.array(${this.opts["feature_names_in_"] ?? void 0}) if ${this.opts["feature_names_in_"] !== void 0} else None}

ctor_KernelCenterer = {k: v for k, v in ctor_KernelCenterer.items() if v is not None}`;
    await this._py.ex`bridgeKernelCenterer[${this.id}] = KernelCenterer(**ctor_KernelCenterer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelCenterer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit KernelCenterer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before fit()");
    }
    await this._py.ex`pms_KernelCenterer_fit = {'K': np.array(${opts["K"] ?? void 0}) if ${opts["K"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelCenterer_fit = {k: v for k, v in pms_KernelCenterer_fit.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_fit = bridgeKernelCenterer[${this.id}].fit(**pms_KernelCenterer_fit)`;
    return this._py`res_KernelCenterer_fit.tolist() if hasattr(res_KernelCenterer_fit, 'tolist') else res_KernelCenterer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before fit_transform()");
    }
    await this._py.ex`pms_KernelCenterer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_KernelCenterer_fit_transform = {k: v for k, v in pms_KernelCenterer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_fit_transform = bridgeKernelCenterer[${this.id}].fit_transform(**pms_KernelCenterer_fit_transform)`;
    return this._py`res_KernelCenterer_fit_transform.tolist() if hasattr(res_KernelCenterer_fit_transform, 'tolist') else res_KernelCenterer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KernelCenterer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KernelCenterer_get_feature_names_out = {k: v for k, v in pms_KernelCenterer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_get_feature_names_out = bridgeKernelCenterer[${this.id}].get_feature_names_out(**pms_KernelCenterer_get_feature_names_out)`;
    return this._py`res_KernelCenterer_get_feature_names_out.tolist() if hasattr(res_KernelCenterer_get_feature_names_out, 'tolist') else res_KernelCenterer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelCenterer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelCenterer_get_metadata_routing = {k: v for k, v in pms_KernelCenterer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_get_metadata_routing = bridgeKernelCenterer[${this.id}].get_metadata_routing(**pms_KernelCenterer_get_metadata_routing)`;
    return this._py`res_KernelCenterer_get_metadata_routing.tolist() if hasattr(res_KernelCenterer_get_metadata_routing, 'tolist') else res_KernelCenterer_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_KernelCenterer_set_fit_request = {'K': ${opts["K"] ?? void 0}}

pms_KernelCenterer_set_fit_request = {k: v for k, v in pms_KernelCenterer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_fit_request = bridgeKernelCenterer[${this.id}].set_fit_request(**pms_KernelCenterer_set_fit_request)`;
    return this._py`res_KernelCenterer_set_fit_request.tolist() if hasattr(res_KernelCenterer_set_fit_request, 'tolist') else res_KernelCenterer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before set_output()");
    }
    await this._py.ex`pms_KernelCenterer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KernelCenterer_set_output = {k: v for k, v in pms_KernelCenterer_set_output.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_output = bridgeKernelCenterer[${this.id}].set_output(**pms_KernelCenterer_set_output)`;
    return this._py`res_KernelCenterer_set_output.tolist() if hasattr(res_KernelCenterer_set_output, 'tolist') else res_KernelCenterer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelCenterer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_KernelCenterer_set_transform_request = {'K': ${opts["K"] ?? void 0}, 'copy': ${opts["copy"] ?? void 0}}

pms_KernelCenterer_set_transform_request = {k: v for k, v in pms_KernelCenterer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_set_transform_request = bridgeKernelCenterer[${this.id}].set_transform_request(**pms_KernelCenterer_set_transform_request)`;
    return this._py`res_KernelCenterer_set_transform_request.tolist() if hasattr(res_KernelCenterer_set_transform_request, 'tolist') else res_KernelCenterer_set_transform_request`;
  }
  /**
    Center kernel matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelCenterer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelCenterer must call init() before transform()");
    }
    await this._py.ex`pms_KernelCenterer_transform = {'K': np.array(${opts["K"] ?? void 0}) if ${opts["K"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_KernelCenterer_transform = {k: v for k, v in pms_KernelCenterer_transform.items() if v is not None}`;
    await this._py.ex`res_KernelCenterer_transform = bridgeKernelCenterer[${this.id}].transform(**pms_KernelCenterer_transform)`;
    return this._py`res_KernelCenterer_transform.tolist() if hasattr(res_KernelCenterer_transform, 'tolist') else res_KernelCenterer_transform`;
  }
};

// src/generated/preprocessing/LabelBinarizer.ts
import crypto229 from "node:crypto";
var LabelBinarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelBinarizer${crypto229.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelBinarizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import LabelBinarizer
try: bridgeLabelBinarizer
except NameError: bridgeLabelBinarizer = {}
`;
    await this._py.ex`ctor_LabelBinarizer = {'neg_label': ${this.opts["neg_label"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_LabelBinarizer = {k: v for k, v in ctor_LabelBinarizer.items() if v is not None}`;
    await this._py.ex`bridgeLabelBinarizer[${this.id}] = LabelBinarizer(**ctor_LabelBinarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit label binarizer.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before fit()");
    }
    await this._py.ex`pms_LabelBinarizer_fit = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_fit = {k: v for k, v in pms_LabelBinarizer_fit.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_fit = bridgeLabelBinarizer[${this.id}].fit(**pms_LabelBinarizer_fit)`;
    return this._py`res_LabelBinarizer_fit.tolist() if hasattr(res_LabelBinarizer_fit, 'tolist') else res_LabelBinarizer_fit`;
  }
  /**
      Fit label binarizer/transform multi-class labels to binary labels.
  
      The output of transform is sometimes referred to as the 1-of-K coding scheme.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_LabelBinarizer_fit_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_fit_transform = {k: v for k, v in pms_LabelBinarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_fit_transform = bridgeLabelBinarizer[${this.id}].fit_transform(**pms_LabelBinarizer_fit_transform)`;
    return this._py`res_LabelBinarizer_fit_transform.tolist() if hasattr(res_LabelBinarizer_fit_transform, 'tolist') else res_LabelBinarizer_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelBinarizer_get_metadata_routing = {k: v for k, v in pms_LabelBinarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_get_metadata_routing = bridgeLabelBinarizer[${this.id}].get_metadata_routing(**pms_LabelBinarizer_get_metadata_routing)`;
    return this._py`res_LabelBinarizer_get_metadata_routing.tolist() if hasattr(res_LabelBinarizer_get_metadata_routing, 'tolist') else res_LabelBinarizer_get_metadata_routing`;
  }
  /**
    Transform binary labels back to multi-class labels.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_inverse_transform = {'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'threshold': ${opts["threshold"] ?? void 0}}

pms_LabelBinarizer_inverse_transform = {k: v for k, v in pms_LabelBinarizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_inverse_transform = bridgeLabelBinarizer[${this.id}].inverse_transform(**pms_LabelBinarizer_inverse_transform)`;
    return this._py`res_LabelBinarizer_inverse_transform.tolist() if hasattr(res_LabelBinarizer_inverse_transform, 'tolist') else res_LabelBinarizer_inverse_transform`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_LabelBinarizer_set_inverse_transform_request = {'threshold': ${opts["threshold"] ?? void 0}}

pms_LabelBinarizer_set_inverse_transform_request = {k: v for k, v in pms_LabelBinarizer_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_set_inverse_transform_request = bridgeLabelBinarizer[${this.id}].set_inverse_transform_request(**pms_LabelBinarizer_set_inverse_transform_request)`;
    return this._py`res_LabelBinarizer_set_inverse_transform_request.tolist() if hasattr(res_LabelBinarizer_set_inverse_transform_request, 'tolist') else res_LabelBinarizer_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before set_output()");
    }
    await this._py.ex`pms_LabelBinarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LabelBinarizer_set_output = {k: v for k, v in pms_LabelBinarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_set_output = bridgeLabelBinarizer[${this.id}].set_output(**pms_LabelBinarizer_set_output)`;
    return this._py`res_LabelBinarizer_set_output.tolist() if hasattr(res_LabelBinarizer_set_output, 'tolist') else res_LabelBinarizer_set_output`;
  }
  /**
      Transform multi-class labels to binary labels.
  
      The output of transform is sometimes referred to by some authors as the 1-of-K coding scheme.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelBinarizer must call init() before transform()");
    }
    await this._py.ex`pms_LabelBinarizer_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelBinarizer_transform = {k: v for k, v in pms_LabelBinarizer_transform.items() if v is not None}`;
    await this._py.ex`res_LabelBinarizer_transform = bridgeLabelBinarizer[${this.id}].transform(**pms_LabelBinarizer_transform)`;
    return this._py`res_LabelBinarizer_transform.tolist() if hasattr(res_LabelBinarizer_transform, 'tolist') else res_LabelBinarizer_transform`;
  }
  /**
    Holds the label for each class.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_classes_ = bridgeLabelBinarizer[${this.id}].classes_`;
      return this._py`attr_LabelBinarizer_classes_.tolist() if hasattr(attr_LabelBinarizer_classes_, 'tolist') else attr_LabelBinarizer_classes_`;
    })();
  }
  /**
    Represents the type of the target data as evaluated by [`type\_of\_target`](sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target "sklearn.utils.multiclass.type_of_target"). Possible type are â€˜continuousâ€™, â€˜continuous-multioutputâ€™, â€˜binaryâ€™, â€˜multiclassâ€™, â€˜multiclass-multioutputâ€™, â€˜multilabel-indicatorâ€™, and â€˜unknownâ€™.
   */
  get y_type_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing y_type_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_y_type_ = bridgeLabelBinarizer[${this.id}].y_type_`;
      return this._py`attr_LabelBinarizer_y_type_.tolist() if hasattr(attr_LabelBinarizer_y_type_, 'tolist') else attr_LabelBinarizer_y_type_`;
    })();
  }
  /**
    `false` otherwise.
   */
  get sparse_input_() {
    if (this._isDisposed) {
      throw new Error("This LabelBinarizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelBinarizer must call init() before accessing sparse_input_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelBinarizer_sparse_input_ = bridgeLabelBinarizer[${this.id}].sparse_input_`;
      return this._py`attr_LabelBinarizer_sparse_input_.tolist() if hasattr(attr_LabelBinarizer_sparse_input_, 'tolist') else attr_LabelBinarizer_sparse_input_`;
    })();
  }
};

// src/generated/preprocessing/LabelEncoder.ts
import crypto230 from "node:crypto";
var LabelEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelEncoder${crypto230.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import LabelEncoder
try: bridgeLabelEncoder
except NameError: bridgeLabelEncoder = {}
`;
    await this._py.ex`ctor_LabelEncoder = {'classes_': np.array(${this.opts["classes_"] ?? void 0}) if ${this.opts["classes_"] !== void 0} else None}

ctor_LabelEncoder = {k: v for k, v in ctor_LabelEncoder.items() if v is not None}`;
    await this._py.ex`bridgeLabelEncoder[${this.id}] = LabelEncoder(**ctor_LabelEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit label encoder.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before fit()");
    }
    await this._py.ex`pms_LabelEncoder_fit = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_fit = {k: v for k, v in pms_LabelEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_fit = bridgeLabelEncoder[${this.id}].fit(**pms_LabelEncoder_fit)`;
    return this._py`res_LabelEncoder_fit.tolist() if hasattr(res_LabelEncoder_fit, 'tolist') else res_LabelEncoder_fit`;
  }
  /**
    Fit label encoder and return encoded labels.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_LabelEncoder_fit_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_fit_transform = {k: v for k, v in pms_LabelEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_fit_transform = bridgeLabelEncoder[${this.id}].fit_transform(**pms_LabelEncoder_fit_transform)`;
    return this._py`res_LabelEncoder_fit_transform.tolist() if hasattr(res_LabelEncoder_fit_transform, 'tolist') else res_LabelEncoder_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelEncoder_get_metadata_routing = {k: v for k, v in pms_LabelEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_get_metadata_routing = bridgeLabelEncoder[${this.id}].get_metadata_routing(**pms_LabelEncoder_get_metadata_routing)`;
    return this._py`res_LabelEncoder_get_metadata_routing.tolist() if hasattr(res_LabelEncoder_get_metadata_routing, 'tolist') else res_LabelEncoder_get_metadata_routing`;
  }
  /**
    Transform labels back to original encoding.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_LabelEncoder_inverse_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_inverse_transform = {k: v for k, v in pms_LabelEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_inverse_transform = bridgeLabelEncoder[${this.id}].inverse_transform(**pms_LabelEncoder_inverse_transform)`;
    return this._py`res_LabelEncoder_inverse_transform.tolist() if hasattr(res_LabelEncoder_inverse_transform, 'tolist') else res_LabelEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_LabelEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LabelEncoder_set_output = {k: v for k, v in pms_LabelEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_set_output = bridgeLabelEncoder[${this.id}].set_output(**pms_LabelEncoder_set_output)`;
    return this._py`res_LabelEncoder_set_output.tolist() if hasattr(res_LabelEncoder_set_output, 'tolist') else res_LabelEncoder_set_output`;
  }
  /**
    Transform labels to normalized encoding.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelEncoder must call init() before transform()");
    }
    await this._py.ex`pms_LabelEncoder_transform = {'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelEncoder_transform = {k: v for k, v in pms_LabelEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_LabelEncoder_transform = bridgeLabelEncoder[${this.id}].transform(**pms_LabelEncoder_transform)`;
    return this._py`res_LabelEncoder_transform.tolist() if hasattr(res_LabelEncoder_transform, 'tolist') else res_LabelEncoder_transform`;
  }
};

// src/generated/preprocessing/MaxAbsScaler.ts
import crypto231 from "node:crypto";
var MaxAbsScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MaxAbsScaler${crypto231.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MaxAbsScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MaxAbsScaler
try: bridgeMaxAbsScaler
except NameError: bridgeMaxAbsScaler = {}
`;
    await this._py.ex`ctor_MaxAbsScaler = {'copy': ${this.opts["copy"] ?? void 0}}

ctor_MaxAbsScaler = {k: v for k, v in ctor_MaxAbsScaler.items() if v is not None}`;
    await this._py.ex`bridgeMaxAbsScaler[${this.id}] = MaxAbsScaler(**ctor_MaxAbsScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMaxAbsScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the maximum absolute value to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before fit()");
    }
    await this._py.ex`pms_MaxAbsScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MaxAbsScaler_fit = {k: v for k, v in pms_MaxAbsScaler_fit.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_fit = bridgeMaxAbsScaler[${this.id}].fit(**pms_MaxAbsScaler_fit)`;
    return this._py`res_MaxAbsScaler_fit.tolist() if hasattr(res_MaxAbsScaler_fit, 'tolist') else res_MaxAbsScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_MaxAbsScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MaxAbsScaler_fit_transform = {k: v for k, v in pms_MaxAbsScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_fit_transform = bridgeMaxAbsScaler[${this.id}].fit_transform(**pms_MaxAbsScaler_fit_transform)`;
    return this._py`res_MaxAbsScaler_fit_transform.tolist() if hasattr(res_MaxAbsScaler_fit_transform, 'tolist') else res_MaxAbsScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MaxAbsScaler_get_feature_names_out = {k: v for k, v in pms_MaxAbsScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_get_feature_names_out = bridgeMaxAbsScaler[${this.id}].get_feature_names_out(**pms_MaxAbsScaler_get_feature_names_out)`;
    return this._py`res_MaxAbsScaler_get_feature_names_out.tolist() if hasattr(res_MaxAbsScaler_get_feature_names_out, 'tolist') else res_MaxAbsScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MaxAbsScaler_get_metadata_routing = {k: v for k, v in pms_MaxAbsScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_get_metadata_routing = bridgeMaxAbsScaler[${this.id}].get_metadata_routing(**pms_MaxAbsScaler_get_metadata_routing)`;
    return this._py`res_MaxAbsScaler_get_metadata_routing.tolist() if hasattr(res_MaxAbsScaler_get_metadata_routing, 'tolist') else res_MaxAbsScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MaxAbsScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MaxAbsScaler_inverse_transform = {k: v for k, v in pms_MaxAbsScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_inverse_transform = bridgeMaxAbsScaler[${this.id}].inverse_transform(**pms_MaxAbsScaler_inverse_transform)`;
    return this._py`res_MaxAbsScaler_inverse_transform.tolist() if hasattr(res_MaxAbsScaler_inverse_transform, 'tolist') else res_MaxAbsScaler_inverse_transform`;
  }
  /**
      Online computation of max absolute value of X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MaxAbsScaler.fit "sklearn.preprocessing.MaxAbsScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_MaxAbsScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MaxAbsScaler_partial_fit = {k: v for k, v in pms_MaxAbsScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_partial_fit = bridgeMaxAbsScaler[${this.id}].partial_fit(**pms_MaxAbsScaler_partial_fit)`;
    return this._py`res_MaxAbsScaler_partial_fit.tolist() if hasattr(res_MaxAbsScaler_partial_fit, 'tolist') else res_MaxAbsScaler_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before set_output()");
    }
    await this._py.ex`pms_MaxAbsScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MaxAbsScaler_set_output = {k: v for k, v in pms_MaxAbsScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_set_output = bridgeMaxAbsScaler[${this.id}].set_output(**pms_MaxAbsScaler_set_output)`;
    return this._py`res_MaxAbsScaler_set_output.tolist() if hasattr(res_MaxAbsScaler_set_output, 'tolist') else res_MaxAbsScaler_set_output`;
  }
  /**
    Scale the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before transform()");
    }
    await this._py.ex`pms_MaxAbsScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MaxAbsScaler_transform = {k: v for k, v in pms_MaxAbsScaler_transform.items() if v is not None}`;
    await this._py.ex`res_MaxAbsScaler_transform = bridgeMaxAbsScaler[${this.id}].transform(**pms_MaxAbsScaler_transform)`;
    return this._py`res_MaxAbsScaler_transform.tolist() if hasattr(res_MaxAbsScaler_transform, 'tolist') else res_MaxAbsScaler_transform`;
  }
  /**
    Per feature relative scaling of the data.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_scale_ = bridgeMaxAbsScaler[${this.id}].scale_`;
      return this._py`attr_MaxAbsScaler_scale_.tolist() if hasattr(attr_MaxAbsScaler_scale_, 'tolist') else attr_MaxAbsScaler_scale_`;
    })();
  }
  /**
    Per feature maximum absolute value.
   */
  get max_abs_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MaxAbsScaler must call init() before accessing max_abs_");
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_max_abs_ = bridgeMaxAbsScaler[${this.id}].max_abs_`;
      return this._py`attr_MaxAbsScaler_max_abs_.tolist() if hasattr(attr_MaxAbsScaler_max_abs_, 'tolist') else attr_MaxAbsScaler_max_abs_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_n_features_in_ = bridgeMaxAbsScaler[${this.id}].n_features_in_`;
      return this._py`attr_MaxAbsScaler_n_features_in_.tolist() if hasattr(attr_MaxAbsScaler_n_features_in_, 'tolist') else attr_MaxAbsScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_feature_names_in_ = bridgeMaxAbsScaler[${this.id}].feature_names_in_`;
      return this._py`attr_MaxAbsScaler_feature_names_in_.tolist() if hasattr(attr_MaxAbsScaler_feature_names_in_, 'tolist') else attr_MaxAbsScaler_feature_names_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This MaxAbsScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MaxAbsScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MaxAbsScaler_n_samples_seen_ = bridgeMaxAbsScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_MaxAbsScaler_n_samples_seen_.tolist() if hasattr(attr_MaxAbsScaler_n_samples_seen_, 'tolist') else attr_MaxAbsScaler_n_samples_seen_`;
    })();
  }
};

// src/generated/preprocessing/MinMaxScaler.ts
import crypto232 from "node:crypto";
var MinMaxScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MinMaxScaler${crypto232.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MinMaxScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MinMaxScaler
try: bridgeMinMaxScaler
except NameError: bridgeMinMaxScaler = {}
`;
    await this._py.ex`ctor_MinMaxScaler = {'feature_range': ${this.opts["feature_range"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'clip': ${this.opts["clip"] ?? void 0}}

ctor_MinMaxScaler = {k: v for k, v in ctor_MinMaxScaler.items() if v is not None}`;
    await this._py.ex`bridgeMinMaxScaler[${this.id}] = MinMaxScaler(**ctor_MinMaxScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMinMaxScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the minimum and maximum to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before fit()");
    }
    await this._py.ex`pms_MinMaxScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinMaxScaler_fit = {k: v for k, v in pms_MinMaxScaler_fit.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_fit = bridgeMinMaxScaler[${this.id}].fit(**pms_MinMaxScaler_fit)`;
    return this._py`res_MinMaxScaler_fit.tolist() if hasattr(res_MinMaxScaler_fit, 'tolist') else res_MinMaxScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_MinMaxScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MinMaxScaler_fit_transform = {k: v for k, v in pms_MinMaxScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_fit_transform = bridgeMinMaxScaler[${this.id}].fit_transform(**pms_MinMaxScaler_fit_transform)`;
    return this._py`res_MinMaxScaler_fit_transform.tolist() if hasattr(res_MinMaxScaler_fit_transform, 'tolist') else res_MinMaxScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MinMaxScaler_get_feature_names_out = {k: v for k, v in pms_MinMaxScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_get_feature_names_out = bridgeMinMaxScaler[${this.id}].get_feature_names_out(**pms_MinMaxScaler_get_feature_names_out)`;
    return this._py`res_MinMaxScaler_get_feature_names_out.tolist() if hasattr(res_MinMaxScaler_get_feature_names_out, 'tolist') else res_MinMaxScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MinMaxScaler_get_metadata_routing = {k: v for k, v in pms_MinMaxScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_get_metadata_routing = bridgeMinMaxScaler[${this.id}].get_metadata_routing(**pms_MinMaxScaler_get_metadata_routing)`;
    return this._py`res_MinMaxScaler_get_metadata_routing.tolist() if hasattr(res_MinMaxScaler_get_metadata_routing, 'tolist') else res_MinMaxScaler_get_metadata_routing`;
  }
  /**
    Undo the scaling of X according to feature\_range.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MinMaxScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinMaxScaler_inverse_transform = {k: v for k, v in pms_MinMaxScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_inverse_transform = bridgeMinMaxScaler[${this.id}].inverse_transform(**pms_MinMaxScaler_inverse_transform)`;
    return this._py`res_MinMaxScaler_inverse_transform.tolist() if hasattr(res_MinMaxScaler_inverse_transform, 'tolist') else res_MinMaxScaler_inverse_transform`;
  }
  /**
      Online computation of min and max on X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.MinMaxScaler.fit "sklearn.preprocessing.MinMaxScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_MinMaxScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinMaxScaler_partial_fit = {k: v for k, v in pms_MinMaxScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_partial_fit = bridgeMinMaxScaler[${this.id}].partial_fit(**pms_MinMaxScaler_partial_fit)`;
    return this._py`res_MinMaxScaler_partial_fit.tolist() if hasattr(res_MinMaxScaler_partial_fit, 'tolist') else res_MinMaxScaler_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before set_output()");
    }
    await this._py.ex`pms_MinMaxScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MinMaxScaler_set_output = {k: v for k, v in pms_MinMaxScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_set_output = bridgeMinMaxScaler[${this.id}].set_output(**pms_MinMaxScaler_set_output)`;
    return this._py`res_MinMaxScaler_set_output.tolist() if hasattr(res_MinMaxScaler_set_output, 'tolist') else res_MinMaxScaler_set_output`;
  }
  /**
    Scale features of X according to feature\_range.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before transform()");
    }
    await this._py.ex`pms_MinMaxScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinMaxScaler_transform = {k: v for k, v in pms_MinMaxScaler_transform.items() if v is not None}`;
    await this._py.ex`res_MinMaxScaler_transform = bridgeMinMaxScaler[${this.id}].transform(**pms_MinMaxScaler_transform)`;
    return this._py`res_MinMaxScaler_transform.tolist() if hasattr(res_MinMaxScaler_transform, 'tolist') else res_MinMaxScaler_transform`;
  }
  /**
    Per feature adjustment for minimum. Equivalent to `min \- X.min(axis=0) \* self.scale\_`
   */
  get min_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before accessing min_");
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_min_ = bridgeMinMaxScaler[${this.id}].min_`;
      return this._py`attr_MinMaxScaler_min_.tolist() if hasattr(attr_MinMaxScaler_min_, 'tolist') else attr_MinMaxScaler_min_`;
    })();
  }
  /**
    Per feature relative scaling of the data. Equivalent to `(max \- min) / (X.max(axis=0) \- X.min(axis=0))`
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinMaxScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_scale_ = bridgeMinMaxScaler[${this.id}].scale_`;
      return this._py`attr_MinMaxScaler_scale_.tolist() if hasattr(attr_MinMaxScaler_scale_, 'tolist') else attr_MinMaxScaler_scale_`;
    })();
  }
  /**
    Per feature minimum seen in the data
   */
  get data_min_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_min_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_min_ = bridgeMinMaxScaler[${this.id}].data_min_`;
      return this._py`attr_MinMaxScaler_data_min_.tolist() if hasattr(attr_MinMaxScaler_data_min_, 'tolist') else attr_MinMaxScaler_data_min_`;
    })();
  }
  /**
    Per feature maximum seen in the data
   */
  get data_max_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_max_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_max_ = bridgeMinMaxScaler[${this.id}].data_max_`;
      return this._py`attr_MinMaxScaler_data_max_.tolist() if hasattr(attr_MinMaxScaler_data_max_, 'tolist') else attr_MinMaxScaler_data_max_`;
    })();
  }
  /**
    Per feature range `(data\_max\_ \- data\_min\_)` seen in the data
   */
  get data_range_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing data_range_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_data_range_ = bridgeMinMaxScaler[${this.id}].data_range_`;
      return this._py`attr_MinMaxScaler_data_range_.tolist() if hasattr(attr_MinMaxScaler_data_range_, 'tolist') else attr_MinMaxScaler_data_range_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_n_features_in_ = bridgeMinMaxScaler[${this.id}].n_features_in_`;
      return this._py`attr_MinMaxScaler_n_features_in_.tolist() if hasattr(attr_MinMaxScaler_n_features_in_, 'tolist') else attr_MinMaxScaler_n_features_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator. It will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_n_samples_seen_ = bridgeMinMaxScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_MinMaxScaler_n_samples_seen_.tolist() if hasattr(attr_MinMaxScaler_n_samples_seen_, 'tolist') else attr_MinMaxScaler_n_samples_seen_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MinMaxScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinMaxScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinMaxScaler_feature_names_in_ = bridgeMinMaxScaler[${this.id}].feature_names_in_`;
      return this._py`attr_MinMaxScaler_feature_names_in_.tolist() if hasattr(attr_MinMaxScaler_feature_names_in_, 'tolist') else attr_MinMaxScaler_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/MultiLabelBinarizer.ts
import crypto233 from "node:crypto";
var MultiLabelBinarizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiLabelBinarizer${crypto233.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiLabelBinarizer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import MultiLabelBinarizer
try: bridgeMultiLabelBinarizer
except NameError: bridgeMultiLabelBinarizer = {}
`;
    await this._py.ex`ctor_MultiLabelBinarizer = {'classes': np.array(${this.opts["classes"] ?? void 0}) if ${this.opts["classes"] !== void 0} else None, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_MultiLabelBinarizer = {k: v for k, v in ctor_MultiLabelBinarizer.items() if v is not None}`;
    await this._py.ex`bridgeMultiLabelBinarizer[${this.id}] = MultiLabelBinarizer(**ctor_MultiLabelBinarizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiLabelBinarizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the label sets binarizer, storing [classes\_](../../glossary.html#term-classes_).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiLabelBinarizer must call init() before fit()");
    }
    await this._py.ex`pms_MultiLabelBinarizer_fit = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_fit = {k: v for k, v in pms_MultiLabelBinarizer_fit.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_fit = bridgeMultiLabelBinarizer[${this.id}].fit(**pms_MultiLabelBinarizer_fit)`;
    return this._py`res_MultiLabelBinarizer_fit.tolist() if hasattr(res_MultiLabelBinarizer_fit, 'tolist') else res_MultiLabelBinarizer_fit`;
  }
  /**
    Fit the label sets binarizer and transform the given label sets.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_fit_transform = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_fit_transform = {k: v for k, v in pms_MultiLabelBinarizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_fit_transform = bridgeMultiLabelBinarizer[${this.id}].fit_transform(**pms_MultiLabelBinarizer_fit_transform)`;
    return this._py`res_MultiLabelBinarizer_fit_transform.tolist() if hasattr(res_MultiLabelBinarizer_fit_transform, 'tolist') else res_MultiLabelBinarizer_fit_transform`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiLabelBinarizer_get_metadata_routing = {k: v for k, v in pms_MultiLabelBinarizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_get_metadata_routing = bridgeMultiLabelBinarizer[${this.id}].get_metadata_routing(**pms_MultiLabelBinarizer_get_metadata_routing)`;
    return this._py`res_MultiLabelBinarizer_get_metadata_routing.tolist() if hasattr(res_MultiLabelBinarizer_get_metadata_routing, 'tolist') else res_MultiLabelBinarizer_get_metadata_routing`;
  }
  /**
    Transform the given indicator matrix into label sets.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_inverse_transform = {'yt': np.array(${opts["yt"] ?? void 0}) if ${opts["yt"] !== void 0} else None}

pms_MultiLabelBinarizer_inverse_transform = {k: v for k, v in pms_MultiLabelBinarizer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_inverse_transform = bridgeMultiLabelBinarizer[${this.id}].inverse_transform(**pms_MultiLabelBinarizer_inverse_transform)`;
    return this._py`res_MultiLabelBinarizer_inverse_transform.tolist() if hasattr(res_MultiLabelBinarizer_inverse_transform, 'tolist') else res_MultiLabelBinarizer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_MultiLabelBinarizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MultiLabelBinarizer_set_output = {k: v for k, v in pms_MultiLabelBinarizer_set_output.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_set_output = bridgeMultiLabelBinarizer[${this.id}].set_output(**pms_MultiLabelBinarizer_set_output)`;
    return this._py`res_MultiLabelBinarizer_set_output.tolist() if hasattr(res_MultiLabelBinarizer_set_output, 'tolist') else res_MultiLabelBinarizer_set_output`;
  }
  /**
    Transform the given label sets.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiLabelBinarizer must call init() before transform()");
    }
    await this._py.ex`pms_MultiLabelBinarizer_transform = {'y': ${opts["y"] ?? void 0}}

pms_MultiLabelBinarizer_transform = {k: v for k, v in pms_MultiLabelBinarizer_transform.items() if v is not None}`;
    await this._py.ex`res_MultiLabelBinarizer_transform = bridgeMultiLabelBinarizer[${this.id}].transform(**pms_MultiLabelBinarizer_transform)`;
    return this._py`res_MultiLabelBinarizer_transform.tolist() if hasattr(res_MultiLabelBinarizer_transform, 'tolist') else res_MultiLabelBinarizer_transform`;
  }
  /**
    A copy of the `classes` parameter when provided. Otherwise it corresponds to the sorted set of classes found when fitting.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiLabelBinarizer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiLabelBinarizer must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiLabelBinarizer_classes_ = bridgeMultiLabelBinarizer[${this.id}].classes_`;
      return this._py`attr_MultiLabelBinarizer_classes_.tolist() if hasattr(attr_MultiLabelBinarizer_classes_, 'tolist') else attr_MultiLabelBinarizer_classes_`;
    })();
  }
};

// src/generated/preprocessing/Normalizer.ts
import crypto234 from "node:crypto";
var Normalizer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Normalizer${crypto234.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Normalizer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import Normalizer
try: bridgeNormalizer
except NameError: bridgeNormalizer = {}
`;
    await this._py.ex`ctor_Normalizer = {'norm': ${this.opts["norm"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Normalizer = {k: v for k, v in ctor_Normalizer.items() if v is not None}`;
    await this._py.ex`bridgeNormalizer[${this.id}] = Normalizer(**ctor_Normalizer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNormalizer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Only validates estimatorâ€™s parameters.
  
      This method allows to: (i) validate the estimatorâ€™s parameters and (ii) be consistent with the scikit-learn transformer API.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before fit()");
    }
    await this._py.ex`pms_Normalizer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Normalizer_fit = {k: v for k, v in pms_Normalizer_fit.items() if v is not None}`;
    await this._py.ex`res_Normalizer_fit = bridgeNormalizer[${this.id}].fit(**pms_Normalizer_fit)`;
    return this._py`res_Normalizer_fit.tolist() if hasattr(res_Normalizer_fit, 'tolist') else res_Normalizer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before fit_transform()");
    }
    await this._py.ex`pms_Normalizer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Normalizer_fit_transform = {k: v for k, v in pms_Normalizer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Normalizer_fit_transform = bridgeNormalizer[${this.id}].fit_transform(**pms_Normalizer_fit_transform)`;
    return this._py`res_Normalizer_fit_transform.tolist() if hasattr(res_Normalizer_fit_transform, 'tolist') else res_Normalizer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_Normalizer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Normalizer_get_feature_names_out = {k: v for k, v in pms_Normalizer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Normalizer_get_feature_names_out = bridgeNormalizer[${this.id}].get_feature_names_out(**pms_Normalizer_get_feature_names_out)`;
    return this._py`res_Normalizer_get_feature_names_out.tolist() if hasattr(res_Normalizer_get_feature_names_out, 'tolist') else res_Normalizer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Normalizer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Normalizer_get_metadata_routing = {k: v for k, v in pms_Normalizer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Normalizer_get_metadata_routing = bridgeNormalizer[${this.id}].get_metadata_routing(**pms_Normalizer_get_metadata_routing)`;
    return this._py`res_Normalizer_get_metadata_routing.tolist() if hasattr(res_Normalizer_get_metadata_routing, 'tolist') else res_Normalizer_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before set_output()");
    }
    await this._py.ex`pms_Normalizer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Normalizer_set_output = {k: v for k, v in pms_Normalizer_set_output.items() if v is not None}`;
    await this._py.ex`res_Normalizer_set_output = bridgeNormalizer[${this.id}].set_output(**pms_Normalizer_set_output)`;
    return this._py`res_Normalizer_set_output.tolist() if hasattr(res_Normalizer_set_output, 'tolist') else res_Normalizer_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_Normalizer_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_Normalizer_set_transform_request = {k: v for k, v in pms_Normalizer_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_Normalizer_set_transform_request = bridgeNormalizer[${this.id}].set_transform_request(**pms_Normalizer_set_transform_request)`;
    return this._py`res_Normalizer_set_transform_request.tolist() if hasattr(res_Normalizer_set_transform_request, 'tolist') else res_Normalizer_set_transform_request`;
  }
  /**
    Scale each non zero row of X to unit norm.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Normalizer must call init() before transform()");
    }
    await this._py.ex`pms_Normalizer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_Normalizer_transform = {k: v for k, v in pms_Normalizer_transform.items() if v is not None}`;
    await this._py.ex`res_Normalizer_transform = bridgeNormalizer[${this.id}].transform(**pms_Normalizer_transform)`;
    return this._py`res_Normalizer_transform.tolist() if hasattr(res_Normalizer_transform, 'tolist') else res_Normalizer_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Normalizer_n_features_in_ = bridgeNormalizer[${this.id}].n_features_in_`;
      return this._py`attr_Normalizer_n_features_in_.tolist() if hasattr(attr_Normalizer_n_features_in_, 'tolist') else attr_Normalizer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Normalizer instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Normalizer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Normalizer_feature_names_in_ = bridgeNormalizer[${this.id}].feature_names_in_`;
      return this._py`attr_Normalizer_feature_names_in_.tolist() if hasattr(attr_Normalizer_feature_names_in_, 'tolist') else attr_Normalizer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/OneHotEncoder.ts
import crypto235 from "node:crypto";
var OneHotEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneHotEncoder${crypto235.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OneHotEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import OneHotEncoder
try: bridgeOneHotEncoder
except NameError: bridgeOneHotEncoder = {}
`;
    await this._py.ex`ctor_OneHotEncoder = {'categories': ${this.opts["categories"] ?? void 0}, 'drop': np.array(${this.opts["drop"] ?? void 0}) if ${this.opts["drop"] !== void 0} else None, 'sparse': ${this.opts["sparse"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'handle_unknown': ${this.opts["handle_unknown"] ?? void 0}, 'min_frequency': ${this.opts["min_frequency"] ?? void 0}, 'max_categories': ${this.opts["max_categories"] ?? void 0}, 'feature_name_combiner': ${this.opts["feature_name_combiner"] ?? void 0}}

ctor_OneHotEncoder = {k: v for k, v in ctor_OneHotEncoder.items() if v is not None}`;
    await this._py.ex`bridgeOneHotEncoder[${this.id}] = OneHotEncoder(**ctor_OneHotEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneHotEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit OneHotEncoder to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before fit()");
    }
    await this._py.ex`pms_OneHotEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OneHotEncoder_fit = {k: v for k, v in pms_OneHotEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_fit = bridgeOneHotEncoder[${this.id}].fit(**pms_OneHotEncoder_fit)`;
    return this._py`res_OneHotEncoder_fit.tolist() if hasattr(res_OneHotEncoder_fit, 'tolist') else res_OneHotEncoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_OneHotEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_OneHotEncoder_fit_transform = {k: v for k, v in pms_OneHotEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_fit_transform = bridgeOneHotEncoder[${this.id}].fit_transform(**pms_OneHotEncoder_fit_transform)`;
    return this._py`res_OneHotEncoder_fit_transform.tolist() if hasattr(res_OneHotEncoder_fit_transform, 'tolist') else res_OneHotEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_OneHotEncoder_get_feature_names_out = {k: v for k, v in pms_OneHotEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_get_feature_names_out = bridgeOneHotEncoder[${this.id}].get_feature_names_out(**pms_OneHotEncoder_get_feature_names_out)`;
    return this._py`res_OneHotEncoder_get_feature_names_out.tolist() if hasattr(res_OneHotEncoder_get_feature_names_out, 'tolist') else res_OneHotEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OneHotEncoder_get_metadata_routing = {k: v for k, v in pms_OneHotEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_get_metadata_routing = bridgeOneHotEncoder[${this.id}].get_metadata_routing(**pms_OneHotEncoder_get_metadata_routing)`;
    return this._py`res_OneHotEncoder_get_metadata_routing.tolist() if hasattr(res_OneHotEncoder_get_metadata_routing, 'tolist') else res_OneHotEncoder_get_metadata_routing`;
  }
  /**
      Convert the data back to the original representation.
  
      When unknown categories are encountered (all zeros in the one-hot encoding), `undefined` is used to represent this category. If the feature with the unknown category has a dropped category, the dropped category will be its inverse.
  
      For a given input feature, if there is an infrequent category, â€˜infrequent\_sklearnâ€™ will be used to represent the infrequent category.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_OneHotEncoder_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneHotEncoder_inverse_transform = {k: v for k, v in pms_OneHotEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_inverse_transform = bridgeOneHotEncoder[${this.id}].inverse_transform(**pms_OneHotEncoder_inverse_transform)`;
    return this._py`res_OneHotEncoder_inverse_transform.tolist() if hasattr(res_OneHotEncoder_inverse_transform, 'tolist') else res_OneHotEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_OneHotEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_OneHotEncoder_set_output = {k: v for k, v in pms_OneHotEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_set_output = bridgeOneHotEncoder[${this.id}].set_output(**pms_OneHotEncoder_set_output)`;
    return this._py`res_OneHotEncoder_set_output.tolist() if hasattr(res_OneHotEncoder_set_output, 'tolist') else res_OneHotEncoder_set_output`;
  }
  /**
      Transform X using one-hot encoding.
  
      If there are infrequent categories for a feature, the infrequent categories will be grouped into a single category.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneHotEncoder must call init() before transform()");
    }
    await this._py.ex`pms_OneHotEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneHotEncoder_transform = {k: v for k, v in pms_OneHotEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_OneHotEncoder_transform = bridgeOneHotEncoder[${this.id}].transform(**pms_OneHotEncoder_transform)`;
    return this._py`res_OneHotEncoder_transform.tolist() if hasattr(res_OneHotEncoder_transform, 'tolist') else res_OneHotEncoder_transform`;
  }
  /**
    The categories of each feature determined during fitting (in order of the features in X and corresponding with the output of `transform`). This includes the category specified in `drop` (if any).
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_categories_ = bridgeOneHotEncoder[${this.id}].categories_`;
      return this._py`attr_OneHotEncoder_categories_.tolist() if hasattr(attr_OneHotEncoder_categories_, 'tolist') else attr_OneHotEncoder_categories_`;
    })();
  }
  /**
    `drop\_idx\_\[i\]` is the index in `categories\_\[i\]` of the category to be dropped for each feature.
   */
  get drop_idx_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing drop_idx_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_drop_idx_ = bridgeOneHotEncoder[${this.id}].drop_idx_`;
      return this._py`attr_OneHotEncoder_drop_idx_.tolist() if hasattr(attr_OneHotEncoder_drop_idx_, 'tolist') else attr_OneHotEncoder_drop_idx_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_n_features_in_ = bridgeOneHotEncoder[${this.id}].n_features_in_`;
      return this._py`attr_OneHotEncoder_n_features_in_.tolist() if hasattr(attr_OneHotEncoder_n_features_in_, 'tolist') else attr_OneHotEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_feature_names_in_ = bridgeOneHotEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_OneHotEncoder_feature_names_in_.tolist() if hasattr(attr_OneHotEncoder_feature_names_in_, 'tolist') else attr_OneHotEncoder_feature_names_in_`;
    })();
  }
  /**
    Callable with signature `def callable(input\_feature, category)` that returns a string. This is used to create feature names to be returned by [`get\_feature\_names\_out`](#sklearn.preprocessing.OneHotEncoder.get_feature_names_out "sklearn.preprocessing.OneHotEncoder.get_feature_names_out").
   */
  get feature_name_combiner() {
    if (this._isDisposed) {
      throw new Error("This OneHotEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneHotEncoder must call init() before accessing feature_name_combiner"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneHotEncoder_feature_name_combiner = bridgeOneHotEncoder[${this.id}].feature_name_combiner`;
      return this._py`attr_OneHotEncoder_feature_name_combiner.tolist() if hasattr(attr_OneHotEncoder_feature_name_combiner, 'tolist') else attr_OneHotEncoder_feature_name_combiner`;
    })();
  }
};

// src/generated/preprocessing/OrdinalEncoder.ts
import crypto236 from "node:crypto";
var OrdinalEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrdinalEncoder${crypto236.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OrdinalEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import OrdinalEncoder
try: bridgeOrdinalEncoder
except NameError: bridgeOrdinalEncoder = {}
`;
    await this._py.ex`ctor_OrdinalEncoder = {'categories': ${this.opts["categories"] ?? void 0}, 'dtype': ${this.opts["dtype"] ?? void 0}, 'handle_unknown': ${this.opts["handle_unknown"] ?? void 0}, 'unknown_value': ${this.opts["unknown_value"] ?? void 0}, 'encoded_missing_value': ${this.opts["encoded_missing_value"] ?? void 0}, 'min_frequency': ${this.opts["min_frequency"] ?? void 0}, 'max_categories': ${this.opts["max_categories"] ?? void 0}}

ctor_OrdinalEncoder = {k: v for k, v in ctor_OrdinalEncoder.items() if v is not None}`;
    await this._py.ex`bridgeOrdinalEncoder[${this.id}] = OrdinalEncoder(**ctor_OrdinalEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrdinalEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the OrdinalEncoder to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before fit()");
    }
    await this._py.ex`pms_OrdinalEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OrdinalEncoder_fit = {k: v for k, v in pms_OrdinalEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_fit = bridgeOrdinalEncoder[${this.id}].fit(**pms_OrdinalEncoder_fit)`;
    return this._py`res_OrdinalEncoder_fit.tolist() if hasattr(res_OrdinalEncoder_fit, 'tolist') else res_OrdinalEncoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_OrdinalEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_OrdinalEncoder_fit_transform = {k: v for k, v in pms_OrdinalEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_fit_transform = bridgeOrdinalEncoder[${this.id}].fit_transform(**pms_OrdinalEncoder_fit_transform)`;
    return this._py`res_OrdinalEncoder_fit_transform.tolist() if hasattr(res_OrdinalEncoder_fit_transform, 'tolist') else res_OrdinalEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_OrdinalEncoder_get_feature_names_out = {k: v for k, v in pms_OrdinalEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_get_feature_names_out = bridgeOrdinalEncoder[${this.id}].get_feature_names_out(**pms_OrdinalEncoder_get_feature_names_out)`;
    return this._py`res_OrdinalEncoder_get_feature_names_out.tolist() if hasattr(res_OrdinalEncoder_get_feature_names_out, 'tolist') else res_OrdinalEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrdinalEncoder_get_metadata_routing = {k: v for k, v in pms_OrdinalEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_get_metadata_routing = bridgeOrdinalEncoder[${this.id}].get_metadata_routing(**pms_OrdinalEncoder_get_metadata_routing)`;
    return this._py`res_OrdinalEncoder_get_metadata_routing.tolist() if hasattr(res_OrdinalEncoder_get_metadata_routing, 'tolist') else res_OrdinalEncoder_get_metadata_routing`;
  }
  /**
    Convert the data back to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_OrdinalEncoder_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OrdinalEncoder_inverse_transform = {k: v for k, v in pms_OrdinalEncoder_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_inverse_transform = bridgeOrdinalEncoder[${this.id}].inverse_transform(**pms_OrdinalEncoder_inverse_transform)`;
    return this._py`res_OrdinalEncoder_inverse_transform.tolist() if hasattr(res_OrdinalEncoder_inverse_transform, 'tolist') else res_OrdinalEncoder_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_OrdinalEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_OrdinalEncoder_set_output = {k: v for k, v in pms_OrdinalEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_set_output = bridgeOrdinalEncoder[${this.id}].set_output(**pms_OrdinalEncoder_set_output)`;
    return this._py`res_OrdinalEncoder_set_output.tolist() if hasattr(res_OrdinalEncoder_set_output, 'tolist') else res_OrdinalEncoder_set_output`;
  }
  /**
    Transform X to ordinal codes.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OrdinalEncoder must call init() before transform()");
    }
    await this._py.ex`pms_OrdinalEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OrdinalEncoder_transform = {k: v for k, v in pms_OrdinalEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_OrdinalEncoder_transform = bridgeOrdinalEncoder[${this.id}].transform(**pms_OrdinalEncoder_transform)`;
    return this._py`res_OrdinalEncoder_transform.tolist() if hasattr(res_OrdinalEncoder_transform, 'tolist') else res_OrdinalEncoder_transform`;
  }
  /**
    The categories of each feature determined during `fit` (in order of the features in X and corresponding with the output of `transform`). This does not include categories that werenâ€™t seen during `fit`.
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_categories_ = bridgeOrdinalEncoder[${this.id}].categories_`;
      return this._py`attr_OrdinalEncoder_categories_.tolist() if hasattr(attr_OrdinalEncoder_categories_, 'tolist') else attr_OrdinalEncoder_categories_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_n_features_in_ = bridgeOrdinalEncoder[${this.id}].n_features_in_`;
      return this._py`attr_OrdinalEncoder_n_features_in_.tolist() if hasattr(attr_OrdinalEncoder_n_features_in_, 'tolist') else attr_OrdinalEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OrdinalEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrdinalEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrdinalEncoder_feature_names_in_ = bridgeOrdinalEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_OrdinalEncoder_feature_names_in_.tolist() if hasattr(attr_OrdinalEncoder_feature_names_in_, 'tolist') else attr_OrdinalEncoder_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/PolynomialFeatures.ts
import crypto237 from "node:crypto";
var PolynomialFeatures = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PolynomialFeatures${crypto237.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PolynomialFeatures.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import PolynomialFeatures
try: bridgePolynomialFeatures
except NameError: bridgePolynomialFeatures = {}
`;
    await this._py.ex`ctor_PolynomialFeatures = {'degree': ${this.opts["degree"] ?? void 0}, 'interaction_only': ${this.opts["interaction_only"] ?? void 0}, 'include_bias': ${this.opts["include_bias"] ?? void 0}, 'order': ${this.opts["order"] ?? void 0}}

ctor_PolynomialFeatures = {k: v for k, v in ctor_PolynomialFeatures.items() if v is not None}`;
    await this._py.ex`bridgePolynomialFeatures[${this.id}] = PolynomialFeatures(**ctor_PolynomialFeatures)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePolynomialFeatures[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute number of output features.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before fit()");
    }
    await this._py.ex`pms_PolynomialFeatures_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PolynomialFeatures_fit = {k: v for k, v in pms_PolynomialFeatures_fit.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_fit = bridgePolynomialFeatures[${this.id}].fit(**pms_PolynomialFeatures_fit)`;
    return this._py`res_PolynomialFeatures_fit.tolist() if hasattr(res_PolynomialFeatures_fit, 'tolist') else res_PolynomialFeatures_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_PolynomialFeatures_fit_transform = {k: v for k, v in pms_PolynomialFeatures_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_fit_transform = bridgePolynomialFeatures[${this.id}].fit_transform(**pms_PolynomialFeatures_fit_transform)`;
    return this._py`res_PolynomialFeatures_fit_transform.tolist() if hasattr(res_PolynomialFeatures_fit_transform, 'tolist') else res_PolynomialFeatures_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PolynomialFeatures_get_feature_names_out = {k: v for k, v in pms_PolynomialFeatures_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_get_feature_names_out = bridgePolynomialFeatures[${this.id}].get_feature_names_out(**pms_PolynomialFeatures_get_feature_names_out)`;
    return this._py`res_PolynomialFeatures_get_feature_names_out.tolist() if hasattr(res_PolynomialFeatures_get_feature_names_out, 'tolist') else res_PolynomialFeatures_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PolynomialFeatures_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PolynomialFeatures_get_metadata_routing = {k: v for k, v in pms_PolynomialFeatures_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_get_metadata_routing = bridgePolynomialFeatures[${this.id}].get_metadata_routing(**pms_PolynomialFeatures_get_metadata_routing)`;
    return this._py`res_PolynomialFeatures_get_metadata_routing.tolist() if hasattr(res_PolynomialFeatures_get_metadata_routing, 'tolist') else res_PolynomialFeatures_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before set_output()");
    }
    await this._py.ex`pms_PolynomialFeatures_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PolynomialFeatures_set_output = {k: v for k, v in pms_PolynomialFeatures_set_output.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_set_output = bridgePolynomialFeatures[${this.id}].set_output(**pms_PolynomialFeatures_set_output)`;
    return this._py`res_PolynomialFeatures_set_output.tolist() if hasattr(res_PolynomialFeatures_set_output, 'tolist') else res_PolynomialFeatures_set_output`;
  }
  /**
    Transform data to polynomial features.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PolynomialFeatures must call init() before transform()");
    }
    await this._py.ex`pms_PolynomialFeatures_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PolynomialFeatures_transform = {k: v for k, v in pms_PolynomialFeatures_transform.items() if v is not None}`;
    await this._py.ex`res_PolynomialFeatures_transform = bridgePolynomialFeatures[${this.id}].transform(**pms_PolynomialFeatures_transform)`;
    return this._py`res_PolynomialFeatures_transform.tolist() if hasattr(res_PolynomialFeatures_transform, 'tolist') else res_PolynomialFeatures_transform`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_n_features_in_ = bridgePolynomialFeatures[${this.id}].n_features_in_`;
      return this._py`attr_PolynomialFeatures_n_features_in_.tolist() if hasattr(attr_PolynomialFeatures_n_features_in_, 'tolist') else attr_PolynomialFeatures_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_feature_names_in_ = bridgePolynomialFeatures[${this.id}].feature_names_in_`;
      return this._py`attr_PolynomialFeatures_feature_names_in_.tolist() if hasattr(attr_PolynomialFeatures_feature_names_in_, 'tolist') else attr_PolynomialFeatures_feature_names_in_`;
    })();
  }
  /**
    The total number of polynomial output features. The number of output features is computed by iterating over all suitably sized combinations of input features.
   */
  get n_output_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This PolynomialFeatures instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PolynomialFeatures must call init() before accessing n_output_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PolynomialFeatures_n_output_features_ = bridgePolynomialFeatures[${this.id}].n_output_features_`;
      return this._py`attr_PolynomialFeatures_n_output_features_.tolist() if hasattr(attr_PolynomialFeatures_n_output_features_, 'tolist') else attr_PolynomialFeatures_n_output_features_`;
    })();
  }
};

// src/generated/preprocessing/PowerTransformer.ts
import crypto238 from "node:crypto";
var PowerTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PowerTransformer${crypto238.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PowerTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import PowerTransformer
try: bridgePowerTransformer
except NameError: bridgePowerTransformer = {}
`;
    await this._py.ex`ctor_PowerTransformer = {'method': ${this.opts["method"] ?? void 0}, 'standardize': ${this.opts["standardize"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PowerTransformer = {k: v for k, v in ctor_PowerTransformer.items() if v is not None}`;
    await this._py.ex`bridgePowerTransformer[${this.id}] = PowerTransformer(**ctor_PowerTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePowerTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Estimate the optimal parameter lambda for each feature.
  
      The optimal lambda parameter for minimizing skewness is estimated on each feature independently using maximum likelihood.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before fit()");
    }
    await this._py.ex`pms_PowerTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PowerTransformer_fit = {k: v for k, v in pms_PowerTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_fit = bridgePowerTransformer[${this.id}].fit(**pms_PowerTransformer_fit)`;
    return this._py`res_PowerTransformer_fit.tolist() if hasattr(res_PowerTransformer_fit, 'tolist') else res_PowerTransformer_fit`;
  }
  /**
    Fit `PowerTransformer` to `X`, then transform `X`.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_PowerTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PowerTransformer_fit_transform = {k: v for k, v in pms_PowerTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_fit_transform = bridgePowerTransformer[${this.id}].fit_transform(**pms_PowerTransformer_fit_transform)`;
    return this._py`res_PowerTransformer_fit_transform.tolist() if hasattr(res_PowerTransformer_fit_transform, 'tolist') else res_PowerTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PowerTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PowerTransformer_get_feature_names_out = {k: v for k, v in pms_PowerTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_get_feature_names_out = bridgePowerTransformer[${this.id}].get_feature_names_out(**pms_PowerTransformer_get_feature_names_out)`;
    return this._py`res_PowerTransformer_get_feature_names_out.tolist() if hasattr(res_PowerTransformer_get_feature_names_out, 'tolist') else res_PowerTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PowerTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PowerTransformer_get_metadata_routing = {k: v for k, v in pms_PowerTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_get_metadata_routing = bridgePowerTransformer[${this.id}].get_metadata_routing(**pms_PowerTransformer_get_metadata_routing)`;
    return this._py`res_PowerTransformer_get_metadata_routing.tolist() if hasattr(res_PowerTransformer_get_metadata_routing, 'tolist') else res_PowerTransformer_get_metadata_routing`;
  }
  /**
      Apply the inverse power transformation using the fitted lambdas.
  
      The inverse of the Box-Cox transformation is given by:
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PowerTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PowerTransformer_inverse_transform = {k: v for k, v in pms_PowerTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_inverse_transform = bridgePowerTransformer[${this.id}].inverse_transform(**pms_PowerTransformer_inverse_transform)`;
    return this._py`res_PowerTransformer_inverse_transform.tolist() if hasattr(res_PowerTransformer_inverse_transform, 'tolist') else res_PowerTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_PowerTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PowerTransformer_set_output = {k: v for k, v in pms_PowerTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_set_output = bridgePowerTransformer[${this.id}].set_output(**pms_PowerTransformer_set_output)`;
    return this._py`res_PowerTransformer_set_output.tolist() if hasattr(res_PowerTransformer_set_output, 'tolist') else res_PowerTransformer_set_output`;
  }
  /**
    Apply the power transform to each feature using the fitted lambdas.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PowerTransformer must call init() before transform()");
    }
    await this._py.ex`pms_PowerTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PowerTransformer_transform = {k: v for k, v in pms_PowerTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_PowerTransformer_transform = bridgePowerTransformer[${this.id}].transform(**pms_PowerTransformer_transform)`;
    return this._py`res_PowerTransformer_transform.tolist() if hasattr(res_PowerTransformer_transform, 'tolist') else res_PowerTransformer_transform`;
  }
  /**
    The parameters of the power transformation for the selected features.
   */
  get lambdas_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing lambdas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_lambdas_ = bridgePowerTransformer[${this.id}].lambdas_`;
      return this._py`attr_PowerTransformer_lambdas_.tolist() if hasattr(attr_PowerTransformer_lambdas_, 'tolist') else attr_PowerTransformer_lambdas_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_n_features_in_ = bridgePowerTransformer[${this.id}].n_features_in_`;
      return this._py`attr_PowerTransformer_n_features_in_.tolist() if hasattr(attr_PowerTransformer_n_features_in_, 'tolist') else attr_PowerTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PowerTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PowerTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PowerTransformer_feature_names_in_ = bridgePowerTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_PowerTransformer_feature_names_in_.tolist() if hasattr(attr_PowerTransformer_feature_names_in_, 'tolist') else attr_PowerTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/QuantileTransformer.ts
import crypto239 from "node:crypto";
var QuantileTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `QuantileTransformer${crypto239.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "QuantileTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import QuantileTransformer
try: bridgeQuantileTransformer
except NameError: bridgeQuantileTransformer = {}
`;
    await this._py.ex`ctor_QuantileTransformer = {'n_quantiles': ${this.opts["n_quantiles"] ?? void 0}, 'output_distribution': ${this.opts["output_distribution"] ?? void 0}, 'ignore_implicit_zeros': ${this.opts["ignore_implicit_zeros"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_QuantileTransformer = {k: v for k, v in ctor_QuantileTransformer.items() if v is not None}`;
    await this._py.ex`bridgeQuantileTransformer[${this.id}] = QuantileTransformer(**ctor_QuantileTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuantileTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the quantiles used for transforming.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileTransformer must call init() before fit()");
    }
    await this._py.ex`pms_QuantileTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_QuantileTransformer_fit = {k: v for k, v in pms_QuantileTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_fit = bridgeQuantileTransformer[${this.id}].fit(**pms_QuantileTransformer_fit)`;
    return this._py`res_QuantileTransformer_fit.tolist() if hasattr(res_QuantileTransformer_fit, 'tolist') else res_QuantileTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_QuantileTransformer_fit_transform = {k: v for k, v in pms_QuantileTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_fit_transform = bridgeQuantileTransformer[${this.id}].fit_transform(**pms_QuantileTransformer_fit_transform)`;
    return this._py`res_QuantileTransformer_fit_transform.tolist() if hasattr(res_QuantileTransformer_fit_transform, 'tolist') else res_QuantileTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_QuantileTransformer_get_feature_names_out = {k: v for k, v in pms_QuantileTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_get_feature_names_out = bridgeQuantileTransformer[${this.id}].get_feature_names_out(**pms_QuantileTransformer_get_feature_names_out)`;
    return this._py`res_QuantileTransformer_get_feature_names_out.tolist() if hasattr(res_QuantileTransformer_get_feature_names_out, 'tolist') else res_QuantileTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuantileTransformer_get_metadata_routing = {k: v for k, v in pms_QuantileTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_get_metadata_routing = bridgeQuantileTransformer[${this.id}].get_metadata_routing(**pms_QuantileTransformer_get_metadata_routing)`;
    return this._py`res_QuantileTransformer_get_metadata_routing.tolist() if hasattr(res_QuantileTransformer_get_metadata_routing, 'tolist') else res_QuantileTransformer_get_metadata_routing`;
  }
  /**
    Back-projection to the original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuantileTransformer_inverse_transform = {k: v for k, v in pms_QuantileTransformer_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_inverse_transform = bridgeQuantileTransformer[${this.id}].inverse_transform(**pms_QuantileTransformer_inverse_transform)`;
    return this._py`res_QuantileTransformer_inverse_transform.tolist() if hasattr(res_QuantileTransformer_inverse_transform, 'tolist') else res_QuantileTransformer_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_QuantileTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_QuantileTransformer_set_output = {k: v for k, v in pms_QuantileTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_set_output = bridgeQuantileTransformer[${this.id}].set_output(**pms_QuantileTransformer_set_output)`;
    return this._py`res_QuantileTransformer_set_output.tolist() if hasattr(res_QuantileTransformer_set_output, 'tolist') else res_QuantileTransformer_set_output`;
  }
  /**
    Feature-wise transformation of the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileTransformer must call init() before transform()");
    }
    await this._py.ex`pms_QuantileTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuantileTransformer_transform = {k: v for k, v in pms_QuantileTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_QuantileTransformer_transform = bridgeQuantileTransformer[${this.id}].transform(**pms_QuantileTransformer_transform)`;
    return this._py`res_QuantileTransformer_transform.tolist() if hasattr(res_QuantileTransformer_transform, 'tolist') else res_QuantileTransformer_transform`;
  }
  /**
    The actual number of quantiles used to discretize the cumulative distribution function.
   */
  get n_quantiles_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing n_quantiles_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_n_quantiles_ = bridgeQuantileTransformer[${this.id}].n_quantiles_`;
      return this._py`attr_QuantileTransformer_n_quantiles_.tolist() if hasattr(attr_QuantileTransformer_n_quantiles_, 'tolist') else attr_QuantileTransformer_n_quantiles_`;
    })();
  }
  /**
    The values corresponding the quantiles of reference.
   */
  get quantiles_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing quantiles_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_quantiles_ = bridgeQuantileTransformer[${this.id}].quantiles_`;
      return this._py`attr_QuantileTransformer_quantiles_.tolist() if hasattr(attr_QuantileTransformer_quantiles_, 'tolist') else attr_QuantileTransformer_quantiles_`;
    })();
  }
  /**
    Quantiles of references.
   */
  get references_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing references_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_references_ = bridgeQuantileTransformer[${this.id}].references_`;
      return this._py`attr_QuantileTransformer_references_.tolist() if hasattr(attr_QuantileTransformer_references_, 'tolist') else attr_QuantileTransformer_references_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_n_features_in_ = bridgeQuantileTransformer[${this.id}].n_features_in_`;
      return this._py`attr_QuantileTransformer_n_features_in_.tolist() if hasattr(attr_QuantileTransformer_n_features_in_, 'tolist') else attr_QuantileTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileTransformer_feature_names_in_ = bridgeQuantileTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_QuantileTransformer_feature_names_in_.tolist() if hasattr(attr_QuantileTransformer_feature_names_in_, 'tolist') else attr_QuantileTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/RobustScaler.ts
import crypto240 from "node:crypto";
var RobustScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RobustScaler${crypto240.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RobustScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import RobustScaler
try: bridgeRobustScaler
except NameError: bridgeRobustScaler = {}
`;
    await this._py.ex`ctor_RobustScaler = {'with_centering': ${this.opts["with_centering"] ?? void 0}, 'with_scaling': ${this.opts["with_scaling"] ?? void 0}, 'quantile_range': ${this.opts["quantile_range"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'unit_variance': ${this.opts["unit_variance"] ?? void 0}}

ctor_RobustScaler = {k: v for k, v in ctor_RobustScaler.items() if v is not None}`;
    await this._py.ex`bridgeRobustScaler[${this.id}] = RobustScaler(**ctor_RobustScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRobustScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the median and quantiles to be used for scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before fit()");
    }
    await this._py.ex`pms_RobustScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RobustScaler_fit = {k: v for k, v in pms_RobustScaler_fit.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_fit = bridgeRobustScaler[${this.id}].fit(**pms_RobustScaler_fit)`;
    return this._py`res_RobustScaler_fit.tolist() if hasattr(res_RobustScaler_fit, 'tolist') else res_RobustScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_RobustScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_RobustScaler_fit_transform = {k: v for k, v in pms_RobustScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_fit_transform = bridgeRobustScaler[${this.id}].fit_transform(**pms_RobustScaler_fit_transform)`;
    return this._py`res_RobustScaler_fit_transform.tolist() if hasattr(res_RobustScaler_fit_transform, 'tolist') else res_RobustScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RobustScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RobustScaler_get_feature_names_out = {k: v for k, v in pms_RobustScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_get_feature_names_out = bridgeRobustScaler[${this.id}].get_feature_names_out(**pms_RobustScaler_get_feature_names_out)`;
    return this._py`res_RobustScaler_get_feature_names_out.tolist() if hasattr(res_RobustScaler_get_feature_names_out, 'tolist') else res_RobustScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RobustScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RobustScaler_get_metadata_routing = {k: v for k, v in pms_RobustScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_get_metadata_routing = bridgeRobustScaler[${this.id}].get_metadata_routing(**pms_RobustScaler_get_metadata_routing)`;
    return this._py`res_RobustScaler_get_metadata_routing.tolist() if hasattr(res_RobustScaler_get_metadata_routing, 'tolist') else res_RobustScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_RobustScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RobustScaler_inverse_transform = {k: v for k, v in pms_RobustScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_inverse_transform = bridgeRobustScaler[${this.id}].inverse_transform(**pms_RobustScaler_inverse_transform)`;
    return this._py`res_RobustScaler_inverse_transform.tolist() if hasattr(res_RobustScaler_inverse_transform, 'tolist') else res_RobustScaler_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before set_output()");
    }
    await this._py.ex`pms_RobustScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RobustScaler_set_output = {k: v for k, v in pms_RobustScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_set_output = bridgeRobustScaler[${this.id}].set_output(**pms_RobustScaler_set_output)`;
    return this._py`res_RobustScaler_set_output.tolist() if hasattr(res_RobustScaler_set_output, 'tolist') else res_RobustScaler_set_output`;
  }
  /**
    Center and scale the data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before transform()");
    }
    await this._py.ex`pms_RobustScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RobustScaler_transform = {k: v for k, v in pms_RobustScaler_transform.items() if v is not None}`;
    await this._py.ex`res_RobustScaler_transform = bridgeRobustScaler[${this.id}].transform(**pms_RobustScaler_transform)`;
    return this._py`res_RobustScaler_transform.tolist() if hasattr(res_RobustScaler_transform, 'tolist') else res_RobustScaler_transform`;
  }
  /**
    The median value for each feature in the training set.
   */
  get center_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before accessing center_");
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_center_ = bridgeRobustScaler[${this.id}].center_`;
      return this._py`attr_RobustScaler_center_.tolist() if hasattr(attr_RobustScaler_center_, 'tolist') else attr_RobustScaler_center_`;
    })();
  }
  /**
    The (scaled) interquartile range for each feature in the training set.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RobustScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_scale_ = bridgeRobustScaler[${this.id}].scale_`;
      return this._py`attr_RobustScaler_scale_.tolist() if hasattr(attr_RobustScaler_scale_, 'tolist') else attr_RobustScaler_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_n_features_in_ = bridgeRobustScaler[${this.id}].n_features_in_`;
      return this._py`attr_RobustScaler_n_features_in_.tolist() if hasattr(attr_RobustScaler_n_features_in_, 'tolist') else attr_RobustScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RobustScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RobustScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RobustScaler_feature_names_in_ = bridgeRobustScaler[${this.id}].feature_names_in_`;
      return this._py`attr_RobustScaler_feature_names_in_.tolist() if hasattr(attr_RobustScaler_feature_names_in_, 'tolist') else attr_RobustScaler_feature_names_in_`;
    })();
  }
};

// src/generated/preprocessing/SplineTransformer.ts
import crypto241 from "node:crypto";
var SplineTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SplineTransformer${crypto241.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SplineTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import SplineTransformer
try: bridgeSplineTransformer
except NameError: bridgeSplineTransformer = {}
`;
    await this._py.ex`ctor_SplineTransformer = {'n_knots': ${this.opts["n_knots"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'knots': np.array(${this.opts["knots"] ?? void 0}) if ${this.opts["knots"] !== void 0} else None, 'extrapolation': ${this.opts["extrapolation"] ?? void 0}, 'include_bias': ${this.opts["include_bias"] ?? void 0}, 'order': ${this.opts["order"] ?? void 0}, 'sparse_output': ${this.opts["sparse_output"] ?? void 0}}

ctor_SplineTransformer = {k: v for k, v in ctor_SplineTransformer.items() if v is not None}`;
    await this._py.ex`bridgeSplineTransformer[${this.id}] = SplineTransformer(**ctor_SplineTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSplineTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute knot positions of splines.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before fit()");
    }
    await this._py.ex`pms_SplineTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SplineTransformer_fit = {k: v for k, v in pms_SplineTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_fit = bridgeSplineTransformer[${this.id}].fit(**pms_SplineTransformer_fit)`;
    return this._py`res_SplineTransformer_fit.tolist() if hasattr(res_SplineTransformer_fit, 'tolist') else res_SplineTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SplineTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SplineTransformer_fit_transform = {k: v for k, v in pms_SplineTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_fit_transform = bridgeSplineTransformer[${this.id}].fit_transform(**pms_SplineTransformer_fit_transform)`;
    return this._py`res_SplineTransformer_fit_transform.tolist() if hasattr(res_SplineTransformer_fit_transform, 'tolist') else res_SplineTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SplineTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SplineTransformer_get_feature_names_out = {k: v for k, v in pms_SplineTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_get_feature_names_out = bridgeSplineTransformer[${this.id}].get_feature_names_out(**pms_SplineTransformer_get_feature_names_out)`;
    return this._py`res_SplineTransformer_get_feature_names_out.tolist() if hasattr(res_SplineTransformer_get_feature_names_out, 'tolist') else res_SplineTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SplineTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SplineTransformer_get_metadata_routing = {k: v for k, v in pms_SplineTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_get_metadata_routing = bridgeSplineTransformer[${this.id}].get_metadata_routing(**pms_SplineTransformer_get_metadata_routing)`;
    return this._py`res_SplineTransformer_get_metadata_routing.tolist() if hasattr(res_SplineTransformer_get_metadata_routing, 'tolist') else res_SplineTransformer_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_SplineTransformer_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SplineTransformer_set_fit_request = {k: v for k, v in pms_SplineTransformer_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_set_fit_request = bridgeSplineTransformer[${this.id}].set_fit_request(**pms_SplineTransformer_set_fit_request)`;
    return this._py`res_SplineTransformer_set_fit_request.tolist() if hasattr(res_SplineTransformer_set_fit_request, 'tolist') else res_SplineTransformer_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_SplineTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SplineTransformer_set_output = {k: v for k, v in pms_SplineTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_set_output = bridgeSplineTransformer[${this.id}].set_output(**pms_SplineTransformer_set_output)`;
    return this._py`res_SplineTransformer_set_output.tolist() if hasattr(res_SplineTransformer_set_output, 'tolist') else res_SplineTransformer_set_output`;
  }
  /**
    Transform each feature data to B-splines.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SplineTransformer must call init() before transform()");
    }
    await this._py.ex`pms_SplineTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SplineTransformer_transform = {k: v for k, v in pms_SplineTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_SplineTransformer_transform = bridgeSplineTransformer[${this.id}].transform(**pms_SplineTransformer_transform)`;
    return this._py`res_SplineTransformer_transform.tolist() if hasattr(res_SplineTransformer_transform, 'tolist') else res_SplineTransformer_transform`;
  }
  /**
    List of BSplines objects, one for each feature.
   */
  get bsplines_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing bsplines_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_bsplines_ = bridgeSplineTransformer[${this.id}].bsplines_`;
      return this._py`attr_SplineTransformer_bsplines_.tolist() if hasattr(attr_SplineTransformer_bsplines_, 'tolist') else attr_SplineTransformer_bsplines_`;
    })();
  }
  /**
    The total number of input features.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_n_features_in_ = bridgeSplineTransformer[${this.id}].n_features_in_`;
      return this._py`attr_SplineTransformer_n_features_in_.tolist() if hasattr(attr_SplineTransformer_n_features_in_, 'tolist') else attr_SplineTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_feature_names_in_ = bridgeSplineTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_SplineTransformer_feature_names_in_.tolist() if hasattr(attr_SplineTransformer_feature_names_in_, 'tolist') else attr_SplineTransformer_feature_names_in_`;
    })();
  }
  /**
    The total number of output features, which is computed as `n\_features \* n\_splines`, where `n\_splines` is the number of bases elements of the B-splines, `n\_knots + degree \- 1` for non-periodic splines and `n\_knots \- 1` for periodic ones. If `include\_bias=False`, then it is only `n\_features \* (n\_splines \- 1)`.
   */
  get n_features_out_() {
    if (this._isDisposed) {
      throw new Error(
        "This SplineTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SplineTransformer must call init() before accessing n_features_out_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SplineTransformer_n_features_out_ = bridgeSplineTransformer[${this.id}].n_features_out_`;
      return this._py`attr_SplineTransformer_n_features_out_.tolist() if hasattr(attr_SplineTransformer_n_features_out_, 'tolist') else attr_SplineTransformer_n_features_out_`;
    })();
  }
};

// src/generated/preprocessing/StandardScaler.ts
import crypto242 from "node:crypto";
var StandardScaler = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `StandardScaler${crypto242.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("StandardScaler.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import StandardScaler
try: bridgeStandardScaler
except NameError: bridgeStandardScaler = {}
`;
    await this._py.ex`ctor_StandardScaler = {'copy': ${this.opts["copy"] ?? void 0}, 'with_mean': ${this.opts["with_mean"] ?? void 0}, 'with_std': ${this.opts["with_std"] ?? void 0}}

ctor_StandardScaler = {k: v for k, v in ctor_StandardScaler.items() if v is not None}`;
    await this._py.ex`bridgeStandardScaler[${this.id}] = StandardScaler(**ctor_StandardScaler)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeStandardScaler[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the mean and std to be used for later scaling.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before fit()");
    }
    await this._py.ex`pms_StandardScaler_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StandardScaler_fit = {k: v for k, v in pms_StandardScaler_fit.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_fit = bridgeStandardScaler[${this.id}].fit(**pms_StandardScaler_fit)`;
    return this._py`res_StandardScaler_fit.tolist() if hasattr(res_StandardScaler_fit, 'tolist') else res_StandardScaler_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before fit_transform()");
    }
    await this._py.ex`pms_StandardScaler_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_StandardScaler_fit_transform = {k: v for k, v in pms_StandardScaler_fit_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_fit_transform = bridgeStandardScaler[${this.id}].fit_transform(**pms_StandardScaler_fit_transform)`;
    return this._py`res_StandardScaler_fit_transform.tolist() if hasattr(res_StandardScaler_fit_transform, 'tolist') else res_StandardScaler_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_StandardScaler_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_StandardScaler_get_feature_names_out = {k: v for k, v in pms_StandardScaler_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_get_feature_names_out = bridgeStandardScaler[${this.id}].get_feature_names_out(**pms_StandardScaler_get_feature_names_out)`;
    return this._py`res_StandardScaler_get_feature_names_out.tolist() if hasattr(res_StandardScaler_get_feature_names_out, 'tolist') else res_StandardScaler_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_StandardScaler_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_StandardScaler_get_metadata_routing = {k: v for k, v in pms_StandardScaler_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_get_metadata_routing = bridgeStandardScaler[${this.id}].get_metadata_routing(**pms_StandardScaler_get_metadata_routing)`;
    return this._py`res_StandardScaler_get_metadata_routing.tolist() if hasattr(res_StandardScaler_get_metadata_routing, 'tolist') else res_StandardScaler_get_metadata_routing`;
  }
  /**
    Scale back the data to the original representation.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_StandardScaler_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_inverse_transform = {k: v for k, v in pms_StandardScaler_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_inverse_transform = bridgeStandardScaler[${this.id}].inverse_transform(**pms_StandardScaler_inverse_transform)`;
    return this._py`res_StandardScaler_inverse_transform.tolist() if hasattr(res_StandardScaler_inverse_transform, 'tolist') else res_StandardScaler_inverse_transform`;
  }
  /**
      Online computation of mean and std on X for later scaling.
  
      All of X is processed as a single batch. This is intended for cases when [`fit`](#sklearn.preprocessing.StandardScaler.fit "sklearn.preprocessing.StandardScaler.fit") is not feasible due to very large number of `n\_samples` or because X is read from a continuous stream.
  
      The algorithm for incremental mean and std is given in Equation 1.5a,b in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. â€œAlgorithms for computing the sample variance: Analysis and recommendations.â€ The American Statistician 37.3 (1983): 242-247:
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before partial_fit()");
    }
    await this._py.ex`pms_StandardScaler_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_StandardScaler_partial_fit = {k: v for k, v in pms_StandardScaler_partial_fit.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_partial_fit = bridgeStandardScaler[${this.id}].partial_fit(**pms_StandardScaler_partial_fit)`;
    return this._py`res_StandardScaler_partial_fit.tolist() if hasattr(res_StandardScaler_partial_fit, 'tolist') else res_StandardScaler_partial_fit`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StandardScaler_set_fit_request = {k: v for k, v in pms_StandardScaler_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_fit_request = bridgeStandardScaler[${this.id}].set_fit_request(**pms_StandardScaler_set_fit_request)`;
    return this._py`res_StandardScaler_set_fit_request.tolist() if hasattr(res_StandardScaler_set_fit_request, 'tolist') else res_StandardScaler_set_fit_request`;
  }
  /**
      Request metadata passed to the `inverse\_transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_inverse_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_set_inverse_transform_request = {k: v for k, v in pms_StandardScaler_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_inverse_transform_request = bridgeStandardScaler[${this.id}].set_inverse_transform_request(**pms_StandardScaler_set_inverse_transform_request)`;
    return this._py`res_StandardScaler_set_inverse_transform_request.tolist() if hasattr(res_StandardScaler_set_inverse_transform_request, 'tolist') else res_StandardScaler_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before set_output()");
    }
    await this._py.ex`pms_StandardScaler_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_StandardScaler_set_output = {k: v for k, v in pms_StandardScaler_set_output.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_output = bridgeStandardScaler[${this.id}].set_output(**pms_StandardScaler_set_output)`;
    return this._py`res_StandardScaler_set_output.tolist() if hasattr(res_StandardScaler_set_output, 'tolist') else res_StandardScaler_set_output`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_StandardScaler_set_partial_fit_request = {k: v for k, v in pms_StandardScaler_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_partial_fit_request = bridgeStandardScaler[${this.id}].set_partial_fit_request(**pms_StandardScaler_set_partial_fit_request)`;
    return this._py`res_StandardScaler_set_partial_fit_request.tolist() if hasattr(res_StandardScaler_set_partial_fit_request, 'tolist') else res_StandardScaler_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_StandardScaler_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_set_transform_request = {k: v for k, v in pms_StandardScaler_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_set_transform_request = bridgeStandardScaler[${this.id}].set_transform_request(**pms_StandardScaler_set_transform_request)`;
    return this._py`res_StandardScaler_set_transform_request.tolist() if hasattr(res_StandardScaler_set_transform_request, 'tolist') else res_StandardScaler_set_transform_request`;
  }
  /**
    Perform standardization by centering and scaling.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before transform()");
    }
    await this._py.ex`pms_StandardScaler_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_StandardScaler_transform = {k: v for k, v in pms_StandardScaler_transform.items() if v is not None}`;
    await this._py.ex`res_StandardScaler_transform = bridgeStandardScaler[${this.id}].transform(**pms_StandardScaler_transform)`;
    return this._py`res_StandardScaler_transform.tolist() if hasattr(res_StandardScaler_transform, 'tolist') else res_StandardScaler_transform`;
  }
  /**
    Per feature relative scaling of the data to achieve zero mean and unit variance. Generally this is calculated using `np.sqrt(var\_)`. If a variance is zero, we canâ€™t achieve unit variance, and the data is left as-is, giving a scaling factor of 1. `scale\_` is equal to `undefined` when `with\_std=False`.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_scale_ = bridgeStandardScaler[${this.id}].scale_`;
      return this._py`attr_StandardScaler_scale_.tolist() if hasattr(attr_StandardScaler_scale_, 'tolist') else attr_StandardScaler_scale_`;
    })();
  }
  /**
    The mean value for each feature in the training set. Equal to `undefined` when `with\_mean=False` and `with\_std=False`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_mean_ = bridgeStandardScaler[${this.id}].mean_`;
      return this._py`attr_StandardScaler_mean_.tolist() if hasattr(attr_StandardScaler_mean_, 'tolist') else attr_StandardScaler_mean_`;
    })();
  }
  /**
    The variance for each feature in the training set. Used to compute `scale\_`. Equal to `undefined` when `with\_mean=False` and `with\_std=False`.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("StandardScaler must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_var_ = bridgeStandardScaler[${this.id}].var_`;
      return this._py`attr_StandardScaler_var_.tolist() if hasattr(attr_StandardScaler_var_, 'tolist') else attr_StandardScaler_var_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_n_features_in_ = bridgeStandardScaler[${this.id}].n_features_in_`;
      return this._py`attr_StandardScaler_n_features_in_.tolist() if hasattr(attr_StandardScaler_n_features_in_, 'tolist') else attr_StandardScaler_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_feature_names_in_ = bridgeStandardScaler[${this.id}].feature_names_in_`;
      return this._py`attr_StandardScaler_feature_names_in_.tolist() if hasattr(attr_StandardScaler_feature_names_in_, 'tolist') else attr_StandardScaler_feature_names_in_`;
    })();
  }
  /**
    The number of samples processed by the estimator for each feature. If there are no missing samples, the `n\_samples\_seen` will be an integer, otherwise it will be an array of dtype int. If `sample\_weights` are used it will be a float (if no missing data) or an array of dtype float that sums the weights seen so far. Will be reset on new calls to fit, but increments across `partial\_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This StandardScaler instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "StandardScaler must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_StandardScaler_n_samples_seen_ = bridgeStandardScaler[${this.id}].n_samples_seen_`;
      return this._py`attr_StandardScaler_n_samples_seen_.tolist() if hasattr(attr_StandardScaler_n_samples_seen_, 'tolist') else attr_StandardScaler_n_samples_seen_`;
    })();
  }
};

// src/generated/preprocessing/TargetEncoder.ts
import crypto243 from "node:crypto";
var TargetEncoder = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TargetEncoder${crypto243.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TargetEncoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.preprocessing import TargetEncoder
try: bridgeTargetEncoder
except NameError: bridgeTargetEncoder = {}
`;
    await this._py.ex`ctor_TargetEncoder = {'categories': np.array(${this.opts["categories"] ?? void 0}) if ${this.opts["categories"] !== void 0} else None, 'target_type': ${this.opts["target_type"] ?? void 0}, 'smooth': ${this.opts["smooth"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_TargetEncoder = {k: v for k, v in ctor_TargetEncoder.items() if v is not None}`;
    await this._py.ex`bridgeTargetEncoder[${this.id}] = TargetEncoder(**ctor_TargetEncoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTargetEncoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") to X and y.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before fit()");
    }
    await this._py.ex`pms_TargetEncoder_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TargetEncoder_fit = {k: v for k, v in pms_TargetEncoder_fit.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_fit = bridgeTargetEncoder[${this.id}].fit(**pms_TargetEncoder_fit)`;
    return this._py`res_TargetEncoder_fit.tolist() if hasattr(res_TargetEncoder_fit, 'tolist') else res_TargetEncoder_fit`;
  }
  /**
    Fit [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") and transform X with the target encoding.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_TargetEncoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TargetEncoder_fit_transform = {k: v for k, v in pms_TargetEncoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_fit_transform = bridgeTargetEncoder[${this.id}].fit_transform(**pms_TargetEncoder_fit_transform)`;
    return this._py`res_TargetEncoder_fit_transform.tolist() if hasattr(res_TargetEncoder_fit_transform, 'tolist') else res_TargetEncoder_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TargetEncoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TargetEncoder_get_feature_names_out = {k: v for k, v in pms_TargetEncoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_get_feature_names_out = bridgeTargetEncoder[${this.id}].get_feature_names_out(**pms_TargetEncoder_get_feature_names_out)`;
    return this._py`res_TargetEncoder_get_feature_names_out.tolist() if hasattr(res_TargetEncoder_get_feature_names_out, 'tolist') else res_TargetEncoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TargetEncoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TargetEncoder_get_metadata_routing = {k: v for k, v in pms_TargetEncoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_get_metadata_routing = bridgeTargetEncoder[${this.id}].get_metadata_routing(**pms_TargetEncoder_get_metadata_routing)`;
    return this._py`res_TargetEncoder_get_metadata_routing.tolist() if hasattr(res_TargetEncoder_get_metadata_routing, 'tolist') else res_TargetEncoder_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before set_output()");
    }
    await this._py.ex`pms_TargetEncoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TargetEncoder_set_output = {k: v for k, v in pms_TargetEncoder_set_output.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_set_output = bridgeTargetEncoder[${this.id}].set_output(**pms_TargetEncoder_set_output)`;
    return this._py`res_TargetEncoder_set_output.tolist() if hasattr(res_TargetEncoder_set_output, 'tolist') else res_TargetEncoder_set_output`;
  }
  /**
    Transform X with the target encoding.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TargetEncoder must call init() before transform()");
    }
    await this._py.ex`pms_TargetEncoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TargetEncoder_transform = {k: v for k, v in pms_TargetEncoder_transform.items() if v is not None}`;
    await this._py.ex`res_TargetEncoder_transform = bridgeTargetEncoder[${this.id}].transform(**pms_TargetEncoder_transform)`;
    return this._py`res_TargetEncoder_transform.tolist() if hasattr(res_TargetEncoder_transform, 'tolist') else res_TargetEncoder_transform`;
  }
  /**
    Encodings learnt on all of `X`. For feature `i`, `encodings\_\[i\]` are the encodings matching the categories listed in `categories\_\[i\]`.
   */
  get encodings_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing encodings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_encodings_ = bridgeTargetEncoder[${this.id}].encodings_`;
      return this._py`attr_TargetEncoder_encodings_.tolist() if hasattr(attr_TargetEncoder_encodings_, 'tolist') else attr_TargetEncoder_encodings_`;
    })();
  }
  /**
    The categories of each feature determined during fitting or specified in `categories` (in order of the features in `X` and corresponding with the output of [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform")).
   */
  get categories_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing categories_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_categories_ = bridgeTargetEncoder[${this.id}].categories_`;
      return this._py`attr_TargetEncoder_categories_.tolist() if hasattr(attr_TargetEncoder_categories_, 'tolist') else attr_TargetEncoder_categories_`;
    })();
  }
  /**
    Type of target.
   */
  get target_type_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing target_type_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_target_type_ = bridgeTargetEncoder[${this.id}].target_type_`;
      return this._py`attr_TargetEncoder_target_type_.tolist() if hasattr(attr_TargetEncoder_target_type_, 'tolist') else attr_TargetEncoder_target_type_`;
    })();
  }
  /**
    The overall mean of the target. This value is only used in [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform") to encode categories.
   */
  get target_mean_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing target_mean_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_target_mean_ = bridgeTargetEncoder[${this.id}].target_mean_`;
      return this._py`attr_TargetEncoder_target_mean_.tolist() if hasattr(attr_TargetEncoder_target_mean_, 'tolist') else attr_TargetEncoder_target_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_n_features_in_ = bridgeTargetEncoder[${this.id}].n_features_in_`;
      return this._py`attr_TargetEncoder_n_features_in_.tolist() if hasattr(attr_TargetEncoder_n_features_in_, 'tolist') else attr_TargetEncoder_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TargetEncoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TargetEncoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TargetEncoder_feature_names_in_ = bridgeTargetEncoder[${this.id}].feature_names_in_`;
      return this._py`attr_TargetEncoder_feature_names_in_.tolist() if hasattr(attr_TargetEncoder_feature_names_in_, 'tolist') else attr_TargetEncoder_feature_names_in_`;
    })();
  }
};

// src/generated/random_projection/GaussianRandomProjection.ts
import crypto244 from "node:crypto";
var GaussianRandomProjection = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianRandomProjection${crypto244.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianRandomProjection.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.random_projection import GaussianRandomProjection
try: bridgeGaussianRandomProjection
except NameError: bridgeGaussianRandomProjection = {}
`;
    await this._py.ex`ctor_GaussianRandomProjection = {'n_components': ${this.opts["n_components"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'compute_inverse_components': ${this.opts["compute_inverse_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_GaussianRandomProjection = {k: v for k, v in ctor_GaussianRandomProjection.items() if v is not None}`;
    await this._py.ex`bridgeGaussianRandomProjection[${this.id}] = GaussianRandomProjection(**ctor_GaussianRandomProjection)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianRandomProjection[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Generate a sparse random projection matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianRandomProjection must call init() before fit()");
    }
    await this._py.ex`pms_GaussianRandomProjection_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianRandomProjection_fit = {k: v for k, v in pms_GaussianRandomProjection_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_fit = bridgeGaussianRandomProjection[${this.id}].fit(**pms_GaussianRandomProjection_fit)`;
    return this._py`res_GaussianRandomProjection_fit.tolist() if hasattr(res_GaussianRandomProjection_fit, 'tolist') else res_GaussianRandomProjection_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_GaussianRandomProjection_fit_transform = {k: v for k, v in pms_GaussianRandomProjection_fit_transform.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_fit_transform = bridgeGaussianRandomProjection[${this.id}].fit_transform(**pms_GaussianRandomProjection_fit_transform)`;
    return this._py`res_GaussianRandomProjection_fit_transform.tolist() if hasattr(res_GaussianRandomProjection_fit_transform, 'tolist') else res_GaussianRandomProjection_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_GaussianRandomProjection_get_feature_names_out = {k: v for k, v in pms_GaussianRandomProjection_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_get_feature_names_out = bridgeGaussianRandomProjection[${this.id}].get_feature_names_out(**pms_GaussianRandomProjection_get_feature_names_out)`;
    return this._py`res_GaussianRandomProjection_get_feature_names_out.tolist() if hasattr(res_GaussianRandomProjection_get_feature_names_out, 'tolist') else res_GaussianRandomProjection_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GaussianRandomProjection_get_metadata_routing = {k: v for k, v in pms_GaussianRandomProjection_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_get_metadata_routing = bridgeGaussianRandomProjection[${this.id}].get_metadata_routing(**pms_GaussianRandomProjection_get_metadata_routing)`;
    return this._py`res_GaussianRandomProjection_get_metadata_routing.tolist() if hasattr(res_GaussianRandomProjection_get_metadata_routing, 'tolist') else res_GaussianRandomProjection_get_metadata_routing`;
  }
  /**
      Project data back to its original space.
  
      Returns an array X\_original whose transform would be X. Note that even if X is sparse, X\_original is dense: this may use a lot of RAM.
  
      If `compute\_inverse\_components` is `false`, the inverse of the components is computed during each call to `inverse\_transform` which can be costly.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianRandomProjection_inverse_transform = {k: v for k, v in pms_GaussianRandomProjection_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_inverse_transform = bridgeGaussianRandomProjection[${this.id}].inverse_transform(**pms_GaussianRandomProjection_inverse_transform)`;
    return this._py`res_GaussianRandomProjection_inverse_transform.tolist() if hasattr(res_GaussianRandomProjection_inverse_transform, 'tolist') else res_GaussianRandomProjection_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before set_output()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_GaussianRandomProjection_set_output = {k: v for k, v in pms_GaussianRandomProjection_set_output.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_set_output = bridgeGaussianRandomProjection[${this.id}].set_output(**pms_GaussianRandomProjection_set_output)`;
    return this._py`res_GaussianRandomProjection_set_output.tolist() if hasattr(res_GaussianRandomProjection_set_output, 'tolist') else res_GaussianRandomProjection_set_output`;
  }
  /**
    Project the data by using matrix product with the random matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before transform()"
      );
    }
    await this._py.ex`pms_GaussianRandomProjection_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianRandomProjection_transform = {k: v for k, v in pms_GaussianRandomProjection_transform.items() if v is not None}`;
    await this._py.ex`res_GaussianRandomProjection_transform = bridgeGaussianRandomProjection[${this.id}].transform(**pms_GaussianRandomProjection_transform)`;
    return this._py`res_GaussianRandomProjection_transform.tolist() if hasattr(res_GaussianRandomProjection_transform, 'tolist') else res_GaussianRandomProjection_transform`;
  }
  /**
    Concrete number of components computed when n\_components=â€autoâ€.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianRandomProjection_n_components_ = bridgeGaussianRandomProjection[${this.id}].n_components_`;
      return this._py`attr_GaussianRandomProjection_n_components_.tolist() if hasattr(attr_GaussianRandomProjection_n_components_, 'tolist') else attr_GaussianRandomProjection_n_components_`;
    })();
  }
  /**
    Random matrix used for the projection.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianRandomProjection_components_ = bridgeGaussianRandomProjection[${this.id}].components_`;
      return this._py`attr_GaussianRandomProjection_components_.tolist() if hasattr(attr_GaussianRandomProjection_components_, 'tolist') else attr_GaussianRandomProjection_components_`;
    })();
  }
  /**
    Pseudo-inverse of the components, only computed if `compute\_inverse\_components` is `true`.
   */
  get inverse_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before accessing inverse_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianRandomProjection_inverse_components_ = bridgeGaussianRandomProjection[${this.id}].inverse_components_`;
      return this._py`attr_GaussianRandomProjection_inverse_components_.tolist() if hasattr(attr_GaussianRandomProjection_inverse_components_, 'tolist') else attr_GaussianRandomProjection_inverse_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianRandomProjection_n_features_in_ = bridgeGaussianRandomProjection[${this.id}].n_features_in_`;
      return this._py`attr_GaussianRandomProjection_n_features_in_.tolist() if hasattr(attr_GaussianRandomProjection_n_features_in_, 'tolist') else attr_GaussianRandomProjection_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianRandomProjection must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianRandomProjection_feature_names_in_ = bridgeGaussianRandomProjection[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianRandomProjection_feature_names_in_.tolist() if hasattr(attr_GaussianRandomProjection_feature_names_in_, 'tolist') else attr_GaussianRandomProjection_feature_names_in_`;
    })();
  }
};

// src/generated/random_projection/SparseRandomProjection.ts
import crypto245 from "node:crypto";
var SparseRandomProjection = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SparseRandomProjection${crypto245.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SparseRandomProjection.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.random_projection import SparseRandomProjection
try: bridgeSparseRandomProjection
except NameError: bridgeSparseRandomProjection = {}
`;
    await this._py.ex`ctor_SparseRandomProjection = {'n_components': ${this.opts["n_components"] ?? void 0}, 'density': ${this.opts["density"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'dense_output': ${this.opts["dense_output"] ?? void 0}, 'compute_inverse_components': ${this.opts["compute_inverse_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SparseRandomProjection = {k: v for k, v in ctor_SparseRandomProjection.items() if v is not None}`;
    await this._py.ex`bridgeSparseRandomProjection[${this.id}] = SparseRandomProjection(**ctor_SparseRandomProjection)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparseRandomProjection[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Generate a sparse random projection matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SparseRandomProjection must call init() before fit()");
    }
    await this._py.ex`pms_SparseRandomProjection_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparseRandomProjection_fit = {k: v for k, v in pms_SparseRandomProjection_fit.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_fit = bridgeSparseRandomProjection[${this.id}].fit(**pms_SparseRandomProjection_fit)`;
    return this._py`res_SparseRandomProjection_fit.tolist() if hasattr(res_SparseRandomProjection_fit, 'tolist') else res_SparseRandomProjection_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparseRandomProjection_fit_transform = {k: v for k, v in pms_SparseRandomProjection_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_fit_transform = bridgeSparseRandomProjection[${this.id}].fit_transform(**pms_SparseRandomProjection_fit_transform)`;
    return this._py`res_SparseRandomProjection_fit_transform.tolist() if hasattr(res_SparseRandomProjection_fit_transform, 'tolist') else res_SparseRandomProjection_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparseRandomProjection_get_feature_names_out = {k: v for k, v in pms_SparseRandomProjection_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_get_feature_names_out = bridgeSparseRandomProjection[${this.id}].get_feature_names_out(**pms_SparseRandomProjection_get_feature_names_out)`;
    return this._py`res_SparseRandomProjection_get_feature_names_out.tolist() if hasattr(res_SparseRandomProjection_get_feature_names_out, 'tolist') else res_SparseRandomProjection_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparseRandomProjection_get_metadata_routing = {k: v for k, v in pms_SparseRandomProjection_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_get_metadata_routing = bridgeSparseRandomProjection[${this.id}].get_metadata_routing(**pms_SparseRandomProjection_get_metadata_routing)`;
    return this._py`res_SparseRandomProjection_get_metadata_routing.tolist() if hasattr(res_SparseRandomProjection_get_metadata_routing, 'tolist') else res_SparseRandomProjection_get_metadata_routing`;
  }
  /**
      Project data back to its original space.
  
      Returns an array X\_original whose transform would be X. Note that even if X is sparse, X\_original is dense: this may use a lot of RAM.
  
      If `compute\_inverse\_components` is `false`, the inverse of the components is computed during each call to `inverse\_transform` which can be costly.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparseRandomProjection_inverse_transform = {k: v for k, v in pms_SparseRandomProjection_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_inverse_transform = bridgeSparseRandomProjection[${this.id}].inverse_transform(**pms_SparseRandomProjection_inverse_transform)`;
    return this._py`res_SparseRandomProjection_inverse_transform.tolist() if hasattr(res_SparseRandomProjection_inverse_transform, 'tolist') else res_SparseRandomProjection_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before set_output()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparseRandomProjection_set_output = {k: v for k, v in pms_SparseRandomProjection_set_output.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_set_output = bridgeSparseRandomProjection[${this.id}].set_output(**pms_SparseRandomProjection_set_output)`;
    return this._py`res_SparseRandomProjection_set_output.tolist() if hasattr(res_SparseRandomProjection_set_output, 'tolist') else res_SparseRandomProjection_set_output`;
  }
  /**
    Project the data by using matrix product with the random matrix.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before transform()"
      );
    }
    await this._py.ex`pms_SparseRandomProjection_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparseRandomProjection_transform = {k: v for k, v in pms_SparseRandomProjection_transform.items() if v is not None}`;
    await this._py.ex`res_SparseRandomProjection_transform = bridgeSparseRandomProjection[${this.id}].transform(**pms_SparseRandomProjection_transform)`;
    return this._py`res_SparseRandomProjection_transform.tolist() if hasattr(res_SparseRandomProjection_transform, 'tolist') else res_SparseRandomProjection_transform`;
  }
  /**
    Concrete number of components computed when n\_components=â€autoâ€.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_n_components_ = bridgeSparseRandomProjection[${this.id}].n_components_`;
      return this._py`attr_SparseRandomProjection_n_components_.tolist() if hasattr(attr_SparseRandomProjection_n_components_, 'tolist') else attr_SparseRandomProjection_n_components_`;
    })();
  }
  /**
    Random matrix used for the projection. Sparse matrix will be of CSR format.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_components_ = bridgeSparseRandomProjection[${this.id}].components_`;
      return this._py`attr_SparseRandomProjection_components_.tolist() if hasattr(attr_SparseRandomProjection_components_, 'tolist') else attr_SparseRandomProjection_components_`;
    })();
  }
  /**
    Pseudo-inverse of the components, only computed if `compute\_inverse\_components` is `true`.
   */
  get inverse_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing inverse_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_inverse_components_ = bridgeSparseRandomProjection[${this.id}].inverse_components_`;
      return this._py`attr_SparseRandomProjection_inverse_components_.tolist() if hasattr(attr_SparseRandomProjection_inverse_components_, 'tolist') else attr_SparseRandomProjection_inverse_components_`;
    })();
  }
  /**
    Concrete density computed from when density = â€œautoâ€.
   */
  get density_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing density_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_density_ = bridgeSparseRandomProjection[${this.id}].density_`;
      return this._py`attr_SparseRandomProjection_density_.tolist() if hasattr(attr_SparseRandomProjection_density_, 'tolist') else attr_SparseRandomProjection_density_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_n_features_in_ = bridgeSparseRandomProjection[${this.id}].n_features_in_`;
      return this._py`attr_SparseRandomProjection_n_features_in_.tolist() if hasattr(attr_SparseRandomProjection_n_features_in_, 'tolist') else attr_SparseRandomProjection_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SparseRandomProjection instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseRandomProjection must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseRandomProjection_feature_names_in_ = bridgeSparseRandomProjection[${this.id}].feature_names_in_`;
      return this._py`attr_SparseRandomProjection_feature_names_in_.tolist() if hasattr(attr_SparseRandomProjection_feature_names_in_, 'tolist') else attr_SparseRandomProjection_feature_names_in_`;
    })();
  }
};

// src/generated/semi_supervised/LabelPropagation.ts
import crypto246 from "node:crypto";
var LabelPropagation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelPropagation${crypto246.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelPropagation.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.semi_supervised import LabelPropagation
try: bridgeLabelPropagation
except NameError: bridgeLabelPropagation = {}
`;
    await this._py.ex`ctor_LabelPropagation = {'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_LabelPropagation = {k: v for k, v in ctor_LabelPropagation.items() if v is not None}`;
    await this._py.ex`bridgeLabelPropagation[${this.id}] = LabelPropagation(**ctor_LabelPropagation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelPropagation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a semi-supervised label propagation model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LabelPropagation must call init() before fit()");
    }
    await this._py.ex`pms_LabelPropagation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelPropagation_fit = {k: v for k, v in pms_LabelPropagation_fit.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_fit = bridgeLabelPropagation[${this.id}].fit(**pms_LabelPropagation_fit)`;
    return this._py`res_LabelPropagation_fit.tolist() if hasattr(res_LabelPropagation_fit, 'tolist') else res_LabelPropagation_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelPropagation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelPropagation_get_metadata_routing = {k: v for k, v in pms_LabelPropagation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_get_metadata_routing = bridgeLabelPropagation[${this.id}].get_metadata_routing(**pms_LabelPropagation_get_metadata_routing)`;
    return this._py`res_LabelPropagation_get_metadata_routing.tolist() if hasattr(res_LabelPropagation_get_metadata_routing, 'tolist') else res_LabelPropagation_get_metadata_routing`;
  }
  /**
    Perform inductive inference across the model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LabelPropagation must call init() before predict()");
    }
    await this._py.ex`pms_LabelPropagation_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LabelPropagation_predict = {k: v for k, v in pms_LabelPropagation_predict.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_predict = bridgeLabelPropagation[${this.id}].predict(**pms_LabelPropagation_predict)`;
    return this._py`res_LabelPropagation_predict.tolist() if hasattr(res_LabelPropagation_predict, 'tolist') else res_LabelPropagation_predict`;
  }
  /**
      Predict probability for each possible outcome.
  
      Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LabelPropagation_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LabelPropagation_predict_proba = {k: v for k, v in pms_LabelPropagation_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_predict_proba = bridgeLabelPropagation[${this.id}].predict_proba(**pms_LabelPropagation_predict_proba)`;
    return this._py`res_LabelPropagation_predict_proba.tolist() if hasattr(res_LabelPropagation_predict_proba, 'tolist') else res_LabelPropagation_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LabelPropagation must call init() before score()");
    }
    await this._py.ex`pms_LabelPropagation_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LabelPropagation_score = {k: v for k, v in pms_LabelPropagation_score.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_score = bridgeLabelPropagation[${this.id}].score(**pms_LabelPropagation_score)`;
    return this._py`res_LabelPropagation_score.tolist() if hasattr(res_LabelPropagation_score, 'tolist') else res_LabelPropagation_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LabelPropagation_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LabelPropagation_set_score_request = {k: v for k, v in pms_LabelPropagation_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LabelPropagation_set_score_request = bridgeLabelPropagation[${this.id}].set_score_request(**pms_LabelPropagation_set_score_request)`;
    return this._py`res_LabelPropagation_set_score_request.tolist() if hasattr(res_LabelPropagation_set_score_request, 'tolist') else res_LabelPropagation_set_score_request`;
  }
  /**
    Input array.
   */
  get X_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LabelPropagation must call init() before accessing X_");
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_X_ = bridgeLabelPropagation[${this.id}].X_`;
      return this._py`attr_LabelPropagation_X_.tolist() if hasattr(attr_LabelPropagation_X_, 'tolist') else attr_LabelPropagation_X_`;
    })();
  }
  /**
    The distinct labels used in classifying instances.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_classes_ = bridgeLabelPropagation[${this.id}].classes_`;
      return this._py`attr_LabelPropagation_classes_.tolist() if hasattr(attr_LabelPropagation_classes_, 'tolist') else attr_LabelPropagation_classes_`;
    })();
  }
  /**
    Categorical distribution for each item.
   */
  get label_distributions_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing label_distributions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_label_distributions_ = bridgeLabelPropagation[${this.id}].label_distributions_`;
      return this._py`attr_LabelPropagation_label_distributions_.tolist() if hasattr(attr_LabelPropagation_label_distributions_, 'tolist') else attr_LabelPropagation_label_distributions_`;
    })();
  }
  /**
    Label assigned to each item during [fit](../../glossary.html#term-fit).
   */
  get transduction_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing transduction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_transduction_ = bridgeLabelPropagation[${this.id}].transduction_`;
      return this._py`attr_LabelPropagation_transduction_.tolist() if hasattr(attr_LabelPropagation_transduction_, 'tolist') else attr_LabelPropagation_transduction_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_n_features_in_ = bridgeLabelPropagation[${this.id}].n_features_in_`;
      return this._py`attr_LabelPropagation_n_features_in_.tolist() if hasattr(attr_LabelPropagation_n_features_in_, 'tolist') else attr_LabelPropagation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_feature_names_in_ = bridgeLabelPropagation[${this.id}].feature_names_in_`;
      return this._py`attr_LabelPropagation_feature_names_in_.tolist() if hasattr(attr_LabelPropagation_feature_names_in_, 'tolist') else attr_LabelPropagation_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LabelPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelPropagation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelPropagation_n_iter_ = bridgeLabelPropagation[${this.id}].n_iter_`;
      return this._py`attr_LabelPropagation_n_iter_.tolist() if hasattr(attr_LabelPropagation_n_iter_, 'tolist') else attr_LabelPropagation_n_iter_`;
    })();
  }
};

// src/generated/semi_supervised/LabelSpreading.ts
import crypto247 from "node:crypto";
var LabelSpreading = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LabelSpreading${crypto247.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LabelSpreading.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.semi_supervised import LabelSpreading
try: bridgeLabelSpreading
except NameError: bridgeLabelSpreading = {}
`;
    await this._py.ex`ctor_LabelSpreading = {'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_LabelSpreading = {k: v for k, v in ctor_LabelSpreading.items() if v is not None}`;
    await this._py.ex`bridgeLabelSpreading[${this.id}] = LabelSpreading(**ctor_LabelSpreading)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLabelSpreading[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit a semi-supervised label propagation model to X.
  
      The input samples (labeled and unlabeled) are provided by matrix X, and target labels are provided by matrix y. We conventionally apply the label -1 to unlabeled samples in matrix y in a semi-supervised classification.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelSpreading must call init() before fit()");
    }
    await this._py.ex`pms_LabelSpreading_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LabelSpreading_fit = {k: v for k, v in pms_LabelSpreading_fit.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_fit = bridgeLabelSpreading[${this.id}].fit(**pms_LabelSpreading_fit)`;
    return this._py`res_LabelSpreading_fit.tolist() if hasattr(res_LabelSpreading_fit, 'tolist') else res_LabelSpreading_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LabelSpreading_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LabelSpreading_get_metadata_routing = {k: v for k, v in pms_LabelSpreading_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_get_metadata_routing = bridgeLabelSpreading[${this.id}].get_metadata_routing(**pms_LabelSpreading_get_metadata_routing)`;
    return this._py`res_LabelSpreading_get_metadata_routing.tolist() if hasattr(res_LabelSpreading_get_metadata_routing, 'tolist') else res_LabelSpreading_get_metadata_routing`;
  }
  /**
    Perform inductive inference across the model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelSpreading must call init() before predict()");
    }
    await this._py.ex`pms_LabelSpreading_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LabelSpreading_predict = {k: v for k, v in pms_LabelSpreading_predict.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_predict = bridgeLabelSpreading[${this.id}].predict(**pms_LabelSpreading_predict)`;
    return this._py`res_LabelSpreading_predict.tolist() if hasattr(res_LabelSpreading_predict, 'tolist') else res_LabelSpreading_predict`;
  }
  /**
      Predict probability for each possible outcome.
  
      Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelSpreading must call init() before predict_proba()");
    }
    await this._py.ex`pms_LabelSpreading_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LabelSpreading_predict_proba = {k: v for k, v in pms_LabelSpreading_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_predict_proba = bridgeLabelSpreading[${this.id}].predict_proba(**pms_LabelSpreading_predict_proba)`;
    return this._py`res_LabelSpreading_predict_proba.tolist() if hasattr(res_LabelSpreading_predict_proba, 'tolist') else res_LabelSpreading_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelSpreading must call init() before score()");
    }
    await this._py.ex`pms_LabelSpreading_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LabelSpreading_score = {k: v for k, v in pms_LabelSpreading_score.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_score = bridgeLabelSpreading[${this.id}].score(**pms_LabelSpreading_score)`;
    return this._py`res_LabelSpreading_score.tolist() if hasattr(res_LabelSpreading_score, 'tolist') else res_LabelSpreading_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LabelSpreading_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LabelSpreading_set_score_request = {k: v for k, v in pms_LabelSpreading_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LabelSpreading_set_score_request = bridgeLabelSpreading[${this.id}].set_score_request(**pms_LabelSpreading_set_score_request)`;
    return this._py`res_LabelSpreading_set_score_request.tolist() if hasattr(res_LabelSpreading_set_score_request, 'tolist') else res_LabelSpreading_set_score_request`;
  }
  /**
    Input array.
   */
  get X_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LabelSpreading must call init() before accessing X_");
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_X_ = bridgeLabelSpreading[${this.id}].X_`;
      return this._py`attr_LabelSpreading_X_.tolist() if hasattr(attr_LabelSpreading_X_, 'tolist') else attr_LabelSpreading_X_`;
    })();
  }
  /**
    The distinct labels used in classifying instances.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_classes_ = bridgeLabelSpreading[${this.id}].classes_`;
      return this._py`attr_LabelSpreading_classes_.tolist() if hasattr(attr_LabelSpreading_classes_, 'tolist') else attr_LabelSpreading_classes_`;
    })();
  }
  /**
    Categorical distribution for each item.
   */
  get label_distributions_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing label_distributions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_label_distributions_ = bridgeLabelSpreading[${this.id}].label_distributions_`;
      return this._py`attr_LabelSpreading_label_distributions_.tolist() if hasattr(attr_LabelSpreading_label_distributions_, 'tolist') else attr_LabelSpreading_label_distributions_`;
    })();
  }
  /**
    Label assigned to each item during [fit](../../glossary.html#term-fit).
   */
  get transduction_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing transduction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_transduction_ = bridgeLabelSpreading[${this.id}].transduction_`;
      return this._py`attr_LabelSpreading_transduction_.tolist() if hasattr(attr_LabelSpreading_transduction_, 'tolist') else attr_LabelSpreading_transduction_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_n_features_in_ = bridgeLabelSpreading[${this.id}].n_features_in_`;
      return this._py`attr_LabelSpreading_n_features_in_.tolist() if hasattr(attr_LabelSpreading_n_features_in_, 'tolist') else attr_LabelSpreading_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_feature_names_in_ = bridgeLabelSpreading[${this.id}].feature_names_in_`;
      return this._py`attr_LabelSpreading_feature_names_in_.tolist() if hasattr(attr_LabelSpreading_feature_names_in_, 'tolist') else attr_LabelSpreading_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LabelSpreading instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LabelSpreading must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LabelSpreading_n_iter_ = bridgeLabelSpreading[${this.id}].n_iter_`;
      return this._py`attr_LabelSpreading_n_iter_.tolist() if hasattr(attr_LabelSpreading_n_iter_, 'tolist') else attr_LabelSpreading_n_iter_`;
    })();
  }
};

// src/generated/semi_supervised/SelfTrainingClassifier.ts
import crypto248 from "node:crypto";
var SelfTrainingClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SelfTrainingClassifier${crypto248.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SelfTrainingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.semi_supervised import SelfTrainingClassifier
try: bridgeSelfTrainingClassifier
except NameError: bridgeSelfTrainingClassifier = {}
`;
    await this._py.ex`ctor_SelfTrainingClassifier = {'base_estimator': ${this.opts["base_estimator"] ?? void 0}, 'threshold': ${this.opts["threshold"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'k_best': ${this.opts["k_best"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_SelfTrainingClassifier = {k: v for k, v in ctor_SelfTrainingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeSelfTrainingClassifier[${this.id}] = SelfTrainingClassifier(**ctor_SelfTrainingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSelfTrainingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Call decision function of the `base\_estimator`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_SelfTrainingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelfTrainingClassifier_decision_function = {k: v for k, v in pms_SelfTrainingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_decision_function = bridgeSelfTrainingClassifier[${this.id}].decision_function(**pms_SelfTrainingClassifier_decision_function)`;
    return this._py`res_SelfTrainingClassifier_decision_function.tolist() if hasattr(res_SelfTrainingClassifier_decision_function, 'tolist') else res_SelfTrainingClassifier_decision_function`;
  }
  /**
    Fit self-training classifier using `X`, `y` as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelfTrainingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_SelfTrainingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelfTrainingClassifier_fit = {k: v for k, v in pms_SelfTrainingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_fit = bridgeSelfTrainingClassifier[${this.id}].fit(**pms_SelfTrainingClassifier_fit)`;
    return this._py`res_SelfTrainingClassifier_fit.tolist() if hasattr(res_SelfTrainingClassifier_fit, 'tolist') else res_SelfTrainingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SelfTrainingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SelfTrainingClassifier_get_metadata_routing = {k: v for k, v in pms_SelfTrainingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_get_metadata_routing = bridgeSelfTrainingClassifier[${this.id}].get_metadata_routing(**pms_SelfTrainingClassifier_get_metadata_routing)`;
    return this._py`res_SelfTrainingClassifier_get_metadata_routing.tolist() if hasattr(res_SelfTrainingClassifier_get_metadata_routing, 'tolist') else res_SelfTrainingClassifier_get_metadata_routing`;
  }
  /**
    Predict the classes of `X`.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_SelfTrainingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelfTrainingClassifier_predict = {k: v for k, v in pms_SelfTrainingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_predict = bridgeSelfTrainingClassifier[${this.id}].predict(**pms_SelfTrainingClassifier_predict)`;
    return this._py`res_SelfTrainingClassifier_predict.tolist() if hasattr(res_SelfTrainingClassifier_predict, 'tolist') else res_SelfTrainingClassifier_predict`;
  }
  /**
    Predict log probability for each possible outcome.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_SelfTrainingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelfTrainingClassifier_predict_log_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_predict_log_proba = bridgeSelfTrainingClassifier[${this.id}].predict_log_proba(**pms_SelfTrainingClassifier_predict_log_proba)`;
    return this._py`res_SelfTrainingClassifier_predict_log_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_log_proba, 'tolist') else res_SelfTrainingClassifier_predict_log_proba`;
  }
  /**
    Predict probability for each possible outcome.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_SelfTrainingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SelfTrainingClassifier_predict_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_predict_proba = bridgeSelfTrainingClassifier[${this.id}].predict_proba(**pms_SelfTrainingClassifier_predict_proba)`;
    return this._py`res_SelfTrainingClassifier_predict_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_proba, 'tolist') else res_SelfTrainingClassifier_predict_proba`;
  }
  /**
    Call score on the `base\_estimator`.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SelfTrainingClassifier must call init() before score()");
    }
    await this._py.ex`pms_SelfTrainingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_SelfTrainingClassifier_score = {k: v for k, v in pms_SelfTrainingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_SelfTrainingClassifier_score = bridgeSelfTrainingClassifier[${this.id}].score(**pms_SelfTrainingClassifier_score)`;
    return this._py`res_SelfTrainingClassifier_score.tolist() if hasattr(res_SelfTrainingClassifier_score, 'tolist') else res_SelfTrainingClassifier_score`;
  }
  /**
    The fitted estimator.
   */
  get base_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing base_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_base_estimator_ = bridgeSelfTrainingClassifier[${this.id}].base_estimator_`;
      return this._py`attr_SelfTrainingClassifier_base_estimator_.tolist() if hasattr(attr_SelfTrainingClassifier_base_estimator_, 'tolist') else attr_SelfTrainingClassifier_base_estimator_`;
    })();
  }
  /**
    Class labels for each output. (Taken from the trained `base\_estimator\_`).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_classes_ = bridgeSelfTrainingClassifier[${this.id}].classes_`;
      return this._py`attr_SelfTrainingClassifier_classes_.tolist() if hasattr(attr_SelfTrainingClassifier_classes_, 'tolist') else attr_SelfTrainingClassifier_classes_`;
    })();
  }
  /**
    The labels used for the final fit of the classifier, including pseudo-labels added during fit.
   */
  get transduction_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing transduction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_transduction_ = bridgeSelfTrainingClassifier[${this.id}].transduction_`;
      return this._py`attr_SelfTrainingClassifier_transduction_.tolist() if hasattr(attr_SelfTrainingClassifier_transduction_, 'tolist') else attr_SelfTrainingClassifier_transduction_`;
    })();
  }
  /**
    The iteration in which each sample was labeled. When a sample has iteration 0, the sample was already labeled in the original dataset. When a sample has iteration -1, the sample was not labeled in any iteration.
   */
  get labeled_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing labeled_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_labeled_iter_ = bridgeSelfTrainingClassifier[${this.id}].labeled_iter_`;
      return this._py`attr_SelfTrainingClassifier_labeled_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_labeled_iter_, 'tolist') else attr_SelfTrainingClassifier_labeled_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_n_features_in_ = bridgeSelfTrainingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_SelfTrainingClassifier_n_features_in_.tolist() if hasattr(attr_SelfTrainingClassifier_n_features_in_, 'tolist') else attr_SelfTrainingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_feature_names_in_ = bridgeSelfTrainingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_SelfTrainingClassifier_feature_names_in_.tolist() if hasattr(attr_SelfTrainingClassifier_feature_names_in_, 'tolist') else attr_SelfTrainingClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of rounds of self-training, that is the number of times the base estimator is fitted on relabeled variants of the training set.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_n_iter_ = bridgeSelfTrainingClassifier[${this.id}].n_iter_`;
      return this._py`attr_SelfTrainingClassifier_n_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_n_iter_, 'tolist') else attr_SelfTrainingClassifier_n_iter_`;
    })();
  }
  /**
    The reason that fitting was stopped.
   */
  get termination_condition_() {
    if (this._isDisposed) {
      throw new Error(
        "This SelfTrainingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SelfTrainingClassifier must call init() before accessing termination_condition_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SelfTrainingClassifier_termination_condition_ = bridgeSelfTrainingClassifier[${this.id}].termination_condition_`;
      return this._py`attr_SelfTrainingClassifier_termination_condition_.tolist() if hasattr(attr_SelfTrainingClassifier_termination_condition_, 'tolist') else attr_SelfTrainingClassifier_termination_condition_`;
    })();
  }
};

// src/generated/svm/LinearSVC.ts
import crypto249 from "node:crypto";
var LinearSVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearSVC${crypto249.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearSVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import LinearSVC
try: bridgeLinearSVC
except NameError: bridgeLinearSVC = {}
`;
    await this._py.ex`ctor_LinearSVC = {'penalty': ${this.opts["penalty"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_LinearSVC = {k: v for k, v in ctor_LinearSVC.items() if v is not None}`;
    await this._py.ex`bridgeLinearSVC[${this.id}] = LinearSVC(**ctor_LinearSVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before decision_function()");
    }
    await this._py.ex`pms_LinearSVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearSVC_decision_function = {k: v for k, v in pms_LinearSVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_decision_function = bridgeLinearSVC[${this.id}].decision_function(**pms_LinearSVC_decision_function)`;
    return this._py`res_LinearSVC_decision_function.tolist() if hasattr(res_LinearSVC_decision_function, 'tolist') else res_LinearSVC_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before densify()");
    }
    await this._py.ex`pms_LinearSVC_densify = {}

pms_LinearSVC_densify = {k: v for k, v in pms_LinearSVC_densify.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_densify = bridgeLinearSVC[${this.id}].densify(**pms_LinearSVC_densify)`;
    return this._py`res_LinearSVC_densify.tolist() if hasattr(res_LinearSVC_densify, 'tolist') else res_LinearSVC_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before fit()");
    }
    await this._py.ex`pms_LinearSVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVC_fit = {k: v for k, v in pms_LinearSVC_fit.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_fit = bridgeLinearSVC[${this.id}].fit(**pms_LinearSVC_fit)`;
    return this._py`res_LinearSVC_fit.tolist() if hasattr(res_LinearSVC_fit, 'tolist') else res_LinearSVC_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVC must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearSVC_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearSVC_get_metadata_routing = {k: v for k, v in pms_LinearSVC_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_get_metadata_routing = bridgeLinearSVC[${this.id}].get_metadata_routing(**pms_LinearSVC_get_metadata_routing)`;
    return this._py`res_LinearSVC_get_metadata_routing.tolist() if hasattr(res_LinearSVC_get_metadata_routing, 'tolist') else res_LinearSVC_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before predict()");
    }
    await this._py.ex`pms_LinearSVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearSVC_predict = {k: v for k, v in pms_LinearSVC_predict.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_predict = bridgeLinearSVC[${this.id}].predict(**pms_LinearSVC_predict)`;
    return this._py`res_LinearSVC_predict.tolist() if hasattr(res_LinearSVC_predict, 'tolist') else res_LinearSVC_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before score()");
    }
    await this._py.ex`pms_LinearSVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVC_score = {k: v for k, v in pms_LinearSVC_score.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_score = bridgeLinearSVC[${this.id}].score(**pms_LinearSVC_score)`;
    return this._py`res_LinearSVC_score.tolist() if hasattr(res_LinearSVC_score, 'tolist') else res_LinearSVC_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LinearSVC_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearSVC_set_fit_request = {k: v for k, v in pms_LinearSVC_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_set_fit_request = bridgeLinearSVC[${this.id}].set_fit_request(**pms_LinearSVC_set_fit_request)`;
    return this._py`res_LinearSVC_set_fit_request.tolist() if hasattr(res_LinearSVC_set_fit_request, 'tolist') else res_LinearSVC_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before set_score_request()");
    }
    await this._py.ex`pms_LinearSVC_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearSVC_set_score_request = {k: v for k, v in pms_LinearSVC_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_set_score_request = bridgeLinearSVC[${this.id}].set_score_request(**pms_LinearSVC_set_score_request)`;
    return this._py`res_LinearSVC_set_score_request.tolist() if hasattr(res_LinearSVC_set_score_request, 'tolist') else res_LinearSVC_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before sparsify()");
    }
    await this._py.ex`pms_LinearSVC_sparsify = {}

pms_LinearSVC_sparsify = {k: v for k, v in pms_LinearSVC_sparsify.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_sparsify = bridgeLinearSVC[${this.id}].sparsify(**pms_LinearSVC_sparsify)`;
    return this._py`res_LinearSVC_sparsify.tolist() if hasattr(res_LinearSVC_sparsify, 'tolist') else res_LinearSVC_sparsify`;
  }
  /**
      Weights assigned to the features (coefficients in the primal problem).
  
      `coef\_` is a readonly property derived from `raw\_coef\_` that follows the internal memory layout of liblinear.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_coef_ = bridgeLinearSVC[${this.id}].coef_`;
      return this._py`attr_LinearSVC_coef_.tolist() if hasattr(attr_LinearSVC_coef_, 'tolist') else attr_LinearSVC_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_intercept_ = bridgeLinearSVC[${this.id}].intercept_`;
      return this._py`attr_LinearSVC_intercept_.tolist() if hasattr(attr_LinearSVC_intercept_, 'tolist') else attr_LinearSVC_intercept_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_classes_ = bridgeLinearSVC[${this.id}].classes_`;
      return this._py`attr_LinearSVC_classes_.tolist() if hasattr(attr_LinearSVC_classes_, 'tolist') else attr_LinearSVC_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVC must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_n_features_in_ = bridgeLinearSVC[${this.id}].n_features_in_`;
      return this._py`attr_LinearSVC_n_features_in_.tolist() if hasattr(attr_LinearSVC_n_features_in_, 'tolist') else attr_LinearSVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_feature_names_in_ = bridgeLinearSVC[${this.id}].feature_names_in_`;
      return this._py`attr_LinearSVC_feature_names_in_.tolist() if hasattr(attr_LinearSVC_feature_names_in_, 'tolist') else attr_LinearSVC_feature_names_in_`;
    })();
  }
  /**
    Maximum number of iterations run across all classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_n_iter_ = bridgeLinearSVC[${this.id}].n_iter_`;
      return this._py`attr_LinearSVC_n_iter_.tolist() if hasattr(attr_LinearSVC_n_iter_, 'tolist') else attr_LinearSVC_n_iter_`;
    })();
  }
};

// src/generated/svm/LinearSVR.ts
import crypto250 from "node:crypto";
var LinearSVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearSVR${crypto250.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearSVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import LinearSVR
try: bridgeLinearSVR
except NameError: bridgeLinearSVR = {}
`;
    await this._py.ex`ctor_LinearSVR = {'epsilon': ${this.opts["epsilon"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_LinearSVR = {k: v for k, v in ctor_LinearSVR.items() if v is not None}`;
    await this._py.ex`bridgeLinearSVR[${this.id}] = LinearSVR(**ctor_LinearSVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before fit()");
    }
    await this._py.ex`pms_LinearSVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVR_fit = {k: v for k, v in pms_LinearSVR_fit.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_fit = bridgeLinearSVR[${this.id}].fit(**pms_LinearSVR_fit)`;
    return this._py`res_LinearSVR_fit.tolist() if hasattr(res_LinearSVR_fit, 'tolist') else res_LinearSVR_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVR must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearSVR_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearSVR_get_metadata_routing = {k: v for k, v in pms_LinearSVR_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_get_metadata_routing = bridgeLinearSVR[${this.id}].get_metadata_routing(**pms_LinearSVR_get_metadata_routing)`;
    return this._py`res_LinearSVR_get_metadata_routing.tolist() if hasattr(res_LinearSVR_get_metadata_routing, 'tolist') else res_LinearSVR_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before predict()");
    }
    await this._py.ex`pms_LinearSVR_predict = {'X': ${opts["X"] ?? void 0}}

pms_LinearSVR_predict = {k: v for k, v in pms_LinearSVR_predict.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_predict = bridgeLinearSVR[${this.id}].predict(**pms_LinearSVR_predict)`;
    return this._py`res_LinearSVR_predict.tolist() if hasattr(res_LinearSVR_predict, 'tolist') else res_LinearSVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before score()");
    }
    await this._py.ex`pms_LinearSVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVR_score = {k: v for k, v in pms_LinearSVR_score.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_score = bridgeLinearSVR[${this.id}].score(**pms_LinearSVR_score)`;
    return this._py`res_LinearSVR_score.tolist() if hasattr(res_LinearSVR_score, 'tolist') else res_LinearSVR_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LinearSVR_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearSVR_set_fit_request = {k: v for k, v in pms_LinearSVR_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_set_fit_request = bridgeLinearSVR[${this.id}].set_fit_request(**pms_LinearSVR_set_fit_request)`;
    return this._py`res_LinearSVR_set_fit_request.tolist() if hasattr(res_LinearSVR_set_fit_request, 'tolist') else res_LinearSVR_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before set_score_request()");
    }
    await this._py.ex`pms_LinearSVR_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearSVR_set_score_request = {k: v for k, v in pms_LinearSVR_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_set_score_request = bridgeLinearSVR[${this.id}].set_score_request(**pms_LinearSVR_set_score_request)`;
    return this._py`res_LinearSVR_set_score_request.tolist() if hasattr(res_LinearSVR_set_score_request, 'tolist') else res_LinearSVR_set_score_request`;
  }
  /**
      Weights assigned to the features (coefficients in the primal problem).
  
      `coef\_` is a readonly property derived from `raw\_coef\_` that follows the internal memory layout of liblinear.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_coef_ = bridgeLinearSVR[${this.id}].coef_`;
      return this._py`attr_LinearSVR_coef_.tolist() if hasattr(attr_LinearSVR_coef_, 'tolist') else attr_LinearSVR_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_intercept_ = bridgeLinearSVR[${this.id}].intercept_`;
      return this._py`attr_LinearSVR_intercept_.tolist() if hasattr(attr_LinearSVR_intercept_, 'tolist') else attr_LinearSVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVR must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_n_features_in_ = bridgeLinearSVR[${this.id}].n_features_in_`;
      return this._py`attr_LinearSVR_n_features_in_.tolist() if hasattr(attr_LinearSVR_n_features_in_, 'tolist') else attr_LinearSVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVR must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_feature_names_in_ = bridgeLinearSVR[${this.id}].feature_names_in_`;
      return this._py`attr_LinearSVR_feature_names_in_.tolist() if hasattr(attr_LinearSVR_feature_names_in_, 'tolist') else attr_LinearSVR_feature_names_in_`;
    })();
  }
  /**
    Maximum number of iterations run across all classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_n_iter_ = bridgeLinearSVR[${this.id}].n_iter_`;
      return this._py`attr_LinearSVR_n_iter_.tolist() if hasattr(attr_LinearSVR_n_iter_, 'tolist') else attr_LinearSVR_n_iter_`;
    })();
  }
};

// src/generated/svm/NuSVC.ts
import crypto251 from "node:crypto";
var NuSVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NuSVC${crypto251.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NuSVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import NuSVC
try: bridgeNuSVC
except NameError: bridgeNuSVC = {}
`;
    await this._py.ex`ctor_NuSVC = {'nu': ${this.opts["nu"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'probability': ${this.opts["probability"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'decision_function_shape': ${this.opts["decision_function_shape"] ?? void 0}, 'break_ties': ${this.opts["break_ties"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_NuSVC = {k: v for k, v in ctor_NuSVC.items() if v is not None}`;
    await this._py.ex`bridgeNuSVC[${this.id}] = NuSVC(**ctor_NuSVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNuSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision function for the samples in X.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before decision_function()");
    }
    await this._py.ex`pms_NuSVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_decision_function = {k: v for k, v in pms_NuSVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_NuSVC_decision_function = bridgeNuSVC[${this.id}].decision_function(**pms_NuSVC_decision_function)`;
    return this._py`res_NuSVC_decision_function.tolist() if hasattr(res_NuSVC_decision_function, 'tolist') else res_NuSVC_decision_function`;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before fit()");
    }
    await this._py.ex`pms_NuSVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVC_fit = {k: v for k, v in pms_NuSVC_fit.items() if v is not None}`;
    await this._py.ex`res_NuSVC_fit = bridgeNuSVC[${this.id}].fit(**pms_NuSVC_fit)`;
    return this._py`res_NuSVC_fit.tolist() if hasattr(res_NuSVC_fit, 'tolist') else res_NuSVC_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_NuSVC_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NuSVC_get_metadata_routing = {k: v for k, v in pms_NuSVC_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NuSVC_get_metadata_routing = bridgeNuSVC[${this.id}].get_metadata_routing(**pms_NuSVC_get_metadata_routing)`;
    return this._py`res_NuSVC_get_metadata_routing.tolist() if hasattr(res_NuSVC_get_metadata_routing, 'tolist') else res_NuSVC_get_metadata_routing`;
  }
  /**
      Perform classification on samples in X.
  
      For an one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict()");
    }
    await this._py.ex`pms_NuSVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict = {k: v for k, v in pms_NuSVC_predict.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict = bridgeNuSVC[${this.id}].predict(**pms_NuSVC_predict)`;
    return this._py`res_NuSVC_predict.tolist() if hasattr(res_NuSVC_predict, 'tolist') else res_NuSVC_predict`;
  }
  /**
      Compute log probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_NuSVC_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict_log_proba = {k: v for k, v in pms_NuSVC_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict_log_proba = bridgeNuSVC[${this.id}].predict_log_proba(**pms_NuSVC_predict_log_proba)`;
    return this._py`res_NuSVC_predict_log_proba.tolist() if hasattr(res_NuSVC_predict_log_proba, 'tolist') else res_NuSVC_predict_log_proba`;
  }
  /**
      Compute probabilities of possible outcomes for samples in X.
  
      The model needs to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict_proba()");
    }
    await this._py.ex`pms_NuSVC_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict_proba = {k: v for k, v in pms_NuSVC_predict_proba.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict_proba = bridgeNuSVC[${this.id}].predict_proba(**pms_NuSVC_predict_proba)`;
    return this._py`res_NuSVC_predict_proba.tolist() if hasattr(res_NuSVC_predict_proba, 'tolist') else res_NuSVC_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before score()");
    }
    await this._py.ex`pms_NuSVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVC_score = {k: v for k, v in pms_NuSVC_score.items() if v is not None}`;
    await this._py.ex`res_NuSVC_score = bridgeNuSVC[${this.id}].score(**pms_NuSVC_score)`;
    return this._py`res_NuSVC_score.tolist() if hasattr(res_NuSVC_score, 'tolist') else res_NuSVC_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before set_fit_request()");
    }
    await this._py.ex`pms_NuSVC_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NuSVC_set_fit_request = {k: v for k, v in pms_NuSVC_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_NuSVC_set_fit_request = bridgeNuSVC[${this.id}].set_fit_request(**pms_NuSVC_set_fit_request)`;
    return this._py`res_NuSVC_set_fit_request.tolist() if hasattr(res_NuSVC_set_fit_request, 'tolist') else res_NuSVC_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before set_score_request()");
    }
    await this._py.ex`pms_NuSVC_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NuSVC_set_score_request = {k: v for k, v in pms_NuSVC_set_score_request.items() if v is not None}`;
    await this._py.ex`res_NuSVC_set_score_request = bridgeNuSVC[${this.id}].set_score_request(**pms_NuSVC_set_score_request)`;
    return this._py`res_NuSVC_set_score_request.tolist() if hasattr(res_NuSVC_set_score_request, 'tolist') else res_NuSVC_set_score_request`;
  }
  /**
    Multipliers of parameter C of each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_class_weight_ = bridgeNuSVC[${this.id}].class_weight_`;
      return this._py`attr_NuSVC_class_weight_.tolist() if hasattr(attr_NuSVC_class_weight_, 'tolist') else attr_NuSVC_class_weight_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_classes_ = bridgeNuSVC[${this.id}].classes_`;
      return this._py`attr_NuSVC_classes_.tolist() if hasattr(attr_NuSVC_classes_, 'tolist') else attr_NuSVC_classes_`;
    })();
  }
  /**
    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_dual_coef_ = bridgeNuSVC[${this.id}].dual_coef_`;
      return this._py`attr_NuSVC_dual_coef_.tolist() if hasattr(attr_NuSVC_dual_coef_, 'tolist') else attr_NuSVC_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 if the algorithm did not converge.
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_fit_status_ = bridgeNuSVC[${this.id}].fit_status_`;
      return this._py`attr_NuSVC_fit_status_.tolist() if hasattr(attr_NuSVC_fit_status_, 'tolist') else attr_NuSVC_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_intercept_ = bridgeNuSVC[${this.id}].intercept_`;
      return this._py`attr_NuSVC_intercept_.tolist() if hasattr(attr_NuSVC_intercept_, 'tolist') else attr_NuSVC_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_n_features_in_ = bridgeNuSVC[${this.id}].n_features_in_`;
      return this._py`attr_NuSVC_n_features_in_.tolist() if hasattr(attr_NuSVC_n_features_in_, 'tolist') else attr_NuSVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_feature_names_in_ = bridgeNuSVC[${this.id}].feature_names_in_`;
      return this._py`attr_NuSVC_feature_names_in_.tolist() if hasattr(attr_NuSVC_feature_names_in_, 'tolist') else attr_NuSVC_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_n_iter_ = bridgeNuSVC[${this.id}].n_iter_`;
      return this._py`attr_NuSVC_n_iter_.tolist() if hasattr(attr_NuSVC_n_iter_, 'tolist') else attr_NuSVC_n_iter_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_support_ = bridgeNuSVC[${this.id}].support_`;
      return this._py`attr_NuSVC_support_.tolist() if hasattr(attr_NuSVC_support_, 'tolist') else attr_NuSVC_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVC must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_support_vectors_ = bridgeNuSVC[${this.id}].support_vectors_`;
      return this._py`attr_NuSVC_support_vectors_.tolist() if hasattr(attr_NuSVC_support_vectors_, 'tolist') else attr_NuSVC_support_vectors_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_shape_fit_ = bridgeNuSVC[${this.id}].shape_fit_`;
      return this._py`attr_NuSVC_shape_fit_.tolist() if hasattr(attr_NuSVC_shape_fit_, 'tolist') else attr_NuSVC_shape_fit_`;
    })();
  }
};

// src/generated/svm/NuSVR.ts
import crypto252 from "node:crypto";
var NuSVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NuSVR${crypto252.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NuSVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import NuSVR
try: bridgeNuSVR
except NameError: bridgeNuSVR = {}
`;
    await this._py.ex`ctor_NuSVR = {'nu': ${this.opts["nu"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_NuSVR = {k: v for k, v in ctor_NuSVR.items() if v is not None}`;
    await this._py.ex`bridgeNuSVR[${this.id}] = NuSVR(**ctor_NuSVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNuSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before fit()");
    }
    await this._py.ex`pms_NuSVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVR_fit = {k: v for k, v in pms_NuSVR_fit.items() if v is not None}`;
    await this._py.ex`res_NuSVR_fit = bridgeNuSVR[${this.id}].fit(**pms_NuSVR_fit)`;
    return this._py`res_NuSVR_fit.tolist() if hasattr(res_NuSVR_fit, 'tolist') else res_NuSVR_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_NuSVR_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NuSVR_get_metadata_routing = {k: v for k, v in pms_NuSVR_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NuSVR_get_metadata_routing = bridgeNuSVR[${this.id}].get_metadata_routing(**pms_NuSVR_get_metadata_routing)`;
    return this._py`res_NuSVR_get_metadata_routing.tolist() if hasattr(res_NuSVR_get_metadata_routing, 'tolist') else res_NuSVR_get_metadata_routing`;
  }
  /**
      Perform regression on samples in X.
  
      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before predict()");
    }
    await this._py.ex`pms_NuSVR_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVR_predict = {k: v for k, v in pms_NuSVR_predict.items() if v is not None}`;
    await this._py.ex`res_NuSVR_predict = bridgeNuSVR[${this.id}].predict(**pms_NuSVR_predict)`;
    return this._py`res_NuSVR_predict.tolist() if hasattr(res_NuSVR_predict, 'tolist') else res_NuSVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before score()");
    }
    await this._py.ex`pms_NuSVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVR_score = {k: v for k, v in pms_NuSVR_score.items() if v is not None}`;
    await this._py.ex`res_NuSVR_score = bridgeNuSVR[${this.id}].score(**pms_NuSVR_score)`;
    return this._py`res_NuSVR_score.tolist() if hasattr(res_NuSVR_score, 'tolist') else res_NuSVR_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before set_fit_request()");
    }
    await this._py.ex`pms_NuSVR_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NuSVR_set_fit_request = {k: v for k, v in pms_NuSVR_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_NuSVR_set_fit_request = bridgeNuSVR[${this.id}].set_fit_request(**pms_NuSVR_set_fit_request)`;
    return this._py`res_NuSVR_set_fit_request.tolist() if hasattr(res_NuSVR_set_fit_request, 'tolist') else res_NuSVR_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before set_score_request()");
    }
    await this._py.ex`pms_NuSVR_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NuSVR_set_score_request = {k: v for k, v in pms_NuSVR_set_score_request.items() if v is not None}`;
    await this._py.ex`res_NuSVR_set_score_request = bridgeNuSVR[${this.id}].set_score_request(**pms_NuSVR_set_score_request)`;
    return this._py`res_NuSVR_set_score_request.tolist() if hasattr(res_NuSVR_set_score_request, 'tolist') else res_NuSVR_set_score_request`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_class_weight_ = bridgeNuSVR[${this.id}].class_weight_`;
      return this._py`attr_NuSVR_class_weight_.tolist() if hasattr(attr_NuSVR_class_weight_, 'tolist') else attr_NuSVR_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vector in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_dual_coef_ = bridgeNuSVR[${this.id}].dual_coef_`;
      return this._py`attr_NuSVR_dual_coef_.tolist() if hasattr(attr_NuSVR_dual_coef_, 'tolist') else attr_NuSVR_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_fit_status_ = bridgeNuSVR[${this.id}].fit_status_`;
      return this._py`attr_NuSVR_fit_status_.tolist() if hasattr(attr_NuSVR_fit_status_, 'tolist') else attr_NuSVR_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_intercept_ = bridgeNuSVR[${this.id}].intercept_`;
      return this._py`attr_NuSVR_intercept_.tolist() if hasattr(attr_NuSVR_intercept_, 'tolist') else attr_NuSVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_n_features_in_ = bridgeNuSVR[${this.id}].n_features_in_`;
      return this._py`attr_NuSVR_n_features_in_.tolist() if hasattr(attr_NuSVR_n_features_in_, 'tolist') else attr_NuSVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVR must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_feature_names_in_ = bridgeNuSVR[${this.id}].feature_names_in_`;
      return this._py`attr_NuSVR_feature_names_in_.tolist() if hasattr(attr_NuSVR_feature_names_in_, 'tolist') else attr_NuSVR_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_n_iter_ = bridgeNuSVR[${this.id}].n_iter_`;
      return this._py`attr_NuSVR_n_iter_.tolist() if hasattr(attr_NuSVR_n_iter_, 'tolist') else attr_NuSVR_n_iter_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_shape_fit_ = bridgeNuSVR[${this.id}].shape_fit_`;
      return this._py`attr_NuSVR_shape_fit_.tolist() if hasattr(attr_NuSVR_shape_fit_, 'tolist') else attr_NuSVR_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_support_ = bridgeNuSVR[${this.id}].support_`;
      return this._py`attr_NuSVR_support_.tolist() if hasattr(attr_NuSVR_support_, 'tolist') else attr_NuSVR_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVR must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_support_vectors_ = bridgeNuSVR[${this.id}].support_vectors_`;
      return this._py`attr_NuSVR_support_vectors_.tolist() if hasattr(attr_NuSVR_support_vectors_, 'tolist') else attr_NuSVR_support_vectors_`;
    })();
  }
};

// src/generated/svm/OneClassSVM.ts
import crypto253 from "node:crypto";
var OneClassSVM = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneClassSVM${crypto253.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OneClassSVM.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import OneClassSVM
try: bridgeOneClassSVM
except NameError: bridgeOneClassSVM = {}
`;
    await this._py.ex`ctor_OneClassSVM = {'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'nu': ${this.opts["nu"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_OneClassSVM = {k: v for k, v in ctor_OneClassSVM.items() if v is not None}`;
    await this._py.ex`bridgeOneClassSVM[${this.id}] = OneClassSVM(**ctor_OneClassSVM)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneClassSVM[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Signed distance to the separating hyperplane.
  
      Signed distance is positive for an inlier and negative for an outlier.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before decision_function()");
    }
    await this._py.ex`pms_OneClassSVM_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_decision_function = {k: v for k, v in pms_OneClassSVM_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_decision_function = bridgeOneClassSVM[${this.id}].decision_function(**pms_OneClassSVM_decision_function)`;
    return this._py`res_OneClassSVM_decision_function.tolist() if hasattr(res_OneClassSVM_decision_function, 'tolist') else res_OneClassSVM_decision_function`;
  }
  /**
    Detect the soft boundary of the set of samples X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before fit()");
    }
    await this._py.ex`pms_OneClassSVM_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneClassSVM_fit = {k: v for k, v in pms_OneClassSVM_fit.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_fit = bridgeOneClassSVM[${this.id}].fit(**pms_OneClassSVM_fit)`;
    return this._py`res_OneClassSVM_fit.tolist() if hasattr(res_OneClassSVM_fit, 'tolist') else res_OneClassSVM_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before fit_predict()");
    }
    await this._py.ex`pms_OneClassSVM_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OneClassSVM_fit_predict = {k: v for k, v in pms_OneClassSVM_fit_predict.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_fit_predict = bridgeOneClassSVM[${this.id}].fit_predict(**pms_OneClassSVM_fit_predict)`;
    return this._py`res_OneClassSVM_fit_predict.tolist() if hasattr(res_OneClassSVM_fit_predict, 'tolist') else res_OneClassSVM_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OneClassSVM_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OneClassSVM_get_metadata_routing = {k: v for k, v in pms_OneClassSVM_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_get_metadata_routing = bridgeOneClassSVM[${this.id}].get_metadata_routing(**pms_OneClassSVM_get_metadata_routing)`;
    return this._py`res_OneClassSVM_get_metadata_routing.tolist() if hasattr(res_OneClassSVM_get_metadata_routing, 'tolist') else res_OneClassSVM_get_metadata_routing`;
  }
  /**
      Perform classification on samples in X.
  
      For a one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before predict()");
    }
    await this._py.ex`pms_OneClassSVM_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_predict = {k: v for k, v in pms_OneClassSVM_predict.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_predict = bridgeOneClassSVM[${this.id}].predict(**pms_OneClassSVM_predict)`;
    return this._py`res_OneClassSVM_predict.tolist() if hasattr(res_OneClassSVM_predict, 'tolist') else res_OneClassSVM_predict`;
  }
  /**
    Raw scoring function of the samples.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before score_samples()");
    }
    await this._py.ex`pms_OneClassSVM_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_score_samples = {k: v for k, v in pms_OneClassSVM_score_samples.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_score_samples = bridgeOneClassSVM[${this.id}].score_samples(**pms_OneClassSVM_score_samples)`;
    return this._py`res_OneClassSVM_score_samples.tolist() if hasattr(res_OneClassSVM_score_samples, 'tolist') else res_OneClassSVM_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before set_fit_request()");
    }
    await this._py.ex`pms_OneClassSVM_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OneClassSVM_set_fit_request = {k: v for k, v in pms_OneClassSVM_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_set_fit_request = bridgeOneClassSVM[${this.id}].set_fit_request(**pms_OneClassSVM_set_fit_request)`;
    return this._py`res_OneClassSVM_set_fit_request.tolist() if hasattr(res_OneClassSVM_set_fit_request, 'tolist') else res_OneClassSVM_set_fit_request`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing class_weight_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_class_weight_ = bridgeOneClassSVM[${this.id}].class_weight_`;
      return this._py`attr_OneClassSVM_class_weight_.tolist() if hasattr(attr_OneClassSVM_class_weight_, 'tolist') else attr_OneClassSVM_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vectors in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing dual_coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_dual_coef_ = bridgeOneClassSVM[${this.id}].dual_coef_`;
      return this._py`attr_OneClassSVM_dual_coef_.tolist() if hasattr(attr_OneClassSVM_dual_coef_, 'tolist') else attr_OneClassSVM_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing fit_status_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_fit_status_ = bridgeOneClassSVM[${this.id}].fit_status_`;
      return this._py`attr_OneClassSVM_fit_status_.tolist() if hasattr(attr_OneClassSVM_fit_status_, 'tolist') else attr_OneClassSVM_fit_status_`;
    })();
  }
  /**
    Constant in the decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_intercept_ = bridgeOneClassSVM[${this.id}].intercept_`;
      return this._py`attr_OneClassSVM_intercept_.tolist() if hasattr(attr_OneClassSVM_intercept_, 'tolist') else attr_OneClassSVM_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_n_features_in_ = bridgeOneClassSVM[${this.id}].n_features_in_`;
      return this._py`attr_OneClassSVM_n_features_in_.tolist() if hasattr(attr_OneClassSVM_n_features_in_, 'tolist') else attr_OneClassSVM_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_feature_names_in_ = bridgeOneClassSVM[${this.id}].feature_names_in_`;
      return this._py`attr_OneClassSVM_feature_names_in_.tolist() if hasattr(attr_OneClassSVM_feature_names_in_, 'tolist') else attr_OneClassSVM_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_n_iter_ = bridgeOneClassSVM[${this.id}].n_iter_`;
      return this._py`attr_OneClassSVM_n_iter_.tolist() if hasattr(attr_OneClassSVM_n_iter_, 'tolist') else attr_OneClassSVM_n_iter_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: decision\_function = score\_samples - `offset\_`. The offset is the opposite of `intercept\_` and is provided for consistency with other outlier detection algorithms.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing offset_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_offset_ = bridgeOneClassSVM[${this.id}].offset_`;
      return this._py`attr_OneClassSVM_offset_.tolist() if hasattr(attr_OneClassSVM_offset_, 'tolist') else attr_OneClassSVM_offset_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing shape_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_shape_fit_ = bridgeOneClassSVM[${this.id}].shape_fit_`;
      return this._py`attr_OneClassSVM_shape_fit_.tolist() if hasattr(attr_OneClassSVM_shape_fit_, 'tolist') else attr_OneClassSVM_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_support_ = bridgeOneClassSVM[${this.id}].support_`;
      return this._py`attr_OneClassSVM_support_.tolist() if hasattr(attr_OneClassSVM_support_, 'tolist') else attr_OneClassSVM_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_support_vectors_ = bridgeOneClassSVM[${this.id}].support_vectors_`;
      return this._py`attr_OneClassSVM_support_vectors_.tolist() if hasattr(attr_OneClassSVM_support_vectors_, 'tolist') else attr_OneClassSVM_support_vectors_`;
    })();
  }
};

// src/generated/svm/SVC.ts
import crypto254 from "node:crypto";
var SVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SVC${crypto254.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import SVC
try: bridgeSVC
except NameError: bridgeSVC = {}
`;
    await this._py.ex`ctor_SVC = {'C': ${this.opts["C"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'probability': ${this.opts["probability"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'decision_function_shape': ${this.opts["decision_function_shape"] ?? void 0}, 'break_ties': ${this.opts["break_ties"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SVC = {k: v for k, v in ctor_SVC.items() if v is not None}`;
    await this._py.ex`bridgeSVC[${this.id}] = SVC(**ctor_SVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision function for the samples in X.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before decision_function()");
    }
    await this._py.ex`pms_SVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_decision_function = {k: v for k, v in pms_SVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_SVC_decision_function = bridgeSVC[${this.id}].decision_function(**pms_SVC_decision_function)`;
    return this._py`res_SVC_decision_function.tolist() if hasattr(res_SVC_decision_function, 'tolist') else res_SVC_decision_function`;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before fit()");
    }
    await this._py.ex`pms_SVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_fit = {k: v for k, v in pms_SVC_fit.items() if v is not None}`;
    await this._py.ex`res_SVC_fit = bridgeSVC[${this.id}].fit(**pms_SVC_fit)`;
    return this._py`res_SVC_fit.tolist() if hasattr(res_SVC_fit, 'tolist') else res_SVC_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_SVC_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SVC_get_metadata_routing = {k: v for k, v in pms_SVC_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SVC_get_metadata_routing = bridgeSVC[${this.id}].get_metadata_routing(**pms_SVC_get_metadata_routing)`;
    return this._py`res_SVC_get_metadata_routing.tolist() if hasattr(res_SVC_get_metadata_routing, 'tolist') else res_SVC_get_metadata_routing`;
  }
  /**
      Perform classification on samples in X.
  
      For an one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict()");
    }
    await this._py.ex`pms_SVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict = {k: v for k, v in pms_SVC_predict.items() if v is not None}`;
    await this._py.ex`res_SVC_predict = bridgeSVC[${this.id}].predict(**pms_SVC_predict)`;
    return this._py`res_SVC_predict.tolist() if hasattr(res_SVC_predict, 'tolist') else res_SVC_predict`;
  }
  /**
      Compute log probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_SVC_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_log_proba = {k: v for k, v in pms_SVC_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_log_proba = bridgeSVC[${this.id}].predict_log_proba(**pms_SVC_predict_log_proba)`;
    return this._py`res_SVC_predict_log_proba.tolist() if hasattr(res_SVC_predict_log_proba, 'tolist') else res_SVC_predict_log_proba`;
  }
  /**
      Compute probabilities of possible outcomes for samples in X.
  
      The model needs to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_proba()");
    }
    await this._py.ex`pms_SVC_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_proba = {k: v for k, v in pms_SVC_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_proba = bridgeSVC[${this.id}].predict_proba(**pms_SVC_predict_proba)`;
    return this._py`res_SVC_predict_proba.tolist() if hasattr(res_SVC_predict_proba, 'tolist') else res_SVC_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before score()");
    }
    await this._py.ex`pms_SVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_score = {k: v for k, v in pms_SVC_score.items() if v is not None}`;
    await this._py.ex`res_SVC_score = bridgeSVC[${this.id}].score(**pms_SVC_score)`;
    return this._py`res_SVC_score.tolist() if hasattr(res_SVC_score, 'tolist') else res_SVC_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SVC_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SVC_set_fit_request = {k: v for k, v in pms_SVC_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SVC_set_fit_request = bridgeSVC[${this.id}].set_fit_request(**pms_SVC_set_fit_request)`;
    return this._py`res_SVC_set_fit_request.tolist() if hasattr(res_SVC_set_fit_request, 'tolist') else res_SVC_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before set_score_request()");
    }
    await this._py.ex`pms_SVC_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SVC_set_score_request = {k: v for k, v in pms_SVC_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SVC_set_score_request = bridgeSVC[${this.id}].set_score_request(**pms_SVC_set_score_request)`;
    return this._py`res_SVC_set_score_request.tolist() if hasattr(res_SVC_set_score_request, 'tolist') else res_SVC_set_score_request`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_class_weight_ = bridgeSVC[${this.id}].class_weight_`;
      return this._py`attr_SVC_class_weight_.tolist() if hasattr(attr_SVC_class_weight_, 'tolist') else attr_SVC_class_weight_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_classes_ = bridgeSVC[${this.id}].classes_`;
      return this._py`attr_SVC_classes_.tolist() if hasattr(attr_SVC_classes_, 'tolist') else attr_SVC_classes_`;
    })();
  }
  /**
    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_dual_coef_ = bridgeSVC[${this.id}].dual_coef_`;
      return this._py`attr_SVC_dual_coef_.tolist() if hasattr(attr_SVC_dual_coef_, 'tolist') else attr_SVC_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_fit_status_ = bridgeSVC[${this.id}].fit_status_`;
      return this._py`attr_SVC_fit_status_.tolist() if hasattr(attr_SVC_fit_status_, 'tolist') else attr_SVC_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_intercept_ = bridgeSVC[${this.id}].intercept_`;
      return this._py`attr_SVC_intercept_.tolist() if hasattr(attr_SVC_intercept_, 'tolist') else attr_SVC_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_features_in_ = bridgeSVC[${this.id}].n_features_in_`;
      return this._py`attr_SVC_n_features_in_.tolist() if hasattr(attr_SVC_n_features_in_, 'tolist') else attr_SVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_feature_names_in_ = bridgeSVC[${this.id}].feature_names_in_`;
      return this._py`attr_SVC_feature_names_in_.tolist() if hasattr(attr_SVC_feature_names_in_, 'tolist') else attr_SVC_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_iter_ = bridgeSVC[${this.id}].n_iter_`;
      return this._py`attr_SVC_n_iter_.tolist() if hasattr(attr_SVC_n_iter_, 'tolist') else attr_SVC_n_iter_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_ = bridgeSVC[${this.id}].support_`;
      return this._py`attr_SVC_support_.tolist() if hasattr(attr_SVC_support_, 'tolist') else attr_SVC_support_`;
    })();
  }
  /**
    Support vectors. An empty array if kernel is precomputed.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_vectors_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_vectors_ = bridgeSVC[${this.id}].support_vectors_`;
      return this._py`attr_SVC_support_vectors_.tolist() if hasattr(attr_SVC_support_vectors_, 'tolist') else attr_SVC_support_vectors_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_shape_fit_ = bridgeSVC[${this.id}].shape_fit_`;
      return this._py`attr_SVC_shape_fit_.tolist() if hasattr(attr_SVC_shape_fit_, 'tolist') else attr_SVC_shape_fit_`;
    })();
  }
};

// src/generated/svm/SVR.ts
import crypto255 from "node:crypto";
var SVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SVR${crypto255.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import SVR
try: bridgeSVR
except NameError: bridgeSVR = {}
`;
    await this._py.ex`ctor_SVR = {'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_SVR = {k: v for k, v in ctor_SVR.items() if v is not None}`;
    await this._py.ex`bridgeSVR[${this.id}] = SVR(**ctor_SVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before fit()");
    }
    await this._py.ex`pms_SVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVR_fit = {k: v for k, v in pms_SVR_fit.items() if v is not None}`;
    await this._py.ex`res_SVR_fit = bridgeSVR[${this.id}].fit(**pms_SVR_fit)`;
    return this._py`res_SVR_fit.tolist() if hasattr(res_SVR_fit, 'tolist') else res_SVR_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_SVR_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SVR_get_metadata_routing = {k: v for k, v in pms_SVR_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SVR_get_metadata_routing = bridgeSVR[${this.id}].get_metadata_routing(**pms_SVR_get_metadata_routing)`;
    return this._py`res_SVR_get_metadata_routing.tolist() if hasattr(res_SVR_get_metadata_routing, 'tolist') else res_SVR_get_metadata_routing`;
  }
  /**
      Perform regression on samples in X.
  
      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before predict()");
    }
    await this._py.ex`pms_SVR_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVR_predict = {k: v for k, v in pms_SVR_predict.items() if v is not None}`;
    await this._py.ex`res_SVR_predict = bridgeSVR[${this.id}].predict(**pms_SVR_predict)`;
    return this._py`res_SVR_predict.tolist() if hasattr(res_SVR_predict, 'tolist') else res_SVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before score()");
    }
    await this._py.ex`pms_SVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVR_score = {k: v for k, v in pms_SVR_score.items() if v is not None}`;
    await this._py.ex`res_SVR_score = bridgeSVR[${this.id}].score(**pms_SVR_score)`;
    return this._py`res_SVR_score.tolist() if hasattr(res_SVR_score, 'tolist') else res_SVR_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SVR_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SVR_set_fit_request = {k: v for k, v in pms_SVR_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SVR_set_fit_request = bridgeSVR[${this.id}].set_fit_request(**pms_SVR_set_fit_request)`;
    return this._py`res_SVR_set_fit_request.tolist() if hasattr(res_SVR_set_fit_request, 'tolist') else res_SVR_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before set_score_request()");
    }
    await this._py.ex`pms_SVR_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SVR_set_score_request = {k: v for k, v in pms_SVR_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SVR_set_score_request = bridgeSVR[${this.id}].set_score_request(**pms_SVR_set_score_request)`;
    return this._py`res_SVR_set_score_request.tolist() if hasattr(res_SVR_set_score_request, 'tolist') else res_SVR_set_score_request`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_class_weight_ = bridgeSVR[${this.id}].class_weight_`;
      return this._py`attr_SVR_class_weight_.tolist() if hasattr(attr_SVR_class_weight_, 'tolist') else attr_SVR_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vector in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_dual_coef_ = bridgeSVR[${this.id}].dual_coef_`;
      return this._py`attr_SVR_dual_coef_.tolist() if hasattr(attr_SVR_dual_coef_, 'tolist') else attr_SVR_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_fit_status_ = bridgeSVR[${this.id}].fit_status_`;
      return this._py`attr_SVR_fit_status_.tolist() if hasattr(attr_SVR_fit_status_, 'tolist') else attr_SVR_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_intercept_ = bridgeSVR[${this.id}].intercept_`;
      return this._py`attr_SVR_intercept_.tolist() if hasattr(attr_SVR_intercept_, 'tolist') else attr_SVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_n_features_in_ = bridgeSVR[${this.id}].n_features_in_`;
      return this._py`attr_SVR_n_features_in_.tolist() if hasattr(attr_SVR_n_features_in_, 'tolist') else attr_SVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_feature_names_in_ = bridgeSVR[${this.id}].feature_names_in_`;
      return this._py`attr_SVR_feature_names_in_.tolist() if hasattr(attr_SVR_feature_names_in_, 'tolist') else attr_SVR_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_n_iter_ = bridgeSVR[${this.id}].n_iter_`;
      return this._py`attr_SVR_n_iter_.tolist() if hasattr(attr_SVR_n_iter_, 'tolist') else attr_SVR_n_iter_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_shape_fit_ = bridgeSVR[${this.id}].shape_fit_`;
      return this._py`attr_SVR_shape_fit_.tolist() if hasattr(attr_SVR_shape_fit_, 'tolist') else attr_SVR_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_support_ = bridgeSVR[${this.id}].support_`;
      return this._py`attr_SVR_support_.tolist() if hasattr(attr_SVR_support_, 'tolist') else attr_SVR_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing support_vectors_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_support_vectors_ = bridgeSVR[${this.id}].support_vectors_`;
      return this._py`attr_SVR_support_vectors_.tolist() if hasattr(attr_SVR_support_vectors_, 'tolist') else attr_SVR_support_vectors_`;
    })();
  }
};

// src/generated/tree/DecisionTreeClassifier.ts
import crypto256 from "node:crypto";
var DecisionTreeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DecisionTreeClassifier${crypto256.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DecisionTreeClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.tree import DecisionTreeClassifier
try: bridgeDecisionTreeClassifier
except NameError: bridgeDecisionTreeClassifier = {}
`;
    await this._py.ex`ctor_DecisionTreeClassifier = {'criterion': ${this.opts["criterion"] ?? void 0}, 'splitter': ${this.opts["splitter"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_DecisionTreeClassifier = {k: v for k, v in ctor_DecisionTreeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeDecisionTreeClassifier[${this.id}] = DecisionTreeClassifier(**ctor_DecisionTreeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDecisionTreeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the index of the leaf that each sample is predicted as.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeClassifier must call init() before apply()");
    }
    await this._py.ex`pms_DecisionTreeClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_apply = {k: v for k, v in pms_DecisionTreeClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_apply = bridgeDecisionTreeClassifier[${this.id}].apply(**pms_DecisionTreeClassifier_apply)`;
    return this._py`res_DecisionTreeClassifier_apply.tolist() if hasattr(res_DecisionTreeClassifier_apply, 'tolist') else res_DecisionTreeClassifier_apply`;
  }
  /**
      Compute the pruning path during Minimal Cost-Complexity Pruning.
  
      See [Minimal Cost-Complexity Pruning](../tree.html#minimal-cost-complexity-pruning) for details on the pruning process.
     */
  async cost_complexity_pruning_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before cost_complexity_pruning_path()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_cost_complexity_pruning_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DecisionTreeClassifier_cost_complexity_pruning_path = {k: v for k, v in pms_DecisionTreeClassifier_cost_complexity_pruning_path.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_cost_complexity_pruning_path = bridgeDecisionTreeClassifier[${this.id}].cost_complexity_pruning_path(**pms_DecisionTreeClassifier_cost_complexity_pruning_path)`;
    return this._py`res_DecisionTreeClassifier_cost_complexity_pruning_path.tolist() if hasattr(res_DecisionTreeClassifier_cost_complexity_pruning_path, 'tolist') else res_DecisionTreeClassifier_cost_complexity_pruning_path`;
  }
  /**
    Return the decision path in the tree.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_decision_path = {k: v for k, v in pms_DecisionTreeClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_decision_path = bridgeDecisionTreeClassifier[${this.id}].decision_path(**pms_DecisionTreeClassifier_decision_path)`;
    return this._py`res_DecisionTreeClassifier_decision_path.tolist() if hasattr(res_DecisionTreeClassifier_decision_path, 'tolist') else res_DecisionTreeClassifier_decision_path`;
  }
  /**
    Build a decision tree classifier from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_DecisionTreeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_fit = {k: v for k, v in pms_DecisionTreeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_fit = bridgeDecisionTreeClassifier[${this.id}].fit(**pms_DecisionTreeClassifier_fit)`;
    return this._py`res_DecisionTreeClassifier_fit.tolist() if hasattr(res_DecisionTreeClassifier_fit, 'tolist') else res_DecisionTreeClassifier_fit`;
  }
  /**
      Return the depth of the decision tree.
  
      The depth of a tree is the maximum distance between the root and any leaf.
     */
  async get_depth(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before get_depth()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_get_depth = {}

pms_DecisionTreeClassifier_get_depth = {k: v for k, v in pms_DecisionTreeClassifier_get_depth.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_get_depth = bridgeDecisionTreeClassifier[${this.id}].get_depth(**pms_DecisionTreeClassifier_get_depth)`;
    return this._py`res_DecisionTreeClassifier_get_depth.tolist() if hasattr(res_DecisionTreeClassifier_get_depth, 'tolist') else res_DecisionTreeClassifier_get_depth`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DecisionTreeClassifier_get_metadata_routing = {k: v for k, v in pms_DecisionTreeClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_get_metadata_routing = bridgeDecisionTreeClassifier[${this.id}].get_metadata_routing(**pms_DecisionTreeClassifier_get_metadata_routing)`;
    return this._py`res_DecisionTreeClassifier_get_metadata_routing.tolist() if hasattr(res_DecisionTreeClassifier_get_metadata_routing, 'tolist') else res_DecisionTreeClassifier_get_metadata_routing`;
  }
  /**
    Return the number of leaves of the decision tree.
   */
  async get_n_leaves(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before get_n_leaves()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_get_n_leaves = {}

pms_DecisionTreeClassifier_get_n_leaves = {k: v for k, v in pms_DecisionTreeClassifier_get_n_leaves.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_get_n_leaves = bridgeDecisionTreeClassifier[${this.id}].get_n_leaves(**pms_DecisionTreeClassifier_get_n_leaves)`;
    return this._py`res_DecisionTreeClassifier_get_n_leaves.tolist() if hasattr(res_DecisionTreeClassifier_get_n_leaves, 'tolist') else res_DecisionTreeClassifier_get_n_leaves`;
  }
  /**
      Predict class or regression value for X.
  
      For a classification model, the predicted class for each sample in X is returned. For a regression model, the predicted value based on X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_predict = {k: v for k, v in pms_DecisionTreeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_predict = bridgeDecisionTreeClassifier[${this.id}].predict(**pms_DecisionTreeClassifier_predict)`;
    return this._py`res_DecisionTreeClassifier_predict.tolist() if hasattr(res_DecisionTreeClassifier_predict, 'tolist') else res_DecisionTreeClassifier_predict`;
  }
  /**
    Predict class log-probabilities of the input samples X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DecisionTreeClassifier_predict_log_proba = {k: v for k, v in pms_DecisionTreeClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_predict_log_proba = bridgeDecisionTreeClassifier[${this.id}].predict_log_proba(**pms_DecisionTreeClassifier_predict_log_proba)`;
    return this._py`res_DecisionTreeClassifier_predict_log_proba.tolist() if hasattr(res_DecisionTreeClassifier_predict_log_proba, 'tolist') else res_DecisionTreeClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities of the input samples X.
  
      The predicted class probability is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_predict_proba = {k: v for k, v in pms_DecisionTreeClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_predict_proba = bridgeDecisionTreeClassifier[${this.id}].predict_proba(**pms_DecisionTreeClassifier_predict_proba)`;
    return this._py`res_DecisionTreeClassifier_predict_proba.tolist() if hasattr(res_DecisionTreeClassifier_predict_proba, 'tolist') else res_DecisionTreeClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeClassifier must call init() before score()");
    }
    await this._py.ex`pms_DecisionTreeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DecisionTreeClassifier_score = {k: v for k, v in pms_DecisionTreeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_score = bridgeDecisionTreeClassifier[${this.id}].score(**pms_DecisionTreeClassifier_score)`;
    return this._py`res_DecisionTreeClassifier_score.tolist() if hasattr(res_DecisionTreeClassifier_score, 'tolist') else res_DecisionTreeClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DecisionTreeClassifier_set_fit_request = {k: v for k, v in pms_DecisionTreeClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_set_fit_request = bridgeDecisionTreeClassifier[${this.id}].set_fit_request(**pms_DecisionTreeClassifier_set_fit_request)`;
    return this._py`res_DecisionTreeClassifier_set_fit_request.tolist() if hasattr(res_DecisionTreeClassifier_set_fit_request, 'tolist') else res_DecisionTreeClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict\_proba` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_proba_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before set_predict_proba_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_set_predict_proba_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_set_predict_proba_request = {k: v for k, v in pms_DecisionTreeClassifier_set_predict_proba_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_set_predict_proba_request = bridgeDecisionTreeClassifier[${this.id}].set_predict_proba_request(**pms_DecisionTreeClassifier_set_predict_proba_request)`;
    return this._py`res_DecisionTreeClassifier_set_predict_proba_request.tolist() if hasattr(res_DecisionTreeClassifier_set_predict_proba_request, 'tolist') else res_DecisionTreeClassifier_set_predict_proba_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_set_predict_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeClassifier_set_predict_request = {k: v for k, v in pms_DecisionTreeClassifier_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_set_predict_request = bridgeDecisionTreeClassifier[${this.id}].set_predict_request(**pms_DecisionTreeClassifier_set_predict_request)`;
    return this._py`res_DecisionTreeClassifier_set_predict_request.tolist() if hasattr(res_DecisionTreeClassifier_set_predict_request, 'tolist') else res_DecisionTreeClassifier_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DecisionTreeClassifier_set_score_request = {k: v for k, v in pms_DecisionTreeClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeClassifier_set_score_request = bridgeDecisionTreeClassifier[${this.id}].set_score_request(**pms_DecisionTreeClassifier_set_score_request)`;
    return this._py`res_DecisionTreeClassifier_set_score_request.tolist() if hasattr(res_DecisionTreeClassifier_set_score_request, 'tolist') else res_DecisionTreeClassifier_set_score_request`;
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_classes_ = bridgeDecisionTreeClassifier[${this.id}].classes_`;
      return this._py`attr_DecisionTreeClassifier_classes_.tolist() if hasattr(attr_DecisionTreeClassifier_classes_, 'tolist') else attr_DecisionTreeClassifier_classes_`;
    })();
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_max_features_ = bridgeDecisionTreeClassifier[${this.id}].max_features_`;
      return this._py`attr_DecisionTreeClassifier_max_features_.tolist() if hasattr(attr_DecisionTreeClassifier_max_features_, 'tolist') else attr_DecisionTreeClassifier_max_features_`;
    })();
  }
  /**
    The number of classes (for single output problems), or a list containing the number of classes for each output (for multi-output problems).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_n_classes_ = bridgeDecisionTreeClassifier[${this.id}].n_classes_`;
      return this._py`attr_DecisionTreeClassifier_n_classes_.tolist() if hasattr(attr_DecisionTreeClassifier_n_classes_, 'tolist') else attr_DecisionTreeClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_n_features_in_ = bridgeDecisionTreeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_DecisionTreeClassifier_n_features_in_.tolist() if hasattr(attr_DecisionTreeClassifier_n_features_in_, 'tolist') else attr_DecisionTreeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_feature_names_in_ = bridgeDecisionTreeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_DecisionTreeClassifier_feature_names_in_.tolist() if hasattr(attr_DecisionTreeClassifier_feature_names_in_, 'tolist') else attr_DecisionTreeClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_n_outputs_ = bridgeDecisionTreeClassifier[${this.id}].n_outputs_`;
      return this._py`attr_DecisionTreeClassifier_n_outputs_.tolist() if hasattr(attr_DecisionTreeClassifier_n_outputs_, 'tolist') else attr_DecisionTreeClassifier_n_outputs_`;
    })();
  }
  /**
    The underlying Tree object. Please refer to `help(sklearn.tree.\_tree.Tree)` for attributes of Tree object and [Understanding the decision tree structure](../../auto_examples/tree/plot_unveil_tree_structure.html#sphx-glr-auto-examples-tree-plot-unveil-tree-structure-py) for basic usage of these attributes.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeClassifier must call init() before accessing tree_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeClassifier_tree_ = bridgeDecisionTreeClassifier[${this.id}].tree_`;
      return this._py`attr_DecisionTreeClassifier_tree_.tolist() if hasattr(attr_DecisionTreeClassifier_tree_, 'tolist') else attr_DecisionTreeClassifier_tree_`;
    })();
  }
};

// src/generated/tree/DecisionTreeRegressor.ts
import crypto257 from "node:crypto";
var DecisionTreeRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DecisionTreeRegressor${crypto257.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DecisionTreeRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.tree import DecisionTreeRegressor
try: bridgeDecisionTreeRegressor
except NameError: bridgeDecisionTreeRegressor = {}
`;
    await this._py.ex`ctor_DecisionTreeRegressor = {'criterion': ${this.opts["criterion"] ?? void 0}, 'splitter': ${this.opts["splitter"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_DecisionTreeRegressor = {k: v for k, v in ctor_DecisionTreeRegressor.items() if v is not None}`;
    await this._py.ex`bridgeDecisionTreeRegressor[${this.id}] = DecisionTreeRegressor(**ctor_DecisionTreeRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDecisionTreeRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the index of the leaf that each sample is predicted as.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeRegressor must call init() before apply()");
    }
    await this._py.ex`pms_DecisionTreeRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeRegressor_apply = {k: v for k, v in pms_DecisionTreeRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_apply = bridgeDecisionTreeRegressor[${this.id}].apply(**pms_DecisionTreeRegressor_apply)`;
    return this._py`res_DecisionTreeRegressor_apply.tolist() if hasattr(res_DecisionTreeRegressor_apply, 'tolist') else res_DecisionTreeRegressor_apply`;
  }
  /**
      Compute the pruning path during Minimal Cost-Complexity Pruning.
  
      See [Minimal Cost-Complexity Pruning](../tree.html#minimal-cost-complexity-pruning) for details on the pruning process.
     */
  async cost_complexity_pruning_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before cost_complexity_pruning_path()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_cost_complexity_pruning_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DecisionTreeRegressor_cost_complexity_pruning_path = {k: v for k, v in pms_DecisionTreeRegressor_cost_complexity_pruning_path.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_cost_complexity_pruning_path = bridgeDecisionTreeRegressor[${this.id}].cost_complexity_pruning_path(**pms_DecisionTreeRegressor_cost_complexity_pruning_path)`;
    return this._py`res_DecisionTreeRegressor_cost_complexity_pruning_path.tolist() if hasattr(res_DecisionTreeRegressor_cost_complexity_pruning_path, 'tolist') else res_DecisionTreeRegressor_cost_complexity_pruning_path`;
  }
  /**
    Return the decision path in the tree.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeRegressor_decision_path = {k: v for k, v in pms_DecisionTreeRegressor_decision_path.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_decision_path = bridgeDecisionTreeRegressor[${this.id}].decision_path(**pms_DecisionTreeRegressor_decision_path)`;
    return this._py`res_DecisionTreeRegressor_decision_path.tolist() if hasattr(res_DecisionTreeRegressor_decision_path, 'tolist') else res_DecisionTreeRegressor_decision_path`;
  }
  /**
    Build a decision tree regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeRegressor must call init() before fit()");
    }
    await this._py.ex`pms_DecisionTreeRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeRegressor_fit = {k: v for k, v in pms_DecisionTreeRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_fit = bridgeDecisionTreeRegressor[${this.id}].fit(**pms_DecisionTreeRegressor_fit)`;
    return this._py`res_DecisionTreeRegressor_fit.tolist() if hasattr(res_DecisionTreeRegressor_fit, 'tolist') else res_DecisionTreeRegressor_fit`;
  }
  /**
      Return the depth of the decision tree.
  
      The depth of a tree is the maximum distance between the root and any leaf.
     */
  async get_depth(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before get_depth()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_get_depth = {}

pms_DecisionTreeRegressor_get_depth = {k: v for k, v in pms_DecisionTreeRegressor_get_depth.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_get_depth = bridgeDecisionTreeRegressor[${this.id}].get_depth(**pms_DecisionTreeRegressor_get_depth)`;
    return this._py`res_DecisionTreeRegressor_get_depth.tolist() if hasattr(res_DecisionTreeRegressor_get_depth, 'tolist') else res_DecisionTreeRegressor_get_depth`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DecisionTreeRegressor_get_metadata_routing = {k: v for k, v in pms_DecisionTreeRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_get_metadata_routing = bridgeDecisionTreeRegressor[${this.id}].get_metadata_routing(**pms_DecisionTreeRegressor_get_metadata_routing)`;
    return this._py`res_DecisionTreeRegressor_get_metadata_routing.tolist() if hasattr(res_DecisionTreeRegressor_get_metadata_routing, 'tolist') else res_DecisionTreeRegressor_get_metadata_routing`;
  }
  /**
    Return the number of leaves of the decision tree.
   */
  async get_n_leaves(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before get_n_leaves()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_get_n_leaves = {}

pms_DecisionTreeRegressor_get_n_leaves = {k: v for k, v in pms_DecisionTreeRegressor_get_n_leaves.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_get_n_leaves = bridgeDecisionTreeRegressor[${this.id}].get_n_leaves(**pms_DecisionTreeRegressor_get_n_leaves)`;
    return this._py`res_DecisionTreeRegressor_get_n_leaves.tolist() if hasattr(res_DecisionTreeRegressor_get_n_leaves, 'tolist') else res_DecisionTreeRegressor_get_n_leaves`;
  }
  /**
      Predict class or regression value for X.
  
      For a classification model, the predicted class for each sample in X is returned. For a regression model, the predicted value based on X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeRegressor must call init() before predict()");
    }
    await this._py.ex`pms_DecisionTreeRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeRegressor_predict = {k: v for k, v in pms_DecisionTreeRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_predict = bridgeDecisionTreeRegressor[${this.id}].predict(**pms_DecisionTreeRegressor_predict)`;
    return this._py`res_DecisionTreeRegressor_predict.tolist() if hasattr(res_DecisionTreeRegressor_predict, 'tolist') else res_DecisionTreeRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DecisionTreeRegressor must call init() before score()");
    }
    await this._py.ex`pms_DecisionTreeRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DecisionTreeRegressor_score = {k: v for k, v in pms_DecisionTreeRegressor_score.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_score = bridgeDecisionTreeRegressor[${this.id}].score(**pms_DecisionTreeRegressor_score)`;
    return this._py`res_DecisionTreeRegressor_score.tolist() if hasattr(res_DecisionTreeRegressor_score, 'tolist') else res_DecisionTreeRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DecisionTreeRegressor_set_fit_request = {k: v for k, v in pms_DecisionTreeRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_set_fit_request = bridgeDecisionTreeRegressor[${this.id}].set_fit_request(**pms_DecisionTreeRegressor_set_fit_request)`;
    return this._py`res_DecisionTreeRegressor_set_fit_request.tolist() if hasattr(res_DecisionTreeRegressor_set_fit_request, 'tolist') else res_DecisionTreeRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_set_predict_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_DecisionTreeRegressor_set_predict_request = {k: v for k, v in pms_DecisionTreeRegressor_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_set_predict_request = bridgeDecisionTreeRegressor[${this.id}].set_predict_request(**pms_DecisionTreeRegressor_set_predict_request)`;
    return this._py`res_DecisionTreeRegressor_set_predict_request.tolist() if hasattr(res_DecisionTreeRegressor_set_predict_request, 'tolist') else res_DecisionTreeRegressor_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DecisionTreeRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DecisionTreeRegressor_set_score_request = {k: v for k, v in pms_DecisionTreeRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DecisionTreeRegressor_set_score_request = bridgeDecisionTreeRegressor[${this.id}].set_score_request(**pms_DecisionTreeRegressor_set_score_request)`;
    return this._py`res_DecisionTreeRegressor_set_score_request.tolist() if hasattr(res_DecisionTreeRegressor_set_score_request, 'tolist') else res_DecisionTreeRegressor_set_score_request`;
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeRegressor_max_features_ = bridgeDecisionTreeRegressor[${this.id}].max_features_`;
      return this._py`attr_DecisionTreeRegressor_max_features_.tolist() if hasattr(attr_DecisionTreeRegressor_max_features_, 'tolist') else attr_DecisionTreeRegressor_max_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeRegressor_n_features_in_ = bridgeDecisionTreeRegressor[${this.id}].n_features_in_`;
      return this._py`attr_DecisionTreeRegressor_n_features_in_.tolist() if hasattr(attr_DecisionTreeRegressor_n_features_in_, 'tolist') else attr_DecisionTreeRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeRegressor_feature_names_in_ = bridgeDecisionTreeRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_DecisionTreeRegressor_feature_names_in_.tolist() if hasattr(attr_DecisionTreeRegressor_feature_names_in_, 'tolist') else attr_DecisionTreeRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeRegressor_n_outputs_ = bridgeDecisionTreeRegressor[${this.id}].n_outputs_`;
      return this._py`attr_DecisionTreeRegressor_n_outputs_.tolist() if hasattr(attr_DecisionTreeRegressor_n_outputs_, 'tolist') else attr_DecisionTreeRegressor_n_outputs_`;
    })();
  }
  /**
    The underlying Tree object. Please refer to `help(sklearn.tree.\_tree.Tree)` for attributes of Tree object and [Understanding the decision tree structure](../../auto_examples/tree/plot_unveil_tree_structure.html#sphx-glr-auto-examples-tree-plot-unveil-tree-structure-py) for basic usage of these attributes.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error(
        "This DecisionTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DecisionTreeRegressor must call init() before accessing tree_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DecisionTreeRegressor_tree_ = bridgeDecisionTreeRegressor[${this.id}].tree_`;
      return this._py`attr_DecisionTreeRegressor_tree_.tolist() if hasattr(attr_DecisionTreeRegressor_tree_, 'tolist') else attr_DecisionTreeRegressor_tree_`;
    })();
  }
};

// src/generated/tree/ExtraTreeClassifier.ts
import crypto258 from "node:crypto";
var ExtraTreeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExtraTreeClassifier${crypto258.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreeClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.tree import ExtraTreeClassifier
try: bridgeExtraTreeClassifier
except NameError: bridgeExtraTreeClassifier = {}
`;
    await this._py.ex`ctor_ExtraTreeClassifier = {'criterion': ${this.opts["criterion"] ?? void 0}, 'splitter': ${this.opts["splitter"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_ExtraTreeClassifier = {k: v for k, v in ctor_ExtraTreeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreeClassifier[${this.id}] = ExtraTreeClassifier(**ctor_ExtraTreeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the index of the leaf that each sample is predicted as.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeClassifier must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreeClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_apply = {k: v for k, v in pms_ExtraTreeClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_apply = bridgeExtraTreeClassifier[${this.id}].apply(**pms_ExtraTreeClassifier_apply)`;
    return this._py`res_ExtraTreeClassifier_apply.tolist() if hasattr(res_ExtraTreeClassifier_apply, 'tolist') else res_ExtraTreeClassifier_apply`;
  }
  /**
      Compute the pruning path during Minimal Cost-Complexity Pruning.
  
      See [Minimal Cost-Complexity Pruning](../tree.html#minimal-cost-complexity-pruning) for details on the pruning process.
     */
  async cost_complexity_pruning_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before cost_complexity_pruning_path()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_cost_complexity_pruning_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreeClassifier_cost_complexity_pruning_path = {k: v for k, v in pms_ExtraTreeClassifier_cost_complexity_pruning_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_cost_complexity_pruning_path = bridgeExtraTreeClassifier[${this.id}].cost_complexity_pruning_path(**pms_ExtraTreeClassifier_cost_complexity_pruning_path)`;
    return this._py`res_ExtraTreeClassifier_cost_complexity_pruning_path.tolist() if hasattr(res_ExtraTreeClassifier_cost_complexity_pruning_path, 'tolist') else res_ExtraTreeClassifier_cost_complexity_pruning_path`;
  }
  /**
    Return the decision path in the tree.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_decision_path = {k: v for k, v in pms_ExtraTreeClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_decision_path = bridgeExtraTreeClassifier[${this.id}].decision_path(**pms_ExtraTreeClassifier_decision_path)`;
    return this._py`res_ExtraTreeClassifier_decision_path.tolist() if hasattr(res_ExtraTreeClassifier_decision_path, 'tolist') else res_ExtraTreeClassifier_decision_path`;
  }
  /**
    Build a decision tree classifier from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_fit = {k: v for k, v in pms_ExtraTreeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_fit = bridgeExtraTreeClassifier[${this.id}].fit(**pms_ExtraTreeClassifier_fit)`;
    return this._py`res_ExtraTreeClassifier_fit.tolist() if hasattr(res_ExtraTreeClassifier_fit, 'tolist') else res_ExtraTreeClassifier_fit`;
  }
  /**
      Return the depth of the decision tree.
  
      The depth of a tree is the maximum distance between the root and any leaf.
     */
  async get_depth(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeClassifier must call init() before get_depth()");
    }
    await this._py.ex`pms_ExtraTreeClassifier_get_depth = {}

pms_ExtraTreeClassifier_get_depth = {k: v for k, v in pms_ExtraTreeClassifier_get_depth.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_get_depth = bridgeExtraTreeClassifier[${this.id}].get_depth(**pms_ExtraTreeClassifier_get_depth)`;
    return this._py`res_ExtraTreeClassifier_get_depth.tolist() if hasattr(res_ExtraTreeClassifier_get_depth, 'tolist') else res_ExtraTreeClassifier_get_depth`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreeClassifier_get_metadata_routing = {k: v for k, v in pms_ExtraTreeClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_get_metadata_routing = bridgeExtraTreeClassifier[${this.id}].get_metadata_routing(**pms_ExtraTreeClassifier_get_metadata_routing)`;
    return this._py`res_ExtraTreeClassifier_get_metadata_routing.tolist() if hasattr(res_ExtraTreeClassifier_get_metadata_routing, 'tolist') else res_ExtraTreeClassifier_get_metadata_routing`;
  }
  /**
    Return the number of leaves of the decision tree.
   */
  async get_n_leaves(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before get_n_leaves()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_get_n_leaves = {}

pms_ExtraTreeClassifier_get_n_leaves = {k: v for k, v in pms_ExtraTreeClassifier_get_n_leaves.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_get_n_leaves = bridgeExtraTreeClassifier[${this.id}].get_n_leaves(**pms_ExtraTreeClassifier_get_n_leaves)`;
    return this._py`res_ExtraTreeClassifier_get_n_leaves.tolist() if hasattr(res_ExtraTreeClassifier_get_n_leaves, 'tolist') else res_ExtraTreeClassifier_get_n_leaves`;
  }
  /**
      Predict class or regression value for X.
  
      For a classification model, the predicted class for each sample in X is returned. For a regression model, the predicted value based on X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeClassifier must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_predict = {k: v for k, v in pms_ExtraTreeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_predict = bridgeExtraTreeClassifier[${this.id}].predict(**pms_ExtraTreeClassifier_predict)`;
    return this._py`res_ExtraTreeClassifier_predict.tolist() if hasattr(res_ExtraTreeClassifier_predict, 'tolist') else res_ExtraTreeClassifier_predict`;
  }
  /**
    Predict class log-probabilities of the input samples X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreeClassifier_predict_log_proba = {k: v for k, v in pms_ExtraTreeClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_predict_log_proba = bridgeExtraTreeClassifier[${this.id}].predict_log_proba(**pms_ExtraTreeClassifier_predict_log_proba)`;
    return this._py`res_ExtraTreeClassifier_predict_log_proba.tolist() if hasattr(res_ExtraTreeClassifier_predict_log_proba, 'tolist') else res_ExtraTreeClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities of the input samples X.
  
      The predicted class probability is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_predict_proba = {k: v for k, v in pms_ExtraTreeClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_predict_proba = bridgeExtraTreeClassifier[${this.id}].predict_proba(**pms_ExtraTreeClassifier_predict_proba)`;
    return this._py`res_ExtraTreeClassifier_predict_proba.tolist() if hasattr(res_ExtraTreeClassifier_predict_proba, 'tolist') else res_ExtraTreeClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeClassifier must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreeClassifier_score = {k: v for k, v in pms_ExtraTreeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_score = bridgeExtraTreeClassifier[${this.id}].score(**pms_ExtraTreeClassifier_score)`;
    return this._py`res_ExtraTreeClassifier_score.tolist() if hasattr(res_ExtraTreeClassifier_score, 'tolist') else res_ExtraTreeClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreeClassifier_set_fit_request = {k: v for k, v in pms_ExtraTreeClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_set_fit_request = bridgeExtraTreeClassifier[${this.id}].set_fit_request(**pms_ExtraTreeClassifier_set_fit_request)`;
    return this._py`res_ExtraTreeClassifier_set_fit_request.tolist() if hasattr(res_ExtraTreeClassifier_set_fit_request, 'tolist') else res_ExtraTreeClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict\_proba` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_proba_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before set_predict_proba_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_set_predict_proba_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_set_predict_proba_request = {k: v for k, v in pms_ExtraTreeClassifier_set_predict_proba_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_set_predict_proba_request = bridgeExtraTreeClassifier[${this.id}].set_predict_proba_request(**pms_ExtraTreeClassifier_set_predict_proba_request)`;
    return this._py`res_ExtraTreeClassifier_set_predict_proba_request.tolist() if hasattr(res_ExtraTreeClassifier_set_predict_proba_request, 'tolist') else res_ExtraTreeClassifier_set_predict_proba_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_set_predict_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeClassifier_set_predict_request = {k: v for k, v in pms_ExtraTreeClassifier_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_set_predict_request = bridgeExtraTreeClassifier[${this.id}].set_predict_request(**pms_ExtraTreeClassifier_set_predict_request)`;
    return this._py`res_ExtraTreeClassifier_set_predict_request.tolist() if hasattr(res_ExtraTreeClassifier_set_predict_request, 'tolist') else res_ExtraTreeClassifier_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreeClassifier_set_score_request = {k: v for k, v in pms_ExtraTreeClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeClassifier_set_score_request = bridgeExtraTreeClassifier[${this.id}].set_score_request(**pms_ExtraTreeClassifier_set_score_request)`;
    return this._py`res_ExtraTreeClassifier_set_score_request.tolist() if hasattr(res_ExtraTreeClassifier_set_score_request, 'tolist') else res_ExtraTreeClassifier_set_score_request`;
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_classes_ = bridgeExtraTreeClassifier[${this.id}].classes_`;
      return this._py`attr_ExtraTreeClassifier_classes_.tolist() if hasattr(attr_ExtraTreeClassifier_classes_, 'tolist') else attr_ExtraTreeClassifier_classes_`;
    })();
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_max_features_ = bridgeExtraTreeClassifier[${this.id}].max_features_`;
      return this._py`attr_ExtraTreeClassifier_max_features_.tolist() if hasattr(attr_ExtraTreeClassifier_max_features_, 'tolist') else attr_ExtraTreeClassifier_max_features_`;
    })();
  }
  /**
    The number of classes (for single output problems), or a list containing the number of classes for each output (for multi-output problems).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_n_classes_ = bridgeExtraTreeClassifier[${this.id}].n_classes_`;
      return this._py`attr_ExtraTreeClassifier_n_classes_.tolist() if hasattr(attr_ExtraTreeClassifier_n_classes_, 'tolist') else attr_ExtraTreeClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_n_features_in_ = bridgeExtraTreeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreeClassifier_n_features_in_.tolist() if hasattr(attr_ExtraTreeClassifier_n_features_in_, 'tolist') else attr_ExtraTreeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_feature_names_in_ = bridgeExtraTreeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreeClassifier_feature_names_in_.tolist() if hasattr(attr_ExtraTreeClassifier_feature_names_in_, 'tolist') else attr_ExtraTreeClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_n_outputs_ = bridgeExtraTreeClassifier[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreeClassifier_n_outputs_.tolist() if hasattr(attr_ExtraTreeClassifier_n_outputs_, 'tolist') else attr_ExtraTreeClassifier_n_outputs_`;
    })();
  }
  /**
    The underlying Tree object. Please refer to `help(sklearn.tree.\_tree.Tree)` for attributes of Tree object and [Understanding the decision tree structure](../../auto_examples/tree/plot_unveil_tree_structure.html#sphx-glr-auto-examples-tree-plot-unveil-tree-structure-py) for basic usage of these attributes.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeClassifier must call init() before accessing tree_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeClassifier_tree_ = bridgeExtraTreeClassifier[${this.id}].tree_`;
      return this._py`attr_ExtraTreeClassifier_tree_.tolist() if hasattr(attr_ExtraTreeClassifier_tree_, 'tolist') else attr_ExtraTreeClassifier_tree_`;
    })();
  }
};

// src/generated/tree/ExtraTreeRegressor.ts
import crypto259 from "node:crypto";
var ExtraTreeRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExtraTreeRegressor${crypto259.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreeRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.tree import ExtraTreeRegressor
try: bridgeExtraTreeRegressor
except NameError: bridgeExtraTreeRegressor = {}
`;
    await this._py.ex`ctor_ExtraTreeRegressor = {'criterion': ${this.opts["criterion"] ?? void 0}, 'splitter': ${this.opts["splitter"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_ExtraTreeRegressor = {k: v for k, v in ctor_ExtraTreeRegressor.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreeRegressor[${this.id}] = ExtraTreeRegressor(**ctor_ExtraTreeRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreeRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the index of the leaf that each sample is predicted as.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeRegressor must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreeRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeRegressor_apply = {k: v for k, v in pms_ExtraTreeRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_apply = bridgeExtraTreeRegressor[${this.id}].apply(**pms_ExtraTreeRegressor_apply)`;
    return this._py`res_ExtraTreeRegressor_apply.tolist() if hasattr(res_ExtraTreeRegressor_apply, 'tolist') else res_ExtraTreeRegressor_apply`;
  }
  /**
      Compute the pruning path during Minimal Cost-Complexity Pruning.
  
      See [Minimal Cost-Complexity Pruning](../tree.html#minimal-cost-complexity-pruning) for details on the pruning process.
     */
  async cost_complexity_pruning_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before cost_complexity_pruning_path()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_cost_complexity_pruning_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreeRegressor_cost_complexity_pruning_path = {k: v for k, v in pms_ExtraTreeRegressor_cost_complexity_pruning_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_cost_complexity_pruning_path = bridgeExtraTreeRegressor[${this.id}].cost_complexity_pruning_path(**pms_ExtraTreeRegressor_cost_complexity_pruning_path)`;
    return this._py`res_ExtraTreeRegressor_cost_complexity_pruning_path.tolist() if hasattr(res_ExtraTreeRegressor_cost_complexity_pruning_path, 'tolist') else res_ExtraTreeRegressor_cost_complexity_pruning_path`;
  }
  /**
    Return the decision path in the tree.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeRegressor_decision_path = {k: v for k, v in pms_ExtraTreeRegressor_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_decision_path = bridgeExtraTreeRegressor[${this.id}].decision_path(**pms_ExtraTreeRegressor_decision_path)`;
    return this._py`res_ExtraTreeRegressor_decision_path.tolist() if hasattr(res_ExtraTreeRegressor_decision_path, 'tolist') else res_ExtraTreeRegressor_decision_path`;
  }
  /**
    Build a decision tree regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeRegressor must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreeRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeRegressor_fit = {k: v for k, v in pms_ExtraTreeRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_fit = bridgeExtraTreeRegressor[${this.id}].fit(**pms_ExtraTreeRegressor_fit)`;
    return this._py`res_ExtraTreeRegressor_fit.tolist() if hasattr(res_ExtraTreeRegressor_fit, 'tolist') else res_ExtraTreeRegressor_fit`;
  }
  /**
      Return the depth of the decision tree.
  
      The depth of a tree is the maximum distance between the root and any leaf.
     */
  async get_depth(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeRegressor must call init() before get_depth()");
    }
    await this._py.ex`pms_ExtraTreeRegressor_get_depth = {}

pms_ExtraTreeRegressor_get_depth = {k: v for k, v in pms_ExtraTreeRegressor_get_depth.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_get_depth = bridgeExtraTreeRegressor[${this.id}].get_depth(**pms_ExtraTreeRegressor_get_depth)`;
    return this._py`res_ExtraTreeRegressor_get_depth.tolist() if hasattr(res_ExtraTreeRegressor_get_depth, 'tolist') else res_ExtraTreeRegressor_get_depth`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreeRegressor_get_metadata_routing = {k: v for k, v in pms_ExtraTreeRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_get_metadata_routing = bridgeExtraTreeRegressor[${this.id}].get_metadata_routing(**pms_ExtraTreeRegressor_get_metadata_routing)`;
    return this._py`res_ExtraTreeRegressor_get_metadata_routing.tolist() if hasattr(res_ExtraTreeRegressor_get_metadata_routing, 'tolist') else res_ExtraTreeRegressor_get_metadata_routing`;
  }
  /**
    Return the number of leaves of the decision tree.
   */
  async get_n_leaves(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before get_n_leaves()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_get_n_leaves = {}

pms_ExtraTreeRegressor_get_n_leaves = {k: v for k, v in pms_ExtraTreeRegressor_get_n_leaves.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_get_n_leaves = bridgeExtraTreeRegressor[${this.id}].get_n_leaves(**pms_ExtraTreeRegressor_get_n_leaves)`;
    return this._py`res_ExtraTreeRegressor_get_n_leaves.tolist() if hasattr(res_ExtraTreeRegressor_get_n_leaves, 'tolist') else res_ExtraTreeRegressor_get_n_leaves`;
  }
  /**
      Predict class or regression value for X.
  
      For a classification model, the predicted class for each sample in X is returned. For a regression model, the predicted value based on X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeRegressor must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreeRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeRegressor_predict = {k: v for k, v in pms_ExtraTreeRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_predict = bridgeExtraTreeRegressor[${this.id}].predict(**pms_ExtraTreeRegressor_predict)`;
    return this._py`res_ExtraTreeRegressor_predict.tolist() if hasattr(res_ExtraTreeRegressor_predict, 'tolist') else res_ExtraTreeRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreeRegressor must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreeRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreeRegressor_score = {k: v for k, v in pms_ExtraTreeRegressor_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_score = bridgeExtraTreeRegressor[${this.id}].score(**pms_ExtraTreeRegressor_score)`;
    return this._py`res_ExtraTreeRegressor_score.tolist() if hasattr(res_ExtraTreeRegressor_score, 'tolist') else res_ExtraTreeRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreeRegressor_set_fit_request = {k: v for k, v in pms_ExtraTreeRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_set_fit_request = bridgeExtraTreeRegressor[${this.id}].set_fit_request(**pms_ExtraTreeRegressor_set_fit_request)`;
    return this._py`res_ExtraTreeRegressor_set_fit_request.tolist() if hasattr(res_ExtraTreeRegressor_set_fit_request, 'tolist') else res_ExtraTreeRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_set_predict_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_ExtraTreeRegressor_set_predict_request = {k: v for k, v in pms_ExtraTreeRegressor_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_set_predict_request = bridgeExtraTreeRegressor[${this.id}].set_predict_request(**pms_ExtraTreeRegressor_set_predict_request)`;
    return this._py`res_ExtraTreeRegressor_set_predict_request.tolist() if hasattr(res_ExtraTreeRegressor_set_predict_request, 'tolist') else res_ExtraTreeRegressor_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreeRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreeRegressor_set_score_request = {k: v for k, v in pms_ExtraTreeRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreeRegressor_set_score_request = bridgeExtraTreeRegressor[${this.id}].set_score_request(**pms_ExtraTreeRegressor_set_score_request)`;
    return this._py`res_ExtraTreeRegressor_set_score_request.tolist() if hasattr(res_ExtraTreeRegressor_set_score_request, 'tolist') else res_ExtraTreeRegressor_set_score_request`;
  }
  /**
    The inferred value of max\_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeRegressor_max_features_ = bridgeExtraTreeRegressor[${this.id}].max_features_`;
      return this._py`attr_ExtraTreeRegressor_max_features_.tolist() if hasattr(attr_ExtraTreeRegressor_max_features_, 'tolist') else attr_ExtraTreeRegressor_max_features_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeRegressor_n_features_in_ = bridgeExtraTreeRegressor[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreeRegressor_n_features_in_.tolist() if hasattr(attr_ExtraTreeRegressor_n_features_in_, 'tolist') else attr_ExtraTreeRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeRegressor_feature_names_in_ = bridgeExtraTreeRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreeRegressor_feature_names_in_.tolist() if hasattr(attr_ExtraTreeRegressor_feature_names_in_, 'tolist') else attr_ExtraTreeRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeRegressor_n_outputs_ = bridgeExtraTreeRegressor[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreeRegressor_n_outputs_.tolist() if hasattr(attr_ExtraTreeRegressor_n_outputs_, 'tolist') else attr_ExtraTreeRegressor_n_outputs_`;
    })();
  }
  /**
    The underlying Tree object. Please refer to `help(sklearn.tree.\_tree.Tree)` for attributes of Tree object and [Understanding the decision tree structure](../../auto_examples/tree/plot_unveil_tree_structure.html#sphx-glr-auto-examples-tree-plot-unveil-tree-structure-py) for basic usage of these attributes.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreeRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreeRegressor must call init() before accessing tree_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreeRegressor_tree_ = bridgeExtraTreeRegressor[${this.id}].tree_`;
      return this._py`attr_ExtraTreeRegressor_tree_.tolist() if hasattr(attr_ExtraTreeRegressor_tree_, 'tolist') else attr_ExtraTreeRegressor_tree_`;
    })();
  }
};

// src/generated/utils/Bunch.ts
import crypto260 from "node:crypto";
var Bunch = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Bunch${crypto260.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Bunch.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.utils import Bunch
try: bridgeBunch
except NameError: bridgeBunch = {}
`;
    await this._py.ex`ctor_Bunch = {}

ctor_Bunch = {k: v for k, v in ctor_Bunch.items() if v is not None}`;
    await this._py.ex`bridgeBunch[${this.id}] = Bunch(**ctor_Bunch)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBunch[${this.id}]`;
    this._isDisposed = true;
  }
  async clear(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before clear()");
    }
    await this._py.ex`pms_Bunch_clear = {}

pms_Bunch_clear = {k: v for k, v in pms_Bunch_clear.items() if v is not None}`;
    await this._py.ex`res_Bunch_clear = bridgeBunch[${this.id}].clear(**pms_Bunch_clear)`;
    return this._py`res_Bunch_clear.tolist() if hasattr(res_Bunch_clear, 'tolist') else res_Bunch_clear`;
  }
  async copy(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before copy()");
    }
    await this._py.ex`pms_Bunch_copy = {}

pms_Bunch_copy = {k: v for k, v in pms_Bunch_copy.items() if v is not None}`;
    await this._py.ex`res_Bunch_copy = bridgeBunch[${this.id}].copy(**pms_Bunch_copy)`;
    return this._py`res_Bunch_copy.tolist() if hasattr(res_Bunch_copy, 'tolist') else res_Bunch_copy`;
  }
  /**
    Create a new dictionary with keys from iterable and values set to value.
   */
  async fromkeys(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before fromkeys()");
    }
    await this._py.ex`pms_Bunch_fromkeys = {}

pms_Bunch_fromkeys = {k: v for k, v in pms_Bunch_fromkeys.items() if v is not None}`;
    await this._py.ex`res_Bunch_fromkeys = bridgeBunch[${this.id}].fromkeys(**pms_Bunch_fromkeys)`;
    return this._py`res_Bunch_fromkeys.tolist() if hasattr(res_Bunch_fromkeys, 'tolist') else res_Bunch_fromkeys`;
  }
  /**
    Return the value for key if key is in the dictionary, else default.
   */
  async get(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before get()");
    }
    await this._py.ex`pms_Bunch_get = {}

pms_Bunch_get = {k: v for k, v in pms_Bunch_get.items() if v is not None}`;
    await this._py.ex`res_Bunch_get = bridgeBunch[${this.id}].get(**pms_Bunch_get)`;
    return this._py`res_Bunch_get.tolist() if hasattr(res_Bunch_get, 'tolist') else res_Bunch_get`;
  }
  async items(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before items()");
    }
    await this._py.ex`pms_Bunch_items = {}

pms_Bunch_items = {k: v for k, v in pms_Bunch_items.items() if v is not None}`;
    await this._py.ex`res_Bunch_items = bridgeBunch[${this.id}].items(**pms_Bunch_items)`;
    return this._py`res_Bunch_items.tolist() if hasattr(res_Bunch_items, 'tolist') else res_Bunch_items`;
  }
  async keys(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before keys()");
    }
    await this._py.ex`pms_Bunch_keys = {}

pms_Bunch_keys = {k: v for k, v in pms_Bunch_keys.items() if v is not None}`;
    await this._py.ex`res_Bunch_keys = bridgeBunch[${this.id}].keys(**pms_Bunch_keys)`;
    return this._py`res_Bunch_keys.tolist() if hasattr(res_Bunch_keys, 'tolist') else res_Bunch_keys`;
  }
  /**
    If key is not found, default is returned if given, otherwise KeyError is raised
   */
  async pop(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before pop()");
    }
    await this._py.ex`pms_Bunch_pop = {}

pms_Bunch_pop = {k: v for k, v in pms_Bunch_pop.items() if v is not None}`;
    await this._py.ex`res_Bunch_pop = bridgeBunch[${this.id}].pop(**pms_Bunch_pop)`;
    return this._py`res_Bunch_pop.tolist() if hasattr(res_Bunch_pop, 'tolist') else res_Bunch_pop`;
  }
  /**
      Remove and return a (key, value) pair as a 2-tuple.
  
      Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.
     */
  async popitem(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before popitem()");
    }
    await this._py.ex`pms_Bunch_popitem = {}

pms_Bunch_popitem = {k: v for k, v in pms_Bunch_popitem.items() if v is not None}`;
    await this._py.ex`res_Bunch_popitem = bridgeBunch[${this.id}].popitem(**pms_Bunch_popitem)`;
    return this._py`res_Bunch_popitem.tolist() if hasattr(res_Bunch_popitem, 'tolist') else res_Bunch_popitem`;
  }
  /**
      Insert key with a value of default if key is not in the dictionary.
  
      Return the value for key if key is in the dictionary, else default.
     */
  async setdefault(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before setdefault()");
    }
    await this._py.ex`pms_Bunch_setdefault = {}

pms_Bunch_setdefault = {k: v for k, v in pms_Bunch_setdefault.items() if v is not None}`;
    await this._py.ex`res_Bunch_setdefault = bridgeBunch[${this.id}].setdefault(**pms_Bunch_setdefault)`;
    return this._py`res_Bunch_setdefault.tolist() if hasattr(res_Bunch_setdefault, 'tolist') else res_Bunch_setdefault`;
  }
  /**
    If E is present and has a .keys() method, then does: for k in E: D\[k\] = E\[k\] If E is present and lacks a .keys() method, then does: for k, v in E: D\[k\] = v In either case, this is followed by: for k in F: D\[k\] = F\[k\]
   */
  async update(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before update()");
    }
    await this._py.ex`pms_Bunch_update = {}

pms_Bunch_update = {k: v for k, v in pms_Bunch_update.items() if v is not None}`;
    await this._py.ex`res_Bunch_update = bridgeBunch[${this.id}].update(**pms_Bunch_update)`;
    return this._py`res_Bunch_update.tolist() if hasattr(res_Bunch_update, 'tolist') else res_Bunch_update`;
  }
  async values(opts) {
    if (this._isDisposed) {
      throw new Error("This Bunch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Bunch must call init() before values()");
    }
    await this._py.ex`pms_Bunch_values = {}

pms_Bunch_values = {k: v for k, v in pms_Bunch_values.items() if v is not None}`;
    await this._py.ex`res_Bunch_values = bridgeBunch[${this.id}].values(**pms_Bunch_values)`;
    return this._py`res_Bunch_values.tolist() if hasattr(res_Bunch_values, 'tolist') else res_Bunch_values`;
  }
};

// src/generated/utils/parallel/Parallel.ts
import crypto261 from "node:crypto";
var Parallel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Parallel${crypto261.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Parallel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Parallel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.utils.parallel import Parallel
try: bridgeParallel
except NameError: bridgeParallel = {}
`;
    await this._py.ex`ctor_Parallel = {}

ctor_Parallel = {k: v for k, v in ctor_Parallel.items() if v is not None}`;
    await this._py.ex`bridgeParallel[${this.id}] = Parallel(**ctor_Parallel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeParallel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Dispatch more data for parallel processing
  
      This method is meant to be called concurrently by the multiprocessing callback. We rely on the thread-safety of dispatch\_one\_batch to protect against concurrent consumption of the unprotected iterator.
     */
  async dispatch_next(opts) {
    if (this._isDisposed) {
      throw new Error("This Parallel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Parallel must call init() before dispatch_next()");
    }
    await this._py.ex`pms_Parallel_dispatch_next = {}

pms_Parallel_dispatch_next = {k: v for k, v in pms_Parallel_dispatch_next.items() if v is not None}`;
    await this._py.ex`res_Parallel_dispatch_next = bridgeParallel[${this.id}].dispatch_next(**pms_Parallel_dispatch_next)`;
    return this._py`res_Parallel_dispatch_next.tolist() if hasattr(res_Parallel_dispatch_next, 'tolist') else res_Parallel_dispatch_next`;
  }
  /**
      Prefetch the tasks for the next batch and dispatch them.
  
      The effective size of the batch is computed here. If there are no more jobs to dispatch, return `false`, else return `true`.
  
      The iterator consumption and dispatching is protected by the same lock so calling this function should be thread safe.
     */
  async dispatch_one_batch(opts) {
    if (this._isDisposed) {
      throw new Error("This Parallel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Parallel must call init() before dispatch_one_batch()");
    }
    await this._py.ex`pms_Parallel_dispatch_one_batch = {}

pms_Parallel_dispatch_one_batch = {k: v for k, v in pms_Parallel_dispatch_one_batch.items() if v is not None}`;
    await this._py.ex`res_Parallel_dispatch_one_batch = bridgeParallel[${this.id}].dispatch_one_batch(**pms_Parallel_dispatch_one_batch)`;
    return this._py`res_Parallel_dispatch_one_batch.tolist() if hasattr(res_Parallel_dispatch_one_batch, 'tolist') else res_Parallel_dispatch_one_batch`;
  }
  /**
    Return the formatted representation of the object.
   */
  async format(opts) {
    if (this._isDisposed) {
      throw new Error("This Parallel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Parallel must call init() before format()");
    }
    await this._py.ex`pms_Parallel_format = {}

pms_Parallel_format = {k: v for k, v in pms_Parallel_format.items() if v is not None}`;
    await this._py.ex`res_Parallel_format = bridgeParallel[${this.id}].format(**pms_Parallel_format)`;
    return this._py`res_Parallel_format.tolist() if hasattr(res_Parallel_format, 'tolist') else res_Parallel_format`;
  }
  /**
    Display the process of the parallel execution only a fraction of time, controlled by self.verbose.
   */
  async print_progress(opts) {
    if (this._isDisposed) {
      throw new Error("This Parallel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Parallel must call init() before print_progress()");
    }
    await this._py.ex`pms_Parallel_print_progress = {}

pms_Parallel_print_progress = {k: v for k, v in pms_Parallel_print_progress.items() if v is not None}`;
    await this._py.ex`res_Parallel_print_progress = bridgeParallel[${this.id}].print_progress(**pms_Parallel_print_progress)`;
    return this._py`res_Parallel_print_progress.tolist() if hasattr(res_Parallel_print_progress, 'tolist') else res_Parallel_print_progress`;
  }
};
export {
  ARDRegression,
  AdaBoostClassifier,
  AdaBoostRegressor,
  AdditiveChi2Sampler,
  AffinityPropagation,
  AgglomerativeClustering,
  BaggingClassifier,
  BaggingRegressor,
  BallTree,
  BayesianGaussianMixture,
  BayesianRidge,
  BernoulliNB,
  BernoulliRBM,
  Binarizer,
  Birch,
  BisectingKMeans,
  Bunch,
  CCA,
  CalibratedClassifierCV,
  CalibrationDisplay,
  CategoricalNB,
  ClassifierChain,
  ColumnTransformer,
  ComplementNB,
  CompoundKernel,
  ConfusionMatrixDisplay,
  ConstantKernel,
  ConvergenceWarning,
  CountVectorizer,
  DBSCAN,
  DataConversionWarning,
  DataDimensionalityWarning,
  DecisionBoundaryDisplay,
  DecisionTreeClassifier,
  DecisionTreeRegressor,
  DetCurveDisplay,
  DictVectorizer,
  DictionaryLearning,
  DistanceMetric,
  DotProduct,
  DummyClassifier,
  DummyRegressor,
  EfficiencyWarning,
  ElasticNet,
  ElasticNetCV,
  EllipticEnvelope,
  EmpiricalCovariance,
  ExpSineSquared,
  Exponentiation,
  ExtraTreeClassifier,
  ExtraTreeRegressor,
  ExtraTreesClassifier,
  ExtraTreesRegressor,
  FactorAnalysis,
  FastICA,
  FeatureAgglomeration,
  FeatureHasher,
  FeatureUnion,
  FitFailedWarning,
  FunctionTransformer,
  GammaRegressor,
  GaussianMixture,
  GaussianNB,
  GaussianProcessClassifier,
  GaussianProcessRegressor,
  GaussianRandomProjection,
  GenericUnivariateSelect,
  GradientBoostingClassifier,
  GradientBoostingRegressor,
  GraphicalLasso,
  GraphicalLassoCV,
  GridSearchCV,
  GroupKFold,
  GroupShuffleSplit,
  HDBSCAN,
  HalvingGridSearchCV,
  HalvingRandomSearchCV,
  HashingVectorizer,
  HistGradientBoostingClassifier,
  HistGradientBoostingRegressor,
  HuberRegressor,
  Hyperparameter,
  InconsistentVersionWarning,
  IncrementalPCA,
  IsolationForest,
  Isomap,
  IsotonicRegression,
  IterativeImputer,
  KBinsDiscretizer,
  KDTree,
  KFold,
  KMeans,
  KNNImputer,
  KNeighborsClassifier,
  KNeighborsRegressor,
  KNeighborsTransformer,
  Kernel,
  KernelCenterer,
  KernelDensity,
  KernelPCA,
  KernelRidge,
  LabelBinarizer,
  LabelEncoder,
  LabelPropagation,
  LabelSpreading,
  Lars,
  LarsCV,
  Lasso,
  LassoCV,
  LassoLars,
  LassoLarsCV,
  LassoLarsIC,
  LatentDirichletAllocation,
  LearningCurveDisplay,
  LeaveOneGroupOut,
  LeaveOneOut,
  LeavePGroupsOut,
  LeavePOut,
  LedoitWolf,
  LinearDiscriminantAnalysis,
  LinearRegression,
  LinearSVC,
  LinearSVR,
  LocalOutlierFactor,
  LocallyLinearEmbedding,
  LogisticRegression,
  LogisticRegressionCV,
  MDS,
  MLPClassifier,
  MLPRegressor,
  Matern,
  MaxAbsScaler,
  MeanShift,
  MinCovDet,
  MinMaxScaler,
  MiniBatchDictionaryLearning,
  MiniBatchKMeans,
  MiniBatchNMF,
  MiniBatchSparsePCA,
  MissingIndicator,
  MultiLabelBinarizer,
  MultiOutputClassifier,
  MultiOutputRegressor,
  MultiTaskElasticNet,
  MultiTaskElasticNetCV,
  MultiTaskLasso,
  MultiTaskLassoCV,
  MultinomialNB,
  NMF,
  NearestCentroid,
  NearestNeighbors,
  NeighborhoodComponentsAnalysis,
  Normalizer,
  NotFittedError,
  NuSVC,
  NuSVR,
  Nystroem,
  OAS,
  OPTICS,
  OneClassSVM,
  OneHotEncoder,
  OneVsOneClassifier,
  OneVsRestClassifier,
  OrdinalEncoder,
  OrthogonalMatchingPursuit,
  OrthogonalMatchingPursuitCV,
  OutputCodeClassifier,
  PCA,
  PLSCanonical,
  PLSRegression,
  PLSSVD,
  PairwiseKernel,
  Parallel,
  ParameterGrid,
  ParameterSampler,
  PartialDependenceDisplay,
  PassiveAggressiveClassifier,
  PatchExtractor,
  Perceptron,
  Pipeline,
  PoissonRegressor,
  PolynomialCountSketch,
  PolynomialFeatures,
  PowerTransformer,
  PrecisionRecallDisplay,
  PredefinedSplit,
  PredictionErrorDisplay,
  Product,
  QuadraticDiscriminantAnalysis,
  QuantileRegressor,
  QuantileTransformer,
  RANSACRegressor,
  RBF,
  RBFSampler,
  RFE,
  RFECV,
  RadiusNeighborsClassifier,
  RadiusNeighborsRegressor,
  RadiusNeighborsTransformer,
  RandomForestClassifier,
  RandomForestRegressor,
  RandomTreesEmbedding,
  RandomizedSearchCV,
  RationalQuadratic,
  RegressorChain,
  RepeatedKFold,
  RepeatedStratifiedKFold,
  Ridge,
  RidgeCV,
  RidgeClassifier,
  RidgeClassifierCV,
  RobustScaler,
  RocCurveDisplay,
  SGDClassifier,
  SGDOneClassSVM,
  SGDRegressor,
  SVC,
  SVR,
  SelectFdr,
  SelectFpr,
  SelectFromModel,
  SelectFwe,
  SelectKBest,
  SelectPercentile,
  SelectorMixin,
  SelfTrainingClassifier,
  SequentialFeatureSelector,
  ShrunkCovariance,
  ShuffleSplit,
  SimpleImputer,
  SkewedChi2Sampler,
  SparseCoder,
  SparsePCA,
  SparseRandomProjection,
  SpectralBiclustering,
  SpectralClustering,
  SpectralCoclustering,
  SpectralEmbedding,
  SplineTransformer,
  StackingClassifier,
  StackingRegressor,
  StandardScaler,
  StratifiedGroupKFold,
  StratifiedKFold,
  StratifiedShuffleSplit,
  Sum,
  TSNE,
  TargetEncoder,
  TfidfTransformer,
  TfidfVectorizer,
  TheilSenRegressor,
  TimeSeriesSplit,
  TransformedTargetRegressor,
  TruncatedSVD,
  TweedieRegressor,
  UndefinedMetricWarning,
  ValidationCurveDisplay,
  VarianceThreshold,
  VotingClassifier,
  VotingRegressor,
  WhiteKernel
};
//# sourceMappingURL=index.js.map