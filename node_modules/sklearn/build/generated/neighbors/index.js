// src/generated/neighbors/BallTree.ts
import crypto from "node:crypto";
var BallTree = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BallTree${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BallTree.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import BallTree
try: bridgeBallTree
except NameError: bridgeBallTree = {}
`;
    await this._py.ex`ctor_BallTree = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}}

ctor_BallTree = {k: v for k, v in ctor_BallTree.items() if v is not None}`;
    await this._py.ex`bridgeBallTree[${this.id}] = BallTree(**ctor_BallTree)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBallTree[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Get data and node arrays.
   */
  async get_arrays(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_arrays()");
    }
    await this._py.ex`pms_BallTree_get_arrays = {}

pms_BallTree_get_arrays = {k: v for k, v in pms_BallTree_get_arrays.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_arrays = bridgeBallTree[${this.id}].get_arrays(**pms_BallTree_get_arrays)`;
    return this._py`res_BallTree_get_arrays.tolist() if hasattr(res_BallTree_get_arrays, 'tolist') else res_BallTree_get_arrays`;
  }
  /**
    Get number of calls.
   */
  async get_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_n_calls()");
    }
    await this._py.ex`pms_BallTree_get_n_calls = {}

pms_BallTree_get_n_calls = {k: v for k, v in pms_BallTree_get_n_calls.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_n_calls = bridgeBallTree[${this.id}].get_n_calls(**pms_BallTree_get_n_calls)`;
    return this._py`res_BallTree_get_n_calls.tolist() if hasattr(res_BallTree_get_n_calls, 'tolist') else res_BallTree_get_n_calls`;
  }
  /**
    Get tree status.
   */
  async get_tree_stats(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before get_tree_stats()");
    }
    await this._py.ex`pms_BallTree_get_tree_stats = {}

pms_BallTree_get_tree_stats = {k: v for k, v in pms_BallTree_get_tree_stats.items() if v is not None}`;
    await this._py.ex`res_BallTree_get_tree_stats = bridgeBallTree[${this.id}].get_tree_stats(**pms_BallTree_get_tree_stats)`;
    return this._py`res_BallTree_get_tree_stats.tolist() if hasattr(res_BallTree_get_tree_stats, 'tolist') else res_BallTree_get_tree_stats`;
  }
  /**
    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.
   */
  async kernel_density(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before kernel_density()");
    }
    await this._py.ex`pms_BallTree_kernel_density = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'h': ${opts["h"] ?? void 0}, 'kernel': ${opts["kernel"] ?? void 0}, 'atol': ${opts["atol"] ?? void 0}, 'rtol': ${opts["rtol"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'return_log': ${opts["return_log"] ?? void 0}}

pms_BallTree_kernel_density = {k: v for k, v in pms_BallTree_kernel_density.items() if v is not None}`;
    await this._py.ex`res_BallTree_kernel_density = bridgeBallTree[${this.id}].kernel_density(**pms_BallTree_kernel_density)`;
    return this._py`res_BallTree_kernel_density.tolist() if hasattr(res_BallTree_kernel_density, 'tolist') else res_BallTree_kernel_density`;
  }
  /**
    query the tree for the k nearest neighbors
   */
  async query(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before query()");
    }
    await this._py.ex`pms_BallTree_query = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'k': ${opts["k"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_BallTree_query = {k: v for k, v in pms_BallTree_query.items() if v is not None}`;
    await this._py.ex`res_BallTree_query = bridgeBallTree[${this.id}].query(**pms_BallTree_query)`;
    return this._py`res_BallTree_query.tolist() if hasattr(res_BallTree_query, 'tolist') else res_BallTree_query`;
  }
  /**
    query the tree for neighbors within a radius r
   */
  async query_radius(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before query_radius()");
    }
    await this._py.ex`pms_BallTree_query_radius = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'count_only': ${opts["count_only"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_BallTree_query_radius = {k: v for k, v in pms_BallTree_query_radius.items() if v is not None}`;
    await this._py.ex`res_BallTree_query_radius = bridgeBallTree[${this.id}].query_radius(**pms_BallTree_query_radius)`;
    return this._py`res_BallTree_query_radius.tolist() if hasattr(res_BallTree_query_radius, 'tolist') else res_BallTree_query_radius`;
  }
  /**
    Reset number of calls to 0.
   */
  async reset_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before reset_n_calls()");
    }
    await this._py.ex`pms_BallTree_reset_n_calls = {}

pms_BallTree_reset_n_calls = {k: v for k, v in pms_BallTree_reset_n_calls.items() if v is not None}`;
    await this._py.ex`res_BallTree_reset_n_calls = bridgeBallTree[${this.id}].reset_n_calls(**pms_BallTree_reset_n_calls)`;
    return this._py`res_BallTree_reset_n_calls.tolist() if hasattr(res_BallTree_reset_n_calls, 'tolist') else res_BallTree_reset_n_calls`;
  }
  /**
    Compute the two-point correlation function
   */
  async two_point_correlation(opts) {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BallTree must call init() before two_point_correlation()"
      );
    }
    await this._py.ex`pms_BallTree_two_point_correlation = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}}

pms_BallTree_two_point_correlation = {k: v for k, v in pms_BallTree_two_point_correlation.items() if v is not None}`;
    await this._py.ex`res_BallTree_two_point_correlation = bridgeBallTree[${this.id}].two_point_correlation(**pms_BallTree_two_point_correlation)`;
    return this._py`res_BallTree_two_point_correlation.tolist() if hasattr(res_BallTree_two_point_correlation, 'tolist') else res_BallTree_two_point_correlation`;
  }
  /**
    The training data
   */
  get data() {
    if (this._isDisposed) {
      throw new Error("This BallTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BallTree must call init() before accessing data");
    }
    return (async () => {
      await this._py.ex`attr_BallTree_data = bridgeBallTree[${this.id}].data`;
      return this._py`attr_BallTree_data.tolist() if hasattr(attr_BallTree_data, 'tolist') else attr_BallTree_data`;
    })();
  }
};

// src/generated/neighbors/KDTree.ts
import crypto2 from "node:crypto";
var KDTree = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KDTree${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KDTree.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KDTree
try: bridgeKDTree
except NameError: bridgeKDTree = {}
`;
    await this._py.ex`ctor_KDTree = {'X': np.array(${this.opts["X"] ?? void 0}) if ${this.opts["X"] !== void 0} else None, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}}

ctor_KDTree = {k: v for k, v in ctor_KDTree.items() if v is not None}`;
    await this._py.ex`bridgeKDTree[${this.id}] = KDTree(**ctor_KDTree)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKDTree[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Get data and node arrays.
   */
  async get_arrays(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_arrays()");
    }
    await this._py.ex`pms_KDTree_get_arrays = {}

pms_KDTree_get_arrays = {k: v for k, v in pms_KDTree_get_arrays.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_arrays = bridgeKDTree[${this.id}].get_arrays(**pms_KDTree_get_arrays)`;
    return this._py`res_KDTree_get_arrays.tolist() if hasattr(res_KDTree_get_arrays, 'tolist') else res_KDTree_get_arrays`;
  }
  /**
    Get number of calls.
   */
  async get_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_n_calls()");
    }
    await this._py.ex`pms_KDTree_get_n_calls = {}

pms_KDTree_get_n_calls = {k: v for k, v in pms_KDTree_get_n_calls.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_n_calls = bridgeKDTree[${this.id}].get_n_calls(**pms_KDTree_get_n_calls)`;
    return this._py`res_KDTree_get_n_calls.tolist() if hasattr(res_KDTree_get_n_calls, 'tolist') else res_KDTree_get_n_calls`;
  }
  /**
    Get tree status.
   */
  async get_tree_stats(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before get_tree_stats()");
    }
    await this._py.ex`pms_KDTree_get_tree_stats = {}

pms_KDTree_get_tree_stats = {k: v for k, v in pms_KDTree_get_tree_stats.items() if v is not None}`;
    await this._py.ex`res_KDTree_get_tree_stats = bridgeKDTree[${this.id}].get_tree_stats(**pms_KDTree_get_tree_stats)`;
    return this._py`res_KDTree_get_tree_stats.tolist() if hasattr(res_KDTree_get_tree_stats, 'tolist') else res_KDTree_get_tree_stats`;
  }
  /**
    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.
   */
  async kernel_density(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before kernel_density()");
    }
    await this._py.ex`pms_KDTree_kernel_density = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'h': ${opts["h"] ?? void 0}, 'kernel': ${opts["kernel"] ?? void 0}, 'atol': ${opts["atol"] ?? void 0}, 'rtol': ${opts["rtol"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'return_log': ${opts["return_log"] ?? void 0}}

pms_KDTree_kernel_density = {k: v for k, v in pms_KDTree_kernel_density.items() if v is not None}`;
    await this._py.ex`res_KDTree_kernel_density = bridgeKDTree[${this.id}].kernel_density(**pms_KDTree_kernel_density)`;
    return this._py`res_KDTree_kernel_density.tolist() if hasattr(res_KDTree_kernel_density, 'tolist') else res_KDTree_kernel_density`;
  }
  /**
    query the tree for the k nearest neighbors
   */
  async query(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before query()");
    }
    await this._py.ex`pms_KDTree_query = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'k': ${opts["k"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}, 'breadth_first': ${opts["breadth_first"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_KDTree_query = {k: v for k, v in pms_KDTree_query.items() if v is not None}`;
    await this._py.ex`res_KDTree_query = bridgeKDTree[${this.id}].query(**pms_KDTree_query)`;
    return this._py`res_KDTree_query.tolist() if hasattr(res_KDTree_query, 'tolist') else res_KDTree_query`;
  }
  /**
    query the tree for neighbors within a radius r
   */
  async query_radius(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before query_radius()");
    }
    await this._py.ex`pms_KDTree_query_radius = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'count_only': ${opts["count_only"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_KDTree_query_radius = {k: v for k, v in pms_KDTree_query_radius.items() if v is not None}`;
    await this._py.ex`res_KDTree_query_radius = bridgeKDTree[${this.id}].query_radius(**pms_KDTree_query_radius)`;
    return this._py`res_KDTree_query_radius.tolist() if hasattr(res_KDTree_query_radius, 'tolist') else res_KDTree_query_radius`;
  }
  /**
    Reset number of calls to 0.
   */
  async reset_n_calls(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before reset_n_calls()");
    }
    await this._py.ex`pms_KDTree_reset_n_calls = {}

pms_KDTree_reset_n_calls = {k: v for k, v in pms_KDTree_reset_n_calls.items() if v is not None}`;
    await this._py.ex`res_KDTree_reset_n_calls = bridgeKDTree[${this.id}].reset_n_calls(**pms_KDTree_reset_n_calls)`;
    return this._py`res_KDTree_reset_n_calls.tolist() if hasattr(res_KDTree_reset_n_calls, 'tolist') else res_KDTree_reset_n_calls`;
  }
  /**
    Compute the two-point correlation function
   */
  async two_point_correlation(opts) {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before two_point_correlation()");
    }
    await this._py.ex`pms_KDTree_two_point_correlation = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'r': ${opts["r"] ?? void 0}, 'dualtree': ${opts["dualtree"] ?? void 0}}

pms_KDTree_two_point_correlation = {k: v for k, v in pms_KDTree_two_point_correlation.items() if v is not None}`;
    await this._py.ex`res_KDTree_two_point_correlation = bridgeKDTree[${this.id}].two_point_correlation(**pms_KDTree_two_point_correlation)`;
    return this._py`res_KDTree_two_point_correlation.tolist() if hasattr(res_KDTree_two_point_correlation, 'tolist') else res_KDTree_two_point_correlation`;
  }
  /**
    The training data
   */
  get data() {
    if (this._isDisposed) {
      throw new Error("This KDTree instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KDTree must call init() before accessing data");
    }
    return (async () => {
      await this._py.ex`attr_KDTree_data = bridgeKDTree[${this.id}].data`;
      return this._py`attr_KDTree_data.tolist() if hasattr(attr_KDTree_data, 'tolist') else attr_KDTree_data`;
    })();
  }
};

// src/generated/neighbors/KernelDensity.ts
import crypto3 from "node:crypto";
var KernelDensity = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KernelDensity${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelDensity.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KernelDensity
try: bridgeKernelDensity
except NameError: bridgeKernelDensity = {}
`;
    await this._py.ex`ctor_KernelDensity = {'bandwidth': ${this.opts["bandwidth"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'atol': ${this.opts["atol"] ?? void 0}, 'rtol': ${this.opts["rtol"] ?? void 0}, 'breadth_first': ${this.opts["breadth_first"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}}

ctor_KernelDensity = {k: v for k, v in ctor_KernelDensity.items() if v is not None}`;
    await this._py.ex`bridgeKernelDensity[${this.id}] = KernelDensity(**ctor_KernelDensity)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelDensity[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the Kernel Density model on the data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before fit()");
    }
    await this._py.ex`pms_KernelDensity_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KernelDensity_fit = {k: v for k, v in pms_KernelDensity_fit.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_fit = bridgeKernelDensity[${this.id}].fit(**pms_KernelDensity_fit)`;
    return this._py`res_KernelDensity_fit.tolist() if hasattr(res_KernelDensity_fit, 'tolist') else res_KernelDensity_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelDensity_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelDensity_get_metadata_routing = {k: v for k, v in pms_KernelDensity_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_get_metadata_routing = bridgeKernelDensity[${this.id}].get_metadata_routing(**pms_KernelDensity_get_metadata_routing)`;
    return this._py`res_KernelDensity_get_metadata_routing.tolist() if hasattr(res_KernelDensity_get_metadata_routing, 'tolist') else res_KernelDensity_get_metadata_routing`;
  }
  /**
      Generate random samples from the model.
  
      Currently, this is implemented only for gaussian and tophat kernels.
     */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before sample()");
    }
    await this._py.ex`pms_KernelDensity_sample = {'n_samples': ${opts["n_samples"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_KernelDensity_sample = {k: v for k, v in pms_KernelDensity_sample.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_sample = bridgeKernelDensity[${this.id}].sample(**pms_KernelDensity_sample)`;
    return this._py`res_KernelDensity_sample.tolist() if hasattr(res_KernelDensity_sample, 'tolist') else res_KernelDensity_sample`;
  }
  /**
    Compute the total log-likelihood under the model.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before score()");
    }
    await this._py.ex`pms_KernelDensity_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelDensity_score = {k: v for k, v in pms_KernelDensity_score.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_score = bridgeKernelDensity[${this.id}].score(**pms_KernelDensity_score)`;
    return this._py`res_KernelDensity_score.tolist() if hasattr(res_KernelDensity_score, 'tolist') else res_KernelDensity_score`;
  }
  /**
    Compute the log-likelihood of each sample under the model.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before score_samples()");
    }
    await this._py.ex`pms_KernelDensity_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelDensity_score_samples = {k: v for k, v in pms_KernelDensity_score_samples.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_score_samples = bridgeKernelDensity[${this.id}].score_samples(**pms_KernelDensity_score_samples)`;
    return this._py`res_KernelDensity_score_samples.tolist() if hasattr(res_KernelDensity_score_samples, 'tolist') else res_KernelDensity_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KernelDensity_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KernelDensity_set_fit_request = {k: v for k, v in pms_KernelDensity_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KernelDensity_set_fit_request = bridgeKernelDensity[${this.id}].set_fit_request(**pms_KernelDensity_set_fit_request)`;
    return this._py`res_KernelDensity_set_fit_request.tolist() if hasattr(res_KernelDensity_set_fit_request, 'tolist') else res_KernelDensity_set_fit_request`;
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_n_features_in_ = bridgeKernelDensity[${this.id}].n_features_in_`;
      return this._py`attr_KernelDensity_n_features_in_.tolist() if hasattr(attr_KernelDensity_n_features_in_, 'tolist') else attr_KernelDensity_n_features_in_`;
    })();
  }
  /**
    The tree algorithm for fast generalized N-point problems.
   */
  get tree_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelDensity must call init() before accessing tree_");
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_tree_ = bridgeKernelDensity[${this.id}].tree_`;
      return this._py`attr_KernelDensity_tree_.tolist() if hasattr(attr_KernelDensity_tree_, 'tolist') else attr_KernelDensity_tree_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_feature_names_in_ = bridgeKernelDensity[${this.id}].feature_names_in_`;
      return this._py`attr_KernelDensity_feature_names_in_.tolist() if hasattr(attr_KernelDensity_feature_names_in_, 'tolist') else attr_KernelDensity_feature_names_in_`;
    })();
  }
  /**
    Value of the bandwidth, given directly by the bandwidth parameter or estimated using the ‘scott’ or ‘silverman’ method.
   */
  get bandwidth_() {
    if (this._isDisposed) {
      throw new Error("This KernelDensity instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelDensity must call init() before accessing bandwidth_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelDensity_bandwidth_ = bridgeKernelDensity[${this.id}].bandwidth_`;
      return this._py`attr_KernelDensity_bandwidth_.tolist() if hasattr(attr_KernelDensity_bandwidth_, 'tolist') else attr_KernelDensity_bandwidth_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsClassifier.ts
import crypto4 from "node:crypto";
var KNeighborsClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsClassifier${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsClassifier
try: bridgeKNeighborsClassifier
except NameError: bridgeKNeighborsClassifier = {}
`;
    await this._py.ex`ctor_KNeighborsClassifier = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsClassifier = {k: v for k, v in ctor_KNeighborsClassifier.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsClassifier[${this.id}] = KNeighborsClassifier(**ctor_KNeighborsClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors classifier from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_KNeighborsClassifier_fit = {k: v for k, v in pms_KNeighborsClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_fit = bridgeKNeighborsClassifier[${this.id}].fit(**pms_KNeighborsClassifier_fit)`;
    return this._py`res_KNeighborsClassifier_fit.tolist() if hasattr(res_KNeighborsClassifier_fit, 'tolist') else res_KNeighborsClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_KNeighborsClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_get_metadata_routing = bridgeKNeighborsClassifier[${this.id}].get_metadata_routing(**pms_KNeighborsClassifier_get_metadata_routing)`;
    return this._py`res_KNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_KNeighborsClassifier_get_metadata_routing, 'tolist') else res_KNeighborsClassifier_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsClassifier_kneighbors = {k: v for k, v in pms_KNeighborsClassifier_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_kneighbors = bridgeKNeighborsClassifier[${this.id}].kneighbors(**pms_KNeighborsClassifier_kneighbors)`;
    return this._py`res_KNeighborsClassifier_kneighbors.tolist() if hasattr(res_KNeighborsClassifier_kneighbors, 'tolist') else res_KNeighborsClassifier_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsClassifier_kneighbors_graph = {k: v for k, v in pms_KNeighborsClassifier_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_kneighbors_graph = bridgeKNeighborsClassifier[${this.id}].kneighbors_graph(**pms_KNeighborsClassifier_kneighbors_graph)`;
    return this._py`res_KNeighborsClassifier_kneighbors_graph.tolist() if hasattr(res_KNeighborsClassifier_kneighbors_graph, 'tolist') else res_KNeighborsClassifier_kneighbors_graph`;
  }
  /**
    Predict the class labels for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before predict()");
    }
    await this._py.ex`pms_KNeighborsClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsClassifier_predict = {k: v for k, v in pms_KNeighborsClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_predict = bridgeKNeighborsClassifier[${this.id}].predict(**pms_KNeighborsClassifier_predict)`;
    return this._py`res_KNeighborsClassifier_predict.tolist() if hasattr(res_KNeighborsClassifier_predict, 'tolist') else res_KNeighborsClassifier_predict`;
  }
  /**
    Return probability estimates for the test data X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsClassifier_predict_proba = {k: v for k, v in pms_KNeighborsClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_predict_proba = bridgeKNeighborsClassifier[${this.id}].predict_proba(**pms_KNeighborsClassifier_predict_proba)`;
    return this._py`res_KNeighborsClassifier_predict_proba.tolist() if hasattr(res_KNeighborsClassifier_predict_proba, 'tolist') else res_KNeighborsClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsClassifier must call init() before score()");
    }
    await this._py.ex`pms_KNeighborsClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KNeighborsClassifier_score = {k: v for k, v in pms_KNeighborsClassifier_score.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_score = bridgeKNeighborsClassifier[${this.id}].score(**pms_KNeighborsClassifier_score)`;
    return this._py`res_KNeighborsClassifier_score.tolist() if hasattr(res_KNeighborsClassifier_score, 'tolist') else res_KNeighborsClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_KNeighborsClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KNeighborsClassifier_set_score_request = {k: v for k, v in pms_KNeighborsClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KNeighborsClassifier_set_score_request = bridgeKNeighborsClassifier[${this.id}].set_score_request(**pms_KNeighborsClassifier_set_score_request)`;
    return this._py`res_KNeighborsClassifier_set_score_request.tolist() if hasattr(res_KNeighborsClassifier_set_score_request, 'tolist') else res_KNeighborsClassifier_set_score_request`;
  }
  /**
    Class labels known to the classifier
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_classes_ = bridgeKNeighborsClassifier[${this.id}].classes_`;
      return this._py`attr_KNeighborsClassifier_classes_.tolist() if hasattr(attr_KNeighborsClassifier_classes_, 'tolist') else attr_KNeighborsClassifier_classes_`;
    })();
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_effective_metric_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_, 'tolist') else attr_KNeighborsClassifier_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_effective_metric_params_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_params_, 'tolist') else attr_KNeighborsClassifier_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_n_features_in_ = bridgeKNeighborsClassifier[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_KNeighborsClassifier_n_features_in_, 'tolist') else attr_KNeighborsClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_feature_names_in_ = bridgeKNeighborsClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_KNeighborsClassifier_feature_names_in_, 'tolist') else attr_KNeighborsClassifier_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_n_samples_fit_ = bridgeKNeighborsClassifier[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_KNeighborsClassifier_n_samples_fit_, 'tolist') else attr_KNeighborsClassifier_n_samples_fit_`;
    })();
  }
  /**
    False when `y`’s shape is (n\_samples, ) or (n\_samples, 1) during fit otherwise `true`.
   */
  get outputs_2d_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsClassifier must call init() before accessing outputs_2d_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsClassifier_outputs_2d_ = bridgeKNeighborsClassifier[${this.id}].outputs_2d_`;
      return this._py`attr_KNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_KNeighborsClassifier_outputs_2d_, 'tolist') else attr_KNeighborsClassifier_outputs_2d_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsRegressor.ts
import crypto5 from "node:crypto";
var KNeighborsRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsRegressor${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsRegressor
try: bridgeKNeighborsRegressor
except NameError: bridgeKNeighborsRegressor = {}
`;
    await this._py.ex`ctor_KNeighborsRegressor = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsRegressor = {k: v for k, v in ctor_KNeighborsRegressor.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsRegressor[${this.id}] = KNeighborsRegressor(**ctor_KNeighborsRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors regressor from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_KNeighborsRegressor_fit = {k: v for k, v in pms_KNeighborsRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_fit = bridgeKNeighborsRegressor[${this.id}].fit(**pms_KNeighborsRegressor_fit)`;
    return this._py`res_KNeighborsRegressor_fit.tolist() if hasattr(res_KNeighborsRegressor_fit, 'tolist') else res_KNeighborsRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_KNeighborsRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_get_metadata_routing = bridgeKNeighborsRegressor[${this.id}].get_metadata_routing(**pms_KNeighborsRegressor_get_metadata_routing)`;
    return this._py`res_KNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_KNeighborsRegressor_get_metadata_routing, 'tolist') else res_KNeighborsRegressor_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsRegressor_kneighbors = {k: v for k, v in pms_KNeighborsRegressor_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_kneighbors = bridgeKNeighborsRegressor[${this.id}].kneighbors(**pms_KNeighborsRegressor_kneighbors)`;
    return this._py`res_KNeighborsRegressor_kneighbors.tolist() if hasattr(res_KNeighborsRegressor_kneighbors, 'tolist') else res_KNeighborsRegressor_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsRegressor_kneighbors_graph = {k: v for k, v in pms_KNeighborsRegressor_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_kneighbors_graph = bridgeKNeighborsRegressor[${this.id}].kneighbors_graph(**pms_KNeighborsRegressor_kneighbors_graph)`;
    return this._py`res_KNeighborsRegressor_kneighbors_graph.tolist() if hasattr(res_KNeighborsRegressor_kneighbors_graph, 'tolist') else res_KNeighborsRegressor_kneighbors_graph`;
  }
  /**
    Predict the target for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before predict()");
    }
    await this._py.ex`pms_KNeighborsRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsRegressor_predict = {k: v for k, v in pms_KNeighborsRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_predict = bridgeKNeighborsRegressor[${this.id}].predict(**pms_KNeighborsRegressor_predict)`;
    return this._py`res_KNeighborsRegressor_predict.tolist() if hasattr(res_KNeighborsRegressor_predict, 'tolist') else res_KNeighborsRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsRegressor must call init() before score()");
    }
    await this._py.ex`pms_KNeighborsRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KNeighborsRegressor_score = {k: v for k, v in pms_KNeighborsRegressor_score.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_score = bridgeKNeighborsRegressor[${this.id}].score(**pms_KNeighborsRegressor_score)`;
    return this._py`res_KNeighborsRegressor_score.tolist() if hasattr(res_KNeighborsRegressor_score, 'tolist') else res_KNeighborsRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_KNeighborsRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KNeighborsRegressor_set_score_request = {k: v for k, v in pms_KNeighborsRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KNeighborsRegressor_set_score_request = bridgeKNeighborsRegressor[${this.id}].set_score_request(**pms_KNeighborsRegressor_set_score_request)`;
    return this._py`res_KNeighborsRegressor_set_score_request.tolist() if hasattr(res_KNeighborsRegressor_set_score_request, 'tolist') else res_KNeighborsRegressor_set_score_request`;
  }
  /**
    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_effective_metric_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_, 'tolist') else attr_KNeighborsRegressor_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_effective_metric_params_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_params_, 'tolist') else attr_KNeighborsRegressor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_n_features_in_ = bridgeKNeighborsRegressor[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_KNeighborsRegressor_n_features_in_, 'tolist') else attr_KNeighborsRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_feature_names_in_ = bridgeKNeighborsRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_KNeighborsRegressor_feature_names_in_, 'tolist') else attr_KNeighborsRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsRegressor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsRegressor_n_samples_fit_ = bridgeKNeighborsRegressor[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_KNeighborsRegressor_n_samples_fit_, 'tolist') else attr_KNeighborsRegressor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/KNeighborsTransformer.ts
import crypto6 from "node:crypto";
var KNeighborsTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `KNeighborsTransformer${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "KNeighborsTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import KNeighborsTransformer
try: bridgeKNeighborsTransformer
except NameError: bridgeKNeighborsTransformer = {}
`;
    await this._py.ex`ctor_KNeighborsTransformer = {'mode': ${this.opts["mode"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KNeighborsTransformer = {k: v for k, v in ctor_KNeighborsTransformer.items() if v is not None}`;
    await this._py.ex`bridgeKNeighborsTransformer[${this.id}] = KNeighborsTransformer(**ctor_KNeighborsTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKNeighborsTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the k-nearest neighbors transformer from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("KNeighborsTransformer must call init() before fit()");
    }
    await this._py.ex`pms_KNeighborsTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KNeighborsTransformer_fit = {k: v for k, v in pms_KNeighborsTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_fit = bridgeKNeighborsTransformer[${this.id}].fit(**pms_KNeighborsTransformer_fit)`;
    return this._py`res_KNeighborsTransformer_fit.tolist() if hasattr(res_KNeighborsTransformer_fit, 'tolist') else res_KNeighborsTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit\_params and returns a transformed version of X.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KNeighborsTransformer_fit_transform = {k: v for k, v in pms_KNeighborsTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_fit_transform = bridgeKNeighborsTransformer[${this.id}].fit_transform(**pms_KNeighborsTransformer_fit_transform)`;
    return this._py`res_KNeighborsTransformer_fit_transform.tolist() if hasattr(res_KNeighborsTransformer_fit_transform, 'tolist') else res_KNeighborsTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_KNeighborsTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_get_feature_names_out = bridgeKNeighborsTransformer[${this.id}].get_feature_names_out(**pms_KNeighborsTransformer_get_feature_names_out)`;
    return this._py`res_KNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_KNeighborsTransformer_get_feature_names_out, 'tolist') else res_KNeighborsTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_KNeighborsTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_get_metadata_routing = bridgeKNeighborsTransformer[${this.id}].get_metadata_routing(**pms_KNeighborsTransformer_get_metadata_routing)`;
    return this._py`res_KNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_KNeighborsTransformer_get_metadata_routing, 'tolist') else res_KNeighborsTransformer_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before kneighbors()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_KNeighborsTransformer_kneighbors = {k: v for k, v in pms_KNeighborsTransformer_kneighbors.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_kneighbors = bridgeKNeighborsTransformer[${this.id}].kneighbors(**pms_KNeighborsTransformer_kneighbors)`;
    return this._py`res_KNeighborsTransformer_kneighbors.tolist() if hasattr(res_KNeighborsTransformer_kneighbors, 'tolist') else res_KNeighborsTransformer_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_KNeighborsTransformer_kneighbors_graph = {k: v for k, v in pms_KNeighborsTransformer_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_kneighbors_graph = bridgeKNeighborsTransformer[${this.id}].kneighbors_graph(**pms_KNeighborsTransformer_kneighbors_graph)`;
    return this._py`res_KNeighborsTransformer_kneighbors_graph.tolist() if hasattr(res_KNeighborsTransformer_kneighbors_graph, 'tolist') else res_KNeighborsTransformer_kneighbors_graph`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KNeighborsTransformer_set_output = {k: v for k, v in pms_KNeighborsTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_set_output = bridgeKNeighborsTransformer[${this.id}].set_output(**pms_KNeighborsTransformer_set_output)`;
    return this._py`res_KNeighborsTransformer_set_output.tolist() if hasattr(res_KNeighborsTransformer_set_output, 'tolist') else res_KNeighborsTransformer_set_output`;
  }
  /**
    Compute the (weighted) graph of Neighbors for points in X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before transform()"
      );
    }
    await this._py.ex`pms_KNeighborsTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KNeighborsTransformer_transform = {k: v for k, v in pms_KNeighborsTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_KNeighborsTransformer_transform = bridgeKNeighborsTransformer[${this.id}].transform(**pms_KNeighborsTransformer_transform)`;
    return this._py`res_KNeighborsTransformer_transform.tolist() if hasattr(res_KNeighborsTransformer_transform, 'tolist') else res_KNeighborsTransformer_transform`;
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_effective_metric_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_`;
      return this._py`attr_KNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_, 'tolist') else attr_KNeighborsTransformer_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_effective_metric_params_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_params_`;
      return this._py`attr_KNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_params_, 'tolist') else attr_KNeighborsTransformer_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_n_features_in_ = bridgeKNeighborsTransformer[${this.id}].n_features_in_`;
      return this._py`attr_KNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_KNeighborsTransformer_n_features_in_, 'tolist') else attr_KNeighborsTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_feature_names_in_ = bridgeKNeighborsTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_KNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_KNeighborsTransformer_feature_names_in_, 'tolist') else attr_KNeighborsTransformer_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This KNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "KNeighborsTransformer must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KNeighborsTransformer_n_samples_fit_ = bridgeKNeighborsTransformer[${this.id}].n_samples_fit_`;
      return this._py`attr_KNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_KNeighborsTransformer_n_samples_fit_, 'tolist') else attr_KNeighborsTransformer_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/LocalOutlierFactor.ts
import crypto7 from "node:crypto";
var LocalOutlierFactor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LocalOutlierFactor${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LocalOutlierFactor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import LocalOutlierFactor
try: bridgeLocalOutlierFactor
except NameError: bridgeLocalOutlierFactor = {}
`;
    await this._py.ex`ctor_LocalOutlierFactor = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'novelty': ${this.opts["novelty"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_LocalOutlierFactor = {k: v for k, v in ctor_LocalOutlierFactor.items() if v is not None}`;
    await this._py.ex`bridgeLocalOutlierFactor[${this.id}] = LocalOutlierFactor(**ctor_LocalOutlierFactor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLocalOutlierFactor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Shifted opposite of the Local Outlier Factor of X.
  
      Bigger is better, i.e. large values correspond to inliers.
  
      **Only available for novelty detection (when novelty is set to `true`).** The shift offset allows a zero threshold for being an outlier. The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_decision_function = {k: v for k, v in pms_LocalOutlierFactor_decision_function.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_decision_function = bridgeLocalOutlierFactor[${this.id}].decision_function(**pms_LocalOutlierFactor_decision_function)`;
    return this._py`res_LocalOutlierFactor_decision_function.tolist() if hasattr(res_LocalOutlierFactor_decision_function, 'tolist') else res_LocalOutlierFactor_decision_function`;
  }
  /**
    Fit the local outlier factor detector from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before fit()");
    }
    await this._py.ex`pms_LocalOutlierFactor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocalOutlierFactor_fit = {k: v for k, v in pms_LocalOutlierFactor_fit.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_fit = bridgeLocalOutlierFactor[${this.id}].fit(**pms_LocalOutlierFactor_fit)`;
    return this._py`res_LocalOutlierFactor_fit.tolist() if hasattr(res_LocalOutlierFactor_fit, 'tolist') else res_LocalOutlierFactor_fit`;
  }
  /**
      Fit the model to the training set X and return the labels.
  
      **Not available for novelty detection (when novelty is set to `true`).** Label is 1 for an inlier and -1 for an outlier according to the LOF score and the contamination parameter.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LocalOutlierFactor_fit_predict = {k: v for k, v in pms_LocalOutlierFactor_fit_predict.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_fit_predict = bridgeLocalOutlierFactor[${this.id}].fit_predict(**pms_LocalOutlierFactor_fit_predict)`;
    return this._py`res_LocalOutlierFactor_fit_predict.tolist() if hasattr(res_LocalOutlierFactor_fit_predict, 'tolist') else res_LocalOutlierFactor_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LocalOutlierFactor_get_metadata_routing = {k: v for k, v in pms_LocalOutlierFactor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_get_metadata_routing = bridgeLocalOutlierFactor[${this.id}].get_metadata_routing(**pms_LocalOutlierFactor_get_metadata_routing)`;
    return this._py`res_LocalOutlierFactor_get_metadata_routing.tolist() if hasattr(res_LocalOutlierFactor_get_metadata_routing, 'tolist') else res_LocalOutlierFactor_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before kneighbors()");
    }
    await this._py.ex`pms_LocalOutlierFactor_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_LocalOutlierFactor_kneighbors = {k: v for k, v in pms_LocalOutlierFactor_kneighbors.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_kneighbors = bridgeLocalOutlierFactor[${this.id}].kneighbors(**pms_LocalOutlierFactor_kneighbors)`;
    return this._py`res_LocalOutlierFactor_kneighbors.tolist() if hasattr(res_LocalOutlierFactor_kneighbors, 'tolist') else res_LocalOutlierFactor_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_LocalOutlierFactor_kneighbors_graph = {k: v for k, v in pms_LocalOutlierFactor_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_kneighbors_graph = bridgeLocalOutlierFactor[${this.id}].kneighbors_graph(**pms_LocalOutlierFactor_kneighbors_graph)`;
    return this._py`res_LocalOutlierFactor_kneighbors_graph.tolist() if hasattr(res_LocalOutlierFactor_kneighbors_graph, 'tolist') else res_LocalOutlierFactor_kneighbors_graph`;
  }
  /**
      Predict the labels (1 inlier, -1 outlier) of X according to LOF.
  
      **Only available for novelty detection (when novelty is set to `true`).** This method allows to generalize prediction to *new observations* (not in the training set). Note that the result of `clf.fit(X)` then `clf.predict(X)` with `novelty=True` may differ from the result obtained by `clf.fit\_predict(X)` with `novelty=False`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LocalOutlierFactor must call init() before predict()");
    }
    await this._py.ex`pms_LocalOutlierFactor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_predict = {k: v for k, v in pms_LocalOutlierFactor_predict.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_predict = bridgeLocalOutlierFactor[${this.id}].predict(**pms_LocalOutlierFactor_predict)`;
    return this._py`res_LocalOutlierFactor_predict.tolist() if hasattr(res_LocalOutlierFactor_predict, 'tolist') else res_LocalOutlierFactor_predict`;
  }
  /**
      Opposite of the Local Outlier Factor of X.
  
      It is the opposite as bigger is better, i.e. large values correspond to inliers.
  
      **Only available for novelty detection (when novelty is set to `true`).** The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point. Because of this, the scores obtained via `score\_samples` may differ from the standard LOF scores. The standard LOF scores for the training data is available via the `negative\_outlier\_factor\_` attribute.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_LocalOutlierFactor_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LocalOutlierFactor_score_samples = {k: v for k, v in pms_LocalOutlierFactor_score_samples.items() if v is not None}`;
    await this._py.ex`res_LocalOutlierFactor_score_samples = bridgeLocalOutlierFactor[${this.id}].score_samples(**pms_LocalOutlierFactor_score_samples)`;
    return this._py`res_LocalOutlierFactor_score_samples.tolist() if hasattr(res_LocalOutlierFactor_score_samples, 'tolist') else res_LocalOutlierFactor_score_samples`;
  }
  /**
      The opposite LOF of the training samples. The higher, the more normal. Inliers tend to have a LOF score close to 1 (`negative\_outlier\_factor\_` close to -1), while outliers tend to have a larger LOF score.
  
      The local outlier factor (LOF) of a sample captures its supposed ‘degree of abnormality’. It is the average of the ratio of the local reachability density of a sample and those of its k-nearest neighbors.
     */
  get negative_outlier_factor_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing negative_outlier_factor_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_negative_outlier_factor_ = bridgeLocalOutlierFactor[${this.id}].negative_outlier_factor_`;
      return this._py`attr_LocalOutlierFactor_negative_outlier_factor_.tolist() if hasattr(attr_LocalOutlierFactor_negative_outlier_factor_, 'tolist') else attr_LocalOutlierFactor_negative_outlier_factor_`;
    })();
  }
  /**
    The actual number of neighbors used for [`kneighbors`](#sklearn.neighbors.LocalOutlierFactor.kneighbors "sklearn.neighbors.LocalOutlierFactor.kneighbors") queries.
   */
  get n_neighbors_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_neighbors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_neighbors_ = bridgeLocalOutlierFactor[${this.id}].n_neighbors_`;
      return this._py`attr_LocalOutlierFactor_n_neighbors_.tolist() if hasattr(attr_LocalOutlierFactor_n_neighbors_, 'tolist') else attr_LocalOutlierFactor_n_neighbors_`;
    })();
  }
  /**
    Offset used to obtain binary labels from the raw scores. Observations having a negative\_outlier\_factor smaller than `offset\_` are detected as abnormal. The offset is set to -1.5 (inliers score around -1), except when a contamination parameter different than “auto” is provided. In that case, the offset is defined in such a way we obtain the expected number of outliers in training.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_offset_ = bridgeLocalOutlierFactor[${this.id}].offset_`;
      return this._py`attr_LocalOutlierFactor_offset_.tolist() if hasattr(attr_LocalOutlierFactor_offset_, 'tolist') else attr_LocalOutlierFactor_offset_`;
    })();
  }
  /**
    The effective metric used for the distance computation.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_effective_metric_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_`;
      return this._py`attr_LocalOutlierFactor_effective_metric_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_, 'tolist') else attr_LocalOutlierFactor_effective_metric_`;
    })();
  }
  /**
    The effective additional keyword arguments for the metric function.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_effective_metric_params_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_params_`;
      return this._py`attr_LocalOutlierFactor_effective_metric_params_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_params_, 'tolist') else attr_LocalOutlierFactor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_features_in_ = bridgeLocalOutlierFactor[${this.id}].n_features_in_`;
      return this._py`attr_LocalOutlierFactor_n_features_in_.tolist() if hasattr(attr_LocalOutlierFactor_n_features_in_, 'tolist') else attr_LocalOutlierFactor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_feature_names_in_ = bridgeLocalOutlierFactor[${this.id}].feature_names_in_`;
      return this._py`attr_LocalOutlierFactor_feature_names_in_.tolist() if hasattr(attr_LocalOutlierFactor_feature_names_in_, 'tolist') else attr_LocalOutlierFactor_feature_names_in_`;
    })();
  }
  /**
    It is the number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This LocalOutlierFactor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LocalOutlierFactor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LocalOutlierFactor_n_samples_fit_ = bridgeLocalOutlierFactor[${this.id}].n_samples_fit_`;
      return this._py`attr_LocalOutlierFactor_n_samples_fit_.tolist() if hasattr(attr_LocalOutlierFactor_n_samples_fit_, 'tolist') else attr_LocalOutlierFactor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/NearestCentroid.ts
import crypto8 from "node:crypto";
var NearestCentroid = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NearestCentroid${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NearestCentroid.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NearestCentroid
try: bridgeNearestCentroid
except NameError: bridgeNearestCentroid = {}
`;
    await this._py.ex`ctor_NearestCentroid = {'metric': ${this.opts["metric"] ?? void 0}, 'shrink_threshold': ${this.opts["shrink_threshold"] ?? void 0}}

ctor_NearestCentroid = {k: v for k, v in ctor_NearestCentroid.items() if v is not None}`;
    await this._py.ex`bridgeNearestCentroid[${this.id}] = NearestCentroid(**ctor_NearestCentroid)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNearestCentroid[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the NearestCentroid model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before fit()");
    }
    await this._py.ex`pms_NearestCentroid_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_NearestCentroid_fit = {k: v for k, v in pms_NearestCentroid_fit.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_fit = bridgeNearestCentroid[${this.id}].fit(**pms_NearestCentroid_fit)`;
    return this._py`res_NearestCentroid_fit.tolist() if hasattr(res_NearestCentroid_fit, 'tolist') else res_NearestCentroid_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NearestCentroid_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NearestCentroid_get_metadata_routing = {k: v for k, v in pms_NearestCentroid_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_get_metadata_routing = bridgeNearestCentroid[${this.id}].get_metadata_routing(**pms_NearestCentroid_get_metadata_routing)`;
    return this._py`res_NearestCentroid_get_metadata_routing.tolist() if hasattr(res_NearestCentroid_get_metadata_routing, 'tolist') else res_NearestCentroid_get_metadata_routing`;
  }
  /**
      Perform classification on an array of test vectors `X`.
  
      The predicted class `C` for each sample in `X` is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before predict()");
    }
    await this._py.ex`pms_NearestCentroid_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NearestCentroid_predict = {k: v for k, v in pms_NearestCentroid_predict.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_predict = bridgeNearestCentroid[${this.id}].predict(**pms_NearestCentroid_predict)`;
    return this._py`res_NearestCentroid_predict.tolist() if hasattr(res_NearestCentroid_predict, 'tolist') else res_NearestCentroid_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NearestCentroid must call init() before score()");
    }
    await this._py.ex`pms_NearestCentroid_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NearestCentroid_score = {k: v for k, v in pms_NearestCentroid_score.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_score = bridgeNearestCentroid[${this.id}].score(**pms_NearestCentroid_score)`;
    return this._py`res_NearestCentroid_score.tolist() if hasattr(res_NearestCentroid_score, 'tolist') else res_NearestCentroid_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_NearestCentroid_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_NearestCentroid_set_score_request = {k: v for k, v in pms_NearestCentroid_set_score_request.items() if v is not None}`;
    await this._py.ex`res_NearestCentroid_set_score_request = bridgeNearestCentroid[${this.id}].set_score_request(**pms_NearestCentroid_set_score_request)`;
    return this._py`res_NearestCentroid_set_score_request.tolist() if hasattr(res_NearestCentroid_set_score_request, 'tolist') else res_NearestCentroid_set_score_request`;
  }
  /**
    Centroid of each class.
   */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing centroids_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_centroids_ = bridgeNearestCentroid[${this.id}].centroids_`;
      return this._py`attr_NearestCentroid_centroids_.tolist() if hasattr(attr_NearestCentroid_centroids_, 'tolist') else attr_NearestCentroid_centroids_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_classes_ = bridgeNearestCentroid[${this.id}].classes_`;
      return this._py`attr_NearestCentroid_classes_.tolist() if hasattr(attr_NearestCentroid_classes_, 'tolist') else attr_NearestCentroid_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_n_features_in_ = bridgeNearestCentroid[${this.id}].n_features_in_`;
      return this._py`attr_NearestCentroid_n_features_in_.tolist() if hasattr(attr_NearestCentroid_n_features_in_, 'tolist') else attr_NearestCentroid_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NearestCentroid instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestCentroid must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestCentroid_feature_names_in_ = bridgeNearestCentroid[${this.id}].feature_names_in_`;
      return this._py`attr_NearestCentroid_feature_names_in_.tolist() if hasattr(attr_NearestCentroid_feature_names_in_, 'tolist') else attr_NearestCentroid_feature_names_in_`;
    })();
  }
};

// src/generated/neighbors/NearestNeighbors.ts
import crypto9 from "node:crypto";
var NearestNeighbors = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NearestNeighbors${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NearestNeighbors.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NearestNeighbors
try: bridgeNearestNeighbors
except NameError: bridgeNearestNeighbors = {}
`;
    await this._py.ex`ctor_NearestNeighbors = {'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'radius': ${this.opts["radius"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_NearestNeighbors = {k: v for k, v in ctor_NearestNeighbors.items() if v is not None}`;
    await this._py.ex`bridgeNearestNeighbors[${this.id}] = NearestNeighbors(**ctor_NearestNeighbors)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNearestNeighbors[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the nearest neighbors estimator from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("NearestNeighbors must call init() before fit()");
    }
    await this._py.ex`pms_NearestNeighbors_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_NearestNeighbors_fit = {k: v for k, v in pms_NearestNeighbors_fit.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_fit = bridgeNearestNeighbors[${this.id}].fit(**pms_NearestNeighbors_fit)`;
    return this._py`res_NearestNeighbors_fit.tolist() if hasattr(res_NearestNeighbors_fit, 'tolist') else res_NearestNeighbors_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NearestNeighbors_get_metadata_routing = {k: v for k, v in pms_NearestNeighbors_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_get_metadata_routing = bridgeNearestNeighbors[${this.id}].get_metadata_routing(**pms_NearestNeighbors_get_metadata_routing)`;
    return this._py`res_NearestNeighbors_get_metadata_routing.tolist() if hasattr(res_NearestNeighbors_get_metadata_routing, 'tolist') else res_NearestNeighbors_get_metadata_routing`;
  }
  /**
      Find the K-neighbors of a point.
  
      Returns indices of and distances to the neighbors of each point.
     */
  async kneighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("NearestNeighbors must call init() before kneighbors()");
    }
    await this._py.ex`pms_NearestNeighbors_kneighbors = {'X': ${opts["X"] ?? void 0}, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}}

pms_NearestNeighbors_kneighbors = {k: v for k, v in pms_NearestNeighbors_kneighbors.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_kneighbors = bridgeNearestNeighbors[${this.id}].kneighbors(**pms_NearestNeighbors_kneighbors)`;
    return this._py`res_NearestNeighbors_kneighbors.tolist() if hasattr(res_NearestNeighbors_kneighbors, 'tolist') else res_NearestNeighbors_kneighbors`;
  }
  /**
    Compute the (weighted) graph of k-Neighbors for points in X.
   */
  async kneighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before kneighbors_graph()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_kneighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_neighbors': ${opts["n_neighbors"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}}

pms_NearestNeighbors_kneighbors_graph = {k: v for k, v in pms_NearestNeighbors_kneighbors_graph.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_kneighbors_graph = bridgeNearestNeighbors[${this.id}].kneighbors_graph(**pms_NearestNeighbors_kneighbors_graph)`;
    return this._py`res_NearestNeighbors_kneighbors_graph.tolist() if hasattr(res_NearestNeighbors_kneighbors_graph, 'tolist') else res_NearestNeighbors_kneighbors_graph`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_NearestNeighbors_radius_neighbors = {k: v for k, v in pms_NearestNeighbors_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_radius_neighbors = bridgeNearestNeighbors[${this.id}].radius_neighbors(**pms_NearestNeighbors_radius_neighbors)`;
    return this._py`res_NearestNeighbors_radius_neighbors.tolist() if hasattr(res_NearestNeighbors_radius_neighbors, 'tolist') else res_NearestNeighbors_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_NearestNeighbors_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_NearestNeighbors_radius_neighbors_graph = {k: v for k, v in pms_NearestNeighbors_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_NearestNeighbors_radius_neighbors_graph = bridgeNearestNeighbors[${this.id}].radius_neighbors_graph(**pms_NearestNeighbors_radius_neighbors_graph)`;
    return this._py`res_NearestNeighbors_radius_neighbors_graph.tolist() if hasattr(res_NearestNeighbors_radius_neighbors_graph, 'tolist') else res_NearestNeighbors_radius_neighbors_graph`;
  }
  /**
    Metric used to compute distances to neighbors.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_effective_metric_ = bridgeNearestNeighbors[${this.id}].effective_metric_`;
      return this._py`attr_NearestNeighbors_effective_metric_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_, 'tolist') else attr_NearestNeighbors_effective_metric_`;
    })();
  }
  /**
    Parameters for the metric used to compute distances to neighbors.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_effective_metric_params_ = bridgeNearestNeighbors[${this.id}].effective_metric_params_`;
      return this._py`attr_NearestNeighbors_effective_metric_params_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_params_, 'tolist') else attr_NearestNeighbors_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_n_features_in_ = bridgeNearestNeighbors[${this.id}].n_features_in_`;
      return this._py`attr_NearestNeighbors_n_features_in_.tolist() if hasattr(attr_NearestNeighbors_n_features_in_, 'tolist') else attr_NearestNeighbors_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_feature_names_in_ = bridgeNearestNeighbors[${this.id}].feature_names_in_`;
      return this._py`attr_NearestNeighbors_feature_names_in_.tolist() if hasattr(attr_NearestNeighbors_feature_names_in_, 'tolist') else attr_NearestNeighbors_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This NearestNeighbors instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NearestNeighbors must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NearestNeighbors_n_samples_fit_ = bridgeNearestNeighbors[${this.id}].n_samples_fit_`;
      return this._py`attr_NearestNeighbors_n_samples_fit_.tolist() if hasattr(attr_NearestNeighbors_n_samples_fit_, 'tolist') else attr_NearestNeighbors_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/NeighborhoodComponentsAnalysis.ts
import crypto10 from "node:crypto";
var NeighborhoodComponentsAnalysis = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NeighborhoodComponentsAnalysis${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "NeighborhoodComponentsAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import NeighborhoodComponentsAnalysis
try: bridgeNeighborhoodComponentsAnalysis
except NameError: bridgeNeighborhoodComponentsAnalysis = {}
`;
    await this._py.ex`ctor_NeighborhoodComponentsAnalysis = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_NeighborhoodComponentsAnalysis = {k: v for k, v in ctor_NeighborhoodComponentsAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeNeighborhoodComponentsAnalysis[${this.id}] = NeighborhoodComponentsAnalysis(**ctor_NeighborhoodComponentsAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNeighborhoodComponentsAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_NeighborhoodComponentsAnalysis_fit = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_fit = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit(**pms_NeighborhoodComponentsAnalysis_fit)`;
    return this._py`res_NeighborhoodComponentsAnalysis_fit.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit, 'tolist') else res_NeighborhoodComponentsAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_fit_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_fit_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit_transform(**pms_NeighborhoodComponentsAnalysis_fit_transform)`;
    return this._py`res_NeighborhoodComponentsAnalysis_fit_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_get_feature_names_out = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_get_feature_names_out = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_feature_names_out(**pms_NeighborhoodComponentsAnalysis_get_feature_names_out)`;
    return this._py`res_NeighborhoodComponentsAnalysis_get_feature_names_out.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_feature_names_out, 'tolist') else res_NeighborhoodComponentsAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_get_metadata_routing = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_get_metadata_routing = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_metadata_routing(**pms_NeighborhoodComponentsAnalysis_get_metadata_routing)`;
    return this._py`res_NeighborhoodComponentsAnalysis_get_metadata_routing.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_metadata_routing, 'tolist') else res_NeighborhoodComponentsAnalysis_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before set_output()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_NeighborhoodComponentsAnalysis_set_output = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_set_output = bridgeNeighborhoodComponentsAnalysis[${this.id}].set_output(**pms_NeighborhoodComponentsAnalysis_set_output)`;
    return this._py`res_NeighborhoodComponentsAnalysis_set_output.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_set_output, 'tolist') else res_NeighborhoodComponentsAnalysis_set_output`;
  }
  /**
    Apply the learned transformation to the given data.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before transform()"
      );
    }
    await this._py.ex`pms_NeighborhoodComponentsAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NeighborhoodComponentsAnalysis_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_NeighborhoodComponentsAnalysis_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].transform(**pms_NeighborhoodComponentsAnalysis_transform)`;
    return this._py`res_NeighborhoodComponentsAnalysis_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_transform`;
  }
  /**
    The linear transformation learned during fitting.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_components_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].components_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_components_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_components_, 'tolist') else attr_NeighborhoodComponentsAnalysis_components_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_n_features_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_n_features_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_features_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_features_in_`;
    })();
  }
  /**
    Counts the number of iterations performed by the optimizer.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_n_iter_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_iter_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_n_iter_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_iter_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_iter_`;
    })();
  }
  /**
    Pseudo random number generator object used during initialization.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_random_state_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].random_state_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_random_state_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_random_state_, 'tolist') else attr_NeighborhoodComponentsAnalysis_random_state_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This NeighborhoodComponentsAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "NeighborhoodComponentsAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NeighborhoodComponentsAnalysis_feature_names_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_NeighborhoodComponentsAnalysis_feature_names_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_feature_names_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsClassifier.ts
import crypto11 from "node:crypto";
var RadiusNeighborsClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsClassifier${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsClassifier
try: bridgeRadiusNeighborsClassifier
except NameError: bridgeRadiusNeighborsClassifier = {}
`;
    await this._py.ex`ctor_RadiusNeighborsClassifier = {'radius': ${this.opts["radius"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'outlier_label': ${this.opts["outlier_label"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsClassifier = {k: v for k, v in ctor_RadiusNeighborsClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsClassifier[${this.id}] = RadiusNeighborsClassifier(**ctor_RadiusNeighborsClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors classifier from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RadiusNeighborsClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RadiusNeighborsClassifier_fit = {k: v for k, v in pms_RadiusNeighborsClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_fit = bridgeRadiusNeighborsClassifier[${this.id}].fit(**pms_RadiusNeighborsClassifier_fit)`;
    return this._py`res_RadiusNeighborsClassifier_fit.tolist() if hasattr(res_RadiusNeighborsClassifier_fit, 'tolist') else res_RadiusNeighborsClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_get_metadata_routing = bridgeRadiusNeighborsClassifier[${this.id}].get_metadata_routing(**pms_RadiusNeighborsClassifier_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsClassifier_get_metadata_routing, 'tolist') else res_RadiusNeighborsClassifier_get_metadata_routing`;
  }
  /**
    Predict the class labels for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsClassifier_predict = {k: v for k, v in pms_RadiusNeighborsClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_predict = bridgeRadiusNeighborsClassifier[${this.id}].predict(**pms_RadiusNeighborsClassifier_predict)`;
    return this._py`res_RadiusNeighborsClassifier_predict.tolist() if hasattr(res_RadiusNeighborsClassifier_predict, 'tolist') else res_RadiusNeighborsClassifier_predict`;
  }
  /**
    Return probability estimates for the test data X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsClassifier_predict_proba = {k: v for k, v in pms_RadiusNeighborsClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_predict_proba = bridgeRadiusNeighborsClassifier[${this.id}].predict_proba(**pms_RadiusNeighborsClassifier_predict_proba)`;
    return this._py`res_RadiusNeighborsClassifier_predict_proba.tolist() if hasattr(res_RadiusNeighborsClassifier_predict_proba, 'tolist') else res_RadiusNeighborsClassifier_predict_proba`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsClassifier_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_radius_neighbors = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors(**pms_RadiusNeighborsClassifier_radius_neighbors)`;
    return this._py`res_RadiusNeighborsClassifier_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsClassifier_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_radius_neighbors_graph = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsClassifier_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsClassifier_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors_graph`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RadiusNeighborsClassifier_score = {k: v for k, v in pms_RadiusNeighborsClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_score = bridgeRadiusNeighborsClassifier[${this.id}].score(**pms_RadiusNeighborsClassifier_score)`;
    return this._py`res_RadiusNeighborsClassifier_score.tolist() if hasattr(res_RadiusNeighborsClassifier_score, 'tolist') else res_RadiusNeighborsClassifier_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RadiusNeighborsClassifier_set_score_request = {k: v for k, v in pms_RadiusNeighborsClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsClassifier_set_score_request = bridgeRadiusNeighborsClassifier[${this.id}].set_score_request(**pms_RadiusNeighborsClassifier_set_score_request)`;
    return this._py`res_RadiusNeighborsClassifier_set_score_request.tolist() if hasattr(res_RadiusNeighborsClassifier_set_score_request, 'tolist') else res_RadiusNeighborsClassifier_set_score_request`;
  }
  /**
    Class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_classes_ = bridgeRadiusNeighborsClassifier[${this.id}].classes_`;
      return this._py`attr_RadiusNeighborsClassifier_classes_.tolist() if hasattr(attr_RadiusNeighborsClassifier_classes_, 'tolist') else attr_RadiusNeighborsClassifier_classes_`;
    })();
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_effective_metric_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_effective_metric_params_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_params_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_n_features_in_ = bridgeRadiusNeighborsClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_features_in_, 'tolist') else attr_RadiusNeighborsClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_feature_names_in_ = bridgeRadiusNeighborsClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_feature_names_in_, 'tolist') else attr_RadiusNeighborsClassifier_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_n_samples_fit_ = bridgeRadiusNeighborsClassifier[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_samples_fit_, 'tolist') else attr_RadiusNeighborsClassifier_n_samples_fit_`;
    })();
  }
  /**
    Label which is given for outlier samples (samples with no neighbors on given radius).
   */
  get outlier_label_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing outlier_label_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_outlier_label_ = bridgeRadiusNeighborsClassifier[${this.id}].outlier_label_`;
      return this._py`attr_RadiusNeighborsClassifier_outlier_label_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outlier_label_, 'tolist') else attr_RadiusNeighborsClassifier_outlier_label_`;
    })();
  }
  /**
    False when `y`’s shape is (n\_samples, ) or (n\_samples, 1) during fit otherwise `true`.
   */
  get outputs_2d_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsClassifier must call init() before accessing outputs_2d_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsClassifier_outputs_2d_ = bridgeRadiusNeighborsClassifier[${this.id}].outputs_2d_`;
      return this._py`attr_RadiusNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outputs_2d_, 'tolist') else attr_RadiusNeighborsClassifier_outputs_2d_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsRegressor.ts
import crypto12 from "node:crypto";
var RadiusNeighborsRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsRegressor${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsRegressor
try: bridgeRadiusNeighborsRegressor
except NameError: bridgeRadiusNeighborsRegressor = {}
`;
    await this._py.ex`ctor_RadiusNeighborsRegressor = {'radius': ${this.opts["radius"] ?? void 0}, 'weights': ${this.opts["weights"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsRegressor = {k: v for k, v in ctor_RadiusNeighborsRegressor.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsRegressor[${this.id}] = RadiusNeighborsRegressor(**ctor_RadiusNeighborsRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors regressor from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RadiusNeighborsRegressor must call init() before fit()");
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RadiusNeighborsRegressor_fit = {k: v for k, v in pms_RadiusNeighborsRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_fit = bridgeRadiusNeighborsRegressor[${this.id}].fit(**pms_RadiusNeighborsRegressor_fit)`;
    return this._py`res_RadiusNeighborsRegressor_fit.tolist() if hasattr(res_RadiusNeighborsRegressor_fit, 'tolist') else res_RadiusNeighborsRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_get_metadata_routing = bridgeRadiusNeighborsRegressor[${this.id}].get_metadata_routing(**pms_RadiusNeighborsRegressor_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsRegressor_get_metadata_routing, 'tolist') else res_RadiusNeighborsRegressor_get_metadata_routing`;
  }
  /**
    Predict the target for the provided data.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsRegressor_predict = {k: v for k, v in pms_RadiusNeighborsRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_predict = bridgeRadiusNeighborsRegressor[${this.id}].predict(**pms_RadiusNeighborsRegressor_predict)`;
    return this._py`res_RadiusNeighborsRegressor_predict.tolist() if hasattr(res_RadiusNeighborsRegressor_predict, 'tolist') else res_RadiusNeighborsRegressor_predict`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsRegressor_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_radius_neighbors = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors(**pms_RadiusNeighborsRegressor_radius_neighbors)`;
    return this._py`res_RadiusNeighborsRegressor_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsRegressor_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_radius_neighbors_graph = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsRegressor_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsRegressor_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors_graph`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RadiusNeighborsRegressor_score = {k: v for k, v in pms_RadiusNeighborsRegressor_score.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_score = bridgeRadiusNeighborsRegressor[${this.id}].score(**pms_RadiusNeighborsRegressor_score)`;
    return this._py`res_RadiusNeighborsRegressor_score.tolist() if hasattr(res_RadiusNeighborsRegressor_score, 'tolist') else res_RadiusNeighborsRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RadiusNeighborsRegressor_set_score_request = {k: v for k, v in pms_RadiusNeighborsRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsRegressor_set_score_request = bridgeRadiusNeighborsRegressor[${this.id}].set_score_request(**pms_RadiusNeighborsRegressor_set_score_request)`;
    return this._py`res_RadiusNeighborsRegressor_set_score_request.tolist() if hasattr(res_RadiusNeighborsRegressor_set_score_request, 'tolist') else res_RadiusNeighborsRegressor_set_score_request`;
  }
  /**
    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_effective_metric_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_effective_metric_params_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_params_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_n_features_in_ = bridgeRadiusNeighborsRegressor[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_features_in_, 'tolist') else attr_RadiusNeighborsRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_feature_names_in_ = bridgeRadiusNeighborsRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_feature_names_in_, 'tolist') else attr_RadiusNeighborsRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsRegressor must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsRegressor_n_samples_fit_ = bridgeRadiusNeighborsRegressor[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_samples_fit_, 'tolist') else attr_RadiusNeighborsRegressor_n_samples_fit_`;
    })();
  }
};

// src/generated/neighbors/RadiusNeighborsTransformer.ts
import crypto13 from "node:crypto";
var RadiusNeighborsTransformer = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RadiusNeighborsTransformer${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RadiusNeighborsTransformer.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.neighbors import RadiusNeighborsTransformer
try: bridgeRadiusNeighborsTransformer
except NameError: bridgeRadiusNeighborsTransformer = {}
`;
    await this._py.ex`ctor_RadiusNeighborsTransformer = {'mode': ${this.opts["mode"] ?? void 0}, 'radius': ${this.opts["radius"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_RadiusNeighborsTransformer = {k: v for k, v in ctor_RadiusNeighborsTransformer.items() if v is not None}`;
    await this._py.ex`bridgeRadiusNeighborsTransformer[${this.id}] = RadiusNeighborsTransformer(**ctor_RadiusNeighborsTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRadiusNeighborsTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the radius neighbors transformer from the training dataset.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before fit()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RadiusNeighborsTransformer_fit = {k: v for k, v in pms_RadiusNeighborsTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_fit = bridgeRadiusNeighborsTransformer[${this.id}].fit(**pms_RadiusNeighborsTransformer_fit)`;
    return this._py`res_RadiusNeighborsTransformer_fit.tolist() if hasattr(res_RadiusNeighborsTransformer_fit, 'tolist') else res_RadiusNeighborsTransformer_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to X and y with optional parameters fit\_params and returns a transformed version of X.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_RadiusNeighborsTransformer_fit_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_fit_transform = bridgeRadiusNeighborsTransformer[${this.id}].fit_transform(**pms_RadiusNeighborsTransformer_fit_transform)`;
    return this._py`res_RadiusNeighborsTransformer_fit_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_fit_transform, 'tolist') else res_RadiusNeighborsTransformer_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_RadiusNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_RadiusNeighborsTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_get_feature_names_out = bridgeRadiusNeighborsTransformer[${this.id}].get_feature_names_out(**pms_RadiusNeighborsTransformer_get_feature_names_out)`;
    return this._py`res_RadiusNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_RadiusNeighborsTransformer_get_feature_names_out, 'tolist') else res_RadiusNeighborsTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RadiusNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_get_metadata_routing = bridgeRadiusNeighborsTransformer[${this.id}].get_metadata_routing(**pms_RadiusNeighborsTransformer_get_metadata_routing)`;
    return this._py`res_RadiusNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsTransformer_get_metadata_routing, 'tolist') else res_RadiusNeighborsTransformer_get_metadata_routing`;
  }
  /**
      Find the neighbors within a given radius of a point or points.
  
      Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.
  
      The result points are *not* necessarily sorted by distance to their query point.
     */
  async radius_neighbors(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before radius_neighbors()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_radius_neighbors = {'X': ${opts["X"] ?? void 0}, 'radius': ${opts["radius"] ?? void 0}, 'return_distance': ${opts["return_distance"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsTransformer_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_radius_neighbors = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors(**pms_RadiusNeighborsTransformer_radius_neighbors)`;
    return this._py`res_RadiusNeighborsTransformer_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors`;
  }
  /**
      Compute the (weighted) graph of Neighbors for points in X.
  
      Neighborhoods are restricted the points at a distance lower than radius.
     */
  async radius_neighbors_graph(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before radius_neighbors_graph()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_radius_neighbors_graph = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'radius': ${opts["radius"] ?? void 0}, 'mode': ${opts["mode"] ?? void 0}, 'sort_results': ${opts["sort_results"] ?? void 0}}

pms_RadiusNeighborsTransformer_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors_graph.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_radius_neighbors_graph = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsTransformer_radius_neighbors_graph)`;
    return this._py`res_RadiusNeighborsTransformer_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors_graph`;
  }
  /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before set_output()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_RadiusNeighborsTransformer_set_output = {k: v for k, v in pms_RadiusNeighborsTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_set_output = bridgeRadiusNeighborsTransformer[${this.id}].set_output(**pms_RadiusNeighborsTransformer_set_output)`;
    return this._py`res_RadiusNeighborsTransformer_set_output.tolist() if hasattr(res_RadiusNeighborsTransformer_set_output, 'tolist') else res_RadiusNeighborsTransformer_set_output`;
  }
  /**
    Compute the (weighted) graph of Neighbors for points in X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before transform()"
      );
    }
    await this._py.ex`pms_RadiusNeighborsTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RadiusNeighborsTransformer_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_RadiusNeighborsTransformer_transform = bridgeRadiusNeighborsTransformer[${this.id}].transform(**pms_RadiusNeighborsTransformer_transform)`;
    return this._py`res_RadiusNeighborsTransformer_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_transform, 'tolist') else res_RadiusNeighborsTransformer_transform`;
  }
  /**
    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.
   */
  get effective_metric_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing effective_metric_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_effective_metric_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_`;
      return this._py`attr_RadiusNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_`;
    })();
  }
  /**
    Additional keyword arguments for the metric function. For most metrics will be same with `metric\_params` parameter, but may also contain the `p` parameter value if the `effective\_metric\_` attribute is set to ‘minkowski’.
   */
  get effective_metric_params_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing effective_metric_params_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_effective_metric_params_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_params_`;
      return this._py`attr_RadiusNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_params_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_params_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_n_features_in_ = bridgeRadiusNeighborsTransformer[${this.id}].n_features_in_`;
      return this._py`attr_RadiusNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_features_in_, 'tolist') else attr_RadiusNeighborsTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_feature_names_in_ = bridgeRadiusNeighborsTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_RadiusNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_feature_names_in_, 'tolist') else attr_RadiusNeighborsTransformer_feature_names_in_`;
    })();
  }
  /**
    Number of samples in the fitted data.
   */
  get n_samples_fit_() {
    if (this._isDisposed) {
      throw new Error(
        "This RadiusNeighborsTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RadiusNeighborsTransformer must call init() before accessing n_samples_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RadiusNeighborsTransformer_n_samples_fit_ = bridgeRadiusNeighborsTransformer[${this.id}].n_samples_fit_`;
      return this._py`attr_RadiusNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_samples_fit_, 'tolist') else attr_RadiusNeighborsTransformer_n_samples_fit_`;
    })();
  }
};
export {
  BallTree,
  KDTree,
  KNeighborsClassifier,
  KNeighborsRegressor,
  KNeighborsTransformer,
  KernelDensity,
  LocalOutlierFactor,
  NearestCentroid,
  NearestNeighbors,
  NeighborhoodComponentsAnalysis,
  RadiusNeighborsClassifier,
  RadiusNeighborsRegressor,
  RadiusNeighborsTransformer
};
//# sourceMappingURL=index.js.map