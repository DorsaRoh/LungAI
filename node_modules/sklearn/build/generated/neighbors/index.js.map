{"version":3,"sources":["../../../src/generated/neighbors/BallTree.ts","../../../src/generated/neighbors/KDTree.ts","../../../src/generated/neighbors/KernelDensity.ts","../../../src/generated/neighbors/KNeighborsClassifier.ts","../../../src/generated/neighbors/KNeighborsRegressor.ts","../../../src/generated/neighbors/KNeighborsTransformer.ts","../../../src/generated/neighbors/LocalOutlierFactor.ts","../../../src/generated/neighbors/NearestCentroid.ts","../../../src/generated/neighbors/NearestNeighbors.ts","../../../src/generated/neighbors/NeighborhoodComponentsAnalysis.ts","../../../src/generated/neighbors/RadiusNeighborsClassifier.ts","../../../src/generated/neighbors/RadiusNeighborsRegressor.ts","../../../src/generated/neighbors/RadiusNeighborsTransformer.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  BallTree for fast generalized N-point problems\n\n  Read more in the [User Guide](../neighbors.html#unsupervised-neighbors).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html)\n */\nexport class BallTree {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      n\\_samples is the number of points in the data set, and n\\_features is the dimension of the parameter space. Note: if X is a C-contiguous array of doubles then data will not be copied. Otherwise, an internal copy will be made.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Number of points at which to switch to brute-force. Changing leaf\\_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree. The amount of memory needed to store the tree scales as approximately n\\_samples / leaf\\_size. For a specified `leaf\\_size`, a leaf node is guaranteed to satisfy `leaf\\_size <= n\\_points <= 2 \\* leaf\\_size`, except in the case that `n\\_samples < leaf\\_size`.\n\n      @defaultValue `40`\n     */\n    leaf_size?: any\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. A list of valid metrics for BallTree is given by `BallTree.valid\\_metrics`. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for more information on any distance metric.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n  }) {\n    this.id = `BallTree${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('BallTree.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import BallTree\ntry: bridgeBallTree\nexcept NameError: bridgeBallTree = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_BallTree = {'X': np.array(${\n      this.opts['X'] ?? undefined\n    }) if ${this.opts['X'] !== undefined} else None, 'leaf_size': ${\n      this.opts['leaf_size'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}}\n\nctor_BallTree = {k: v for k, v in ctor_BallTree.items() if v is not None}`\n\n    await this._py.ex`bridgeBallTree[${this.id}] = BallTree(**ctor_BallTree)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeBallTree[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Get data and node arrays.\n   */\n  async get_arrays(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before get_arrays()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_get_arrays = {}\n\npms_BallTree_get_arrays = {k: v for k, v in pms_BallTree_get_arrays.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_get_arrays = bridgeBallTree[${this.id}].get_arrays(**pms_BallTree_get_arrays)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_get_arrays.tolist() if hasattr(res_BallTree_get_arrays, 'tolist') else res_BallTree_get_arrays`\n  }\n\n  /**\n    Get number of calls.\n   */\n  async get_n_calls(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before get_n_calls()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_get_n_calls = {}\n\npms_BallTree_get_n_calls = {k: v for k, v in pms_BallTree_get_n_calls.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_get_n_calls = bridgeBallTree[${this.id}].get_n_calls(**pms_BallTree_get_n_calls)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_get_n_calls.tolist() if hasattr(res_BallTree_get_n_calls, 'tolist') else res_BallTree_get_n_calls`\n  }\n\n  /**\n    Get tree status.\n   */\n  async get_tree_stats(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before get_tree_stats()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_get_tree_stats = {}\n\npms_BallTree_get_tree_stats = {k: v for k, v in pms_BallTree_get_tree_stats.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_get_tree_stats = bridgeBallTree[${this.id}].get_tree_stats(**pms_BallTree_get_tree_stats)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_get_tree_stats.tolist() if hasattr(res_BallTree_get_tree_stats, 'tolist') else res_BallTree_get_tree_stats`\n  }\n\n  /**\n    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.\n   */\n  async kernel_density(opts: {\n    /**\n      An array of points to query. Last dimension should match dimension of training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      the bandwidth of the kernel\n     */\n    h?: number\n\n    /**\n      specify the kernel to use. Options are - ‘gaussian’ - ‘tophat’ - ‘epanechnikov’ - ‘exponential’ - ‘linear’ - ‘cosine’ Default is kernel = ‘gaussian’\n\n      @defaultValue `'gaussian'`\n     */\n    kernel?: string\n\n    /**\n      Specify the desired absolute tolerance of the result. If the true result is `K\\_true`, then the returned result `K\\_ret` satisfies `abs(K\\_true \\- K\\_ret) < atol + rtol \\* K\\_ret` The default is zero (i.e. machine precision).\n\n      @defaultValue `0`\n     */\n    atol?: number\n\n    /**\n      Specify the desired relative tolerance of the result. If the true result is `K\\_true`, then the returned result `K\\_ret` satisfies `abs(K\\_true \\- K\\_ret) < atol + rtol \\* K\\_ret` The default is `1e-8` (i.e. machine precision).\n\n      @defaultValue `1e-8`\n     */\n    rtol?: number\n\n    /**\n      If `true`, use a breadth-first search. If `false` (default) use a depth-first search. Breadth-first is generally faster for compact kernels and/or high tolerances.\n\n      @defaultValue `false`\n     */\n    breadth_first?: boolean\n\n    /**\n      Return the logarithm of the result. This can be more accurate than returning the result itself for narrow kernels.\n\n      @defaultValue `false`\n     */\n    return_log?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before kernel_density()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_kernel_density = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'h': ${\n      opts['h'] ?? undefined\n    }, 'kernel': ${opts['kernel'] ?? undefined}, 'atol': ${\n      opts['atol'] ?? undefined\n    }, 'rtol': ${opts['rtol'] ?? undefined}, 'breadth_first': ${\n      opts['breadth_first'] ?? undefined\n    }, 'return_log': ${opts['return_log'] ?? undefined}}\n\npms_BallTree_kernel_density = {k: v for k, v in pms_BallTree_kernel_density.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_kernel_density = bridgeBallTree[${this.id}].kernel_density(**pms_BallTree_kernel_density)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_kernel_density.tolist() if hasattr(res_BallTree_kernel_density, 'tolist') else res_BallTree_kernel_density`\n  }\n\n  /**\n    query the tree for the k nearest neighbors\n   */\n  async query(opts: {\n    /**\n      An array of points to query\n     */\n    X?: ArrayLike[]\n\n    /**\n      The number of nearest neighbors to return\n\n      @defaultValue `1`\n     */\n    k?: number\n\n    /**\n      if `true`, return a tuple (d, i) of distances and indices if `false`, return array i\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      if `true`, use the dual tree formalism for the query: a tree is built for the query points, and the pair of trees is used to efficiently search this space. This can lead to better performance as the number of points grows large.\n\n      @defaultValue `false`\n     */\n    dualtree?: boolean\n\n    /**\n      if `true`, then query the nodes in a breadth-first manner. Otherwise, query the nodes in a depth-first manner.\n\n      @defaultValue `false`\n     */\n    breadth_first?: boolean\n\n    /**\n      if `true`, then distances and indices of each point are sorted on return, so that the first column contains the closest points. Otherwise, neighbors are returned in an arbitrary order.\n\n      @defaultValue `true`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before query()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_query = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'k': ${\n      opts['k'] ?? undefined\n    }, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'dualtree': ${opts['dualtree'] ?? undefined}, 'breadth_first': ${\n      opts['breadth_first'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_BallTree_query = {k: v for k, v in pms_BallTree_query.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_query = bridgeBallTree[${this.id}].query(**pms_BallTree_query)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_query.tolist() if hasattr(res_BallTree_query, 'tolist') else res_BallTree_query`\n  }\n\n  /**\n    query the tree for neighbors within a radius r\n   */\n  async query_radius(opts: {\n    /**\n      An array of points to query\n     */\n    X?: ArrayLike[]\n\n    /**\n      r can be a single value, or an array of values of shape x.shape\\[:-1\\] if different radii are desired for each point.\n     */\n    r?: any\n\n    /**\n      if `true`, return distances to neighbors of each point if `false`, return only neighbors Note that unlike the query() method, setting return\\_distance=`true` here adds to the computation time. Not all distances need to be calculated explicitly for return\\_distance=`false`. Results are not sorted by default: see `sort\\_results` keyword.\n\n      @defaultValue `false`\n     */\n    return_distance?: boolean\n\n    /**\n      if `true`, return only the count of points within distance r if `false`, return the indices of all points within distance r If return\\_distance==`true`, setting count\\_only=`true` will result in an error.\n\n      @defaultValue `false`\n     */\n    count_only?: boolean\n\n    /**\n      if `true`, the distances and indices will be sorted before being returned. If `false`, the results will not be sorted. If return\\_distance == `false`, setting sort\\_results = `true` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before query_radius()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_query_radius = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'r': ${\n      opts['r'] ?? undefined\n    }, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'count_only': ${opts['count_only'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_BallTree_query_radius = {k: v for k, v in pms_BallTree_query_radius.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_query_radius = bridgeBallTree[${this.id}].query_radius(**pms_BallTree_query_radius)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_query_radius.tolist() if hasattr(res_BallTree_query_radius, 'tolist') else res_BallTree_query_radius`\n  }\n\n  /**\n    Reset number of calls to 0.\n   */\n  async reset_n_calls(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before reset_n_calls()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_reset_n_calls = {}\n\npms_BallTree_reset_n_calls = {k: v for k, v in pms_BallTree_reset_n_calls.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_reset_n_calls = bridgeBallTree[${this.id}].reset_n_calls(**pms_BallTree_reset_n_calls)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_reset_n_calls.tolist() if hasattr(res_BallTree_reset_n_calls, 'tolist') else res_BallTree_reset_n_calls`\n  }\n\n  /**\n    Compute the two-point correlation function\n   */\n  async two_point_correlation(opts: {\n    /**\n      An array of points to query. Last dimension should match dimension of training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      A one-dimensional array of distances\n     */\n    r?: ArrayLike\n\n    /**\n      If `true`, use a dualtree algorithm. Otherwise, use a single-tree algorithm. Dual tree algorithms can have better scaling for large N.\n\n      @defaultValue `false`\n     */\n    dualtree?: boolean\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BallTree must call init() before two_point_correlation()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BallTree_two_point_correlation = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'r': ${\n      opts['r'] ?? undefined\n    }, 'dualtree': ${opts['dualtree'] ?? undefined}}\n\npms_BallTree_two_point_correlation = {k: v for k, v in pms_BallTree_two_point_correlation.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BallTree_two_point_correlation = bridgeBallTree[${this.id}].two_point_correlation(**pms_BallTree_two_point_correlation)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BallTree_two_point_correlation.tolist() if hasattr(res_BallTree_two_point_correlation, 'tolist') else res_BallTree_two_point_correlation`\n  }\n\n  /**\n    The training data\n   */\n  get data(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BallTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BallTree must call init() before accessing data')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_BallTree_data = bridgeBallTree[${this.id}].data`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BallTree_data.tolist() if hasattr(attr_BallTree_data, 'tolist') else attr_BallTree_data`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  KDTree for fast generalized N-point problems\n\n  Read more in the [User Guide](../neighbors.html#unsupervised-neighbors).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html)\n */\nexport class KDTree {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      n\\_samples is the number of points in the data set, and n\\_features is the dimension of the parameter space. Note: if X is a C-contiguous array of doubles then data will not be copied. Otherwise, an internal copy will be made.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Number of points at which to switch to brute-force. Changing leaf\\_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree. The amount of memory needed to store the tree scales as approximately n\\_samples / leaf\\_size. For a specified `leaf\\_size`, a leaf node is guaranteed to satisfy `leaf\\_size <= n\\_points <= 2 \\* leaf\\_size`, except in the case that `n\\_samples < leaf\\_size`.\n\n      @defaultValue `40`\n     */\n    leaf_size?: any\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. A list of valid metrics for KDTree is given by `KDTree.valid\\_metrics`. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for more information on any distance metric.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n  }) {\n    this.id = `KDTree${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KDTree.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import KDTree\ntry: bridgeKDTree\nexcept NameError: bridgeKDTree = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KDTree = {'X': np.array(${\n      this.opts['X'] ?? undefined\n    }) if ${this.opts['X'] !== undefined} else None, 'leaf_size': ${\n      this.opts['leaf_size'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}}\n\nctor_KDTree = {k: v for k, v in ctor_KDTree.items() if v is not None}`\n\n    await this._py.ex`bridgeKDTree[${this.id}] = KDTree(**ctor_KDTree)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKDTree[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Get data and node arrays.\n   */\n  async get_arrays(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before get_arrays()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_get_arrays = {}\n\npms_KDTree_get_arrays = {k: v for k, v in pms_KDTree_get_arrays.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_get_arrays = bridgeKDTree[${this.id}].get_arrays(**pms_KDTree_get_arrays)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_get_arrays.tolist() if hasattr(res_KDTree_get_arrays, 'tolist') else res_KDTree_get_arrays`\n  }\n\n  /**\n    Get number of calls.\n   */\n  async get_n_calls(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before get_n_calls()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_get_n_calls = {}\n\npms_KDTree_get_n_calls = {k: v for k, v in pms_KDTree_get_n_calls.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_get_n_calls = bridgeKDTree[${this.id}].get_n_calls(**pms_KDTree_get_n_calls)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_get_n_calls.tolist() if hasattr(res_KDTree_get_n_calls, 'tolist') else res_KDTree_get_n_calls`\n  }\n\n  /**\n    Get tree status.\n   */\n  async get_tree_stats(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before get_tree_stats()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_get_tree_stats = {}\n\npms_KDTree_get_tree_stats = {k: v for k, v in pms_KDTree_get_tree_stats.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_get_tree_stats = bridgeKDTree[${this.id}].get_tree_stats(**pms_KDTree_get_tree_stats)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_get_tree_stats.tolist() if hasattr(res_KDTree_get_tree_stats, 'tolist') else res_KDTree_get_tree_stats`\n  }\n\n  /**\n    Compute the kernel density estimate at points X with the given kernel, using the distance metric specified at tree creation.\n   */\n  async kernel_density(opts: {\n    /**\n      An array of points to query. Last dimension should match dimension of training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      the bandwidth of the kernel\n     */\n    h?: number\n\n    /**\n      specify the kernel to use. Options are - ‘gaussian’ - ‘tophat’ - ‘epanechnikov’ - ‘exponential’ - ‘linear’ - ‘cosine’ Default is kernel = ‘gaussian’\n\n      @defaultValue `'gaussian'`\n     */\n    kernel?: string\n\n    /**\n      Specify the desired absolute tolerance of the result. If the true result is `K\\_true`, then the returned result `K\\_ret` satisfies `abs(K\\_true \\- K\\_ret) < atol + rtol \\* K\\_ret` The default is zero (i.e. machine precision).\n\n      @defaultValue `0`\n     */\n    atol?: number\n\n    /**\n      Specify the desired relative tolerance of the result. If the true result is `K\\_true`, then the returned result `K\\_ret` satisfies `abs(K\\_true \\- K\\_ret) < atol + rtol \\* K\\_ret` The default is `1e-8` (i.e. machine precision).\n\n      @defaultValue `1e-8`\n     */\n    rtol?: number\n\n    /**\n      If `true`, use a breadth-first search. If `false` (default) use a depth-first search. Breadth-first is generally faster for compact kernels and/or high tolerances.\n\n      @defaultValue `false`\n     */\n    breadth_first?: boolean\n\n    /**\n      Return the logarithm of the result. This can be more accurate than returning the result itself for narrow kernels.\n\n      @defaultValue `false`\n     */\n    return_log?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before kernel_density()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_kernel_density = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'h': ${\n      opts['h'] ?? undefined\n    }, 'kernel': ${opts['kernel'] ?? undefined}, 'atol': ${\n      opts['atol'] ?? undefined\n    }, 'rtol': ${opts['rtol'] ?? undefined}, 'breadth_first': ${\n      opts['breadth_first'] ?? undefined\n    }, 'return_log': ${opts['return_log'] ?? undefined}}\n\npms_KDTree_kernel_density = {k: v for k, v in pms_KDTree_kernel_density.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_kernel_density = bridgeKDTree[${this.id}].kernel_density(**pms_KDTree_kernel_density)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_kernel_density.tolist() if hasattr(res_KDTree_kernel_density, 'tolist') else res_KDTree_kernel_density`\n  }\n\n  /**\n    query the tree for the k nearest neighbors\n   */\n  async query(opts: {\n    /**\n      An array of points to query\n     */\n    X?: ArrayLike[]\n\n    /**\n      The number of nearest neighbors to return\n\n      @defaultValue `1`\n     */\n    k?: number\n\n    /**\n      if `true`, return a tuple (d, i) of distances and indices if `false`, return array i\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      if `true`, use the dual tree formalism for the query: a tree is built for the query points, and the pair of trees is used to efficiently search this space. This can lead to better performance as the number of points grows large.\n\n      @defaultValue `false`\n     */\n    dualtree?: boolean\n\n    /**\n      if `true`, then query the nodes in a breadth-first manner. Otherwise, query the nodes in a depth-first manner.\n\n      @defaultValue `false`\n     */\n    breadth_first?: boolean\n\n    /**\n      if `true`, then distances and indices of each point are sorted on return, so that the first column contains the closest points. Otherwise, neighbors are returned in an arbitrary order.\n\n      @defaultValue `true`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before query()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_query = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'k': ${\n      opts['k'] ?? undefined\n    }, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'dualtree': ${opts['dualtree'] ?? undefined}, 'breadth_first': ${\n      opts['breadth_first'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_KDTree_query = {k: v for k, v in pms_KDTree_query.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_query = bridgeKDTree[${this.id}].query(**pms_KDTree_query)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_query.tolist() if hasattr(res_KDTree_query, 'tolist') else res_KDTree_query`\n  }\n\n  /**\n    query the tree for neighbors within a radius r\n   */\n  async query_radius(opts: {\n    /**\n      An array of points to query\n     */\n    X?: ArrayLike[]\n\n    /**\n      r can be a single value, or an array of values of shape x.shape\\[:-1\\] if different radii are desired for each point.\n     */\n    r?: any\n\n    /**\n      if `true`, return distances to neighbors of each point if `false`, return only neighbors Note that unlike the query() method, setting return\\_distance=`true` here adds to the computation time. Not all distances need to be calculated explicitly for return\\_distance=`false`. Results are not sorted by default: see `sort\\_results` keyword.\n\n      @defaultValue `false`\n     */\n    return_distance?: boolean\n\n    /**\n      if `true`, return only the count of points within distance r if `false`, return the indices of all points within distance r If return\\_distance==`true`, setting count\\_only=`true` will result in an error.\n\n      @defaultValue `false`\n     */\n    count_only?: boolean\n\n    /**\n      if `true`, the distances and indices will be sorted before being returned. If `false`, the results will not be sorted. If return\\_distance == `false`, setting sort\\_results = `true` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before query_radius()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_query_radius = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'r': ${\n      opts['r'] ?? undefined\n    }, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'count_only': ${opts['count_only'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_KDTree_query_radius = {k: v for k, v in pms_KDTree_query_radius.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_query_radius = bridgeKDTree[${this.id}].query_radius(**pms_KDTree_query_radius)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_query_radius.tolist() if hasattr(res_KDTree_query_radius, 'tolist') else res_KDTree_query_radius`\n  }\n\n  /**\n    Reset number of calls to 0.\n   */\n  async reset_n_calls(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before reset_n_calls()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_reset_n_calls = {}\n\npms_KDTree_reset_n_calls = {k: v for k, v in pms_KDTree_reset_n_calls.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_reset_n_calls = bridgeKDTree[${this.id}].reset_n_calls(**pms_KDTree_reset_n_calls)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_reset_n_calls.tolist() if hasattr(res_KDTree_reset_n_calls, 'tolist') else res_KDTree_reset_n_calls`\n  }\n\n  /**\n    Compute the two-point correlation function\n   */\n  async two_point_correlation(opts: {\n    /**\n      An array of points to query. Last dimension should match dimension of training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      A one-dimensional array of distances\n     */\n    r?: ArrayLike\n\n    /**\n      If `true`, use a dualtree algorithm. Otherwise, use a single-tree algorithm. Dual tree algorithms can have better scaling for large N.\n\n      @defaultValue `false`\n     */\n    dualtree?: boolean\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before two_point_correlation()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KDTree_two_point_correlation = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'r': ${\n      opts['r'] ?? undefined\n    }, 'dualtree': ${opts['dualtree'] ?? undefined}}\n\npms_KDTree_two_point_correlation = {k: v for k, v in pms_KDTree_two_point_correlation.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KDTree_two_point_correlation = bridgeKDTree[${this.id}].two_point_correlation(**pms_KDTree_two_point_correlation)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KDTree_two_point_correlation.tolist() if hasattr(res_KDTree_two_point_correlation, 'tolist') else res_KDTree_two_point_correlation`\n  }\n\n  /**\n    The training data\n   */\n  get data(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KDTree instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KDTree must call init() before accessing data')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_KDTree_data = bridgeKDTree[${this.id}].data`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KDTree_data.tolist() if hasattr(attr_KDTree_data, 'tolist') else attr_KDTree_data`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Kernel Density Estimation.\n\n  Read more in the [User Guide](../density.html#kernel-density).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KernelDensity.html)\n */\nexport class KernelDensity {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The bandwidth of the kernel. If bandwidth is a float, it defines the bandwidth of the kernel. If bandwidth is a string, one of the estimation methods is implemented.\n\n      @defaultValue `1`\n     */\n    bandwidth?: number | 'scott' | 'silverman'\n\n    /**\n      The tree algorithm to use.\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'kd_tree' | 'ball_tree' | 'auto'\n\n    /**\n      The kernel to use.\n\n      @defaultValue `'gaussian'`\n     */\n    kernel?:\n      | 'gaussian'\n      | 'tophat'\n      | 'epanechnikov'\n      | 'exponential'\n      | 'linear'\n      | 'cosine'\n\n    /**\n      Metric to use for distance computation. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      Not all metrics are valid with all algorithms: refer to the documentation of [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") and [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\"). Note that the normalization of the density output is correct only for the Euclidean distance metric.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: string\n\n    /**\n      The desired absolute tolerance of the result. A larger tolerance will generally lead to faster execution.\n\n      @defaultValue `0`\n     */\n    atol?: number\n\n    /**\n      The desired relative tolerance of the result. A larger tolerance will generally lead to faster execution.\n\n      @defaultValue `0`\n     */\n    rtol?: number\n\n    /**\n      If true (default), use a breadth-first approach to the problem. Otherwise use a depth-first approach.\n\n      @defaultValue `true`\n     */\n    breadth_first?: boolean\n\n    /**\n      Specify the leaf size of the underlying tree. See [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\") for details.\n\n      @defaultValue `40`\n     */\n    leaf_size?: number\n\n    /**\n      Additional parameters to be passed to the tree for use with the metric. For more information, see the documentation of [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\").\n     */\n    metric_params?: any\n  }) {\n    this.id = `KernelDensity${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KernelDensity.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import KernelDensity\ntry: bridgeKernelDensity\nexcept NameError: bridgeKernelDensity = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KernelDensity = {'bandwidth': ${\n      this.opts['bandwidth'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'atol': ${\n      this.opts['atol'] ?? undefined\n    }, 'rtol': ${this.opts['rtol'] ?? undefined}, 'breadth_first': ${\n      this.opts['breadth_first'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }}\n\nctor_KernelDensity = {k: v for k, v in ctor_KernelDensity.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKernelDensity[${this.id}] = KernelDensity(**ctor_KernelDensity)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKernelDensity[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the Kernel Density model on the data.\n   */\n  async fit(opts: {\n    /**\n      List of n\\_features-dimensional data points. Each row corresponds to a single data point.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\").\n     */\n    y?: any\n\n    /**\n      List of sample weights attached to the data X.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${\n      opts['sample_weight'] !== undefined\n    } else None}\n\npms_KernelDensity_fit = {k: v for k, v in pms_KernelDensity_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_fit = bridgeKernelDensity[${this.id}].fit(**pms_KernelDensity_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_fit.tolist() if hasattr(res_KernelDensity_fit, 'tolist') else res_KernelDensity_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelDensity must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KernelDensity_get_metadata_routing = {k: v for k, v in pms_KernelDensity_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_get_metadata_routing = bridgeKernelDensity[${this.id}].get_metadata_routing(**pms_KernelDensity_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_get_metadata_routing.tolist() if hasattr(res_KernelDensity_get_metadata_routing, 'tolist') else res_KernelDensity_get_metadata_routing`\n  }\n\n  /**\n    Generate random samples from the model.\n\n    Currently, this is implemented only for gaussian and tophat kernels.\n   */\n  async sample(opts: {\n    /**\n      Number of samples to generate.\n\n      @defaultValue `1`\n     */\n    n_samples?: number\n\n    /**\n      Determines random number generation used to generate random samples. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before sample()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_sample = {'n_samples': ${\n      opts['n_samples'] ?? undefined\n    }, 'random_state': ${opts['random_state'] ?? undefined}}\n\npms_KernelDensity_sample = {k: v for k, v in pms_KernelDensity_sample.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_sample = bridgeKernelDensity[${this.id}].sample(**pms_KernelDensity_sample)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_sample.tolist() if hasattr(res_KernelDensity_sample, 'tolist') else res_KernelDensity_sample`\n  }\n\n  /**\n    Compute the total log-likelihood under the model.\n   */\n  async score(opts: {\n    /**\n      List of n\\_features-dimensional data points. Each row corresponds to a single data point.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\").\n     */\n    y?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KernelDensity_score = {k: v for k, v in pms_KernelDensity_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_score = bridgeKernelDensity[${this.id}].score(**pms_KernelDensity_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_score.tolist() if hasattr(res_KernelDensity_score, 'tolist') else res_KernelDensity_score`\n  }\n\n  /**\n    Compute the log-likelihood of each sample under the model.\n   */\n  async score_samples(opts: {\n    /**\n      An array of points to query. Last dimension should match dimension of training data (n\\_features).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KernelDensity_score_samples = {k: v for k, v in pms_KernelDensity_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_score_samples = bridgeKernelDensity[${this.id}].score_samples(**pms_KernelDensity_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_score_samples.tolist() if hasattr(res_KernelDensity_score_samples, 'tolist') else res_KernelDensity_score_samples`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelDensity_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KernelDensity_set_fit_request = {k: v for k, v in pms_KernelDensity_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelDensity_set_fit_request = bridgeKernelDensity[${this.id}].set_fit_request(**pms_KernelDensity_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelDensity_set_fit_request.tolist() if hasattr(res_KernelDensity_set_fit_request, 'tolist') else res_KernelDensity_set_fit_request`\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelDensity must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelDensity_n_features_in_ = bridgeKernelDensity[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelDensity_n_features_in_.tolist() if hasattr(attr_KernelDensity_n_features_in_, 'tolist') else attr_KernelDensity_n_features_in_`\n    })()\n  }\n\n  /**\n    The tree algorithm for fast generalized N-point problems.\n   */\n  get tree_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelDensity must call init() before accessing tree_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelDensity_tree_ = bridgeKernelDensity[${this.id}].tree_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelDensity_tree_.tolist() if hasattr(attr_KernelDensity_tree_, 'tolist') else attr_KernelDensity_tree_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelDensity must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelDensity_feature_names_in_ = bridgeKernelDensity[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelDensity_feature_names_in_.tolist() if hasattr(attr_KernelDensity_feature_names_in_, 'tolist') else attr_KernelDensity_feature_names_in_`\n    })()\n  }\n\n  /**\n    Value of the bandwidth, given directly by the bandwidth parameter or estimated using the ‘scott’ or ‘silverman’ method.\n   */\n  get bandwidth_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelDensity instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelDensity must call init() before accessing bandwidth_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelDensity_bandwidth_ = bridgeKernelDensity[${this.id}].bandwidth_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelDensity_bandwidth_.tolist() if hasattr(attr_KernelDensity_bandwidth_, 'tolist') else attr_KernelDensity_bandwidth_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Classifier implementing the k-nearest neighbors vote.\n\n  Read more in the [User Guide](../neighbors.html#classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html)\n */\nexport class KNeighborsClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to use by default for [`kneighbors`](#sklearn.neighbors.KNeighborsClassifier.kneighbors \"sklearn.neighbors.KNeighborsClassifier.kneighbors\") queries.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Weight function used in prediction. Possible values:\n\n      @defaultValue `'uniform'`\n     */\n    weights?: 'uniform' | 'distance'\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details. Doesn’t affect [`fit`](#sklearn.neighbors.KNeighborsClassifier.fit \"sklearn.neighbors.KNeighborsClassifier.fit\") method.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `KNeighborsClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'KNeighborsClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import KNeighborsClassifier\ntry: bridgeKNeighborsClassifier\nexcept NameError: bridgeKNeighborsClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KNeighborsClassifier = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'weights': ${this.opts['weights'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'p': ${\n      this.opts['p'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_KNeighborsClassifier = {k: v for k, v in ctor_KNeighborsClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKNeighborsClassifier[${this.id}] = KNeighborsClassifier(**ctor_KNeighborsClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKNeighborsClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the k-nearest neighbors classifier from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_KNeighborsClassifier_fit = {k: v for k, v in pms_KNeighborsClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_fit = bridgeKNeighborsClassifier[${this.id}].fit(**pms_KNeighborsClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_fit.tolist() if hasattr(res_KNeighborsClassifier_fit, 'tolist') else res_KNeighborsClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_KNeighborsClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_get_metadata_routing = bridgeKNeighborsClassifier[${this.id}].get_metadata_routing(**pms_KNeighborsClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_KNeighborsClassifier_get_metadata_routing, 'tolist') else res_KNeighborsClassifier_get_metadata_routing`\n  }\n\n  /**\n    Find the K-neighbors of a point.\n\n    Returns indices of and distances to the neighbors of each point.\n   */\n  async kneighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Number of neighbors required for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before kneighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsClassifier_kneighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'n_neighbors': ${opts['n_neighbors'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }}\n\npms_KNeighborsClassifier_kneighbors = {k: v for k, v in pms_KNeighborsClassifier_kneighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_kneighbors = bridgeKNeighborsClassifier[${this.id}].kneighbors(**pms_KNeighborsClassifier_kneighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_kneighbors.tolist() if hasattr(res_KNeighborsClassifier_kneighbors, 'tolist') else res_KNeighborsClassifier_kneighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of k-Neighbors for points in X.\n   */\n  async kneighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor. For `metric='precomputed'` the shape should be (n\\_queries, n\\_indexed). Otherwise the shape should be (n\\_queries, n\\_features).\n     */\n    X?: any\n\n    /**\n      Number of neighbors for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before kneighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsClassifier_kneighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'n_neighbors': ${\n      opts['n_neighbors'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}}\n\npms_KNeighborsClassifier_kneighbors_graph = {k: v for k, v in pms_KNeighborsClassifier_kneighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_kneighbors_graph = bridgeKNeighborsClassifier[${this.id}].kneighbors_graph(**pms_KNeighborsClassifier_kneighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_kneighbors_graph.tolist() if hasattr(res_KNeighborsClassifier_kneighbors_graph, 'tolist') else res_KNeighborsClassifier_kneighbors_graph`\n  }\n\n  /**\n    Predict the class labels for the provided data.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KNeighborsClassifier_predict = {k: v for k, v in pms_KNeighborsClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_predict = bridgeKNeighborsClassifier[${this.id}].predict(**pms_KNeighborsClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_predict.tolist() if hasattr(res_KNeighborsClassifier_predict, 'tolist') else res_KNeighborsClassifier_predict`\n  }\n\n  /**\n    Return probability estimates for the test data X.\n   */\n  async predict_proba(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KNeighborsClassifier_predict_proba = {k: v for k, v in pms_KNeighborsClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_predict_proba = bridgeKNeighborsClassifier[${this.id}].predict_proba(**pms_KNeighborsClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_predict_proba.tolist() if hasattr(res_KNeighborsClassifier_predict_proba, 'tolist') else res_KNeighborsClassifier_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_KNeighborsClassifier_score = {k: v for k, v in pms_KNeighborsClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_score = bridgeKNeighborsClassifier[${this.id}].score(**pms_KNeighborsClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_score.tolist() if hasattr(res_KNeighborsClassifier_score, 'tolist') else res_KNeighborsClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KNeighborsClassifier_set_score_request = {k: v for k, v in pms_KNeighborsClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsClassifier_set_score_request = bridgeKNeighborsClassifier[${this.id}].set_score_request(**pms_KNeighborsClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsClassifier_set_score_request.tolist() if hasattr(res_KNeighborsClassifier_set_score_request, 'tolist') else res_KNeighborsClassifier_set_score_request`\n  }\n\n  /**\n    Class labels known to the classifier\n   */\n  get classes_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_classes_ = bridgeKNeighborsClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_classes_.tolist() if hasattr(attr_KNeighborsClassifier_classes_, 'tolist') else attr_KNeighborsClassifier_classes_`\n    })()\n  }\n\n  /**\n    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_effective_metric_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_, 'tolist') else attr_KNeighborsClassifier_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_effective_metric_params_ = bridgeKNeighborsClassifier[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_KNeighborsClassifier_effective_metric_params_, 'tolist') else attr_KNeighborsClassifier_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_n_features_in_ = bridgeKNeighborsClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_KNeighborsClassifier_n_features_in_, 'tolist') else attr_KNeighborsClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_feature_names_in_ = bridgeKNeighborsClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_KNeighborsClassifier_feature_names_in_, 'tolist') else attr_KNeighborsClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_n_samples_fit_ = bridgeKNeighborsClassifier[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_KNeighborsClassifier_n_samples_fit_, 'tolist') else attr_KNeighborsClassifier_n_samples_fit_`\n    })()\n  }\n\n  /**\n    False when `y`’s shape is (n\\_samples, ) or (n\\_samples, 1) during fit otherwise `true`.\n   */\n  get outputs_2d_(): Promise<boolean> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsClassifier must call init() before accessing outputs_2d_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsClassifier_outputs_2d_ = bridgeKNeighborsClassifier[${this.id}].outputs_2d_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_KNeighborsClassifier_outputs_2d_, 'tolist') else attr_KNeighborsClassifier_outputs_2d_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Regression based on k-nearest neighbors.\n\n  The target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set.\n\n  Read more in the [User Guide](../neighbors.html#regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsRegressor.html)\n */\nexport class KNeighborsRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to use by default for [`kneighbors`](#sklearn.neighbors.KNeighborsRegressor.kneighbors \"sklearn.neighbors.KNeighborsRegressor.kneighbors\") queries.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Weight function used in prediction. Possible values:\n\n      @defaultValue `'uniform'`\n     */\n    weights?: 'uniform' | 'distance'\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details. Doesn’t affect [`fit`](#sklearn.neighbors.KNeighborsRegressor.fit \"sklearn.neighbors.KNeighborsRegressor.fit\") method.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `KNeighborsRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'KNeighborsRegressor.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import KNeighborsRegressor\ntry: bridgeKNeighborsRegressor\nexcept NameError: bridgeKNeighborsRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KNeighborsRegressor = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'weights': ${this.opts['weights'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'p': ${\n      this.opts['p'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_KNeighborsRegressor = {k: v for k, v in ctor_KNeighborsRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKNeighborsRegressor[${this.id}] = KNeighborsRegressor(**ctor_KNeighborsRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKNeighborsRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the k-nearest neighbors regressor from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_KNeighborsRegressor_fit = {k: v for k, v in pms_KNeighborsRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_fit = bridgeKNeighborsRegressor[${this.id}].fit(**pms_KNeighborsRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_fit.tolist() if hasattr(res_KNeighborsRegressor_fit, 'tolist') else res_KNeighborsRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_KNeighborsRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_get_metadata_routing = bridgeKNeighborsRegressor[${this.id}].get_metadata_routing(**pms_KNeighborsRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_KNeighborsRegressor_get_metadata_routing, 'tolist') else res_KNeighborsRegressor_get_metadata_routing`\n  }\n\n  /**\n    Find the K-neighbors of a point.\n\n    Returns indices of and distances to the neighbors of each point.\n   */\n  async kneighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Number of neighbors required for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before kneighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsRegressor_kneighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'n_neighbors': ${opts['n_neighbors'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }}\n\npms_KNeighborsRegressor_kneighbors = {k: v for k, v in pms_KNeighborsRegressor_kneighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_kneighbors = bridgeKNeighborsRegressor[${this.id}].kneighbors(**pms_KNeighborsRegressor_kneighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_kneighbors.tolist() if hasattr(res_KNeighborsRegressor_kneighbors, 'tolist') else res_KNeighborsRegressor_kneighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of k-Neighbors for points in X.\n   */\n  async kneighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor. For `metric='precomputed'` the shape should be (n\\_queries, n\\_indexed). Otherwise the shape should be (n\\_queries, n\\_features).\n     */\n    X?: any\n\n    /**\n      Number of neighbors for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before kneighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsRegressor_kneighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'n_neighbors': ${\n      opts['n_neighbors'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}}\n\npms_KNeighborsRegressor_kneighbors_graph = {k: v for k, v in pms_KNeighborsRegressor_kneighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_kneighbors_graph = bridgeKNeighborsRegressor[${this.id}].kneighbors_graph(**pms_KNeighborsRegressor_kneighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_kneighbors_graph.tolist() if hasattr(res_KNeighborsRegressor_kneighbors_graph, 'tolist') else res_KNeighborsRegressor_kneighbors_graph`\n  }\n\n  /**\n    Predict the target for the provided data.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KNeighborsRegressor_predict = {k: v for k, v in pms_KNeighborsRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_predict = bridgeKNeighborsRegressor[${this.id}].predict(**pms_KNeighborsRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_predict.tolist() if hasattr(res_KNeighborsRegressor_predict, 'tolist') else res_KNeighborsRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_KNeighborsRegressor_score = {k: v for k, v in pms_KNeighborsRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_score = bridgeKNeighborsRegressor[${this.id}].score(**pms_KNeighborsRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_score.tolist() if hasattr(res_KNeighborsRegressor_score, 'tolist') else res_KNeighborsRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_KNeighborsRegressor_set_score_request = {k: v for k, v in pms_KNeighborsRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsRegressor_set_score_request = bridgeKNeighborsRegressor[${this.id}].set_score_request(**pms_KNeighborsRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsRegressor_set_score_request.tolist() if hasattr(res_KNeighborsRegressor_set_score_request, 'tolist') else res_KNeighborsRegressor_set_score_request`\n  }\n\n  /**\n    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsRegressor_effective_metric_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_, 'tolist') else attr_KNeighborsRegressor_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsRegressor_effective_metric_params_ = bridgeKNeighborsRegressor[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_KNeighborsRegressor_effective_metric_params_, 'tolist') else attr_KNeighborsRegressor_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsRegressor_n_features_in_ = bridgeKNeighborsRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_KNeighborsRegressor_n_features_in_, 'tolist') else attr_KNeighborsRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsRegressor_feature_names_in_ = bridgeKNeighborsRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_KNeighborsRegressor_feature_names_in_, 'tolist') else attr_KNeighborsRegressor_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsRegressor must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsRegressor_n_samples_fit_ = bridgeKNeighborsRegressor[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_KNeighborsRegressor_n_samples_fit_, 'tolist') else attr_KNeighborsRegressor_n_samples_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transform X into a (weighted) graph of k nearest neighbors.\n\n  The transformed data is a sparse graph as returned by kneighbors\\_graph.\n\n  Read more in the [User Guide](../neighbors.html#neighbors-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsTransformer.html)\n */\nexport class KNeighborsTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, and ‘distance’ will return the distances between neighbors according to the given metric.\n\n      @defaultValue `'distance'`\n     */\n    mode?: 'distance' | 'connectivity'\n\n    /**\n      Number of neighbors for each sample in the transformed sparse graph. For compatibility reasons, as each sample is considered as its own neighbor, one extra neighbor will be computed when mode == ‘distance’. In this case, the sparse graph contains (n\\_neighbors + 1) neighbors.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      Distance matrices are not supported.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise\\_distances. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. If `\\-1`, then the number of jobs is set to the number of CPU cores.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `KNeighborsTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'KNeighborsTransformer.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import KNeighborsTransformer\ntry: bridgeKNeighborsTransformer\nexcept NameError: bridgeKNeighborsTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KNeighborsTransformer = {'mode': ${\n      this.opts['mode'] ?? undefined\n    }, 'n_neighbors': ${this.opts['n_neighbors'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_KNeighborsTransformer = {k: v for k, v in ctor_KNeighborsTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeKNeighborsTransformer[${this.id}] = KNeighborsTransformer(**ctor_KNeighborsTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKNeighborsTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the k-nearest neighbors transformer from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KNeighborsTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KNeighborsTransformer_fit = {k: v for k, v in pms_KNeighborsTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_fit = bridgeKNeighborsTransformer[${this.id}].fit(**pms_KNeighborsTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_fit.tolist() if hasattr(res_KNeighborsTransformer_fit, 'tolist') else res_KNeighborsTransformer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to X and y with optional parameters fit\\_params and returns a transformed version of X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training set.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KNeighborsTransformer_fit_transform = {k: v for k, v in pms_KNeighborsTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_fit_transform = bridgeKNeighborsTransformer[${this.id}].fit_transform(**pms_KNeighborsTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_fit_transform.tolist() if hasattr(res_KNeighborsTransformer_fit_transform, 'tolist') else res_KNeighborsTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_KNeighborsTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_get_feature_names_out = bridgeKNeighborsTransformer[${this.id}].get_feature_names_out(**pms_KNeighborsTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_KNeighborsTransformer_get_feature_names_out, 'tolist') else res_KNeighborsTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_KNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_KNeighborsTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_get_metadata_routing = bridgeKNeighborsTransformer[${this.id}].get_metadata_routing(**pms_KNeighborsTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_KNeighborsTransformer_get_metadata_routing, 'tolist') else res_KNeighborsTransformer_get_metadata_routing`\n  }\n\n  /**\n    Find the K-neighbors of a point.\n\n    Returns indices of and distances to the neighbors of each point.\n   */\n  async kneighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Number of neighbors required for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before kneighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsTransformer_kneighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'n_neighbors': ${opts['n_neighbors'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }}\n\npms_KNeighborsTransformer_kneighbors = {k: v for k, v in pms_KNeighborsTransformer_kneighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_kneighbors = bridgeKNeighborsTransformer[${this.id}].kneighbors(**pms_KNeighborsTransformer_kneighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_kneighbors.tolist() if hasattr(res_KNeighborsTransformer_kneighbors, 'tolist') else res_KNeighborsTransformer_kneighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of k-Neighbors for points in X.\n   */\n  async kneighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor. For `metric='precomputed'` the shape should be (n\\_queries, n\\_indexed). Otherwise the shape should be (n\\_queries, n\\_features).\n     */\n    X?: any\n\n    /**\n      Number of neighbors for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before kneighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KNeighborsTransformer_kneighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'n_neighbors': ${\n      opts['n_neighbors'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}}\n\npms_KNeighborsTransformer_kneighbors_graph = {k: v for k, v in pms_KNeighborsTransformer_kneighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_kneighbors_graph = bridgeKNeighborsTransformer[${this.id}].kneighbors_graph(**pms_KNeighborsTransformer_kneighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_kneighbors_graph.tolist() if hasattr(res_KNeighborsTransformer_kneighbors_graph, 'tolist') else res_KNeighborsTransformer_kneighbors_graph`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KNeighborsTransformer_set_output = {k: v for k, v in pms_KNeighborsTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_set_output = bridgeKNeighborsTransformer[${this.id}].set_output(**pms_KNeighborsTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_set_output.tolist() if hasattr(res_KNeighborsTransformer_set_output, 'tolist') else res_KNeighborsTransformer_set_output`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n   */\n  async transform(opts: {\n    /**\n      Sample data.\n     */\n    X?: ArrayLike[]\n  }): Promise<SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_KNeighborsTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KNeighborsTransformer_transform = {k: v for k, v in pms_KNeighborsTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KNeighborsTransformer_transform = bridgeKNeighborsTransformer[${this.id}].transform(**pms_KNeighborsTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KNeighborsTransformer_transform.tolist() if hasattr(res_KNeighborsTransformer_transform, 'tolist') else res_KNeighborsTransformer_transform`\n  }\n\n  /**\n    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsTransformer_effective_metric_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_, 'tolist') else attr_KNeighborsTransformer_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsTransformer_effective_metric_params_ = bridgeKNeighborsTransformer[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_KNeighborsTransformer_effective_metric_params_, 'tolist') else attr_KNeighborsTransformer_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsTransformer_n_features_in_ = bridgeKNeighborsTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_KNeighborsTransformer_n_features_in_, 'tolist') else attr_KNeighborsTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsTransformer_feature_names_in_ = bridgeKNeighborsTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_KNeighborsTransformer_feature_names_in_, 'tolist') else attr_KNeighborsTransformer_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This KNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KNeighborsTransformer must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KNeighborsTransformer_n_samples_fit_ = bridgeKNeighborsTransformer[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_KNeighborsTransformer_n_samples_fit_, 'tolist') else attr_KNeighborsTransformer_n_samples_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Unsupervised Outlier Detection using the Local Outlier Factor (LOF).\n\n  The anomaly score of each sample is called the Local Outlier Factor. It measures the local deviation of the density of a given sample with respect to its neighbors. It is local in that the anomaly score depends on how isolated the object is with respect to the surrounding neighborhood. More precisely, locality is given by k-nearest neighbors, whose distance is used to estimate the local density. By comparing the local density of a sample to the local densities of its neighbors, one can identify samples that have a substantially lower density than their neighbors. These are considered outliers.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.LocalOutlierFactor.html)\n */\nexport class LocalOutlierFactor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to use by default for [`kneighbors`](#sklearn.neighbors.LocalOutlierFactor.kneighbors \"sklearn.neighbors.LocalOutlierFactor.kneighbors\") queries. If n\\_neighbors is larger than the number of samples provided, all samples will be used.\n\n      @defaultValue `20`\n     */\n    n_neighbors?: number\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf is size passed to [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree \"sklearn.neighbors.BallTree\") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree \"sklearn.neighbors.KDTree\"). This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Parameter for the Minkowski metric from [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\"). When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The amount of contamination of the data set, i.e. the proportion of outliers in the data set. When fitting this is used to define the threshold on the scores of the samples.\n\n      @defaultValue `'auto'`\n     */\n    contamination?: 'auto' | number\n\n    /**\n      By default, LocalOutlierFactor is only meant to be used for outlier detection (novelty=`false`). Set novelty to `true` if you want to use LocalOutlierFactor for novelty detection. In this case be aware that you should only use predict, decision\\_function and score\\_samples on new unseen data and not on the training set; and note that the results obtained this way may differ from the standard LOF results.\n\n      @defaultValue `false`\n     */\n    novelty?: boolean\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `LocalOutlierFactor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'LocalOutlierFactor.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import LocalOutlierFactor\ntry: bridgeLocalOutlierFactor\nexcept NameError: bridgeLocalOutlierFactor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LocalOutlierFactor = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'algorithm': ${this.opts['algorithm'] ?? undefined}, 'leaf_size': ${\n      this.opts['leaf_size'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'p': ${\n      this.opts['p'] ?? undefined\n    }, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'contamination': ${\n      this.opts['contamination'] ?? undefined\n    }, 'novelty': ${this.opts['novelty'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_LocalOutlierFactor = {k: v for k, v in ctor_LocalOutlierFactor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLocalOutlierFactor[${this.id}] = LocalOutlierFactor(**ctor_LocalOutlierFactor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLocalOutlierFactor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Shifted opposite of the Local Outlier Factor of X.\n\n    Bigger is better, i.e. large values correspond to inliers.\n\n    **Only available for novelty detection (when novelty is set to `true`).** The shift offset allows a zero threshold for being an outlier. The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point.\n   */\n  async decision_function(opts: {\n    /**\n      The query sample or samples to compute the Local Outlier Factor w.r.t. the training samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocalOutlierFactor_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LocalOutlierFactor_decision_function = {k: v for k, v in pms_LocalOutlierFactor_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_decision_function = bridgeLocalOutlierFactor[${this.id}].decision_function(**pms_LocalOutlierFactor_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_decision_function.tolist() if hasattr(res_LocalOutlierFactor_decision_function, 'tolist') else res_LocalOutlierFactor_decision_function`\n  }\n\n  /**\n    Fit the local outlier factor detector from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LocalOutlierFactor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocalOutlierFactor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LocalOutlierFactor_fit = {k: v for k, v in pms_LocalOutlierFactor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_fit = bridgeLocalOutlierFactor[${this.id}].fit(**pms_LocalOutlierFactor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_fit.tolist() if hasattr(res_LocalOutlierFactor_fit, 'tolist') else res_LocalOutlierFactor_fit`\n  }\n\n  /**\n    Fit the model to the training set X and return the labels.\n\n    **Not available for novelty detection (when novelty is set to `true`).** Label is 1 for an inlier and -1 for an outlier according to the LOF score and the contamination parameter.\n   */\n  async fit_predict(opts: {\n    /**\n      The query sample or samples to compute the Local Outlier Factor w.r.t. the training samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before fit_predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocalOutlierFactor_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_LocalOutlierFactor_fit_predict = {k: v for k, v in pms_LocalOutlierFactor_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_fit_predict = bridgeLocalOutlierFactor[${this.id}].fit_predict(**pms_LocalOutlierFactor_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_fit_predict.tolist() if hasattr(res_LocalOutlierFactor_fit_predict, 'tolist') else res_LocalOutlierFactor_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocalOutlierFactor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LocalOutlierFactor_get_metadata_routing = {k: v for k, v in pms_LocalOutlierFactor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_get_metadata_routing = bridgeLocalOutlierFactor[${this.id}].get_metadata_routing(**pms_LocalOutlierFactor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_get_metadata_routing.tolist() if hasattr(res_LocalOutlierFactor_get_metadata_routing, 'tolist') else res_LocalOutlierFactor_get_metadata_routing`\n  }\n\n  /**\n    Find the K-neighbors of a point.\n\n    Returns indices of and distances to the neighbors of each point.\n   */\n  async kneighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Number of neighbors required for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LocalOutlierFactor must call init() before kneighbors()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocalOutlierFactor_kneighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'n_neighbors': ${opts['n_neighbors'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }}\n\npms_LocalOutlierFactor_kneighbors = {k: v for k, v in pms_LocalOutlierFactor_kneighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_kneighbors = bridgeLocalOutlierFactor[${this.id}].kneighbors(**pms_LocalOutlierFactor_kneighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_kneighbors.tolist() if hasattr(res_LocalOutlierFactor_kneighbors, 'tolist') else res_LocalOutlierFactor_kneighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of k-Neighbors for points in X.\n   */\n  async kneighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor. For `metric='precomputed'` the shape should be (n\\_queries, n\\_indexed). Otherwise the shape should be (n\\_queries, n\\_features).\n     */\n    X?: any\n\n    /**\n      Number of neighbors for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before kneighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LocalOutlierFactor_kneighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'n_neighbors': ${\n      opts['n_neighbors'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}}\n\npms_LocalOutlierFactor_kneighbors_graph = {k: v for k, v in pms_LocalOutlierFactor_kneighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_kneighbors_graph = bridgeLocalOutlierFactor[${this.id}].kneighbors_graph(**pms_LocalOutlierFactor_kneighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_kneighbors_graph.tolist() if hasattr(res_LocalOutlierFactor_kneighbors_graph, 'tolist') else res_LocalOutlierFactor_kneighbors_graph`\n  }\n\n  /**\n    Predict the labels (1 inlier, -1 outlier) of X according to LOF.\n\n    **Only available for novelty detection (when novelty is set to `true`).** This method allows to generalize prediction to *new observations* (not in the training set). Note that the result of `clf.fit(X)` then `clf.predict(X)` with `novelty=True` may differ from the result obtained by `clf.fit\\_predict(X)` with `novelty=False`.\n   */\n  async predict(opts: {\n    /**\n      The query sample or samples to compute the Local Outlier Factor w.r.t. the training samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LocalOutlierFactor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocalOutlierFactor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LocalOutlierFactor_predict = {k: v for k, v in pms_LocalOutlierFactor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_predict = bridgeLocalOutlierFactor[${this.id}].predict(**pms_LocalOutlierFactor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_predict.tolist() if hasattr(res_LocalOutlierFactor_predict, 'tolist') else res_LocalOutlierFactor_predict`\n  }\n\n  /**\n    Opposite of the Local Outlier Factor of X.\n\n    It is the opposite as bigger is better, i.e. large values correspond to inliers.\n\n    **Only available for novelty detection (when novelty is set to `true`).** The argument X is supposed to contain *new data*: if X contains a point from training, it considers the later in its own neighborhood. Also, the samples in X are not considered in the neighborhood of any point. Because of this, the scores obtained via `score\\_samples` may differ from the standard LOF scores. The standard LOF scores for the training data is available via the `negative\\_outlier\\_factor\\_` attribute.\n   */\n  async score_samples(opts: {\n    /**\n      The query sample or samples to compute the Local Outlier Factor w.r.t. the training samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before score_samples()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LocalOutlierFactor_score_samples = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LocalOutlierFactor_score_samples = {k: v for k, v in pms_LocalOutlierFactor_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LocalOutlierFactor_score_samples = bridgeLocalOutlierFactor[${this.id}].score_samples(**pms_LocalOutlierFactor_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LocalOutlierFactor_score_samples.tolist() if hasattr(res_LocalOutlierFactor_score_samples, 'tolist') else res_LocalOutlierFactor_score_samples`\n  }\n\n  /**\n    The opposite LOF of the training samples. The higher, the more normal. Inliers tend to have a LOF score close to 1 (`negative\\_outlier\\_factor\\_` close to -1), while outliers tend to have a larger LOF score.\n\n    The local outlier factor (LOF) of a sample captures its supposed ‘degree of abnormality’. It is the average of the ratio of the local reachability density of a sample and those of its k-nearest neighbors.\n   */\n  get negative_outlier_factor_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing negative_outlier_factor_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_negative_outlier_factor_ = bridgeLocalOutlierFactor[${this.id}].negative_outlier_factor_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_negative_outlier_factor_.tolist() if hasattr(attr_LocalOutlierFactor_negative_outlier_factor_, 'tolist') else attr_LocalOutlierFactor_negative_outlier_factor_`\n    })()\n  }\n\n  /**\n    The actual number of neighbors used for [`kneighbors`](#sklearn.neighbors.LocalOutlierFactor.kneighbors \"sklearn.neighbors.LocalOutlierFactor.kneighbors\") queries.\n   */\n  get n_neighbors_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing n_neighbors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_n_neighbors_ = bridgeLocalOutlierFactor[${this.id}].n_neighbors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_n_neighbors_.tolist() if hasattr(attr_LocalOutlierFactor_n_neighbors_, 'tolist') else attr_LocalOutlierFactor_n_neighbors_`\n    })()\n  }\n\n  /**\n    Offset used to obtain binary labels from the raw scores. Observations having a negative\\_outlier\\_factor smaller than `offset\\_` are detected as abnormal. The offset is set to -1.5 (inliers score around -1), except when a contamination parameter different than “auto” is provided. In that case, the offset is defined in such a way we obtain the expected number of outliers in training.\n   */\n  get offset_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_offset_ = bridgeLocalOutlierFactor[${this.id}].offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_offset_.tolist() if hasattr(attr_LocalOutlierFactor_offset_, 'tolist') else attr_LocalOutlierFactor_offset_`\n    })()\n  }\n\n  /**\n    The effective metric used for the distance computation.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_effective_metric_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_effective_metric_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_, 'tolist') else attr_LocalOutlierFactor_effective_metric_`\n    })()\n  }\n\n  /**\n    The effective additional keyword arguments for the metric function.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_effective_metric_params_ = bridgeLocalOutlierFactor[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_effective_metric_params_.tolist() if hasattr(attr_LocalOutlierFactor_effective_metric_params_, 'tolist') else attr_LocalOutlierFactor_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_n_features_in_ = bridgeLocalOutlierFactor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_n_features_in_.tolist() if hasattr(attr_LocalOutlierFactor_n_features_in_, 'tolist') else attr_LocalOutlierFactor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_feature_names_in_ = bridgeLocalOutlierFactor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_feature_names_in_.tolist() if hasattr(attr_LocalOutlierFactor_feature_names_in_, 'tolist') else attr_LocalOutlierFactor_feature_names_in_`\n    })()\n  }\n\n  /**\n    It is the number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LocalOutlierFactor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LocalOutlierFactor must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LocalOutlierFactor_n_samples_fit_ = bridgeLocalOutlierFactor[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LocalOutlierFactor_n_samples_fit_.tolist() if hasattr(attr_LocalOutlierFactor_n_samples_fit_, 'tolist') else attr_LocalOutlierFactor_n_samples_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Nearest centroid classifier.\n\n  Each class is represented by its centroid, with test samples classified to the class with the nearest centroid.\n\n  Read more in the [User Guide](../neighbors.html#nearest-centroid-classifier).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestCentroid.html)\n */\nexport class NearestCentroid {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Metric to use for distance computation. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values. Note that “wminkowski”, “seuclidean” and “mahalanobis” are not supported.\n\n      The centroids for the samples corresponding to each class is the point from which the sum of the distances (according to the metric) of all samples that belong to that particular class are minimized. If the `\"manhattan\"` metric is provided, this centroid is the median and for all other metrics, the centroid is now set to be the mean.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: string\n\n    /**\n      Threshold for shrinking centroids to remove features.\n     */\n    shrink_threshold?: number\n  }) {\n    this.id = `NearestCentroid${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NearestCentroid.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import NearestCentroid\ntry: bridgeNearestCentroid\nexcept NameError: bridgeNearestCentroid = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NearestCentroid = {'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'shrink_threshold': ${this.opts['shrink_threshold'] ?? undefined}}\n\nctor_NearestCentroid = {k: v for k, v in ctor_NearestCentroid.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeNearestCentroid[${this.id}] = NearestCentroid(**ctor_NearestCentroid)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNearestCentroid[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the NearestCentroid model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. Note that centroid shrinking cannot be used with sparse matrices.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_NearestCentroid_fit = {k: v for k, v in pms_NearestCentroid_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_fit = bridgeNearestCentroid[${this.id}].fit(**pms_NearestCentroid_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_fit.tolist() if hasattr(res_NearestCentroid_fit, 'tolist') else res_NearestCentroid_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NearestCentroid_get_metadata_routing = {k: v for k, v in pms_NearestCentroid_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_get_metadata_routing = bridgeNearestCentroid[${this.id}].get_metadata_routing(**pms_NearestCentroid_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_get_metadata_routing.tolist() if hasattr(res_NearestCentroid_get_metadata_routing, 'tolist') else res_NearestCentroid_get_metadata_routing`\n  }\n\n  /**\n    Perform classification on an array of test vectors `X`.\n\n    The predicted class `C` for each sample in `X` is returned.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NearestCentroid_predict = {k: v for k, v in pms_NearestCentroid_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_predict = bridgeNearestCentroid[${this.id}].predict(**pms_NearestCentroid_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_predict.tolist() if hasattr(res_NearestCentroid_predict, 'tolist') else res_NearestCentroid_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NearestCentroid_score = {k: v for k, v in pms_NearestCentroid_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_score = bridgeNearestCentroid[${this.id}].score(**pms_NearestCentroid_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_score.tolist() if hasattr(res_NearestCentroid_score, 'tolist') else res_NearestCentroid_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NearestCentroid_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_NearestCentroid_set_score_request = {k: v for k, v in pms_NearestCentroid_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_set_score_request = bridgeNearestCentroid[${this.id}].set_score_request(**pms_NearestCentroid_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_set_score_request.tolist() if hasattr(res_NearestCentroid_set_score_request, 'tolist') else res_NearestCentroid_set_score_request`\n  }\n\n  /**\n    Centroid of each class.\n   */\n  get centroids_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing centroids_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_centroids_ = bridgeNearestCentroid[${this.id}].centroids_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_centroids_.tolist() if hasattr(attr_NearestCentroid_centroids_, 'tolist') else attr_NearestCentroid_centroids_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_classes_ = bridgeNearestCentroid[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_classes_.tolist() if hasattr(attr_NearestCentroid_classes_, 'tolist') else attr_NearestCentroid_classes_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_n_features_in_ = bridgeNearestCentroid[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_n_features_in_.tolist() if hasattr(attr_NearestCentroid_n_features_in_, 'tolist') else attr_NearestCentroid_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_feature_names_in_ = bridgeNearestCentroid[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_feature_names_in_.tolist() if hasattr(attr_NearestCentroid_feature_names_in_, 'tolist') else attr_NearestCentroid_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Unsupervised learner for implementing neighbor searches.\n\n  Read more in the [User Guide](../neighbors.html#unsupervised-neighbors).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html)\n */\nexport class NearestNeighbors {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to use by default for [`kneighbors`](#sklearn.neighbors.NearestNeighbors.kneighbors \"sklearn.neighbors.NearestNeighbors.kneighbors\") queries.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Range of parameter space to use by default for [`radius\\_neighbors`](#sklearn.neighbors.NearestNeighbors.radius_neighbors \"sklearn.neighbors.NearestNeighbors.radius_neighbors\") queries.\n\n      @defaultValue `1`\n     */\n    radius?: number\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise\\_distances. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `NearestNeighbors${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NearestNeighbors.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import NearestNeighbors\ntry: bridgeNearestNeighbors\nexcept NameError: bridgeNearestNeighbors = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NearestNeighbors = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'radius': ${this.opts['radius'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_NearestNeighbors = {k: v for k, v in ctor_NearestNeighbors.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeNearestNeighbors[${this.id}] = NearestNeighbors(**ctor_NearestNeighbors)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNearestNeighbors[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the nearest neighbors estimator from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestNeighbors must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestNeighbors_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_NearestNeighbors_fit = {k: v for k, v in pms_NearestNeighbors_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_fit = bridgeNearestNeighbors[${this.id}].fit(**pms_NearestNeighbors_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_fit.tolist() if hasattr(res_NearestNeighbors_fit, 'tolist') else res_NearestNeighbors_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestNeighbors_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NearestNeighbors_get_metadata_routing = {k: v for k, v in pms_NearestNeighbors_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_get_metadata_routing = bridgeNearestNeighbors[${this.id}].get_metadata_routing(**pms_NearestNeighbors_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_get_metadata_routing.tolist() if hasattr(res_NearestNeighbors_get_metadata_routing, 'tolist') else res_NearestNeighbors_get_metadata_routing`\n  }\n\n  /**\n    Find the K-neighbors of a point.\n\n    Returns indices of and distances to the neighbors of each point.\n   */\n  async kneighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Number of neighbors required for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestNeighbors must call init() before kneighbors()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestNeighbors_kneighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'n_neighbors': ${opts['n_neighbors'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }}\n\npms_NearestNeighbors_kneighbors = {k: v for k, v in pms_NearestNeighbors_kneighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_kneighbors = bridgeNearestNeighbors[${this.id}].kneighbors(**pms_NearestNeighbors_kneighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_kneighbors.tolist() if hasattr(res_NearestNeighbors_kneighbors, 'tolist') else res_NearestNeighbors_kneighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of k-Neighbors for points in X.\n   */\n  async kneighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor. For `metric='precomputed'` the shape should be (n\\_queries, n\\_indexed). Otherwise the shape should be (n\\_queries, n\\_features).\n     */\n    X?: any\n\n    /**\n      Number of neighbors for each sample. The default is the value passed to the constructor.\n     */\n    n_neighbors?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before kneighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestNeighbors_kneighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'n_neighbors': ${\n      opts['n_neighbors'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}}\n\npms_NearestNeighbors_kneighbors_graph = {k: v for k, v in pms_NearestNeighbors_kneighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_kneighbors_graph = bridgeNearestNeighbors[${this.id}].kneighbors_graph(**pms_NearestNeighbors_kneighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_kneighbors_graph.tolist() if hasattr(res_NearestNeighbors_kneighbors_graph, 'tolist') else res_NearestNeighbors_kneighbors_graph`\n  }\n\n  /**\n    Find the neighbors within a given radius of a point or points.\n\n    Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.\n\n    The result points are *not* necessarily sorted by distance to their query point.\n   */\n  async radius_neighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: any\n\n    /**\n      Limiting distance of neighbors to return. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      If `true`, the distances and indices will be sorted by increasing distances before being returned. If `false`, the results may not be sorted. If `return\\_distance=False`, setting `sort\\_results=True` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before radius_neighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestNeighbors_radius_neighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'radius': ${opts['radius'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_NearestNeighbors_radius_neighbors = {k: v for k, v in pms_NearestNeighbors_radius_neighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_radius_neighbors = bridgeNearestNeighbors[${this.id}].radius_neighbors(**pms_NearestNeighbors_radius_neighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_radius_neighbors.tolist() if hasattr(res_NearestNeighbors_radius_neighbors, 'tolist') else res_NearestNeighbors_radius_neighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n\n    Neighborhoods are restricted the points at a distance lower than radius.\n   */\n  async radius_neighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Radius of neighborhoods. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n\n    /**\n      If `true`, in each row of the result, the non-zero entries will be sorted by increasing distances. If `false`, the non-zero entries may not be sorted. Only used with mode=’distance’.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before radius_neighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NearestNeighbors_radius_neighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'radius': ${\n      opts['radius'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_NearestNeighbors_radius_neighbors_graph = {k: v for k, v in pms_NearestNeighbors_radius_neighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestNeighbors_radius_neighbors_graph = bridgeNearestNeighbors[${this.id}].radius_neighbors_graph(**pms_NearestNeighbors_radius_neighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestNeighbors_radius_neighbors_graph.tolist() if hasattr(res_NearestNeighbors_radius_neighbors_graph, 'tolist') else res_NearestNeighbors_radius_neighbors_graph`\n  }\n\n  /**\n    Metric used to compute distances to neighbors.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestNeighbors_effective_metric_ = bridgeNearestNeighbors[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestNeighbors_effective_metric_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_, 'tolist') else attr_NearestNeighbors_effective_metric_`\n    })()\n  }\n\n  /**\n    Parameters for the metric used to compute distances to neighbors.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestNeighbors_effective_metric_params_ = bridgeNearestNeighbors[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestNeighbors_effective_metric_params_.tolist() if hasattr(attr_NearestNeighbors_effective_metric_params_, 'tolist') else attr_NearestNeighbors_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestNeighbors_n_features_in_ = bridgeNearestNeighbors[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestNeighbors_n_features_in_.tolist() if hasattr(attr_NearestNeighbors_n_features_in_, 'tolist') else attr_NearestNeighbors_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestNeighbors_feature_names_in_ = bridgeNearestNeighbors[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestNeighbors_feature_names_in_.tolist() if hasattr(attr_NearestNeighbors_feature_names_in_, 'tolist') else attr_NearestNeighbors_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NearestNeighbors instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestNeighbors must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestNeighbors_n_samples_fit_ = bridgeNearestNeighbors[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestNeighbors_n_samples_fit_.tolist() if hasattr(attr_NearestNeighbors_n_samples_fit_, 'tolist') else attr_NearestNeighbors_n_samples_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Neighborhood Components Analysis.\n\n  Neighborhood Component Analysis (NCA) is a machine learning algorithm for metric learning. It learns a linear transformation in a supervised fashion to improve the classification accuracy of a stochastic nearest neighbors rule in the transformed space.\n\n  Read more in the [User Guide](../neighbors.html#nca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html)\n */\nexport class NeighborhoodComponentsAnalysis {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Preferred dimensionality of the projected space. If `undefined` it will be set to `n\\_features`.\n     */\n    n_components?: number\n\n    /**\n      Initialization of the linear transformation. Possible options are `'auto'`, `'pca'`, `'lda'`, `'identity'`, `'random'`, and a numpy array of shape `(n\\_features\\_a, n\\_features\\_b)`.\n\n      @defaultValue `'auto'`\n     */\n    init?: 'auto' | 'pca' | 'lda' | 'identity' | 'random' | NDArray[]\n\n    /**\n      If `true` and [`fit`](#sklearn.neighbors.NeighborhoodComponentsAnalysis.fit \"sklearn.neighbors.NeighborhoodComponentsAnalysis.fit\") has been called before, the solution of the previous call to [`fit`](#sklearn.neighbors.NeighborhoodComponentsAnalysis.fit \"sklearn.neighbors.NeighborhoodComponentsAnalysis.fit\") is used as the initial linear transformation (`n\\_components` and `init` will be ignored).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      Maximum number of iterations in the optimization.\n\n      @defaultValue `50`\n     */\n    max_iter?: number\n\n    /**\n      Convergence tolerance for the optimization.\n\n      @defaultValue `0.00001`\n     */\n    tol?: number\n\n    /**\n      If not `undefined`, this function is called after every iteration of the optimizer, taking as arguments the current solution (flattened transformation matrix) and the number of iterations. This might be useful in case one wants to examine or store the transformation found after each iteration.\n     */\n    callback?: any\n\n    /**\n      If 0, no progress messages will be printed. If 1, progress messages will be printed to stdout. If > 1, progress messages will be printed and the `disp` parameter of [`scipy.optimize.minimize`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize \"(in SciPy v1.11.3)\") will be set to `verbose \\- 2`.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      A pseudo random number generator object or a seed for it if int. If `init='random'`, `random\\_state` is used to initialize the random transformation. If `init='pca'`, `random\\_state` is passed as an argument to PCA when initializing the transformation. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `NeighborhoodComponentsAnalysis${\n      crypto.randomUUID().split('-')[0]\n    }`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import NeighborhoodComponentsAnalysis\ntry: bridgeNeighborhoodComponentsAnalysis\nexcept NameError: bridgeNeighborhoodComponentsAnalysis = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NeighborhoodComponentsAnalysis = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'callback': ${this.opts['callback'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_NeighborhoodComponentsAnalysis = {k: v for k, v in ctor_NeighborhoodComponentsAnalysis.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeNeighborhoodComponentsAnalysis[${this.id}] = NeighborhoodComponentsAnalysis(**ctor_NeighborhoodComponentsAnalysis)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNeighborhoodComponentsAnalysis[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      The training samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      The corresponding training labels.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_NeighborhoodComponentsAnalysis_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_NeighborhoodComponentsAnalysis_fit = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_fit = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit(**pms_NeighborhoodComponentsAnalysis_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_fit.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit, 'tolist') else res_NeighborhoodComponentsAnalysis_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NeighborhoodComponentsAnalysis_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_NeighborhoodComponentsAnalysis_fit_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_fit_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].fit_transform(**pms_NeighborhoodComponentsAnalysis_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_fit_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_fit_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NeighborhoodComponentsAnalysis_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_NeighborhoodComponentsAnalysis_get_feature_names_out = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_get_feature_names_out = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_feature_names_out(**pms_NeighborhoodComponentsAnalysis_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_get_feature_names_out.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_feature_names_out, 'tolist') else res_NeighborhoodComponentsAnalysis_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NeighborhoodComponentsAnalysis_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_NeighborhoodComponentsAnalysis_get_metadata_routing = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_get_metadata_routing = bridgeNeighborhoodComponentsAnalysis[${this.id}].get_metadata_routing(**pms_NeighborhoodComponentsAnalysis_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_get_metadata_routing.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_get_metadata_routing, 'tolist') else res_NeighborhoodComponentsAnalysis_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NeighborhoodComponentsAnalysis_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_NeighborhoodComponentsAnalysis_set_output = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_set_output = bridgeNeighborhoodComponentsAnalysis[${this.id}].set_output(**pms_NeighborhoodComponentsAnalysis_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_set_output.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_set_output, 'tolist') else res_NeighborhoodComponentsAnalysis_set_output`\n  }\n\n  /**\n    Apply the learned transformation to the given data.\n   */\n  async transform(opts: {\n    /**\n      Data samples.\n     */\n    X?: ArrayLike[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_NeighborhoodComponentsAnalysis_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NeighborhoodComponentsAnalysis_transform = {k: v for k, v in pms_NeighborhoodComponentsAnalysis_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NeighborhoodComponentsAnalysis_transform = bridgeNeighborhoodComponentsAnalysis[${this.id}].transform(**pms_NeighborhoodComponentsAnalysis_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NeighborhoodComponentsAnalysis_transform.tolist() if hasattr(res_NeighborhoodComponentsAnalysis_transform, 'tolist') else res_NeighborhoodComponentsAnalysis_transform`\n  }\n\n  /**\n    The linear transformation learned during fitting.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NeighborhoodComponentsAnalysis_components_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NeighborhoodComponentsAnalysis_components_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_components_, 'tolist') else attr_NeighborhoodComponentsAnalysis_components_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NeighborhoodComponentsAnalysis_n_features_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NeighborhoodComponentsAnalysis_n_features_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_features_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_features_in_`\n    })()\n  }\n\n  /**\n    Counts the number of iterations performed by the optimizer.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NeighborhoodComponentsAnalysis_n_iter_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NeighborhoodComponentsAnalysis_n_iter_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_n_iter_, 'tolist') else attr_NeighborhoodComponentsAnalysis_n_iter_`\n    })()\n  }\n\n  /**\n    Pseudo random number generator object used during initialization.\n   */\n  get random_state_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before accessing random_state_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NeighborhoodComponentsAnalysis_random_state_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].random_state_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NeighborhoodComponentsAnalysis_random_state_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_random_state_, 'tolist') else attr_NeighborhoodComponentsAnalysis_random_state_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This NeighborhoodComponentsAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NeighborhoodComponentsAnalysis must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NeighborhoodComponentsAnalysis_feature_names_in_ = bridgeNeighborhoodComponentsAnalysis[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NeighborhoodComponentsAnalysis_feature_names_in_.tolist() if hasattr(attr_NeighborhoodComponentsAnalysis_feature_names_in_, 'tolist') else attr_NeighborhoodComponentsAnalysis_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Classifier implementing a vote among neighbors within a given radius.\n\n  Read more in the [User Guide](../neighbors.html#classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.RadiusNeighborsClassifier.html)\n */\nexport class RadiusNeighborsClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Range of parameter space to use by default for [`radius\\_neighbors`](#sklearn.neighbors.RadiusNeighborsClassifier.radius_neighbors \"sklearn.neighbors.RadiusNeighborsClassifier.radius_neighbors\") queries.\n\n      @defaultValue `1`\n     */\n    radius?: number\n\n    /**\n      Weight function used in prediction. Possible values:\n\n      @defaultValue `'uniform'`\n     */\n    weights?: 'uniform' | 'distance'\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Label for outlier samples (samples with no neighbors in given radius).\n     */\n    outlier_label?: 'most_frequent'\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `RadiusNeighborsClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'RadiusNeighborsClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import RadiusNeighborsClassifier\ntry: bridgeRadiusNeighborsClassifier\nexcept NameError: bridgeRadiusNeighborsClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RadiusNeighborsClassifier = {'radius': ${\n      this.opts['radius'] ?? undefined\n    }, 'weights': ${this.opts['weights'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'p': ${\n      this.opts['p'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'outlier_label': ${\n      this.opts['outlier_label'] ?? undefined\n    }, 'metric_params': ${this.opts['metric_params'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_RadiusNeighborsClassifier = {k: v for k, v in ctor_RadiusNeighborsClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRadiusNeighborsClassifier[${this.id}] = RadiusNeighborsClassifier(**ctor_RadiusNeighborsClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRadiusNeighborsClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the radius neighbors classifier from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RadiusNeighborsClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_RadiusNeighborsClassifier_fit = {k: v for k, v in pms_RadiusNeighborsClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_fit = bridgeRadiusNeighborsClassifier[${this.id}].fit(**pms_RadiusNeighborsClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_fit.tolist() if hasattr(res_RadiusNeighborsClassifier_fit, 'tolist') else res_RadiusNeighborsClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RadiusNeighborsClassifier_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_get_metadata_routing = bridgeRadiusNeighborsClassifier[${this.id}].get_metadata_routing(**pms_RadiusNeighborsClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsClassifier_get_metadata_routing, 'tolist') else res_RadiusNeighborsClassifier_get_metadata_routing`\n  }\n\n  /**\n    Predict the class labels for the provided data.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RadiusNeighborsClassifier_predict = {k: v for k, v in pms_RadiusNeighborsClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_predict = bridgeRadiusNeighborsClassifier[${this.id}].predict(**pms_RadiusNeighborsClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_predict.tolist() if hasattr(res_RadiusNeighborsClassifier_predict, 'tolist') else res_RadiusNeighborsClassifier_predict`\n  }\n\n  /**\n    Return probability estimates for the test data X.\n   */\n  async predict_proba(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RadiusNeighborsClassifier_predict_proba = {k: v for k, v in pms_RadiusNeighborsClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_predict_proba = bridgeRadiusNeighborsClassifier[${this.id}].predict_proba(**pms_RadiusNeighborsClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_predict_proba.tolist() if hasattr(res_RadiusNeighborsClassifier_predict_proba, 'tolist') else res_RadiusNeighborsClassifier_predict_proba`\n  }\n\n  /**\n    Find the neighbors within a given radius of a point or points.\n\n    Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.\n\n    The result points are *not* necessarily sorted by distance to their query point.\n   */\n  async radius_neighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: any\n\n    /**\n      Limiting distance of neighbors to return. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      If `true`, the distances and indices will be sorted by increasing distances before being returned. If `false`, the results may not be sorted. If `return\\_distance=False`, setting `sort\\_results=True` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before radius_neighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsClassifier_radius_neighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'radius': ${opts['radius'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_RadiusNeighborsClassifier_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_radius_neighbors = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors(**pms_RadiusNeighborsClassifier_radius_neighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n\n    Neighborhoods are restricted the points at a distance lower than radius.\n   */\n  async radius_neighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Radius of neighborhoods. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n\n    /**\n      If `true`, in each row of the result, the non-zero entries will be sorted by increasing distances. If `false`, the non-zero entries may not be sorted. Only used with mode=’distance’.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before radius_neighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsClassifier_radius_neighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'radius': ${\n      opts['radius'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_RadiusNeighborsClassifier_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsClassifier_radius_neighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_radius_neighbors_graph = bridgeRadiusNeighborsClassifier[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsClassifier_radius_neighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsClassifier_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsClassifier_radius_neighbors_graph`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RadiusNeighborsClassifier_score = {k: v for k, v in pms_RadiusNeighborsClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_score = bridgeRadiusNeighborsClassifier[${this.id}].score(**pms_RadiusNeighborsClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_score.tolist() if hasattr(res_RadiusNeighborsClassifier_score, 'tolist') else res_RadiusNeighborsClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RadiusNeighborsClassifier_set_score_request = {k: v for k, v in pms_RadiusNeighborsClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsClassifier_set_score_request = bridgeRadiusNeighborsClassifier[${this.id}].set_score_request(**pms_RadiusNeighborsClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsClassifier_set_score_request.tolist() if hasattr(res_RadiusNeighborsClassifier_set_score_request, 'tolist') else res_RadiusNeighborsClassifier_set_score_request`\n  }\n\n  /**\n    Class labels known to the classifier.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_classes_ = bridgeRadiusNeighborsClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_classes_.tolist() if hasattr(attr_RadiusNeighborsClassifier_classes_, 'tolist') else attr_RadiusNeighborsClassifier_classes_`\n    })()\n  }\n\n  /**\n    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_effective_metric_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_effective_metric_params_ = bridgeRadiusNeighborsClassifier[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsClassifier_effective_metric_params_, 'tolist') else attr_RadiusNeighborsClassifier_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_n_features_in_ = bridgeRadiusNeighborsClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_features_in_, 'tolist') else attr_RadiusNeighborsClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_feature_names_in_ = bridgeRadiusNeighborsClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsClassifier_feature_names_in_, 'tolist') else attr_RadiusNeighborsClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_n_samples_fit_ = bridgeRadiusNeighborsClassifier[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsClassifier_n_samples_fit_, 'tolist') else attr_RadiusNeighborsClassifier_n_samples_fit_`\n    })()\n  }\n\n  /**\n    Label which is given for outlier samples (samples with no neighbors on given radius).\n   */\n  get outlier_label_(): Promise<number | ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing outlier_label_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_outlier_label_ = bridgeRadiusNeighborsClassifier[${this.id}].outlier_label_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_outlier_label_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outlier_label_, 'tolist') else attr_RadiusNeighborsClassifier_outlier_label_`\n    })()\n  }\n\n  /**\n    False when `y`’s shape is (n\\_samples, ) or (n\\_samples, 1) during fit otherwise `true`.\n   */\n  get outputs_2d_(): Promise<boolean> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsClassifier must call init() before accessing outputs_2d_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsClassifier_outputs_2d_ = bridgeRadiusNeighborsClassifier[${this.id}].outputs_2d_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsClassifier_outputs_2d_.tolist() if hasattr(attr_RadiusNeighborsClassifier_outputs_2d_, 'tolist') else attr_RadiusNeighborsClassifier_outputs_2d_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Regression based on neighbors within a fixed radius.\n\n  The target is predicted by local interpolation of the targets associated of the nearest neighbors in the training set.\n\n  Read more in the [User Guide](../neighbors.html#regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.RadiusNeighborsRegressor.html)\n */\nexport class RadiusNeighborsRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Range of parameter space to use by default for [`radius\\_neighbors`](#sklearn.neighbors.RadiusNeighborsRegressor.radius_neighbors \"sklearn.neighbors.RadiusNeighborsRegressor.radius_neighbors\") queries.\n\n      @defaultValue `1`\n     */\n    radius?: number\n\n    /**\n      Weight function used in prediction. Possible values:\n\n      @defaultValue `'uniform'`\n     */\n    weights?: 'uniform' | 'distance'\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a [sparse graph](../../glossary.html#term-sparse-graph), in which case only “nonzero” elements may be considered neighbors.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `RadiusNeighborsRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'RadiusNeighborsRegressor.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import RadiusNeighborsRegressor\ntry: bridgeRadiusNeighborsRegressor\nexcept NameError: bridgeRadiusNeighborsRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RadiusNeighborsRegressor = {'radius': ${\n      this.opts['radius'] ?? undefined\n    }, 'weights': ${this.opts['weights'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'p': ${\n      this.opts['p'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_RadiusNeighborsRegressor = {k: v for k, v in ctor_RadiusNeighborsRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRadiusNeighborsRegressor[${this.id}] = RadiusNeighborsRegressor(**ctor_RadiusNeighborsRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRadiusNeighborsRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the radius neighbors regressor from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RadiusNeighborsRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_RadiusNeighborsRegressor_fit = {k: v for k, v in pms_RadiusNeighborsRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_fit = bridgeRadiusNeighborsRegressor[${this.id}].fit(**pms_RadiusNeighborsRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_fit.tolist() if hasattr(res_RadiusNeighborsRegressor_fit, 'tolist') else res_RadiusNeighborsRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RadiusNeighborsRegressor_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_get_metadata_routing = bridgeRadiusNeighborsRegressor[${this.id}].get_metadata_routing(**pms_RadiusNeighborsRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsRegressor_get_metadata_routing, 'tolist') else res_RadiusNeighborsRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict the target for the provided data.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RadiusNeighborsRegressor_predict = {k: v for k, v in pms_RadiusNeighborsRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_predict = bridgeRadiusNeighborsRegressor[${this.id}].predict(**pms_RadiusNeighborsRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_predict.tolist() if hasattr(res_RadiusNeighborsRegressor_predict, 'tolist') else res_RadiusNeighborsRegressor_predict`\n  }\n\n  /**\n    Find the neighbors within a given radius of a point or points.\n\n    Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.\n\n    The result points are *not* necessarily sorted by distance to their query point.\n   */\n  async radius_neighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: any\n\n    /**\n      Limiting distance of neighbors to return. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      If `true`, the distances and indices will be sorted by increasing distances before being returned. If `false`, the results may not be sorted. If `return\\_distance=False`, setting `sort\\_results=True` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before radius_neighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsRegressor_radius_neighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'radius': ${opts['radius'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_RadiusNeighborsRegressor_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_radius_neighbors = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors(**pms_RadiusNeighborsRegressor_radius_neighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n\n    Neighborhoods are restricted the points at a distance lower than radius.\n   */\n  async radius_neighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Radius of neighborhoods. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n\n    /**\n      If `true`, in each row of the result, the non-zero entries will be sorted by increasing distances. If `false`, the non-zero entries may not be sorted. Only used with mode=’distance’.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before radius_neighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsRegressor_radius_neighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'radius': ${\n      opts['radius'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_RadiusNeighborsRegressor_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsRegressor_radius_neighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_radius_neighbors_graph = bridgeRadiusNeighborsRegressor[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsRegressor_radius_neighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsRegressor_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsRegressor_radius_neighbors_graph`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RadiusNeighborsRegressor_score = {k: v for k, v in pms_RadiusNeighborsRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_score = bridgeRadiusNeighborsRegressor[${this.id}].score(**pms_RadiusNeighborsRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_score.tolist() if hasattr(res_RadiusNeighborsRegressor_score, 'tolist') else res_RadiusNeighborsRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RadiusNeighborsRegressor_set_score_request = {k: v for k, v in pms_RadiusNeighborsRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsRegressor_set_score_request = bridgeRadiusNeighborsRegressor[${this.id}].set_score_request(**pms_RadiusNeighborsRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsRegressor_set_score_request.tolist() if hasattr(res_RadiusNeighborsRegressor_set_score_request, 'tolist') else res_RadiusNeighborsRegressor_set_score_request`\n  }\n\n  /**\n    The distance metric to use. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsRegressor_effective_metric_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsRegressor_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsRegressor_effective_metric_params_ = bridgeRadiusNeighborsRegressor[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsRegressor_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsRegressor_effective_metric_params_, 'tolist') else attr_RadiusNeighborsRegressor_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsRegressor_n_features_in_ = bridgeRadiusNeighborsRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsRegressor_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_features_in_, 'tolist') else attr_RadiusNeighborsRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsRegressor_feature_names_in_ = bridgeRadiusNeighborsRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsRegressor_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsRegressor_feature_names_in_, 'tolist') else attr_RadiusNeighborsRegressor_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsRegressor must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsRegressor_n_samples_fit_ = bridgeRadiusNeighborsRegressor[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsRegressor_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsRegressor_n_samples_fit_, 'tolist') else attr_RadiusNeighborsRegressor_n_samples_fit_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Transform X into a (weighted) graph of neighbors nearer than a radius.\n\n  The transformed data is a sparse graph as returned by `radius\\_neighbors\\_graph`.\n\n  Read more in the [User Guide](../neighbors.html#neighbors-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.RadiusNeighborsTransformer.html)\n */\nexport class RadiusNeighborsTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, and ‘distance’ will return the distances between neighbors according to the given metric.\n\n      @defaultValue `'distance'`\n     */\n    mode?: 'distance' | 'connectivity'\n\n    /**\n      Radius of neighborhood in the transformed sparse graph.\n\n      @defaultValue `1`\n     */\n    radius?: number\n\n    /**\n      Algorithm used to compute the nearest neighbors:\n\n      @defaultValue `'auto'`\n     */\n    algorithm?: 'auto' | 'ball_tree' | 'kd_tree' | 'brute'\n\n    /**\n      Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n      @defaultValue `30`\n     */\n    leaf_size?: number\n\n    /**\n      Metric to use for distance computation. Default is “minkowski”, which results in the standard Euclidean distance when p = 2. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values.\n\n      If metric is a callable function, it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors. This works for Scipy’s metrics, but is less efficient than passing the metric name as a string.\n\n      Distance matrices are not supported.\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: string\n\n    /**\n      Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise\\_distances. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n\n    /**\n      The number of parallel jobs to run for neighbors search. If `\\-1`, then the number of jobs is set to the number of CPU cores.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `RadiusNeighborsTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'RadiusNeighborsTransformer.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import RadiusNeighborsTransformer\ntry: bridgeRadiusNeighborsTransformer\nexcept NameError: bridgeRadiusNeighborsTransformer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RadiusNeighborsTransformer = {'mode': ${\n      this.opts['mode'] ?? undefined\n    }, 'radius': ${this.opts['radius'] ?? undefined}, 'algorithm': ${\n      this.opts['algorithm'] ?? undefined\n    }, 'leaf_size': ${this.opts['leaf_size'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_RadiusNeighborsTransformer = {k: v for k, v in ctor_RadiusNeighborsTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRadiusNeighborsTransformer[${this.id}] = RadiusNeighborsTransformer(**ctor_RadiusNeighborsTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRadiusNeighborsTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the radius neighbors transformer from the training dataset.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsTransformer_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_RadiusNeighborsTransformer_fit = {k: v for k, v in pms_RadiusNeighborsTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_fit = bridgeRadiusNeighborsTransformer[${this.id}].fit(**pms_RadiusNeighborsTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_fit.tolist() if hasattr(res_RadiusNeighborsTransformer_fit, 'tolist') else res_RadiusNeighborsTransformer_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to X and y with optional parameters fit\\_params and returns a transformed version of X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training set.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_RadiusNeighborsTransformer_fit_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_fit_transform = bridgeRadiusNeighborsTransformer[${this.id}].fit_transform(**pms_RadiusNeighborsTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_fit_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_fit_transform, 'tolist') else res_RadiusNeighborsTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_RadiusNeighborsTransformer_get_feature_names_out = {k: v for k, v in pms_RadiusNeighborsTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_get_feature_names_out = bridgeRadiusNeighborsTransformer[${this.id}].get_feature_names_out(**pms_RadiusNeighborsTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_get_feature_names_out.tolist() if hasattr(res_RadiusNeighborsTransformer_get_feature_names_out, 'tolist') else res_RadiusNeighborsTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RadiusNeighborsTransformer_get_metadata_routing = {k: v for k, v in pms_RadiusNeighborsTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_get_metadata_routing = bridgeRadiusNeighborsTransformer[${this.id}].get_metadata_routing(**pms_RadiusNeighborsTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_get_metadata_routing.tolist() if hasattr(res_RadiusNeighborsTransformer_get_metadata_routing, 'tolist') else res_RadiusNeighborsTransformer_get_metadata_routing`\n  }\n\n  /**\n    Find the neighbors within a given radius of a point or points.\n\n    Return the indices and distances of each point from the dataset lying in a ball with size `radius` around the points of the query array. Points lying on the boundary are included in the results.\n\n    The result points are *not* necessarily sorted by distance to their query point.\n   */\n  async radius_neighbors(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: any\n\n    /**\n      Limiting distance of neighbors to return. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Whether or not to return the distances.\n\n      @defaultValue `true`\n     */\n    return_distance?: boolean\n\n    /**\n      If `true`, the distances and indices will be sorted by increasing distances before being returned. If `false`, the results may not be sorted. If `return\\_distance=False`, setting `sort\\_results=True` will result in an error.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before radius_neighbors()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RadiusNeighborsTransformer_radius_neighbors = {'X': ${\n      opts['X'] ?? undefined\n    }, 'radius': ${opts['radius'] ?? undefined}, 'return_distance': ${\n      opts['return_distance'] ?? undefined\n    }, 'sort_results': ${opts['sort_results'] ?? undefined}}\n\npms_RadiusNeighborsTransformer_radius_neighbors = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_radius_neighbors = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors(**pms_RadiusNeighborsTransformer_radius_neighbors)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_radius_neighbors.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n\n    Neighborhoods are restricted the points at a distance lower than radius.\n   */\n  async radius_neighbors_graph(opts: {\n    /**\n      The query point or points. If not provided, neighbors of each indexed point are returned. In this case, the query point is not considered its own neighbor.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Radius of neighborhoods. The default is the value passed to the constructor.\n     */\n    radius?: number\n\n    /**\n      Type of returned matrix: ‘connectivity’ will return the connectivity matrix with ones and zeros, in ‘distance’ the edges are distances between points, type of distance depends on the selected metric parameter in NearestNeighbors class.\n\n      @defaultValue `'connectivity'`\n     */\n    mode?: 'connectivity' | 'distance'\n\n    /**\n      If `true`, in each row of the result, the non-zero entries will be sorted by increasing distances. If `false`, the non-zero entries may not be sorted. Only used with mode=’distance’.\n\n      @defaultValue `false`\n     */\n    sort_results?: boolean\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before radius_neighbors_graph()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_radius_neighbors_graph = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'radius': ${\n      opts['radius'] ?? undefined\n    }, 'mode': ${opts['mode'] ?? undefined}, 'sort_results': ${\n      opts['sort_results'] ?? undefined\n    }}\n\npms_RadiusNeighborsTransformer_radius_neighbors_graph = {k: v for k, v in pms_RadiusNeighborsTransformer_radius_neighbors_graph.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_radius_neighbors_graph = bridgeRadiusNeighborsTransformer[${this.id}].radius_neighbors_graph(**pms_RadiusNeighborsTransformer_radius_neighbors_graph)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_radius_neighbors_graph.tolist() if hasattr(res_RadiusNeighborsTransformer_radius_neighbors_graph, 'tolist') else res_RadiusNeighborsTransformer_radius_neighbors_graph`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_RadiusNeighborsTransformer_set_output = {k: v for k, v in pms_RadiusNeighborsTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_set_output = bridgeRadiusNeighborsTransformer[${this.id}].set_output(**pms_RadiusNeighborsTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_set_output.tolist() if hasattr(res_RadiusNeighborsTransformer_set_output, 'tolist') else res_RadiusNeighborsTransformer_set_output`\n  }\n\n  /**\n    Compute the (weighted) graph of Neighbors for points in X.\n   */\n  async transform(opts: {\n    /**\n      Sample data.\n     */\n    X?: ArrayLike[]\n  }): Promise<SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RadiusNeighborsTransformer_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RadiusNeighborsTransformer_transform = {k: v for k, v in pms_RadiusNeighborsTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RadiusNeighborsTransformer_transform = bridgeRadiusNeighborsTransformer[${this.id}].transform(**pms_RadiusNeighborsTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RadiusNeighborsTransformer_transform.tolist() if hasattr(res_RadiusNeighborsTransformer_transform, 'tolist') else res_RadiusNeighborsTransformer_transform`\n  }\n\n  /**\n    The distance metric used. It will be same as the `metric` parameter or a synonym of it, e.g. ‘euclidean’ if the `metric` parameter set to ‘minkowski’ and `p` parameter set to 2.\n   */\n  get effective_metric_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before accessing effective_metric_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsTransformer_effective_metric_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsTransformer_effective_metric_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_`\n    })()\n  }\n\n  /**\n    Additional keyword arguments for the metric function. For most metrics will be same with `metric\\_params` parameter, but may also contain the `p` parameter value if the `effective\\_metric\\_` attribute is set to ‘minkowski’.\n   */\n  get effective_metric_params_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before accessing effective_metric_params_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsTransformer_effective_metric_params_ = bridgeRadiusNeighborsTransformer[${this.id}].effective_metric_params_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsTransformer_effective_metric_params_.tolist() if hasattr(attr_RadiusNeighborsTransformer_effective_metric_params_, 'tolist') else attr_RadiusNeighborsTransformer_effective_metric_params_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsTransformer_n_features_in_ = bridgeRadiusNeighborsTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsTransformer_n_features_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_features_in_, 'tolist') else attr_RadiusNeighborsTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsTransformer_feature_names_in_ = bridgeRadiusNeighborsTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsTransformer_feature_names_in_.tolist() if hasattr(attr_RadiusNeighborsTransformer_feature_names_in_, 'tolist') else attr_RadiusNeighborsTransformer_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of samples in the fitted data.\n   */\n  get n_samples_fit_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RadiusNeighborsTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RadiusNeighborsTransformer must call init() before accessing n_samples_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RadiusNeighborsTransformer_n_samples_fit_ = bridgeRadiusNeighborsTransformer[${this.id}].n_samples_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RadiusNeighborsTransformer_n_samples_fit_.tolist() if hasattr(attr_RadiusNeighborsTransformer_n_samples_fit_, 'tolist') else attr_RadiusNeighborsTransformer_n_samples_fit_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}