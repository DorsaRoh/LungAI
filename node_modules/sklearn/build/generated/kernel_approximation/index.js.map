{"version":3,"sources":["../../../src/generated/kernel_approximation/AdditiveChi2Sampler.ts","../../../src/generated/kernel_approximation/Nystroem.ts","../../../src/generated/kernel_approximation/PolynomialCountSketch.ts","../../../src/generated/kernel_approximation/RBFSampler.ts","../../../src/generated/kernel_approximation/SkewedChi2Sampler.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Approximate feature map for additive chi2 kernel.\n\n  Uses sampling the fourier transform of the kernel characteristic at regular intervals.\n\n  Since the kernel that is to be approximated is additive, the components of the input vectors can be treated separately. Each entry in the original space is transformed into 2\\*sample\\_steps-1 features, where sample\\_steps is a parameter of the method. Typical values of sample\\_steps include 1, 2 and 3.\n\n  Optimal choices for the sampling interval for certain data ranges can be computed (see the reference). The default values should be reasonable.\n\n  Read more in the [User Guide](../kernel_approximation.html#additive-chi-kernel-approx).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.kernel_approximation.AdditiveChi2Sampler.html)\n */\nexport class AdditiveChi2Sampler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Gives the number of (complex) sampling points.\n\n      @defaultValue `2`\n     */\n    sample_steps?: number\n\n    /**\n      Sampling interval. Must be specified when sample\\_steps not in {1,2,3}.\n     */\n    sample_interval?: number\n  }) {\n    this.id = `AdditiveChi2Sampler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'AdditiveChi2Sampler.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.kernel_approximation import AdditiveChi2Sampler\ntry: bridgeAdditiveChi2Sampler\nexcept NameError: bridgeAdditiveChi2Sampler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_AdditiveChi2Sampler = {'sample_steps': ${\n      this.opts['sample_steps'] ?? undefined\n    }, 'sample_interval': ${this.opts['sample_interval'] ?? undefined}}\n\nctor_AdditiveChi2Sampler = {k: v for k, v in ctor_AdditiveChi2Sampler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeAdditiveChi2Sampler[${this.id}] = AdditiveChi2Sampler(**ctor_AdditiveChi2Sampler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeAdditiveChi2Sampler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Only validates estimator’s parameters.\n\n    This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('AdditiveChi2Sampler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_AdditiveChi2Sampler_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_AdditiveChi2Sampler_fit = {k: v for k, v in pms_AdditiveChi2Sampler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_fit = bridgeAdditiveChi2Sampler[${this.id}].fit(**pms_AdditiveChi2Sampler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_fit.tolist() if hasattr(res_AdditiveChi2Sampler_fit, 'tolist') else res_AdditiveChi2Sampler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_AdditiveChi2Sampler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_AdditiveChi2Sampler_fit_transform = {k: v for k, v in pms_AdditiveChi2Sampler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_fit_transform = bridgeAdditiveChi2Sampler[${this.id}].fit_transform(**pms_AdditiveChi2Sampler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_fit_transform.tolist() if hasattr(res_AdditiveChi2Sampler_fit_transform, 'tolist') else res_AdditiveChi2Sampler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in [`fit`](#sklearn.kernel_approximation.AdditiveChi2Sampler.fit \"sklearn.kernel_approximation.AdditiveChi2Sampler.fit\").\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_AdditiveChi2Sampler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_AdditiveChi2Sampler_get_feature_names_out = {k: v for k, v in pms_AdditiveChi2Sampler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_get_feature_names_out = bridgeAdditiveChi2Sampler[${this.id}].get_feature_names_out(**pms_AdditiveChi2Sampler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_get_feature_names_out.tolist() if hasattr(res_AdditiveChi2Sampler_get_feature_names_out, 'tolist') else res_AdditiveChi2Sampler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_AdditiveChi2Sampler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_AdditiveChi2Sampler_get_metadata_routing = {k: v for k, v in pms_AdditiveChi2Sampler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_get_metadata_routing = bridgeAdditiveChi2Sampler[${this.id}].get_metadata_routing(**pms_AdditiveChi2Sampler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_get_metadata_routing.tolist() if hasattr(res_AdditiveChi2Sampler_get_metadata_routing, 'tolist') else res_AdditiveChi2Sampler_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_AdditiveChi2Sampler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_AdditiveChi2Sampler_set_output = {k: v for k, v in pms_AdditiveChi2Sampler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_set_output = bridgeAdditiveChi2Sampler[${this.id}].set_output(**pms_AdditiveChi2Sampler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_set_output.tolist() if hasattr(res_AdditiveChi2Sampler_set_output, 'tolist') else res_AdditiveChi2Sampler_set_output`\n  }\n\n  /**\n    Apply approximate feature map to X.\n   */\n  async transform(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<NDArray | SparseMatrix> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('AdditiveChi2Sampler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_AdditiveChi2Sampler_transform = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_AdditiveChi2Sampler_transform = {k: v for k, v in pms_AdditiveChi2Sampler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_AdditiveChi2Sampler_transform = bridgeAdditiveChi2Sampler[${this.id}].transform(**pms_AdditiveChi2Sampler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_AdditiveChi2Sampler_transform.tolist() if hasattr(res_AdditiveChi2Sampler_transform, 'tolist') else res_AdditiveChi2Sampler_transform`\n  }\n\n  /**\n    Stored sampling interval. Specified as a parameter if `sample\\_steps` not in {1,2,3}.\n   */\n  get sample_interval_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before accessing sample_interval_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AdditiveChi2Sampler_sample_interval_ = bridgeAdditiveChi2Sampler[${this.id}].sample_interval_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AdditiveChi2Sampler_sample_interval_.tolist() if hasattr(attr_AdditiveChi2Sampler_sample_interval_, 'tolist') else attr_AdditiveChi2Sampler_sample_interval_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AdditiveChi2Sampler_n_features_in_ = bridgeAdditiveChi2Sampler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AdditiveChi2Sampler_n_features_in_.tolist() if hasattr(attr_AdditiveChi2Sampler_n_features_in_, 'tolist') else attr_AdditiveChi2Sampler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This AdditiveChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'AdditiveChi2Sampler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_AdditiveChi2Sampler_feature_names_in_ = bridgeAdditiveChi2Sampler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_AdditiveChi2Sampler_feature_names_in_.tolist() if hasattr(attr_AdditiveChi2Sampler_feature_names_in_, 'tolist') else attr_AdditiveChi2Sampler_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Approximate a kernel map using a subset of the training data.\n\n  Constructs an approximate feature map for an arbitrary kernel using a subset of the data as basis.\n\n  Read more in the [User Guide](../kernel_approximation.html#nystroem-kernel-approx).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.kernel_approximation.Nystroem.html)\n */\nexport class Nystroem {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Kernel map to be approximated. A callable should accept two arguments and the keyword arguments passed to this object as `kernel\\_params`, and should return a floating point number.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: string\n\n    /**\n      Gamma parameter for the RBF, laplacian, polynomial, exponential chi2 and sigmoid kernels. Interpretation of the default value is left to the kernel; see the documentation for sklearn.metrics.pairwise. Ignored by other kernels.\n     */\n    gamma?: number\n\n    /**\n      Zero coefficient for polynomial and sigmoid kernels. Ignored by other kernels.\n     */\n    coef0?: number\n\n    /**\n      Degree of the polynomial kernel. Ignored by other kernels.\n     */\n    degree?: number\n\n    /**\n      Additional parameters (keyword arguments) for kernel function passed as callable object.\n     */\n    kernel_params?: any\n\n    /**\n      Number of features to construct. How many data points will be used to construct the mapping.\n\n      @defaultValue `100`\n     */\n    n_components?: number\n\n    /**\n      Pseudo-random number generator to control the uniform sampling without replacement of `n\\_components` of the training data to construct the basis kernel. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The number of jobs to use for the computation. This works by breaking down the kernel matrix into `n\\_jobs` even slices and computing them in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `Nystroem${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Nystroem.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.kernel_approximation import Nystroem\ntry: bridgeNystroem\nexcept NameError: bridgeNystroem = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Nystroem = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'kernel_params': ${\n      this.opts['kernel_params'] ?? undefined\n    }, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_Nystroem = {k: v for k, v in ctor_Nystroem.items() if v is not None}`\n\n    await this._py.ex`bridgeNystroem[${this.id}] = Nystroem(**ctor_Nystroem)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNystroem[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit estimator to data.\n\n    Samples a subset of training points, computes kernel on these and computes normalization matrix.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_Nystroem_fit = {k: v for k, v in pms_Nystroem_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_fit = bridgeNystroem[${this.id}].fit(**pms_Nystroem_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_fit.tolist() if hasattr(res_Nystroem_fit, 'tolist') else res_Nystroem_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_Nystroem_fit_transform = {k: v for k, v in pms_Nystroem_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_fit_transform = bridgeNystroem[${this.id}].fit_transform(**pms_Nystroem_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_fit_transform.tolist() if hasattr(res_Nystroem_fit_transform, 'tolist') else res_Nystroem_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Nystroem must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Nystroem_get_feature_names_out = {k: v for k, v in pms_Nystroem_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_get_feature_names_out = bridgeNystroem[${this.id}].get_feature_names_out(**pms_Nystroem_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_get_feature_names_out.tolist() if hasattr(res_Nystroem_get_feature_names_out, 'tolist') else res_Nystroem_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Nystroem_get_metadata_routing = {k: v for k, v in pms_Nystroem_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_get_metadata_routing = bridgeNystroem[${this.id}].get_metadata_routing(**pms_Nystroem_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_get_metadata_routing.tolist() if hasattr(res_Nystroem_get_metadata_routing, 'tolist') else res_Nystroem_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Nystroem_set_output = {k: v for k, v in pms_Nystroem_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_set_output = bridgeNystroem[${this.id}].set_output(**pms_Nystroem_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_set_output.tolist() if hasattr(res_Nystroem_set_output, 'tolist') else res_Nystroem_set_output`\n  }\n\n  /**\n    Apply feature map to X.\n\n    Computes an approximate feature map using the kernel between some training points and X.\n   */\n  async transform(opts: {\n    /**\n      Data to transform.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Nystroem_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_Nystroem_transform = {k: v for k, v in pms_Nystroem_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Nystroem_transform = bridgeNystroem[${this.id}].transform(**pms_Nystroem_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Nystroem_transform.tolist() if hasattr(res_Nystroem_transform, 'tolist') else res_Nystroem_transform`\n  }\n\n  /**\n    Subset of training points used to construct the feature map.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Nystroem must call init() before accessing components_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Nystroem_components_ = bridgeNystroem[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Nystroem_components_.tolist() if hasattr(attr_Nystroem_components_, 'tolist') else attr_Nystroem_components_`\n    })()\n  }\n\n  /**\n    Indices of `components\\_` in the training set.\n   */\n  get component_indices_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Nystroem must call init() before accessing component_indices_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Nystroem_component_indices_ = bridgeNystroem[${this.id}].component_indices_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Nystroem_component_indices_.tolist() if hasattr(attr_Nystroem_component_indices_, 'tolist') else attr_Nystroem_component_indices_`\n    })()\n  }\n\n  /**\n    Normalization matrix needed for embedding. Square root of the kernel matrix on `components\\_`.\n   */\n  get normalization_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Nystroem must call init() before accessing normalization_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Nystroem_normalization_ = bridgeNystroem[${this.id}].normalization_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Nystroem_normalization_.tolist() if hasattr(attr_Nystroem_normalization_, 'tolist') else attr_Nystroem_normalization_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Nystroem must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Nystroem_n_features_in_ = bridgeNystroem[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Nystroem_n_features_in_.tolist() if hasattr(attr_Nystroem_n_features_in_, 'tolist') else attr_Nystroem_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Nystroem instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Nystroem must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Nystroem_feature_names_in_ = bridgeNystroem[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Nystroem_feature_names_in_.tolist() if hasattr(attr_Nystroem_feature_names_in_, 'tolist') else attr_Nystroem_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Polynomial kernel approximation via Tensor Sketch.\n\n  Implements Tensor Sketch, which approximates the feature map of the polynomial kernel:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.kernel_approximation.PolynomialCountSketch.html)\n */\nexport class PolynomialCountSketch {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Parameter of the polynomial kernel whose feature map will be approximated.\n\n      @defaultValue `1`\n     */\n    gamma?: number\n\n    /**\n      Degree of the polynomial kernel whose feature map will be approximated.\n\n      @defaultValue `2`\n     */\n    degree?: number\n\n    /**\n      Constant term of the polynomial kernel whose feature map will be approximated.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Dimensionality of the output feature space. Usually, `n\\_components` should be greater than the number of features in input samples in order to achieve good performance. The optimal score / run time balance is typically achieved around `n\\_components` = 10 \\* `n\\_features`, but this depends on the specific dataset being used.\n\n      @defaultValue `100`\n     */\n    n_components?: number\n\n    /**\n      Determines random number generation for indexHash and bitHash initialization. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `PolynomialCountSketch${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'PolynomialCountSketch.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.kernel_approximation import PolynomialCountSketch\ntry: bridgePolynomialCountSketch\nexcept NameError: bridgePolynomialCountSketch = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PolynomialCountSketch = {'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_PolynomialCountSketch = {k: v for k, v in ctor_PolynomialCountSketch.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePolynomialCountSketch[${this.id}] = PolynomialCountSketch(**ctor_PolynomialCountSketch)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePolynomialCountSketch[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model with X.\n\n    Initializes the internal variables. The method needs no information about the distribution of data, so we only care about n\\_features in X.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PolynomialCountSketch must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialCountSketch_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_PolynomialCountSketch_fit = {k: v for k, v in pms_PolynomialCountSketch_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_fit = bridgePolynomialCountSketch[${this.id}].fit(**pms_PolynomialCountSketch_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_fit.tolist() if hasattr(res_PolynomialCountSketch_fit, 'tolist') else res_PolynomialCountSketch_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PolynomialCountSketch_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_PolynomialCountSketch_fit_transform = {k: v for k, v in pms_PolynomialCountSketch_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_fit_transform = bridgePolynomialCountSketch[${this.id}].fit_transform(**pms_PolynomialCountSketch_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_fit_transform.tolist() if hasattr(res_PolynomialCountSketch_fit_transform, 'tolist') else res_PolynomialCountSketch_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PolynomialCountSketch_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_PolynomialCountSketch_get_feature_names_out = {k: v for k, v in pms_PolynomialCountSketch_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_get_feature_names_out = bridgePolynomialCountSketch[${this.id}].get_feature_names_out(**pms_PolynomialCountSketch_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_get_feature_names_out.tolist() if hasattr(res_PolynomialCountSketch_get_feature_names_out, 'tolist') else res_PolynomialCountSketch_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PolynomialCountSketch_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PolynomialCountSketch_get_metadata_routing = {k: v for k, v in pms_PolynomialCountSketch_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_get_metadata_routing = bridgePolynomialCountSketch[${this.id}].get_metadata_routing(**pms_PolynomialCountSketch_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_get_metadata_routing.tolist() if hasattr(res_PolynomialCountSketch_get_metadata_routing, 'tolist') else res_PolynomialCountSketch_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialCountSketch_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_PolynomialCountSketch_set_output = {k: v for k, v in pms_PolynomialCountSketch_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_set_output = bridgePolynomialCountSketch[${this.id}].set_output(**pms_PolynomialCountSketch_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_set_output.tolist() if hasattr(res_PolynomialCountSketch_set_output, 'tolist') else res_PolynomialCountSketch_set_output`\n  }\n\n  /**\n    Generate the feature map approximation for X.\n   */\n  async transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PolynomialCountSketch_transform = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_PolynomialCountSketch_transform = {k: v for k, v in pms_PolynomialCountSketch_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PolynomialCountSketch_transform = bridgePolynomialCountSketch[${this.id}].transform(**pms_PolynomialCountSketch_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PolynomialCountSketch_transform.tolist() if hasattr(res_PolynomialCountSketch_transform, 'tolist') else res_PolynomialCountSketch_transform`\n  }\n\n  /**\n    Array of indexes in range \\[0, n\\_components) used to represent the 2-wise independent hash functions for Count Sketch computation.\n   */\n  get indexHash_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before accessing indexHash_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialCountSketch_indexHash_ = bridgePolynomialCountSketch[${this.id}].indexHash_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialCountSketch_indexHash_.tolist() if hasattr(attr_PolynomialCountSketch_indexHash_, 'tolist') else attr_PolynomialCountSketch_indexHash_`\n    })()\n  }\n\n  /**\n    Array with random entries in {+1, -1}, used to represent the 2-wise independent hash functions for Count Sketch computation.\n   */\n  get bitHash_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before accessing bitHash_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialCountSketch_bitHash_ = bridgePolynomialCountSketch[${this.id}].bitHash_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialCountSketch_bitHash_.tolist() if hasattr(attr_PolynomialCountSketch_bitHash_, 'tolist') else attr_PolynomialCountSketch_bitHash_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialCountSketch_n_features_in_ = bridgePolynomialCountSketch[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialCountSketch_n_features_in_.tolist() if hasattr(attr_PolynomialCountSketch_n_features_in_, 'tolist') else attr_PolynomialCountSketch_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PolynomialCountSketch instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PolynomialCountSketch must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PolynomialCountSketch_feature_names_in_ = bridgePolynomialCountSketch[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PolynomialCountSketch_feature_names_in_.tolist() if hasattr(attr_PolynomialCountSketch_feature_names_in_, 'tolist') else attr_PolynomialCountSketch_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Approximate a RBF kernel feature map using random Fourier features.\n\n  It implements a variant of Random Kitchen Sinks.\\[1\\]\n\n  Read more in the [User Guide](../kernel_approximation.html#rbf-kernel-approx).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.kernel_approximation.RBFSampler.html)\n */\nexport class RBFSampler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Parameter of RBF kernel: exp(-gamma \\* x^2). If `gamma='scale'` is passed then it uses 1 / (n\\_features \\* X.var()) as value of gamma.\n\n      @defaultValue `1`\n     */\n    gamma?: 'scale' | number\n\n    /**\n      Number of Monte Carlo samples per original feature. Equals the dimensionality of the computed feature space.\n\n      @defaultValue `100`\n     */\n    n_components?: number\n\n    /**\n      Pseudo-random number generator to control the generation of the random weights and random offset when fitting the training data. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `RBFSampler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RBFSampler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.kernel_approximation import RBFSampler\ntry: bridgeRBFSampler\nexcept NameError: bridgeRBFSampler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RBFSampler = {'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_RBFSampler = {k: v for k, v in ctor_RBFSampler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRBFSampler[${this.id}] = RBFSampler(**ctor_RBFSampler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRBFSampler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model with X.\n\n    Samples random projection according to n\\_features.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RBFSampler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RBFSampler_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_RBFSampler_fit = {k: v for k, v in pms_RBFSampler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_fit = bridgeRBFSampler[${this.id}].fit(**pms_RBFSampler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_fit.tolist() if hasattr(res_RBFSampler_fit, 'tolist') else res_RBFSampler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RBFSampler must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RBFSampler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_RBFSampler_fit_transform = {k: v for k, v in pms_RBFSampler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_fit_transform = bridgeRBFSampler[${this.id}].fit_transform(**pms_RBFSampler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_fit_transform.tolist() if hasattr(res_RBFSampler_fit_transform, 'tolist') else res_RBFSampler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RBFSampler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_RBFSampler_get_feature_names_out = {k: v for k, v in pms_RBFSampler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_get_feature_names_out = bridgeRBFSampler[${this.id}].get_feature_names_out(**pms_RBFSampler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_get_feature_names_out.tolist() if hasattr(res_RBFSampler_get_feature_names_out, 'tolist') else res_RBFSampler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RBFSampler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RBFSampler_get_metadata_routing = {k: v for k, v in pms_RBFSampler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_get_metadata_routing = bridgeRBFSampler[${this.id}].get_metadata_routing(**pms_RBFSampler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_get_metadata_routing.tolist() if hasattr(res_RBFSampler_get_metadata_routing, 'tolist') else res_RBFSampler_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RBFSampler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RBFSampler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_RBFSampler_set_output = {k: v for k, v in pms_RBFSampler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_set_output = bridgeRBFSampler[${this.id}].set_output(**pms_RBFSampler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_set_output.tolist() if hasattr(res_RBFSampler_set_output, 'tolist') else res_RBFSampler_set_output`\n  }\n\n  /**\n    Apply the approximate feature map to X.\n   */\n  async transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RBFSampler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RBFSampler_transform = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_RBFSampler_transform = {k: v for k, v in pms_RBFSampler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RBFSampler_transform = bridgeRBFSampler[${this.id}].transform(**pms_RBFSampler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RBFSampler_transform.tolist() if hasattr(res_RBFSampler_transform, 'tolist') else res_RBFSampler_transform`\n  }\n\n  /**\n    Random offset used to compute the projection in the `n\\_components` dimensions of the feature space.\n   */\n  get random_offset_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before accessing random_offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RBFSampler_random_offset_ = bridgeRBFSampler[${this.id}].random_offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RBFSampler_random_offset_.tolist() if hasattr(attr_RBFSampler_random_offset_, 'tolist') else attr_RBFSampler_random_offset_`\n    })()\n  }\n\n  /**\n    Random projection directions drawn from the Fourier transform of the RBF kernel.\n   */\n  get random_weights_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before accessing random_weights_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RBFSampler_random_weights_ = bridgeRBFSampler[${this.id}].random_weights_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RBFSampler_random_weights_.tolist() if hasattr(attr_RBFSampler_random_weights_, 'tolist') else attr_RBFSampler_random_weights_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RBFSampler_n_features_in_ = bridgeRBFSampler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RBFSampler_n_features_in_.tolist() if hasattr(attr_RBFSampler_n_features_in_, 'tolist') else attr_RBFSampler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RBFSampler instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RBFSampler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RBFSampler_feature_names_in_ = bridgeRBFSampler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RBFSampler_feature_names_in_.tolist() if hasattr(attr_RBFSampler_feature_names_in_, 'tolist') else attr_RBFSampler_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Approximate feature map for “skewed chi-squared” kernel.\n\n  Read more in the [User Guide](../kernel_approximation.html#skewed-chi-kernel-approx).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.kernel_approximation.SkewedChi2Sampler.html)\n */\nexport class SkewedChi2Sampler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      “skewedness” parameter of the kernel. Needs to be cross-validated.\n\n      @defaultValue `1`\n     */\n    skewedness?: number\n\n    /**\n      Number of Monte Carlo samples per original feature. Equals the dimensionality of the computed feature space.\n\n      @defaultValue `100`\n     */\n    n_components?: number\n\n    /**\n      Pseudo-random number generator to control the generation of the random weights and random offset when fitting the training data. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SkewedChi2Sampler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SkewedChi2Sampler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.kernel_approximation import SkewedChi2Sampler\ntry: bridgeSkewedChi2Sampler\nexcept NameError: bridgeSkewedChi2Sampler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SkewedChi2Sampler = {'skewedness': ${\n      this.opts['skewedness'] ?? undefined\n    }, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_SkewedChi2Sampler = {k: v for k, v in ctor_SkewedChi2Sampler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSkewedChi2Sampler[${this.id}] = SkewedChi2Sampler(**ctor_SkewedChi2Sampler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSkewedChi2Sampler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model with X.\n\n    Samples random projection according to n\\_features.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SkewedChi2Sampler must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SkewedChi2Sampler_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_SkewedChi2Sampler_fit = {k: v for k, v in pms_SkewedChi2Sampler_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_fit = bridgeSkewedChi2Sampler[${this.id}].fit(**pms_SkewedChi2Sampler_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_fit.tolist() if hasattr(res_SkewedChi2Sampler_fit, 'tolist') else res_SkewedChi2Sampler_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SkewedChi2Sampler_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_SkewedChi2Sampler_fit_transform = {k: v for k, v in pms_SkewedChi2Sampler_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_fit_transform = bridgeSkewedChi2Sampler[${this.id}].fit_transform(**pms_SkewedChi2Sampler_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_fit_transform.tolist() if hasattr(res_SkewedChi2Sampler_fit_transform, 'tolist') else res_SkewedChi2Sampler_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in `fit`.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SkewedChi2Sampler_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_SkewedChi2Sampler_get_feature_names_out = {k: v for k, v in pms_SkewedChi2Sampler_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_get_feature_names_out = bridgeSkewedChi2Sampler[${this.id}].get_feature_names_out(**pms_SkewedChi2Sampler_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_get_feature_names_out.tolist() if hasattr(res_SkewedChi2Sampler_get_feature_names_out, 'tolist') else res_SkewedChi2Sampler_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SkewedChi2Sampler_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SkewedChi2Sampler_get_metadata_routing = {k: v for k, v in pms_SkewedChi2Sampler_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_get_metadata_routing = bridgeSkewedChi2Sampler[${this.id}].get_metadata_routing(**pms_SkewedChi2Sampler_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_get_metadata_routing.tolist() if hasattr(res_SkewedChi2Sampler_get_metadata_routing, 'tolist') else res_SkewedChi2Sampler_get_metadata_routing`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SkewedChi2Sampler must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SkewedChi2Sampler_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_SkewedChi2Sampler_set_output = {k: v for k, v in pms_SkewedChi2Sampler_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_set_output = bridgeSkewedChi2Sampler[${this.id}].set_output(**pms_SkewedChi2Sampler_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_set_output.tolist() if hasattr(res_SkewedChi2Sampler_set_output, 'tolist') else res_SkewedChi2Sampler_set_output`\n  }\n\n  /**\n    Apply the approximate feature map to X.\n   */\n  async transform(opts: {\n    /**\n      New data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. All values of X must be strictly greater than “-skewedness”.\n     */\n    X?: ArrayLike\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SkewedChi2Sampler must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SkewedChi2Sampler_transform = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SkewedChi2Sampler_transform = {k: v for k, v in pms_SkewedChi2Sampler_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SkewedChi2Sampler_transform = bridgeSkewedChi2Sampler[${this.id}].transform(**pms_SkewedChi2Sampler_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SkewedChi2Sampler_transform.tolist() if hasattr(res_SkewedChi2Sampler_transform, 'tolist') else res_SkewedChi2Sampler_transform`\n  }\n\n  /**\n    Weight array, sampled from a secant hyperbolic distribution, which will be used to linearly transform the log of the data.\n   */\n  get random_weights_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before accessing random_weights_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SkewedChi2Sampler_random_weights_ = bridgeSkewedChi2Sampler[${this.id}].random_weights_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SkewedChi2Sampler_random_weights_.tolist() if hasattr(attr_SkewedChi2Sampler_random_weights_, 'tolist') else attr_SkewedChi2Sampler_random_weights_`\n    })()\n  }\n\n  /**\n    Bias term, which will be added to the data. It is uniformly distributed between 0 and 2\\*pi.\n   */\n  get random_offset_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before accessing random_offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SkewedChi2Sampler_random_offset_ = bridgeSkewedChi2Sampler[${this.id}].random_offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SkewedChi2Sampler_random_offset_.tolist() if hasattr(attr_SkewedChi2Sampler_random_offset_, 'tolist') else attr_SkewedChi2Sampler_random_offset_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SkewedChi2Sampler_n_features_in_ = bridgeSkewedChi2Sampler[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SkewedChi2Sampler_n_features_in_.tolist() if hasattr(attr_SkewedChi2Sampler_n_features_in_, 'tolist') else attr_SkewedChi2Sampler_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SkewedChi2Sampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SkewedChi2Sampler must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SkewedChi2Sampler_feature_names_in_ = bridgeSkewedChi2Sampler[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SkewedChi2Sampler_feature_names_in_.tolist() if hasattr(attr_SkewedChi2Sampler_feature_names_in_, 'tolist') else attr_SkewedChi2Sampler_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto"]}