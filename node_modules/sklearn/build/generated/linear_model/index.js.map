{"version":3,"sources":["../../../src/generated/linear_model/ARDRegression.ts","../../../src/generated/linear_model/BayesianRidge.ts","../../../src/generated/linear_model/ElasticNet.ts","../../../src/generated/linear_model/ElasticNetCV.ts","../../../src/generated/linear_model/GammaRegressor.ts","../../../src/generated/linear_model/HuberRegressor.ts","../../../src/generated/linear_model/Lars.ts","../../../src/generated/linear_model/LarsCV.ts","../../../src/generated/linear_model/Lasso.ts","../../../src/generated/linear_model/LassoCV.ts","../../../src/generated/linear_model/LassoLars.ts","../../../src/generated/linear_model/LassoLarsCV.ts","../../../src/generated/linear_model/LassoLarsIC.ts","../../../src/generated/linear_model/LinearRegression.ts","../../../src/generated/linear_model/LogisticRegression.ts","../../../src/generated/linear_model/LogisticRegressionCV.ts","../../../src/generated/linear_model/MultiTaskElasticNet.ts","../../../src/generated/linear_model/MultiTaskElasticNetCV.ts","../../../src/generated/linear_model/MultiTaskLasso.ts","../../../src/generated/linear_model/MultiTaskLassoCV.ts","../../../src/generated/linear_model/OrthogonalMatchingPursuit.ts","../../../src/generated/linear_model/OrthogonalMatchingPursuitCV.ts","../../../src/generated/linear_model/PassiveAggressiveClassifier.ts","../../../src/generated/linear_model/Perceptron.ts","../../../src/generated/linear_model/PoissonRegressor.ts","../../../src/generated/linear_model/QuantileRegressor.ts","../../../src/generated/linear_model/RANSACRegressor.ts","../../../src/generated/linear_model/Ridge.ts","../../../src/generated/linear_model/RidgeClassifier.ts","../../../src/generated/linear_model/RidgeClassifierCV.ts","../../../src/generated/linear_model/RidgeCV.ts","../../../src/generated/linear_model/SGDClassifier.ts","../../../src/generated/linear_model/SGDOneClassSVM.ts","../../../src/generated/linear_model/SGDRegressor.ts","../../../src/generated/linear_model/TheilSenRegressor.ts","../../../src/generated/linear_model/TweedieRegressor.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Bayesian ARD regression.\n\n  Fit the weights of a regression model, using an ARD prior. The weights of the regression model are assumed to be in Gaussian distributions. Also estimate the parameters lambda (precisions of the distributions of the weights) and alpha (precision of the distribution of the noise). The estimation is done by an iterative procedures (Evidence Maximization)\n\n  Read more in the [User Guide](../linear_model.html#bayesian-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ARDRegression.html)\n */\nexport class ARDRegression {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Maximum number of iterations. If `undefined`, it corresponds to `max\\_iter=300`.\n     */\n    max_iter?: number\n\n    /**\n      Stop the algorithm if w has converged.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Hyper-parameter : shape parameter for the Gamma distribution prior over the alpha parameter.\n\n      @defaultValue `0.000001`\n     */\n    alpha_1?: number\n\n    /**\n      Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.\n\n      @defaultValue `0.000001`\n     */\n    alpha_2?: number\n\n    /**\n      Hyper-parameter : shape parameter for the Gamma distribution prior over the lambda parameter.\n\n      @defaultValue `0.000001`\n     */\n    lambda_1?: number\n\n    /**\n      Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.\n\n      @defaultValue `0.000001`\n     */\n    lambda_2?: number\n\n    /**\n      If `true`, compute the objective function at each step of the model.\n\n      @defaultValue `false`\n     */\n    compute_score?: boolean\n\n    /**\n      Threshold for removing (pruning) weights with high precision from the computation.\n\n      @defaultValue `10`\n     */\n    threshold_lambda?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Verbose mode when fitting the model.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Maximum number of iterations.\n     */\n    n_iter?: number\n  }) {\n    this.id = `ARDRegression${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ARDRegression.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import ARDRegression\ntry: bridgeARDRegression\nexcept NameError: bridgeARDRegression = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_ARDRegression = {'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'alpha_1': ${\n      this.opts['alpha_1'] ?? undefined\n    }, 'alpha_2': ${this.opts['alpha_2'] ?? undefined}, 'lambda_1': ${\n      this.opts['lambda_1'] ?? undefined\n    }, 'lambda_2': ${this.opts['lambda_2'] ?? undefined}, 'compute_score': ${\n      this.opts['compute_score'] ?? undefined\n    }, 'threshold_lambda': ${\n      this.opts['threshold_lambda'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }}\n\nctor_ARDRegression = {k: v for k, v in ctor_ARDRegression.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeARDRegression[${this.id}] = ARDRegression(**ctor_ARDRegression)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeARDRegression[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data and parameters.\n\n    Iterative procedure to maximize the evidence\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (integers). Will be cast to X’s dtype if necessary.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_ARDRegression_fit = {k: v for k, v in pms_ARDRegression_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_fit = bridgeARDRegression[${this.id}].fit(**pms_ARDRegression_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_fit.tolist() if hasattr(res_ARDRegression_fit, 'tolist') else res_ARDRegression_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_ARDRegression_get_metadata_routing = {k: v for k, v in pms_ARDRegression_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_get_metadata_routing = bridgeARDRegression[${this.id}].get_metadata_routing(**pms_ARDRegression_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_get_metadata_routing.tolist() if hasattr(res_ARDRegression_get_metadata_routing, 'tolist') else res_ARDRegression_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n\n    In addition to the mean of the predictive distribution, also its standard deviation can be returned.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Whether to return the standard deviation of posterior prediction.\n\n      @defaultValue `false`\n     */\n    return_std?: boolean\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'return_std': ${\n      opts['return_std'] ?? undefined\n    }}\n\npms_ARDRegression_predict = {k: v for k, v in pms_ARDRegression_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_predict = bridgeARDRegression[${this.id}].predict(**pms_ARDRegression_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_predict.tolist() if hasattr(res_ARDRegression_predict, 'tolist') else res_ARDRegression_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_ARDRegression_score = {k: v for k, v in pms_ARDRegression_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_score = bridgeARDRegression[${this.id}].score(**pms_ARDRegression_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_score.tolist() if hasattr(res_ARDRegression_score, 'tolist') else res_ARDRegression_score`\n  }\n\n  /**\n    Request metadata passed to the `predict` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_predict_request(opts: {\n    /**\n      Metadata routing for `return\\_std` parameter in `predict`.\n     */\n    return_std?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before set_predict_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_set_predict_request = {'return_std': ${\n      opts['return_std'] ?? undefined\n    }}\n\npms_ARDRegression_set_predict_request = {k: v for k, v in pms_ARDRegression_set_predict_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_set_predict_request = bridgeARDRegression[${this.id}].set_predict_request(**pms_ARDRegression_set_predict_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_set_predict_request.tolist() if hasattr(res_ARDRegression_set_predict_request, 'tolist') else res_ARDRegression_set_predict_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ARDRegression_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_ARDRegression_set_score_request = {k: v for k, v in pms_ARDRegression_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ARDRegression_set_score_request = bridgeARDRegression[${this.id}].set_score_request(**pms_ARDRegression_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ARDRegression_set_score_request.tolist() if hasattr(res_ARDRegression_set_score_request, 'tolist') else res_ARDRegression_set_score_request`\n  }\n\n  /**\n    Coefficients of the regression model (mean of distribution)\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_coef_ = bridgeARDRegression[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_coef_.tolist() if hasattr(attr_ARDRegression_coef_, 'tolist') else attr_ARDRegression_coef_`\n    })()\n  }\n\n  /**\n    estimated precision of the noise.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_alpha_ = bridgeARDRegression[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_alpha_.tolist() if hasattr(attr_ARDRegression_alpha_, 'tolist') else attr_ARDRegression_alpha_`\n    })()\n  }\n\n  /**\n    estimated precisions of the weights.\n   */\n  get lambda_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing lambda_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_lambda_ = bridgeARDRegression[${this.id}].lambda_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_lambda_.tolist() if hasattr(attr_ARDRegression_lambda_, 'tolist') else attr_ARDRegression_lambda_`\n    })()\n  }\n\n  /**\n    estimated variance-covariance matrix of the weights\n   */\n  get sigma_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing sigma_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_sigma_ = bridgeARDRegression[${this.id}].sigma_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_sigma_.tolist() if hasattr(attr_ARDRegression_sigma_, 'tolist') else attr_ARDRegression_sigma_`\n    })()\n  }\n\n  /**\n    if computed, value of the objective function (to be maximized)\n   */\n  get scores_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_scores_ = bridgeARDRegression[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_scores_.tolist() if hasattr(attr_ARDRegression_scores_, 'tolist') else attr_ARDRegression_scores_`\n    })()\n  }\n\n  /**\n    The actual number of iterations to reach the stopping criterion.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ARDRegression must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_n_iter_ = bridgeARDRegression[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_n_iter_.tolist() if hasattr(attr_ARDRegression_n_iter_, 'tolist') else attr_ARDRegression_n_iter_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_intercept_ = bridgeARDRegression[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_intercept_.tolist() if hasattr(attr_ARDRegression_intercept_, 'tolist') else attr_ARDRegression_intercept_`\n    })()\n  }\n\n  /**\n    If `fit\\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\\_features) otherwise.\n   */\n  get X_offset_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before accessing X_offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_X_offset_ = bridgeARDRegression[${this.id}].X_offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_X_offset_.tolist() if hasattr(attr_ARDRegression_X_offset_, 'tolist') else attr_ARDRegression_X_offset_`\n    })()\n  }\n\n  /**\n    Set to np.ones(n\\_features).\n   */\n  get X_scale_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before accessing X_scale_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_X_scale_ = bridgeARDRegression[${this.id}].X_scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_X_scale_.tolist() if hasattr(attr_ARDRegression_X_scale_, 'tolist') else attr_ARDRegression_X_scale_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_n_features_in_ = bridgeARDRegression[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_n_features_in_.tolist() if hasattr(attr_ARDRegression_n_features_in_, 'tolist') else attr_ARDRegression_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ARDRegression instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ARDRegression must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ARDRegression_feature_names_in_ = bridgeARDRegression[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ARDRegression_feature_names_in_.tolist() if hasattr(attr_ARDRegression_feature_names_in_, 'tolist') else attr_ARDRegression_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Bayesian ridge regression.\n\n  Fit a Bayesian ridge model. See the Notes section for details on this implementation and the optimization of the regularization parameters lambda (precision of the weights) and alpha (precision of the noise).\n\n  Read more in the [User Guide](../linear_model.html#bayesian-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.BayesianRidge.html)\n */\nexport class BayesianRidge {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion. If `undefined`, it corresponds to `max\\_iter=300`.\n     */\n    max_iter?: number\n\n    /**\n      Stop the algorithm if w has converged.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Hyper-parameter : shape parameter for the Gamma distribution prior over the alpha parameter.\n\n      @defaultValue `0.000001`\n     */\n    alpha_1?: number\n\n    /**\n      Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.\n\n      @defaultValue `0.000001`\n     */\n    alpha_2?: number\n\n    /**\n      Hyper-parameter : shape parameter for the Gamma distribution prior over the lambda parameter.\n\n      @defaultValue `0.000001`\n     */\n    lambda_1?: number\n\n    /**\n      Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.\n\n      @defaultValue `0.000001`\n     */\n    lambda_2?: number\n\n    /**\n      Initial value for alpha (precision of the noise). If not set, alpha\\_init is 1/Var(y).\n     */\n    alpha_init?: number\n\n    /**\n      Initial value for lambda (precision of the weights). If not set, lambda\\_init is 1.\n     */\n    lambda_init?: number\n\n    /**\n      If `true`, compute the log marginal likelihood at each iteration of the optimization.\n\n      @defaultValue `false`\n     */\n    compute_score?: boolean\n\n    /**\n      Whether to calculate the intercept for this model. The intercept is not treated as a probabilistic parameter and thus has no associated variance. If set to `false`, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Verbose mode when fitting the model.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Maximum number of iterations. Should be greater than or equal to 1.\n     */\n    n_iter?: number\n  }) {\n    this.id = `BayesianRidge${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('BayesianRidge.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import BayesianRidge\ntry: bridgeBayesianRidge\nexcept NameError: bridgeBayesianRidge = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_BayesianRidge = {'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'alpha_1': ${\n      this.opts['alpha_1'] ?? undefined\n    }, 'alpha_2': ${this.opts['alpha_2'] ?? undefined}, 'lambda_1': ${\n      this.opts['lambda_1'] ?? undefined\n    }, 'lambda_2': ${this.opts['lambda_2'] ?? undefined}, 'alpha_init': ${\n      this.opts['alpha_init'] ?? undefined\n    }, 'lambda_init': ${\n      this.opts['lambda_init'] ?? undefined\n    }, 'compute_score': ${\n      this.opts['compute_score'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }}\n\nctor_BayesianRidge = {k: v for k, v in ctor_BayesianRidge.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeBayesianRidge[${this.id}] = BayesianRidge(**ctor_BayesianRidge)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeBayesianRidge[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: NDArray[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray\n\n    /**\n      Individual weights for each sample.\n     */\n    sample_weight?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_BayesianRidge_fit = {k: v for k, v in pms_BayesianRidge_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_fit = bridgeBayesianRidge[${this.id}].fit(**pms_BayesianRidge_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_fit.tolist() if hasattr(res_BayesianRidge_fit, 'tolist') else res_BayesianRidge_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_BayesianRidge_get_metadata_routing = {k: v for k, v in pms_BayesianRidge_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_get_metadata_routing = bridgeBayesianRidge[${this.id}].get_metadata_routing(**pms_BayesianRidge_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_get_metadata_routing.tolist() if hasattr(res_BayesianRidge_get_metadata_routing, 'tolist') else res_BayesianRidge_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n\n    In addition to the mean of the predictive distribution, also its standard deviation can be returned.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Whether to return the standard deviation of posterior prediction.\n\n      @defaultValue `false`\n     */\n    return_std?: boolean\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'return_std': ${\n      opts['return_std'] ?? undefined\n    }}\n\npms_BayesianRidge_predict = {k: v for k, v in pms_BayesianRidge_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_predict = bridgeBayesianRidge[${this.id}].predict(**pms_BayesianRidge_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_predict.tolist() if hasattr(res_BayesianRidge_predict, 'tolist') else res_BayesianRidge_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_BayesianRidge_score = {k: v for k, v in pms_BayesianRidge_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_score = bridgeBayesianRidge[${this.id}].score(**pms_BayesianRidge_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_score.tolist() if hasattr(res_BayesianRidge_score, 'tolist') else res_BayesianRidge_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_BayesianRidge_set_fit_request = {k: v for k, v in pms_BayesianRidge_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_set_fit_request = bridgeBayesianRidge[${this.id}].set_fit_request(**pms_BayesianRidge_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_set_fit_request.tolist() if hasattr(res_BayesianRidge_set_fit_request, 'tolist') else res_BayesianRidge_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `predict` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_predict_request(opts: {\n    /**\n      Metadata routing for `return\\_std` parameter in `predict`.\n     */\n    return_std?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before set_predict_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_set_predict_request = {'return_std': ${\n      opts['return_std'] ?? undefined\n    }}\n\npms_BayesianRidge_set_predict_request = {k: v for k, v in pms_BayesianRidge_set_predict_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_set_predict_request = bridgeBayesianRidge[${this.id}].set_predict_request(**pms_BayesianRidge_set_predict_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_set_predict_request.tolist() if hasattr(res_BayesianRidge_set_predict_request, 'tolist') else res_BayesianRidge_set_predict_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_BayesianRidge_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_BayesianRidge_set_score_request = {k: v for k, v in pms_BayesianRidge_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_BayesianRidge_set_score_request = bridgeBayesianRidge[${this.id}].set_score_request(**pms_BayesianRidge_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_BayesianRidge_set_score_request.tolist() if hasattr(res_BayesianRidge_set_score_request, 'tolist') else res_BayesianRidge_set_score_request`\n  }\n\n  /**\n    Coefficients of the regression model (mean of distribution)\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_coef_ = bridgeBayesianRidge[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_coef_.tolist() if hasattr(attr_BayesianRidge_coef_, 'tolist') else attr_BayesianRidge_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_intercept_ = bridgeBayesianRidge[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_intercept_.tolist() if hasattr(attr_BayesianRidge_intercept_, 'tolist') else attr_BayesianRidge_intercept_`\n    })()\n  }\n\n  /**\n    Estimated precision of the noise.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_alpha_ = bridgeBayesianRidge[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_alpha_.tolist() if hasattr(attr_BayesianRidge_alpha_, 'tolist') else attr_BayesianRidge_alpha_`\n    })()\n  }\n\n  /**\n    Estimated precision of the weights.\n   */\n  get lambda_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing lambda_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_lambda_ = bridgeBayesianRidge[${this.id}].lambda_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_lambda_.tolist() if hasattr(attr_BayesianRidge_lambda_, 'tolist') else attr_BayesianRidge_lambda_`\n    })()\n  }\n\n  /**\n    Estimated variance-covariance matrix of the weights\n   */\n  get sigma_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing sigma_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_sigma_ = bridgeBayesianRidge[${this.id}].sigma_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_sigma_.tolist() if hasattr(attr_BayesianRidge_sigma_, 'tolist') else attr_BayesianRidge_sigma_`\n    })()\n  }\n\n  /**\n    If computed\\_score is `true`, value of the log marginal likelihood (to be maximized) at each iteration of the optimization. The array starts with the value of the log marginal likelihood obtained for the initial values of alpha and lambda and ends with the value obtained for the estimated alpha and lambda.\n   */\n  get scores_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing scores_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_scores_ = bridgeBayesianRidge[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_scores_.tolist() if hasattr(attr_BayesianRidge_scores_, 'tolist') else attr_BayesianRidge_scores_`\n    })()\n  }\n\n  /**\n    The actual number of iterations to reach the stopping criterion.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('BayesianRidge must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_n_iter_ = bridgeBayesianRidge[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_n_iter_.tolist() if hasattr(attr_BayesianRidge_n_iter_, 'tolist') else attr_BayesianRidge_n_iter_`\n    })()\n  }\n\n  /**\n    If `fit\\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\\_features) otherwise.\n   */\n  get X_offset_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before accessing X_offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_X_offset_ = bridgeBayesianRidge[${this.id}].X_offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_X_offset_.tolist() if hasattr(attr_BayesianRidge_X_offset_, 'tolist') else attr_BayesianRidge_X_offset_`\n    })()\n  }\n\n  /**\n    Set to np.ones(n\\_features).\n   */\n  get X_scale_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before accessing X_scale_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_X_scale_ = bridgeBayesianRidge[${this.id}].X_scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_X_scale_.tolist() if hasattr(attr_BayesianRidge_X_scale_, 'tolist') else attr_BayesianRidge_X_scale_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_n_features_in_ = bridgeBayesianRidge[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_n_features_in_.tolist() if hasattr(attr_BayesianRidge_n_features_in_, 'tolist') else attr_BayesianRidge_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This BayesianRidge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'BayesianRidge must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_BayesianRidge_feature_names_in_ = bridgeBayesianRidge[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_BayesianRidge_feature_names_in_.tolist() if hasattr(attr_BayesianRidge_feature_names_in_, 'tolist') else attr_BayesianRidge_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear regression with combined L1 and L2 priors as regularizer.\n\n  Minimizes the objective function:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNet.html)\n */\nexport class ElasticNet {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the penalty terms. Defaults to 1.0. See the notes for the exact mathematical meaning of this parameter. `alpha \\= 0` is equivalent to an ordinary least square, solved by the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object. For numerical reasons, using `alpha \\= 0` with the `Lasso` object is not advised. Given this, you should use the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      The ElasticNet mixing parameter, with `0 <= l1\\_ratio <= 1`. For `l1\\_ratio \\= 0` the penalty is an L2 penalty. `For l1\\_ratio \\= 1` it is an L1 penalty. For `0 < l1\\_ratio < 1`, the penalty is a combination of L1 and L2.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether the intercept should be estimated or not. If `false`, the data is assumed to be already centered.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always `false` to preserve sparsity.\n\n      @defaultValue `false`\n     */\n    precompute?: boolean | ArrayLike[]\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`, see Notes below.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      When set to `true`, forces the coefficients to be positive.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `ElasticNet${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ElasticNet.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import ElasticNet\ntry: bridgeElasticNet\nexcept NameError: bridgeElasticNet = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_ElasticNet = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'l1_ratio': ${this.opts['l1_ratio'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'precompute': np.array(${this.opts['precompute'] ?? undefined}) if ${\n      this.opts['precompute'] !== undefined\n    } else None, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_ElasticNet = {k: v for k, v in ctor_ElasticNet.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeElasticNet[${this.id}] = ElasticNet(**ctor_ElasticNet)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeElasticNet[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit model with coordinate descent.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: any\n\n    /**\n      Target. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray\n\n    /**\n      Sample weights. Internally, the `sample\\_weight` vector will be rescaled to sum to `n\\_samples`.\n     */\n    sample_weight?: number | ArrayLike\n\n    /**\n      Allow to bypass several input checking. Don’t use this parameter unless you know what you do.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }}\n\npms_ElasticNet_fit = {k: v for k, v in pms_ElasticNet_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_fit = bridgeElasticNet[${this.id}].fit(**pms_ElasticNet_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_fit.tolist() if hasattr(res_ElasticNet_fit, 'tolist') else res_ElasticNet_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNet must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_ElasticNet_get_metadata_routing = {k: v for k, v in pms_ElasticNet_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_get_metadata_routing = bridgeElasticNet[${this.id}].get_metadata_routing(**pms_ElasticNet_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_get_metadata_routing.tolist() if hasattr(res_ElasticNet_get_metadata_routing, 'tolist') else res_ElasticNet_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_ElasticNet_path = {k: v for k, v in pms_ElasticNet_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_path = bridgeElasticNet[${this.id}].path(**pms_ElasticNet_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_path.tolist() if hasattr(res_ElasticNet_path, 'tolist') else res_ElasticNet_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_ElasticNet_predict = {k: v for k, v in pms_ElasticNet_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_predict = bridgeElasticNet[${this.id}].predict(**pms_ElasticNet_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_predict.tolist() if hasattr(res_ElasticNet_predict, 'tolist') else res_ElasticNet_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_ElasticNet_score = {k: v for k, v in pms_ElasticNet_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_score = bridgeElasticNet[${this.id}].score(**pms_ElasticNet_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_score.tolist() if hasattr(res_ElasticNet_score, 'tolist') else res_ElasticNet_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `check\\_input` parameter in `fit`.\n     */\n    check_input?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_set_fit_request = {'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_ElasticNet_set_fit_request = {k: v for k, v in pms_ElasticNet_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_set_fit_request = bridgeElasticNet[${this.id}].set_fit_request(**pms_ElasticNet_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_set_fit_request.tolist() if hasattr(res_ElasticNet_set_fit_request, 'tolist') else res_ElasticNet_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNet_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_ElasticNet_set_score_request = {k: v for k, v in pms_ElasticNet_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNet_set_score_request = bridgeElasticNet[${this.id}].set_score_request(**pms_ElasticNet_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNet_set_score_request.tolist() if hasattr(res_ElasticNet_set_score_request, 'tolist') else res_ElasticNet_set_score_request`\n  }\n\n  /**\n    Parameter vector (w in the cost function formula).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_coef_ = bridgeElasticNet[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_coef_.tolist() if hasattr(attr_ElasticNet_coef_, 'tolist') else attr_ElasticNet_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_intercept_ = bridgeElasticNet[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_intercept_.tolist() if hasattr(attr_ElasticNet_intercept_, 'tolist') else attr_ElasticNet_intercept_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance.\n   */\n  get n_iter_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_n_iter_ = bridgeElasticNet[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_n_iter_.tolist() if hasattr(attr_ElasticNet_n_iter_, 'tolist') else attr_ElasticNet_n_iter_`\n    })()\n  }\n\n  /**\n    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.\n   */\n  get dual_gap_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNet must call init() before accessing dual_gap_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_dual_gap_ = bridgeElasticNet[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_dual_gap_.tolist() if hasattr(attr_ElasticNet_dual_gap_, 'tolist') else attr_ElasticNet_dual_gap_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNet must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_n_features_in_ = bridgeElasticNet[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_n_features_in_.tolist() if hasattr(attr_ElasticNet_n_features_in_, 'tolist') else attr_ElasticNet_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNet instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNet must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNet_feature_names_in_ = bridgeElasticNet[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNet_feature_names_in_.tolist() if hasattr(attr_ElasticNet_feature_names_in_, 'tolist') else attr_ElasticNet_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Elastic Net model with iterative fitting along a regularization path.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  Read more in the [User Guide](../linear_model.html#elastic-net).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNetCV.html)\n */\nexport class ElasticNetCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Float between 0 and 1 passed to ElasticNet (scaling between l1 and l2 penalties). For `l1\\_ratio \\= 0` the penalty is an L2 penalty. For `l1\\_ratio \\= 1` it is an L1 penalty. For `0 < l1\\_ratio < 1`, the penalty is a combination of L1 and L2 This parameter can be a list, in which case the different values are tested by cross-validation and the one giving the best prediction score is used. Note that a good choice of list of values for l1\\_ratio is often to put more values close to 1 (i.e. Lasso) and less close to 0 (i.e. Ridge), as in `\\[.1, .5, .7, .9, .95, .99, 1\\]`.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path, used for each l1\\_ratio.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: boolean | number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      When set to `true`, forces the coefficients to be positive.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `ElasticNetCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ElasticNetCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import ElasticNetCV\ntry: bridgeElasticNetCV\nexcept NameError: bridgeElasticNetCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_ElasticNetCV = {'l1_ratio': ${\n      this.opts['l1_ratio'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'n_alphas': ${\n      this.opts['n_alphas'] ?? undefined\n    }, 'alphas': ${this.opts['alphas'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'precompute': np.array(${this.opts['precompute'] ?? undefined}) if ${\n      this.opts['precompute'] !== undefined\n    } else None, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_ElasticNetCV = {k: v for k, v in ctor_ElasticNetCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeElasticNetCV[${this.id}] = ElasticNetCV(**ctor_ElasticNetCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeElasticNetCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit linear model with coordinate descent.\n\n    Fit is on grid of alphas and best alpha estimated by cross-validation.\n   */\n  async fit(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If y is mono-output, X can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights used for fitting and evaluation of the weighted mean squared error of each cv-fold. Note that the cross validated MSE that is finally used to find the best model is the unweighted mean over the (weighted) MSEs of each test fold.\n     */\n    sample_weight?: number | ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_ElasticNetCV_fit = {k: v for k, v in pms_ElasticNetCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_fit = bridgeElasticNetCV[${this.id}].fit(**pms_ElasticNetCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_fit.tolist() if hasattr(res_ElasticNetCV_fit, 'tolist') else res_ElasticNetCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_ElasticNetCV_get_metadata_routing = {k: v for k, v in pms_ElasticNetCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_get_metadata_routing = bridgeElasticNetCV[${this.id}].get_metadata_routing(**pms_ElasticNetCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_get_metadata_routing.tolist() if hasattr(res_ElasticNetCV_get_metadata_routing, 'tolist') else res_ElasticNetCV_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_ElasticNetCV_path = {k: v for k, v in pms_ElasticNetCV_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_path = bridgeElasticNetCV[${this.id}].path(**pms_ElasticNetCV_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_path.tolist() if hasattr(res_ElasticNetCV_path, 'tolist') else res_ElasticNetCV_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_ElasticNetCV_predict = {k: v for k, v in pms_ElasticNetCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_predict = bridgeElasticNetCV[${this.id}].predict(**pms_ElasticNetCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_predict.tolist() if hasattr(res_ElasticNetCV_predict, 'tolist') else res_ElasticNetCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_ElasticNetCV_score = {k: v for k, v in pms_ElasticNetCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_score = bridgeElasticNetCV[${this.id}].score(**pms_ElasticNetCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_score.tolist() if hasattr(res_ElasticNetCV_score, 'tolist') else res_ElasticNetCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_ElasticNetCV_set_fit_request = {k: v for k, v in pms_ElasticNetCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_set_fit_request = bridgeElasticNetCV[${this.id}].set_fit_request(**pms_ElasticNetCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_set_fit_request.tolist() if hasattr(res_ElasticNetCV_set_fit_request, 'tolist') else res_ElasticNetCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_ElasticNetCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_ElasticNetCV_set_score_request = {k: v for k, v in pms_ElasticNetCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ElasticNetCV_set_score_request = bridgeElasticNetCV[${this.id}].set_score_request(**pms_ElasticNetCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ElasticNetCV_set_score_request.tolist() if hasattr(res_ElasticNetCV_set_score_request, 'tolist') else res_ElasticNetCV_set_score_request`\n  }\n\n  /**\n    The amount of penalization chosen by cross validation.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_alpha_ = bridgeElasticNetCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_alpha_.tolist() if hasattr(attr_ElasticNetCV_alpha_, 'tolist') else attr_ElasticNetCV_alpha_`\n    })()\n  }\n\n  /**\n    The compromise between l1 and l2 penalization chosen by cross validation.\n   */\n  get l1_ratio_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing l1_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_l1_ratio_ = bridgeElasticNetCV[${this.id}].l1_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_l1_ratio_.tolist() if hasattr(attr_ElasticNetCV_l1_ratio_, 'tolist') else attr_ElasticNetCV_l1_ratio_`\n    })()\n  }\n\n  /**\n    Parameter vector (w in the cost function formula).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_coef_ = bridgeElasticNetCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_coef_.tolist() if hasattr(attr_ElasticNetCV_coef_, 'tolist') else attr_ElasticNetCV_coef_`\n    })()\n  }\n\n  /**\n    Independent term in the decision function.\n   */\n  get intercept_(): Promise<number | NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_intercept_ = bridgeElasticNetCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_intercept_.tolist() if hasattr(attr_ElasticNetCV_intercept_, 'tolist') else attr_ElasticNetCV_intercept_`\n    })()\n  }\n\n  /**\n    Mean square error for the test set on each fold, varying l1\\_ratio and alpha.\n   */\n  get mse_path_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing mse_path_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_mse_path_ = bridgeElasticNetCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_mse_path_.tolist() if hasattr(attr_ElasticNetCV_mse_path_, 'tolist') else attr_ElasticNetCV_mse_path_`\n    })()\n  }\n\n  /**\n    The grid of alphas used for fitting, for each l1\\_ratio.\n   */\n  get alphas_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_alphas_ = bridgeElasticNetCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_alphas_.tolist() if hasattr(attr_ElasticNetCV_alphas_, 'tolist') else attr_ElasticNetCV_alphas_`\n    })()\n  }\n\n  /**\n    The dual gaps at the end of the optimization for the optimal alpha.\n   */\n  get dual_gap_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing dual_gap_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_dual_gap_ = bridgeElasticNetCV[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_dual_gap_.tolist() if hasattr(attr_ElasticNetCV_dual_gap_, 'tolist') else attr_ElasticNetCV_dual_gap_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ElasticNetCV must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_n_iter_ = bridgeElasticNetCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_n_iter_.tolist() if hasattr(attr_ElasticNetCV_n_iter_, 'tolist') else attr_ElasticNetCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_n_features_in_ = bridgeElasticNetCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_n_features_in_.tolist() if hasattr(attr_ElasticNetCV_n_features_in_, 'tolist') else attr_ElasticNetCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This ElasticNetCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ElasticNetCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ElasticNetCV_feature_names_in_ = bridgeElasticNetCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ElasticNetCV_feature_names_in_.tolist() if hasattr(attr_ElasticNetCV_feature_names_in_, 'tolist') else attr_ElasticNetCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generalized Linear Model with a Gamma distribution.\n\n  This regressor uses the ‘log’ link function.\n\n  Read more in the [User Guide](../linear_model.html#generalized-linear-models).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.GammaRegressor.html)\n */\nexport class GammaRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L2 penalty term and determines the regularization strength. `alpha \\= 0` is equivalent to unpenalized GLMs. In this case, the design matrix `X` must have full column rank (no collinearities). Values of `alpha` must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Specifies if a constant (a.k.a. bias or intercept) should be added to the linear predictor `X @ coef\\_ + intercept\\_`.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Algorithm to use in the optimization problem:\n\n      @defaultValue `'lbfgs'`\n     */\n    solver?: 'lbfgs' | 'newton-cholesky'\n\n    /**\n      The maximal number of iterations for the solver. Values must be in the range `\\[1, inf)`.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Stopping criterion. For the lbfgs solver, the iteration will stop when `max{|g\\_j|, j \\= 1, ..., d} <= tol` where `g\\_j` is the j-th component of the gradient (derivative) of the objective function. Values must be in the range `(0.0, inf)`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      If set to `true`, reuse the solution of the previous call to `fit` as initialization for `coef\\_` and `intercept\\_`.\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      For the lbfgs solver set verbose to any positive number for verbosity. Values must be in the range `\\[0, inf)`.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n  }) {\n    this.id = `GammaRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('GammaRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import GammaRegressor\ntry: bridgeGammaRegressor\nexcept NameError: bridgeGammaRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_GammaRegressor = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_GammaRegressor = {k: v for k, v in ctor_GammaRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeGammaRegressor[${this.id}] = GammaRegressor(**ctor_GammaRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeGammaRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a Generalized Linear Model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GammaRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GammaRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_GammaRegressor_fit = {k: v for k, v in pms_GammaRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_fit = bridgeGammaRegressor[${this.id}].fit(**pms_GammaRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_fit.tolist() if hasattr(res_GammaRegressor_fit, 'tolist') else res_GammaRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_GammaRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_GammaRegressor_get_metadata_routing = {k: v for k, v in pms_GammaRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_get_metadata_routing = bridgeGammaRegressor[${this.id}].get_metadata_routing(**pms_GammaRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_get_metadata_routing.tolist() if hasattr(res_GammaRegressor_get_metadata_routing, 'tolist') else res_GammaRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using GLM with feature matrix X.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GammaRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GammaRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_GammaRegressor_predict = {k: v for k, v in pms_GammaRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_predict = bridgeGammaRegressor[${this.id}].predict(**pms_GammaRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_predict.tolist() if hasattr(res_GammaRegressor_predict, 'tolist') else res_GammaRegressor_predict`\n  }\n\n  /**\n    Compute D^2, the percentage of deviance explained.\n\n    D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).\n\n    D^2 is defined as \\\\(D^2 = 1-\\\\frac{D(y\\_{true},y\\_{pred})}{D\\_{null}}\\\\), \\\\(D\\_{null}\\\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\\\(y\\_{pred} = \\\\bar{y}\\\\). The mean \\\\(\\\\bar{y}\\\\) is averaged by sample\\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      True values of target.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GammaRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_GammaRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_GammaRegressor_score = {k: v for k, v in pms_GammaRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_score = bridgeGammaRegressor[${this.id}].score(**pms_GammaRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_score.tolist() if hasattr(res_GammaRegressor_score, 'tolist') else res_GammaRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_GammaRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_GammaRegressor_set_fit_request = {k: v for k, v in pms_GammaRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_set_fit_request = bridgeGammaRegressor[${this.id}].set_fit_request(**pms_GammaRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_set_fit_request.tolist() if hasattr(res_GammaRegressor_set_fit_request, 'tolist') else res_GammaRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_GammaRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_GammaRegressor_set_score_request = {k: v for k, v in pms_GammaRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_GammaRegressor_set_score_request = bridgeGammaRegressor[${this.id}].set_score_request(**pms_GammaRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_GammaRegressor_set_score_request.tolist() if hasattr(res_GammaRegressor_set_score_request, 'tolist') else res_GammaRegressor_set_score_request`\n  }\n\n  /**\n    Estimated coefficients for the linear predictor (`X @ coef\\_ + intercept\\_`) in the GLM.\n   */\n  get coef_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('GammaRegressor must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GammaRegressor_coef_ = bridgeGammaRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GammaRegressor_coef_.tolist() if hasattr(attr_GammaRegressor_coef_, 'tolist') else attr_GammaRegressor_coef_`\n    })()\n  }\n\n  /**\n    Intercept (a.k.a. bias) added to linear predictor.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GammaRegressor_intercept_ = bridgeGammaRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GammaRegressor_intercept_.tolist() if hasattr(attr_GammaRegressor_intercept_, 'tolist') else attr_GammaRegressor_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GammaRegressor_n_features_in_ = bridgeGammaRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GammaRegressor_n_features_in_.tolist() if hasattr(attr_GammaRegressor_n_features_in_, 'tolist') else attr_GammaRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Actual number of iterations used in the solver.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GammaRegressor_n_iter_ = bridgeGammaRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GammaRegressor_n_iter_.tolist() if hasattr(attr_GammaRegressor_n_iter_, 'tolist') else attr_GammaRegressor_n_iter_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This GammaRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'GammaRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_GammaRegressor_feature_names_in_ = bridgeGammaRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_GammaRegressor_feature_names_in_.tolist() if hasattr(attr_GammaRegressor_feature_names_in_, 'tolist') else attr_GammaRegressor_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  L2-regularized linear regression model that is robust to outliers.\n\n  The Huber Regressor optimizes the squared loss for the samples where `|(y \\- Xw \\- c) / sigma| < epsilon` and the absolute loss for the samples where `|(y \\- Xw \\- c) / sigma| > epsilon`, where the model coefficients `w`, the intercept `c` and the scale `sigma` are parameters to be optimized. The parameter sigma makes sure that if y is scaled up or down by a certain factor, one does not need to rescale epsilon to achieve the same robustness. Note that this does not take into account the fact that the different features of X may be of different scales.\n\n  The Huber loss function has the advantage of not being heavily influenced by the outliers while not completely ignoring their effect.\n\n  Read more in the [User Guide](../linear_model.html#huber-regression)\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.HuberRegressor.html)\n */\nexport class HuberRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The parameter epsilon controls the number of samples that should be classified as outliers. The smaller the epsilon, the more robust it is to outliers. Epsilon must be in the range `\\[1, inf)`.\n\n      @defaultValue `1.35`\n     */\n    epsilon?: number\n\n    /**\n      Maximum number of iterations that `scipy.optimize.minimize(method=\"L-BFGS-B\")` should run for.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Strength of the squared L2 regularization. Note that the penalty is equal to `alpha \\* ||w||^2`. Must be in the range `\\[0, inf)`.\n\n      @defaultValue `0.0001`\n     */\n    alpha?: number\n\n    /**\n      This is useful if the stored attributes of a previously used model has to be reused. If set to `false`, then the coefficients will be rewritten for every call to fit. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      Whether or not to fit the intercept. This can be set to `false` if the data is already centered around the origin.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The iteration will stop when `max{|proj g\\_i | i \\= 1, ..., n}` <= `tol` where pg\\_i is the i-th component of the projected gradient.\n\n      @defaultValue `0.00001`\n     */\n    tol?: number\n  }) {\n    this.id = `HuberRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('HuberRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import HuberRegressor\ntry: bridgeHuberRegressor\nexcept NameError: bridgeHuberRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_HuberRegressor = {'epsilon': ${\n      this.opts['epsilon'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }}\n\nctor_HuberRegressor = {k: v for k, v in ctor_HuberRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeHuberRegressor[${this.id}] = HuberRegressor(**ctor_HuberRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeHuberRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike\n\n    /**\n      Target vector relative to X.\n     */\n    y?: ArrayLike\n\n    /**\n      Weight given to each sample.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HuberRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HuberRegressor_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_HuberRegressor_fit = {k: v for k, v in pms_HuberRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_fit = bridgeHuberRegressor[${this.id}].fit(**pms_HuberRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_fit.tolist() if hasattr(res_HuberRegressor_fit, 'tolist') else res_HuberRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_HuberRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_HuberRegressor_get_metadata_routing = {k: v for k, v in pms_HuberRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_get_metadata_routing = bridgeHuberRegressor[${this.id}].get_metadata_routing(**pms_HuberRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_get_metadata_routing.tolist() if hasattr(res_HuberRegressor_get_metadata_routing, 'tolist') else res_HuberRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HuberRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HuberRegressor_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_HuberRegressor_predict = {k: v for k, v in pms_HuberRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_predict = bridgeHuberRegressor[${this.id}].predict(**pms_HuberRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_predict.tolist() if hasattr(res_HuberRegressor_predict, 'tolist') else res_HuberRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HuberRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_HuberRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_HuberRegressor_score = {k: v for k, v in pms_HuberRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_score = bridgeHuberRegressor[${this.id}].score(**pms_HuberRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_score.tolist() if hasattr(res_HuberRegressor_score, 'tolist') else res_HuberRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_HuberRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_HuberRegressor_set_fit_request = {k: v for k, v in pms_HuberRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_set_fit_request = bridgeHuberRegressor[${this.id}].set_fit_request(**pms_HuberRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_set_fit_request.tolist() if hasattr(res_HuberRegressor_set_fit_request, 'tolist') else res_HuberRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_HuberRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_HuberRegressor_set_score_request = {k: v for k, v in pms_HuberRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_HuberRegressor_set_score_request = bridgeHuberRegressor[${this.id}].set_score_request(**pms_HuberRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_HuberRegressor_set_score_request.tolist() if hasattr(res_HuberRegressor_set_score_request, 'tolist') else res_HuberRegressor_set_score_request`\n  }\n\n  /**\n    Features got by optimizing the L2-regularized Huber loss.\n   */\n  get coef_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HuberRegressor must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_coef_ = bridgeHuberRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_coef_.tolist() if hasattr(attr_HuberRegressor_coef_, 'tolist') else attr_HuberRegressor_coef_`\n    })()\n  }\n\n  /**\n    Bias.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_intercept_ = bridgeHuberRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_intercept_.tolist() if hasattr(attr_HuberRegressor_intercept_, 'tolist') else attr_HuberRegressor_intercept_`\n    })()\n  }\n\n  /**\n    The value by which `|y \\- Xw \\- c|` is scaled down.\n   */\n  get scale_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('HuberRegressor must call init() before accessing scale_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_scale_ = bridgeHuberRegressor[${this.id}].scale_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_scale_.tolist() if hasattr(attr_HuberRegressor_scale_, 'tolist') else attr_HuberRegressor_scale_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_n_features_in_ = bridgeHuberRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_n_features_in_.tolist() if hasattr(attr_HuberRegressor_n_features_in_, 'tolist') else attr_HuberRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_feature_names_in_ = bridgeHuberRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_feature_names_in_.tolist() if hasattr(attr_HuberRegressor_feature_names_in_, 'tolist') else attr_HuberRegressor_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations that `scipy.optimize.minimize(method=\"L-BFGS-B\")` has run for.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_n_iter_ = bridgeHuberRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_n_iter_.tolist() if hasattr(attr_HuberRegressor_n_iter_, 'tolist') else attr_HuberRegressor_n_iter_`\n    })()\n  }\n\n  /**\n    A boolean mask which is set to `true` where the samples are identified as outliers.\n   */\n  get outliers_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This HuberRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'HuberRegressor must call init() before accessing outliers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_HuberRegressor_outliers_ = bridgeHuberRegressor[${this.id}].outliers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_HuberRegressor_outliers_.tolist() if hasattr(attr_HuberRegressor_outliers_, 'tolist') else attr_HuberRegressor_outliers_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Least Angle Regression model a.k.a. LAR.\n\n  Read more in the [User Guide](../linear_model.html#least-angle-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lars.html)\n */\nexport class Lars {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: boolean | 'auto' | ArrayLike\n\n    /**\n      Target number of non-zero coefficients. Use `np.inf` for no limit.\n\n      @defaultValue `500`\n     */\n    n_nonzero_coefs?: number\n\n    /**\n      The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems. Unlike the `tol` parameter in some iterative optimization-based algorithms, this parameter does not control the tolerance of the optimization.\n     */\n    eps?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      If `true` the full path is stored in the `coef\\_path\\_` attribute. If you compute the solution for a large problem or many targets, setting `fit\\_path` to `false` will lead to a speedup, especially with a small alpha.\n\n      @defaultValue `true`\n     */\n    fit_path?: boolean\n\n    /**\n      Upper bound on a uniform noise parameter to be added to the `y` values, to satisfy the model’s assumption of one-at-a-time computations. Might help with stability.\n     */\n    jitter?: number\n\n    /**\n      Determines random number generation for jittering. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state). Ignored if `jitter` is `undefined`.\n     */\n    random_state?: number\n  }) {\n    this.id = `Lars${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Lars.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import Lars\ntry: bridgeLars\nexcept NameError: bridgeLars = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Lars = {'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'normalize': ${\n      this.opts['normalize'] ?? undefined\n    }, 'precompute': ${\n      this.opts['precompute'] ?? undefined\n    }, 'n_nonzero_coefs': ${\n      this.opts['n_nonzero_coefs'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'fit_path': ${this.opts['fit_path'] ?? undefined}, 'jitter': ${\n      this.opts['jitter'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_Lars = {k: v for k, v in ctor_Lars.items() if v is not None}`\n\n    await this._py.ex`bridgeLars[${this.id}] = Lars(**ctor_Lars)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLars[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None}\n\npms_Lars_fit = {k: v for k, v in pms_Lars_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_Lars_fit = bridgeLars[${this.id}].fit(**pms_Lars_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_fit.tolist() if hasattr(res_Lars_fit, 'tolist') else res_Lars_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Lars_get_metadata_routing = {k: v for k, v in pms_Lars_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lars_get_metadata_routing = bridgeLars[${this.id}].get_metadata_routing(**pms_Lars_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_get_metadata_routing.tolist() if hasattr(res_Lars_get_metadata_routing, 'tolist') else res_Lars_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_Lars_predict = {k: v for k, v in pms_Lars_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lars_predict = bridgeLars[${this.id}].predict(**pms_Lars_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_predict.tolist() if hasattr(res_Lars_predict, 'tolist') else res_Lars_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_Lars_score = {k: v for k, v in pms_Lars_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lars_score = bridgeLars[${this.id}].score(**pms_Lars_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_score.tolist() if hasattr(res_Lars_score, 'tolist') else res_Lars_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `Xy` parameter in `fit`.\n     */\n    Xy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_set_fit_request = {'Xy': ${\n      opts['Xy'] ?? undefined\n    }}\n\npms_Lars_set_fit_request = {k: v for k, v in pms_Lars_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lars_set_fit_request = bridgeLars[${this.id}].set_fit_request(**pms_Lars_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_set_fit_request.tolist() if hasattr(res_Lars_set_fit_request, 'tolist') else res_Lars_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lars_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Lars_set_score_request = {k: v for k, v in pms_Lars_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lars_set_score_request = bridgeLars[${this.id}].set_score_request(**pms_Lars_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lars_set_score_request.tolist() if hasattr(res_Lars_set_score_request, 'tolist') else res_Lars_set_score_request`\n  }\n\n  /**\n    Maximum of covariances (in absolute value) at each iteration. `n\\_alphas` is either `max\\_iter`, `n\\_features` or the number of nodes in the path with `alpha >= alpha\\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\\_targets`.\n   */\n  get alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lars_alphas_ = bridgeLars[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_alphas_.tolist() if hasattr(attr_Lars_alphas_, 'tolist') else attr_Lars_alphas_`\n    })()\n  }\n\n  /**\n    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\\_targets`.\n   */\n  get active_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing active_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lars_active_ = bridgeLars[${this.id}].active_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_active_.tolist() if hasattr(attr_Lars_active_, 'tolist') else attr_Lars_active_`\n    })()\n  }\n\n  /**\n    The varying values of the coefficients along the path. It is not present if the `fit\\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\\_targets`.\n   */\n  get coef_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing coef_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lars_coef_path_ = bridgeLars[${this.id}].coef_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_coef_path_.tolist() if hasattr(attr_Lars_coef_path_, 'tolist') else attr_Lars_coef_path_`\n    })()\n  }\n\n  /**\n    Parameter vector (w in the formulation formula).\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lars_coef_ = bridgeLars[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_coef_.tolist() if hasattr(attr_Lars_coef_, 'tolist') else attr_Lars_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lars_intercept_ = bridgeLars[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_intercept_.tolist() if hasattr(attr_Lars_intercept_, 'tolist') else attr_Lars_intercept_`\n    })()\n  }\n\n  /**\n    The number of iterations taken by lars\\_path to find the grid of alphas for each target.\n   */\n  get n_iter_(): Promise<ArrayLike | number> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lars_n_iter_ = bridgeLars[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_n_iter_.tolist() if hasattr(attr_Lars_n_iter_, 'tolist') else attr_Lars_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lars must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lars_n_features_in_ = bridgeLars[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_n_features_in_.tolist() if hasattr(attr_Lars_n_features_in_, 'tolist') else attr_Lars_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Lars must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lars_feature_names_in_ = bridgeLars[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lars_feature_names_in_.tolist() if hasattr(attr_Lars_feature_names_in_, 'tolist') else attr_Lars_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Cross-validated Least Angle Regression model.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  Read more in the [User Guide](../linear_model.html#least-angle-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LarsCV.html)\n */\nexport class LarsCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Maximum number of iterations to perform.\n\n      @defaultValue `500`\n     */\n    max_iter?: number\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix cannot be passed as argument since we will use only subsets of X.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: boolean | 'auto' | ArrayLike\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      The maximum number of points on the path used to compute the residuals in the cross-validation.\n\n      @defaultValue `1000`\n     */\n    max_n_alphas?: number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems. Unlike the `tol` parameter in some iterative optimization-based algorithms, this parameter does not control the tolerance of the optimization.\n     */\n    eps?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n  }) {\n    this.id = `LarsCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LarsCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LarsCV\ntry: bridgeLarsCV\nexcept NameError: bridgeLarsCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LarsCV = {'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'normalize': ${this.opts['normalize'] ?? undefined}, 'precompute': ${\n      this.opts['precompute'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'max_n_alphas': ${\n      this.opts['max_n_alphas'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}}\n\nctor_LarsCV = {k: v for k, v in ctor_LarsCV.items() if v is not None}`\n\n    await this._py.ex`bridgeLarsCV[${this.id}] = LarsCV(**ctor_LarsCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLarsCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LarsCV_fit = {k: v for k, v in pms_LarsCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_fit = bridgeLarsCV[${this.id}].fit(**pms_LarsCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_fit.tolist() if hasattr(res_LarsCV_fit, 'tolist') else res_LarsCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LarsCV_get_metadata_routing = {k: v for k, v in pms_LarsCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_get_metadata_routing = bridgeLarsCV[${this.id}].get_metadata_routing(**pms_LarsCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_get_metadata_routing.tolist() if hasattr(res_LarsCV_get_metadata_routing, 'tolist') else res_LarsCV_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LarsCV_predict = {k: v for k, v in pms_LarsCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_predict = bridgeLarsCV[${this.id}].predict(**pms_LarsCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_predict.tolist() if hasattr(res_LarsCV_predict, 'tolist') else res_LarsCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LarsCV_score = {k: v for k, v in pms_LarsCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_score = bridgeLarsCV[${this.id}].score(**pms_LarsCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_score.tolist() if hasattr(res_LarsCV_score, 'tolist') else res_LarsCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `Xy` parameter in `fit`.\n     */\n    Xy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_set_fit_request = {'Xy': ${\n      opts['Xy'] ?? undefined\n    }}\n\npms_LarsCV_set_fit_request = {k: v for k, v in pms_LarsCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_set_fit_request = bridgeLarsCV[${this.id}].set_fit_request(**pms_LarsCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_set_fit_request.tolist() if hasattr(res_LarsCV_set_fit_request, 'tolist') else res_LarsCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LarsCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LarsCV_set_score_request = {k: v for k, v in pms_LarsCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LarsCV_set_score_request = bridgeLarsCV[${this.id}].set_score_request(**pms_LarsCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LarsCV_set_score_request.tolist() if hasattr(res_LarsCV_set_score_request, 'tolist') else res_LarsCV_set_score_request`\n  }\n\n  /**\n    Indices of active variables at the end of the path. If this is a list of lists, the outer list length is `n\\_targets`.\n   */\n  get active_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing active_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LarsCV_active_ = bridgeLarsCV[${this.id}].active_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_active_.tolist() if hasattr(attr_LarsCV_active_, 'tolist') else attr_LarsCV_active_`\n    })()\n  }\n\n  /**\n    parameter vector (w in the formulation formula)\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LarsCV_coef_ = bridgeLarsCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_coef_.tolist() if hasattr(attr_LarsCV_coef_, 'tolist') else attr_LarsCV_coef_`\n    })()\n  }\n\n  /**\n    independent term in decision function\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_intercept_ = bridgeLarsCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_intercept_.tolist() if hasattr(attr_LarsCV_intercept_, 'tolist') else attr_LarsCV_intercept_`\n    })()\n  }\n\n  /**\n    the varying values of the coefficients along the path\n   */\n  get coef_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing coef_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_coef_path_ = bridgeLarsCV[${this.id}].coef_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_coef_path_.tolist() if hasattr(attr_LarsCV_coef_path_, 'tolist') else attr_LarsCV_coef_path_`\n    })()\n  }\n\n  /**\n    the estimated regularization parameter alpha\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LarsCV_alpha_ = bridgeLarsCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_alpha_.tolist() if hasattr(attr_LarsCV_alpha_, 'tolist') else attr_LarsCV_alpha_`\n    })()\n  }\n\n  /**\n    the different values of alpha along the path\n   */\n  get alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LarsCV_alphas_ = bridgeLarsCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_alphas_.tolist() if hasattr(attr_LarsCV_alphas_, 'tolist') else attr_LarsCV_alphas_`\n    })()\n  }\n\n  /**\n    all the values of alpha along the path for the different folds\n   */\n  get cv_alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing cv_alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_cv_alphas_ = bridgeLarsCV[${this.id}].cv_alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_cv_alphas_.tolist() if hasattr(attr_LarsCV_cv_alphas_, 'tolist') else attr_LarsCV_cv_alphas_`\n    })()\n  }\n\n  /**\n    the mean square error on left-out for each fold along the path (alpha values given by `cv\\_alphas`)\n   */\n  get mse_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing mse_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_mse_path_ = bridgeLarsCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_mse_path_.tolist() if hasattr(attr_LarsCV_mse_path_, 'tolist') else attr_LarsCV_mse_path_`\n    })()\n  }\n\n  /**\n    the number of iterations run by Lars with the optimal alpha.\n   */\n  get n_iter_(): Promise<ArrayLike | number> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LarsCV_n_iter_ = bridgeLarsCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_n_iter_.tolist() if hasattr(attr_LarsCV_n_iter_, 'tolist') else attr_LarsCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LarsCV must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_n_features_in_ = bridgeLarsCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_n_features_in_.tolist() if hasattr(attr_LarsCV_n_features_in_, 'tolist') else attr_LarsCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LarsCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LarsCV_feature_names_in_ = bridgeLarsCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LarsCV_feature_names_in_.tolist() if hasattr(attr_LarsCV_feature_names_in_, 'tolist') else attr_LarsCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear Model trained with L1 prior as regularizer (aka the Lasso).\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html)\n */\nexport class Lasso {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L1 term, controlling regularization strength. `alpha` must be a non-negative float i.e. in `\\[0, inf)`.\n\n      When `alpha \\= 0`, the objective is equivalent to ordinary least squares, solved by the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object. For numerical reasons, using `alpha \\= 0` with the `Lasso` object is not advised. Instead, you should use the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to `false`, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always `false` to preserve sparsity.\n\n      @defaultValue `false`\n     */\n    precompute?: boolean | ArrayLike[]\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`, see Notes below.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      When set to `true`, forces the coefficients to be positive.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `Lasso${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Lasso.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import Lasso\ntry: bridgeLasso\nexcept NameError: bridgeLasso = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Lasso = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'precompute': np.array(${this.opts['precompute'] ?? undefined}) if ${\n      this.opts['precompute'] !== undefined\n    } else None, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_Lasso = {k: v for k, v in ctor_Lasso.items() if v is not None}`\n\n    await this._py.ex`bridgeLasso[${this.id}] = Lasso(**ctor_Lasso)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLasso[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit model with coordinate descent.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: any\n\n    /**\n      Target. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray\n\n    /**\n      Sample weights. Internally, the `sample\\_weight` vector will be rescaled to sum to `n\\_samples`.\n     */\n    sample_weight?: number | ArrayLike\n\n    /**\n      Allow to bypass several input checking. Don’t use this parameter unless you know what you do.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }}\n\npms_Lasso_fit = {k: v for k, v in pms_Lasso_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_fit = bridgeLasso[${this.id}].fit(**pms_Lasso_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_fit.tolist() if hasattr(res_Lasso_fit, 'tolist') else res_Lasso_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Lasso_get_metadata_routing = {k: v for k, v in pms_Lasso_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_get_metadata_routing = bridgeLasso[${this.id}].get_metadata_routing(**pms_Lasso_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_get_metadata_routing.tolist() if hasattr(res_Lasso_get_metadata_routing, 'tolist') else res_Lasso_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_Lasso_path = {k: v for k, v in pms_Lasso_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_path = bridgeLasso[${this.id}].path(**pms_Lasso_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_path.tolist() if hasattr(res_Lasso_path, 'tolist') else res_Lasso_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_Lasso_predict = {k: v for k, v in pms_Lasso_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_predict = bridgeLasso[${this.id}].predict(**pms_Lasso_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_predict.tolist() if hasattr(res_Lasso_predict, 'tolist') else res_Lasso_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_Lasso_score = {k: v for k, v in pms_Lasso_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_score = bridgeLasso[${this.id}].score(**pms_Lasso_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_score.tolist() if hasattr(res_Lasso_score, 'tolist') else res_Lasso_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `check\\_input` parameter in `fit`.\n     */\n    check_input?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_set_fit_request = {'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_Lasso_set_fit_request = {k: v for k, v in pms_Lasso_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_set_fit_request = bridgeLasso[${this.id}].set_fit_request(**pms_Lasso_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_set_fit_request.tolist() if hasattr(res_Lasso_set_fit_request, 'tolist') else res_Lasso_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Lasso_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Lasso_set_score_request = {k: v for k, v in pms_Lasso_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Lasso_set_score_request = bridgeLasso[${this.id}].set_score_request(**pms_Lasso_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Lasso_set_score_request.tolist() if hasattr(res_Lasso_set_score_request, 'tolist') else res_Lasso_set_score_request`\n  }\n\n  /**\n    Parameter vector (w in the cost function formula).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lasso_coef_ = bridgeLasso[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_coef_.tolist() if hasattr(attr_Lasso_coef_, 'tolist') else attr_Lasso_coef_`\n    })()\n  }\n\n  /**\n    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.\n   */\n  get dual_gap_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before accessing dual_gap_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lasso_dual_gap_ = bridgeLasso[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_dual_gap_.tolist() if hasattr(attr_Lasso_dual_gap_, 'tolist') else attr_Lasso_dual_gap_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lasso_intercept_ = bridgeLasso[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_intercept_.tolist() if hasattr(attr_Lasso_intercept_, 'tolist') else attr_Lasso_intercept_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Lasso_n_iter_ = bridgeLasso[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_n_iter_.tolist() if hasattr(attr_Lasso_n_iter_, 'tolist') else attr_Lasso_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Lasso must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lasso_n_features_in_ = bridgeLasso[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_n_features_in_.tolist() if hasattr(attr_Lasso_n_features_in_, 'tolist') else attr_Lasso_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Lasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Lasso must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Lasso_feature_names_in_ = bridgeLasso[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Lasso_feature_names_in_.tolist() if hasattr(attr_Lasso_feature_names_in_, 'tolist') else attr_Lasso_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Lasso linear model with iterative fitting along a regularization path.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  The best model is selected by cross-validation.\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LassoCV.html)\n */\nexport class LassoCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      If positive, restrict regression coefficients to be positive.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `LassoCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LassoCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LassoCV\ntry: bridgeLassoCV\nexcept NameError: bridgeLassoCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LassoCV = {'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'n_alphas': ${this.opts['n_alphas'] ?? undefined}, 'alphas': ${\n      this.opts['alphas'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'precompute': np.array(${this.opts['precompute'] ?? undefined}) if ${\n      this.opts['precompute'] !== undefined\n    } else None, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_LassoCV = {k: v for k, v in ctor_LassoCV.items() if v is not None}`\n\n    await this._py.ex`bridgeLassoCV[${this.id}] = LassoCV(**ctor_LassoCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLassoCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit linear model with coordinate descent.\n\n    Fit is on grid of alphas and best alpha estimated by cross-validation.\n   */\n  async fit(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If y is mono-output, X can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights used for fitting and evaluation of the weighted mean squared error of each cv-fold. Note that the cross validated MSE that is finally used to find the best model is the unweighted mean over the (weighted) MSEs of each test fold.\n     */\n    sample_weight?: number | ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LassoCV_fit = {k: v for k, v in pms_LassoCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_fit = bridgeLassoCV[${this.id}].fit(**pms_LassoCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_fit.tolist() if hasattr(res_LassoCV_fit, 'tolist') else res_LassoCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LassoCV_get_metadata_routing = {k: v for k, v in pms_LassoCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_get_metadata_routing = bridgeLassoCV[${this.id}].get_metadata_routing(**pms_LassoCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_get_metadata_routing.tolist() if hasattr(res_LassoCV_get_metadata_routing, 'tolist') else res_LassoCV_get_metadata_routing`\n  }\n\n  /**\n    Compute Lasso path with coordinate descent.\n\n    The Lasso optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'eps': ${\n      opts['eps'] ?? undefined\n    }, 'n_alphas': ${opts['n_alphas'] ?? undefined}, 'alphas': np.array(${\n      opts['alphas'] ?? undefined\n    }) if ${opts['alphas'] !== undefined} else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'params': ${\n      opts['params'] ?? undefined\n    }}\n\npms_LassoCV_path = {k: v for k, v in pms_LassoCV_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_path = bridgeLassoCV[${this.id}].path(**pms_LassoCV_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_path.tolist() if hasattr(res_LassoCV_path, 'tolist') else res_LassoCV_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LassoCV_predict = {k: v for k, v in pms_LassoCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_predict = bridgeLassoCV[${this.id}].predict(**pms_LassoCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_predict.tolist() if hasattr(res_LassoCV_predict, 'tolist') else res_LassoCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LassoCV_score = {k: v for k, v in pms_LassoCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_score = bridgeLassoCV[${this.id}].score(**pms_LassoCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_score.tolist() if hasattr(res_LassoCV_score, 'tolist') else res_LassoCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LassoCV_set_fit_request = {k: v for k, v in pms_LassoCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_set_fit_request = bridgeLassoCV[${this.id}].set_fit_request(**pms_LassoCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_set_fit_request.tolist() if hasattr(res_LassoCV_set_fit_request, 'tolist') else res_LassoCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LassoCV_set_score_request = {k: v for k, v in pms_LassoCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoCV_set_score_request = bridgeLassoCV[${this.id}].set_score_request(**pms_LassoCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoCV_set_score_request.tolist() if hasattr(res_LassoCV_set_score_request, 'tolist') else res_LassoCV_set_score_request`\n  }\n\n  /**\n    The amount of penalization chosen by cross validation.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LassoCV_alpha_ = bridgeLassoCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_alpha_.tolist() if hasattr(attr_LassoCV_alpha_, 'tolist') else attr_LassoCV_alpha_`\n    })()\n  }\n\n  /**\n    Parameter vector (w in the cost function formula).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_LassoCV_coef_ = bridgeLassoCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_coef_.tolist() if hasattr(attr_LassoCV_coef_, 'tolist') else attr_LassoCV_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_intercept_ = bridgeLassoCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_intercept_.tolist() if hasattr(attr_LassoCV_intercept_, 'tolist') else attr_LassoCV_intercept_`\n    })()\n  }\n\n  /**\n    Mean square error for the test set on each fold, varying alpha.\n   */\n  get mse_path_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing mse_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_mse_path_ = bridgeLassoCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_mse_path_.tolist() if hasattr(attr_LassoCV_mse_path_, 'tolist') else attr_LassoCV_mse_path_`\n    })()\n  }\n\n  /**\n    The grid of alphas used for fitting.\n   */\n  get alphas_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_alphas_ = bridgeLassoCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_alphas_.tolist() if hasattr(attr_LassoCV_alphas_, 'tolist') else attr_LassoCV_alphas_`\n    })()\n  }\n\n  /**\n    The dual gap at the end of the optimization for the optimal alpha (`alpha\\_`).\n   */\n  get dual_gap_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing dual_gap_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_dual_gap_ = bridgeLassoCV[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_dual_gap_.tolist() if hasattr(attr_LassoCV_dual_gap_, 'tolist') else attr_LassoCV_dual_gap_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoCV must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_n_iter_ = bridgeLassoCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_n_iter_.tolist() if hasattr(attr_LassoCV_n_iter_, 'tolist') else attr_LassoCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_n_features_in_ = bridgeLassoCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_n_features_in_.tolist() if hasattr(attr_LassoCV_n_features_in_, 'tolist') else attr_LassoCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoCV_feature_names_in_ = bridgeLassoCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoCV_feature_names_in_.tolist() if hasattr(attr_LassoCV_feature_names_in_, 'tolist') else attr_LassoCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Lasso model fit with Least Angle Regression a.k.a. Lars.\n\n  It is a Linear Model trained with an L1 prior as regularizer.\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LassoLars.html)\n */\nexport class LassoLars {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the penalty term. Defaults to 1.0. `alpha \\= 0` is equivalent to an ordinary least square, solved by [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\"). For numerical reasons, using `alpha \\= 0` with the LassoLars object is not advised and you should prefer the LinearRegression object.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: boolean | 'auto' | ArrayLike\n\n    /**\n      Maximum number of iterations to perform.\n\n      @defaultValue `500`\n     */\n    max_iter?: number\n\n    /**\n      The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems. Unlike the `tol` parameter in some iterative optimization-based algorithms, this parameter does not control the tolerance of the optimization.\n     */\n    eps?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      If `true` the full path is stored in the `coef\\_path\\_` attribute. If you compute the solution for a large problem or many targets, setting `fit\\_path` to `false` will lead to a speedup, especially with a small alpha.\n\n      @defaultValue `true`\n     */\n    fit_path?: boolean\n\n    /**\n      Restrict coefficients to be >= 0. Be aware that you might want to remove fit\\_intercept which is set `true` by default. Under the positive restriction the model coefficients will not converge to the ordinary-least-squares solution for small values of alpha. Only coefficients up to the smallest alpha value (`alphas\\_\\[alphas\\_ > 0.\\].min()` when fit\\_path=`true`) reached by the stepwise Lars-Lasso algorithm are typically in congruence with the solution of the coordinate descent Lasso estimator.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      Upper bound on a uniform noise parameter to be added to the `y` values, to satisfy the model’s assumption of one-at-a-time computations. Might help with stability.\n     */\n    jitter?: number\n\n    /**\n      Determines random number generation for jittering. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state). Ignored if `jitter` is `undefined`.\n     */\n    random_state?: number\n  }) {\n    this.id = `LassoLars${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LassoLars.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LassoLars\ntry: bridgeLassoLars\nexcept NameError: bridgeLassoLars = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LassoLars = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'normalize': ${\n      this.opts['normalize'] ?? undefined\n    }, 'precompute': ${this.opts['precompute'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'fit_path': ${this.opts['fit_path'] ?? undefined}, 'positive': ${\n      this.opts['positive'] ?? undefined\n    }, 'jitter': ${this.opts['jitter'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_LassoLars = {k: v for k, v in ctor_LassoLars.items() if v is not None}`\n\n    await this._py.ex`bridgeLassoLars[${this.id}] = LassoLars(**ctor_LassoLars)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLassoLars[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None}\n\npms_LassoLars_fit = {k: v for k, v in pms_LassoLars_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_fit = bridgeLassoLars[${this.id}].fit(**pms_LassoLars_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_fit.tolist() if hasattr(res_LassoLars_fit, 'tolist') else res_LassoLars_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLars must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LassoLars_get_metadata_routing = {k: v for k, v in pms_LassoLars_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_get_metadata_routing = bridgeLassoLars[${this.id}].get_metadata_routing(**pms_LassoLars_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_get_metadata_routing.tolist() if hasattr(res_LassoLars_get_metadata_routing, 'tolist') else res_LassoLars_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LassoLars_predict = {k: v for k, v in pms_LassoLars_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_predict = bridgeLassoLars[${this.id}].predict(**pms_LassoLars_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_predict.tolist() if hasattr(res_LassoLars_predict, 'tolist') else res_LassoLars_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LassoLars_score = {k: v for k, v in pms_LassoLars_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_score = bridgeLassoLars[${this.id}].score(**pms_LassoLars_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_score.tolist() if hasattr(res_LassoLars_score, 'tolist') else res_LassoLars_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `Xy` parameter in `fit`.\n     */\n    Xy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_set_fit_request = {'Xy': ${\n      opts['Xy'] ?? undefined\n    }}\n\npms_LassoLars_set_fit_request = {k: v for k, v in pms_LassoLars_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_set_fit_request = bridgeLassoLars[${this.id}].set_fit_request(**pms_LassoLars_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_set_fit_request.tolist() if hasattr(res_LassoLars_set_fit_request, 'tolist') else res_LassoLars_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLars_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LassoLars_set_score_request = {k: v for k, v in pms_LassoLars_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLars_set_score_request = bridgeLassoLars[${this.id}].set_score_request(**pms_LassoLars_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLars_set_score_request.tolist() if hasattr(res_LassoLars_set_score_request, 'tolist') else res_LassoLars_set_score_request`\n  }\n\n  /**\n    Maximum of covariances (in absolute value) at each iteration. `n\\_alphas` is either `max\\_iter`, `n\\_features` or the number of nodes in the path with `alpha >= alpha\\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\\_targets`.\n   */\n  get alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_alphas_ = bridgeLassoLars[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_alphas_.tolist() if hasattr(attr_LassoLars_alphas_, 'tolist') else attr_LassoLars_alphas_`\n    })()\n  }\n\n  /**\n    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\\_targets`.\n   */\n  get active_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing active_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_active_ = bridgeLassoLars[${this.id}].active_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_active_.tolist() if hasattr(attr_LassoLars_active_, 'tolist') else attr_LassoLars_active_`\n    })()\n  }\n\n  /**\n    If a list is passed it’s expected to be one of n\\_targets such arrays. The varying values of the coefficients along the path. It is not present if the `fit\\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\\_targets`.\n   */\n  get coef_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing coef_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_coef_path_ = bridgeLassoLars[${this.id}].coef_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_coef_path_.tolist() if hasattr(attr_LassoLars_coef_path_, 'tolist') else attr_LassoLars_coef_path_`\n    })()\n  }\n\n  /**\n    Parameter vector (w in the formulation formula).\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_coef_ = bridgeLassoLars[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_coef_.tolist() if hasattr(attr_LassoLars_coef_, 'tolist') else attr_LassoLars_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_intercept_ = bridgeLassoLars[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_intercept_.tolist() if hasattr(attr_LassoLars_intercept_, 'tolist') else attr_LassoLars_intercept_`\n    })()\n  }\n\n  /**\n    The number of iterations taken by lars\\_path to find the grid of alphas for each target.\n   */\n  get n_iter_(): Promise<ArrayLike | number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLars must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_n_iter_ = bridgeLassoLars[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_n_iter_.tolist() if hasattr(attr_LassoLars_n_iter_, 'tolist') else attr_LassoLars_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLars must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_n_features_in_ = bridgeLassoLars[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_n_features_in_.tolist() if hasattr(attr_LassoLars_n_features_in_, 'tolist') else attr_LassoLars_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLars instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLars must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLars_feature_names_in_ = bridgeLassoLars[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLars_feature_names_in_.tolist() if hasattr(attr_LassoLars_feature_names_in_, 'tolist') else attr_LassoLars_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Cross-validated Lasso, using the LARS algorithm.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LassoLarsCV.html)\n */\nexport class LassoLarsCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Maximum number of iterations to perform.\n\n      @defaultValue `500`\n     */\n    max_iter?: number\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix cannot be passed as argument since we will use only subsets of X.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: boolean | 'auto'\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      The maximum number of points on the path used to compute the residuals in the cross-validation.\n\n      @defaultValue `1000`\n     */\n    max_n_alphas?: number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems. Unlike the `tol` parameter in some iterative optimization-based algorithms, this parameter does not control the tolerance of the optimization.\n     */\n    eps?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Restrict coefficients to be >= 0. Be aware that you might want to remove fit\\_intercept which is set `true` by default. Under the positive restriction the model coefficients do not converge to the ordinary-least-squares solution for small values of alpha. Only coefficients up to the smallest alpha value (`alphas\\_\\[alphas\\_ > 0.\\].min()` when fit\\_path=`true`) reached by the stepwise Lars-Lasso algorithm are typically in congruence with the solution of the coordinate descent Lasso estimator. As a consequence using LassoLarsCV only makes sense for problems where a sparse solution is expected and/or reached.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n  }) {\n    this.id = `LassoLarsCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LassoLarsCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LassoLarsCV\ntry: bridgeLassoLarsCV\nexcept NameError: bridgeLassoLarsCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LassoLarsCV = {'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'normalize': ${this.opts['normalize'] ?? undefined}, 'precompute': ${\n      this.opts['precompute'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'max_n_alphas': ${\n      this.opts['max_n_alphas'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'positive': ${\n      this.opts['positive'] ?? undefined\n    }}\n\nctor_LassoLarsCV = {k: v for k, v in ctor_LassoLarsCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLassoLarsCV[${this.id}] = LassoLarsCV(**ctor_LassoLarsCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLassoLarsCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LassoLarsCV_fit = {k: v for k, v in pms_LassoLarsCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_fit = bridgeLassoLarsCV[${this.id}].fit(**pms_LassoLarsCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_fit.tolist() if hasattr(res_LassoLarsCV_fit, 'tolist') else res_LassoLarsCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LassoLarsCV_get_metadata_routing = {k: v for k, v in pms_LassoLarsCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_get_metadata_routing = bridgeLassoLarsCV[${this.id}].get_metadata_routing(**pms_LassoLarsCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_get_metadata_routing.tolist() if hasattr(res_LassoLarsCV_get_metadata_routing, 'tolist') else res_LassoLarsCV_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LassoLarsCV_predict = {k: v for k, v in pms_LassoLarsCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_predict = bridgeLassoLarsCV[${this.id}].predict(**pms_LassoLarsCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_predict.tolist() if hasattr(res_LassoLarsCV_predict, 'tolist') else res_LassoLarsCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LassoLarsCV_score = {k: v for k, v in pms_LassoLarsCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_score = bridgeLassoLarsCV[${this.id}].score(**pms_LassoLarsCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_score.tolist() if hasattr(res_LassoLarsCV_score, 'tolist') else res_LassoLarsCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `Xy` parameter in `fit`.\n     */\n    Xy?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_set_fit_request = {'Xy': ${\n      opts['Xy'] ?? undefined\n    }}\n\npms_LassoLarsCV_set_fit_request = {k: v for k, v in pms_LassoLarsCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_set_fit_request = bridgeLassoLarsCV[${this.id}].set_fit_request(**pms_LassoLarsCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_set_fit_request.tolist() if hasattr(res_LassoLarsCV_set_fit_request, 'tolist') else res_LassoLarsCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LassoLarsCV_set_score_request = {k: v for k, v in pms_LassoLarsCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsCV_set_score_request = bridgeLassoLarsCV[${this.id}].set_score_request(**pms_LassoLarsCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsCV_set_score_request.tolist() if hasattr(res_LassoLarsCV_set_score_request, 'tolist') else res_LassoLarsCV_set_score_request`\n  }\n\n  /**\n    parameter vector (w in the formulation formula)\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_coef_ = bridgeLassoLarsCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_coef_.tolist() if hasattr(attr_LassoLarsCV_coef_, 'tolist') else attr_LassoLarsCV_coef_`\n    })()\n  }\n\n  /**\n    independent term in decision function.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_intercept_ = bridgeLassoLarsCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_intercept_.tolist() if hasattr(attr_LassoLarsCV_intercept_, 'tolist') else attr_LassoLarsCV_intercept_`\n    })()\n  }\n\n  /**\n    the varying values of the coefficients along the path\n   */\n  get coef_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before accessing coef_path_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_coef_path_ = bridgeLassoLarsCV[${this.id}].coef_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_coef_path_.tolist() if hasattr(attr_LassoLarsCV_coef_path_, 'tolist') else attr_LassoLarsCV_coef_path_`\n    })()\n  }\n\n  /**\n    the estimated regularization parameter alpha\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_alpha_ = bridgeLassoLarsCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_alpha_.tolist() if hasattr(attr_LassoLarsCV_alpha_, 'tolist') else attr_LassoLarsCV_alpha_`\n    })()\n  }\n\n  /**\n    the different values of alpha along the path\n   */\n  get alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_alphas_ = bridgeLassoLarsCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_alphas_.tolist() if hasattr(attr_LassoLarsCV_alphas_, 'tolist') else attr_LassoLarsCV_alphas_`\n    })()\n  }\n\n  /**\n    all the values of alpha along the path for the different folds\n   */\n  get cv_alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before accessing cv_alphas_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_cv_alphas_ = bridgeLassoLarsCV[${this.id}].cv_alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_cv_alphas_.tolist() if hasattr(attr_LassoLarsCV_cv_alphas_, 'tolist') else attr_LassoLarsCV_cv_alphas_`\n    })()\n  }\n\n  /**\n    the mean square error on left-out for each fold along the path (alpha values given by `cv\\_alphas`)\n   */\n  get mse_path_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing mse_path_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_mse_path_ = bridgeLassoLarsCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_mse_path_.tolist() if hasattr(attr_LassoLarsCV_mse_path_, 'tolist') else attr_LassoLarsCV_mse_path_`\n    })()\n  }\n\n  /**\n    the number of iterations run by Lars with the optimal alpha.\n   */\n  get n_iter_(): Promise<ArrayLike | number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_n_iter_ = bridgeLassoLarsCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_n_iter_.tolist() if hasattr(attr_LassoLarsCV_n_iter_, 'tolist') else attr_LassoLarsCV_n_iter_`\n    })()\n  }\n\n  /**\n    Indices of active variables at the end of the path.\n   */\n  get active_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsCV must call init() before accessing active_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_active_ = bridgeLassoLarsCV[${this.id}].active_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_active_.tolist() if hasattr(attr_LassoLarsCV_active_, 'tolist') else attr_LassoLarsCV_active_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_n_features_in_ = bridgeLassoLarsCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_n_features_in_.tolist() if hasattr(attr_LassoLarsCV_n_features_in_, 'tolist') else attr_LassoLarsCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsCV_feature_names_in_ = bridgeLassoLarsCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsCV_feature_names_in_.tolist() if hasattr(attr_LassoLarsCV_feature_names_in_, 'tolist') else attr_LassoLarsCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Lasso model fit with Lars using BIC or AIC for model selection.\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LassoLarsIC.html)\n */\nexport class LassoLarsIC {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The type of criterion to use.\n\n      @defaultValue `'aic'`\n     */\n    criterion?: 'aic' | 'bic'\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: boolean | 'auto' | ArrayLike\n\n    /**\n      Maximum number of iterations to perform. Can be used for early stopping.\n\n      @defaultValue `500`\n     */\n    max_iter?: number\n\n    /**\n      The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems. Unlike the `tol` parameter in some iterative optimization-based algorithms, this parameter does not control the tolerance of the optimization.\n     */\n    eps?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Restrict coefficients to be >= 0. Be aware that you might want to remove fit\\_intercept which is set `true` by default. Under the positive restriction the model coefficients do not converge to the ordinary-least-squares solution for small values of alpha. Only coefficients up to the smallest alpha value (`alphas\\_\\[alphas\\_ > 0.\\].min()` when fit\\_path=`true`) reached by the stepwise Lars-Lasso algorithm are typically in congruence with the solution of the coordinate descent Lasso estimator. As a consequence using LassoLarsIC only makes sense for problems where a sparse solution is expected and/or reached.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      The estimated noise variance of the data. If `undefined`, an unbiased estimate is computed by an OLS model. However, it is only possible in the case where `n\\_samples > n\\_features + fit\\_intercept`.\n     */\n    noise_variance?: number\n  }) {\n    this.id = `LassoLarsIC${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LassoLarsIC.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LassoLarsIC\ntry: bridgeLassoLarsIC\nexcept NameError: bridgeLassoLarsIC = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LassoLarsIC = {'criterion': ${\n      this.opts['criterion'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'normalize': ${\n      this.opts['normalize'] ?? undefined\n    }, 'precompute': ${this.opts['precompute'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'noise_variance': ${\n      this.opts['noise_variance'] ?? undefined\n    }}\n\nctor_LassoLarsIC = {k: v for k, v in ctor_LassoLarsIC.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLassoLarsIC[${this.id}] = LassoLarsIC(**ctor_LassoLarsIC)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLassoLarsIC[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: ArrayLike\n\n    /**\n      If provided, this parameter will override the choice of copy\\_X made at instance creation. If `true`, X will be copied; else, it may be overwritten.\n     */\n    copy_X?: boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }}\n\npms_LassoLarsIC_fit = {k: v for k, v in pms_LassoLarsIC_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_fit = bridgeLassoLarsIC[${this.id}].fit(**pms_LassoLarsIC_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_fit.tolist() if hasattr(res_LassoLarsIC_fit, 'tolist') else res_LassoLarsIC_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LassoLarsIC_get_metadata_routing = {k: v for k, v in pms_LassoLarsIC_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_get_metadata_routing = bridgeLassoLarsIC[${this.id}].get_metadata_routing(**pms_LassoLarsIC_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_get_metadata_routing.tolist() if hasattr(res_LassoLarsIC_get_metadata_routing, 'tolist') else res_LassoLarsIC_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_LassoLarsIC_predict = {k: v for k, v in pms_LassoLarsIC_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_predict = bridgeLassoLarsIC[${this.id}].predict(**pms_LassoLarsIC_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_predict.tolist() if hasattr(res_LassoLarsIC_predict, 'tolist') else res_LassoLarsIC_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LassoLarsIC_score = {k: v for k, v in pms_LassoLarsIC_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_score = bridgeLassoLarsIC[${this.id}].score(**pms_LassoLarsIC_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_score.tolist() if hasattr(res_LassoLarsIC_score, 'tolist') else res_LassoLarsIC_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `copy\\_X` parameter in `fit`.\n     */\n    copy_X?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_set_fit_request = {'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }}\n\npms_LassoLarsIC_set_fit_request = {k: v for k, v in pms_LassoLarsIC_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_set_fit_request = bridgeLassoLarsIC[${this.id}].set_fit_request(**pms_LassoLarsIC_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_set_fit_request.tolist() if hasattr(res_LassoLarsIC_set_fit_request, 'tolist') else res_LassoLarsIC_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LassoLarsIC_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LassoLarsIC_set_score_request = {k: v for k, v in pms_LassoLarsIC_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LassoLarsIC_set_score_request = bridgeLassoLarsIC[${this.id}].set_score_request(**pms_LassoLarsIC_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LassoLarsIC_set_score_request.tolist() if hasattr(res_LassoLarsIC_set_score_request, 'tolist') else res_LassoLarsIC_set_score_request`\n  }\n\n  /**\n    parameter vector (w in the formulation formula)\n   */\n  get coef_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_coef_ = bridgeLassoLarsIC[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_coef_.tolist() if hasattr(attr_LassoLarsIC_coef_, 'tolist') else attr_LassoLarsIC_coef_`\n    })()\n  }\n\n  /**\n    independent term in decision function.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_intercept_ = bridgeLassoLarsIC[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_intercept_.tolist() if hasattr(attr_LassoLarsIC_intercept_, 'tolist') else attr_LassoLarsIC_intercept_`\n    })()\n  }\n\n  /**\n    the alpha parameter chosen by the information criterion\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_alpha_ = bridgeLassoLarsIC[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_alpha_.tolist() if hasattr(attr_LassoLarsIC_alpha_, 'tolist') else attr_LassoLarsIC_alpha_`\n    })()\n  }\n\n  /**\n    Maximum of covariances (in absolute value) at each iteration. `n\\_alphas` is either `max\\_iter`, `n\\_features` or the number of nodes in the path with `alpha >= alpha\\_min`, whichever is smaller. If a list, it will be of length `n\\_targets`.\n   */\n  get alphas_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before accessing alphas_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_alphas_ = bridgeLassoLarsIC[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_alphas_.tolist() if hasattr(attr_LassoLarsIC_alphas_, 'tolist') else attr_LassoLarsIC_alphas_`\n    })()\n  }\n\n  /**\n    number of iterations run by lars\\_path to find the grid of alphas.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LassoLarsIC must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_n_iter_ = bridgeLassoLarsIC[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_n_iter_.tolist() if hasattr(attr_LassoLarsIC_n_iter_, 'tolist') else attr_LassoLarsIC_n_iter_`\n    })()\n  }\n\n  /**\n    The value of the information criteria (‘aic’, ‘bic’) across all alphas. The alpha which has the smallest information criterion is chosen, as specified in [\\[1\\]](#rde9cc43d0d41-1).\n   */\n  get criterion_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before accessing criterion_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_criterion_ = bridgeLassoLarsIC[${this.id}].criterion_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_criterion_.tolist() if hasattr(attr_LassoLarsIC_criterion_, 'tolist') else attr_LassoLarsIC_criterion_`\n    })()\n  }\n\n  /**\n    The estimated noise variance from the data used to compute the criterion.\n   */\n  get noise_variance_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before accessing noise_variance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_noise_variance_ = bridgeLassoLarsIC[${this.id}].noise_variance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_noise_variance_.tolist() if hasattr(attr_LassoLarsIC_noise_variance_, 'tolist') else attr_LassoLarsIC_noise_variance_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_n_features_in_ = bridgeLassoLarsIC[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_n_features_in_.tolist() if hasattr(attr_LassoLarsIC_n_features_in_, 'tolist') else attr_LassoLarsIC_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LassoLarsIC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LassoLarsIC must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LassoLarsIC_feature_names_in_ = bridgeLassoLarsIC[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LassoLarsIC_feature_names_in_.tolist() if hasattr(attr_LassoLarsIC_feature_names_in_, 'tolist') else attr_LassoLarsIC_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Ordinary least squares Linear Regression.\n\n  LinearRegression fits a linear model with coefficients w = (w1, …, wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html)\n */\nexport class LinearRegression {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether to calculate the intercept for this model. If set to `false`, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The number of jobs to use for the computation. This will only provide speedup in case of sufficiently large problems, that is if firstly `n\\_targets > 1` and secondly `X` is sparse or if `positive` is set to `true`. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      When set to `true`, forces the coefficients to be positive. This option is only supported for dense arrays.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n  }) {\n    this.id = `LinearRegression${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LinearRegression.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\ntry: bridgeLinearRegression\nexcept NameError: bridgeLinearRegression = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LinearRegression = {'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}}\n\nctor_LinearRegression = {k: v for k, v in ctor_LinearRegression.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLinearRegression[${this.id}] = LinearRegression(**ctor_LinearRegression)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLinearRegression[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit linear model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: ArrayLike\n\n    /**\n      Individual weights for each sample.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearRegression must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearRegression_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearRegression_fit = {k: v for k, v in pms_LinearRegression_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_fit = bridgeLinearRegression[${this.id}].fit(**pms_LinearRegression_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_fit.tolist() if hasattr(res_LinearRegression_fit, 'tolist') else res_LinearRegression_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearRegression_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LinearRegression_get_metadata_routing = {k: v for k, v in pms_LinearRegression_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_get_metadata_routing = bridgeLinearRegression[${this.id}].get_metadata_routing(**pms_LinearRegression_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_get_metadata_routing.tolist() if hasattr(res_LinearRegression_get_metadata_routing, 'tolist') else res_LinearRegression_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearRegression must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearRegression_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_LinearRegression_predict = {k: v for k, v in pms_LinearRegression_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_predict = bridgeLinearRegression[${this.id}].predict(**pms_LinearRegression_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_predict.tolist() if hasattr(res_LinearRegression_predict, 'tolist') else res_LinearRegression_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LinearRegression must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LinearRegression_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LinearRegression_score = {k: v for k, v in pms_LinearRegression_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_score = bridgeLinearRegression[${this.id}].score(**pms_LinearRegression_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_score.tolist() if hasattr(res_LinearRegression_score, 'tolist') else res_LinearRegression_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LinearRegression_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearRegression_set_fit_request = {k: v for k, v in pms_LinearRegression_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_set_fit_request = bridgeLinearRegression[${this.id}].set_fit_request(**pms_LinearRegression_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_set_fit_request.tolist() if hasattr(res_LinearRegression_set_fit_request, 'tolist') else res_LinearRegression_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LinearRegression_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LinearRegression_set_score_request = {k: v for k, v in pms_LinearRegression_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LinearRegression_set_score_request = bridgeLinearRegression[${this.id}].set_score_request(**pms_LinearRegression_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LinearRegression_set_score_request.tolist() if hasattr(res_LinearRegression_set_score_request, 'tolist') else res_LinearRegression_set_score_request`\n  }\n\n  /**\n    Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n\\_targets, n\\_features), while if only one target is passed, this is a 1D array of length n\\_features.\n   */\n  get coef_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_coef_ = bridgeLinearRegression[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_coef_.tolist() if hasattr(attr_LinearRegression_coef_, 'tolist') else attr_LinearRegression_coef_`\n    })()\n  }\n\n  /**\n    Rank of matrix `X`. Only available when `X` is dense.\n   */\n  get rank_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing rank_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_rank_ = bridgeLinearRegression[${this.id}].rank_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_rank_.tolist() if hasattr(attr_LinearRegression_rank_, 'tolist') else attr_LinearRegression_rank_`\n    })()\n  }\n\n  /**\n    Singular values of `X`. Only available when `X` is dense.\n   */\n  get singular_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing singular_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_singular_ = bridgeLinearRegression[${this.id}].singular_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_singular_.tolist() if hasattr(attr_LinearRegression_singular_, 'tolist') else attr_LinearRegression_singular_`\n    })()\n  }\n\n  /**\n    Independent term in the linear model. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number | any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_intercept_ = bridgeLinearRegression[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_intercept_.tolist() if hasattr(attr_LinearRegression_intercept_, 'tolist') else attr_LinearRegression_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_n_features_in_ = bridgeLinearRegression[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_n_features_in_.tolist() if hasattr(attr_LinearRegression_n_features_in_, 'tolist') else attr_LinearRegression_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LinearRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LinearRegression must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LinearRegression_feature_names_in_ = bridgeLinearRegression[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LinearRegression_feature_names_in_.tolist() if hasattr(attr_LinearRegression_feature_names_in_, 'tolist') else attr_LinearRegression_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Logistic Regression (aka logit, MaxEnt) classifier.\n\n  In the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme if the ‘multi\\_class’ option is set to ‘ovr’, and uses the cross-entropy loss if the ‘multi\\_class’ option is set to ‘multinomial’. (Currently the ‘multinomial’ option is supported only by the ‘lbfgs’, ‘sag’, ‘saga’ and ‘newton-cg’ solvers.)\n\n  This class implements regularized logistic regression using the ‘liblinear’ library, ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ solvers. **Note that regularization is applied by default**. It can handle both dense and sparse input. Use C-ordered arrays or CSR matrices containing 64-bit floats for optimal performance; any other input format will be converted (and copied).\n\n  The ‘newton-cg’, ‘sag’, and ‘lbfgs’ solvers support only L2 regularization with primal formulation, or no regularization. The ‘liblinear’ solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty. The Elastic-Net regularization is only supported by the ‘saga’ solver.\n\n  Read more in the [User Guide](../linear_model.html#logistic-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html)\n */\nexport class LogisticRegression {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Specify the norm of the penalty:\n\n      @defaultValue `'l2'`\n     */\n    penalty?: 'l1' | 'l2' | 'elasticnet'\n\n    /**\n      Dual (constrained) or primal (regularized, see also [this equation](../linear_model.html#regularized-logistic-loss)) formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=`false` when n\\_samples > n\\_features.\n\n      @defaultValue `false`\n     */\n    dual?: boolean\n\n    /**\n      Tolerance for stopping criteria.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Useful only when the solver ‘liblinear’ is used and self.fit\\_intercept is set to `true`. In this case, x becomes \\[x, self.intercept\\_scaling\\], i.e. a “synthetic” feature with constant value equal to intercept\\_scaling is appended to the instance vector. The intercept becomes `intercept\\_scaling \\* synthetic\\_feature\\_weight`.\n\n      Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept\\_scaling has to be increased.\n\n      @defaultValue `1`\n     */\n    intercept_scaling?: number\n\n    /**\n      Weights associated with classes in the form `{class\\_label: weight}`. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n\n      Note that these weights will be multiplied with sample\\_weight (passed through the fit method) if sample\\_weight is specified.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Used when `solver` == ‘sag’, ‘saga’ or ‘liblinear’ to shuffle the data. See [Glossary](../../glossary.html#term-random_state) for details.\n     */\n    random_state?: number\n\n    /**\n      Algorithm to use in the optimization problem. Default is ‘lbfgs’. To choose a solver, you might want to consider the following aspects:\n\n      @defaultValue `'lbfgs'`\n     */\n    solver?:\n      | 'lbfgs'\n      | 'liblinear'\n      | 'newton-cg'\n      | 'newton-cholesky'\n      | 'sag'\n      | 'saga'\n\n    /**\n      Maximum number of iterations taken for the solvers to converge.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      If the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, *even when the data is binary*. ‘multinomial’ is unavailable when solver=’liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=’liblinear’, and otherwise selects ‘multinomial’.\n\n      @defaultValue `'auto'`\n     */\n    multi_class?: 'auto' | 'ovr' | 'multinomial'\n\n    /**\n      For the liblinear and lbfgs solvers set verbose to any positive number for verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      Number of CPU cores used when parallelizing over classes if multi\\_class=’ovr’”. This parameter is ignored when the `solver` is set to ‘liblinear’ regardless of whether ‘multi\\_class’ is specified or not. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The Elastic-Net mixing parameter, with `0 <= l1\\_ratio <= 1`. Only used if `penalty='elasticnet'`. Setting `l1\\_ratio=0` is equivalent to using `penalty='l2'`, while setting `l1\\_ratio=1` is equivalent to using `penalty='l1'`. For `0 < l1\\_ratio <1`, the penalty is a combination of L1 and L2.\n     */\n    l1_ratio?: number\n  }) {\n    this.id = `LogisticRegression${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'LogisticRegression.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\ntry: bridgeLogisticRegression\nexcept NameError: bridgeLogisticRegression = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LogisticRegression = {'penalty': ${\n      this.opts['penalty'] ?? undefined\n    }, 'dual': ${this.opts['dual'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'C': ${this.opts['C'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'intercept_scaling': ${\n      this.opts['intercept_scaling'] ?? undefined\n    }, 'class_weight': ${\n      this.opts['class_weight'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'multi_class': ${\n      this.opts['multi_class'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'l1_ratio': ${\n      this.opts['l1_ratio'] ?? undefined\n    }}\n\nctor_LogisticRegression = {k: v for k, v in ctor_LogisticRegression.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLogisticRegression[${this.id}] = LogisticRegression(**ctor_LogisticRegression)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLogisticRegression[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegression_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegression_decision_function = {k: v for k, v in pms_LogisticRegression_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_decision_function = bridgeLogisticRegression[${this.id}].decision_function(**pms_LogisticRegression_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_decision_function.tolist() if hasattr(res_LogisticRegression_decision_function, 'tolist') else res_LogisticRegression_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegression must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_densify = {}\n\npms_LogisticRegression_densify = {k: v for k, v in pms_LogisticRegression_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_densify = bridgeLogisticRegression[${this.id}].densify(**pms_LogisticRegression_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_densify.tolist() if hasattr(res_LogisticRegression_densify, 'tolist') else res_LogisticRegression_densify`\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target vector relative to X.\n     */\n    y?: ArrayLike\n\n    /**\n      Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.\n     */\n    sample_weight?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegression must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LogisticRegression_fit = {k: v for k, v in pms_LogisticRegression_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_fit = bridgeLogisticRegression[${this.id}].fit(**pms_LogisticRegression_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_fit.tolist() if hasattr(res_LogisticRegression_fit, 'tolist') else res_LogisticRegression_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegression_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LogisticRegression_get_metadata_routing = {k: v for k, v in pms_LogisticRegression_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_get_metadata_routing = bridgeLogisticRegression[${this.id}].get_metadata_routing(**pms_LogisticRegression_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_get_metadata_routing.tolist() if hasattr(res_LogisticRegression_get_metadata_routing, 'tolist') else res_LogisticRegression_get_metadata_routing`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegression must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegression_predict = {k: v for k, v in pms_LogisticRegression_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_predict = bridgeLogisticRegression[${this.id}].predict(**pms_LogisticRegression_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_predict.tolist() if hasattr(res_LogisticRegression_predict, 'tolist') else res_LogisticRegression_predict`\n  }\n\n  /**\n    Predict logarithm of probability estimates.\n\n    The returned estimates for all classes are ordered by the label of classes.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Vector to be scored, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegression_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegression_predict_log_proba = {k: v for k, v in pms_LogisticRegression_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_predict_log_proba = bridgeLogisticRegression[${this.id}].predict_log_proba(**pms_LogisticRegression_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_predict_log_proba.tolist() if hasattr(res_LogisticRegression_predict_log_proba, 'tolist') else res_LogisticRegression_predict_log_proba`\n  }\n\n  /**\n    Probability estimates.\n\n    The returned estimates for all classes are ordered by the label of classes.\n\n    For a multi\\_class problem, if multi\\_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.\n   */\n  async predict_proba(opts: {\n    /**\n      Vector to be scored, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegression_predict_proba = {k: v for k, v in pms_LogisticRegression_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_predict_proba = bridgeLogisticRegression[${this.id}].predict_proba(**pms_LogisticRegression_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_predict_proba.tolist() if hasattr(res_LogisticRegression_predict_proba, 'tolist') else res_LogisticRegression_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegression must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LogisticRegression_score = {k: v for k, v in pms_LogisticRegression_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_score = bridgeLogisticRegression[${this.id}].score(**pms_LogisticRegression_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_score.tolist() if hasattr(res_LogisticRegression_score, 'tolist') else res_LogisticRegression_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegression_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LogisticRegression_set_fit_request = {k: v for k, v in pms_LogisticRegression_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_set_fit_request = bridgeLogisticRegression[${this.id}].set_fit_request(**pms_LogisticRegression_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_set_fit_request.tolist() if hasattr(res_LogisticRegression_set_fit_request, 'tolist') else res_LogisticRegression_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegression_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LogisticRegression_set_score_request = {k: v for k, v in pms_LogisticRegression_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_set_score_request = bridgeLogisticRegression[${this.id}].set_score_request(**pms_LogisticRegression_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_set_score_request.tolist() if hasattr(res_LogisticRegression_set_score_request, 'tolist') else res_LogisticRegression_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegression must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegression_sparsify = {}\n\npms_LogisticRegression_sparsify = {k: v for k, v in pms_LogisticRegression_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegression_sparsify = bridgeLogisticRegression[${this.id}].sparsify(**pms_LogisticRegression_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegression_sparsify.tolist() if hasattr(res_LogisticRegression_sparsify, 'tolist') else res_LogisticRegression_sparsify`\n  }\n\n  /**\n    A list of class labels known to the classifier.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_classes_ = bridgeLogisticRegression[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_classes_.tolist() if hasattr(attr_LogisticRegression_classes_, 'tolist') else attr_LogisticRegression_classes_`\n    })()\n  }\n\n  /**\n    Coefficient of the features in the decision function.\n\n    `coef\\_` is of shape (1, n\\_features) when the given problem is binary. In particular, when `multi\\_class='multinomial'`, `coef\\_` corresponds to outcome 1 (`true`) and `\\-coef\\_` corresponds to outcome 0 (`false`).\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_coef_ = bridgeLogisticRegression[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_coef_.tolist() if hasattr(attr_LogisticRegression_coef_, 'tolist') else attr_LogisticRegression_coef_`\n    })()\n  }\n\n  /**\n    Intercept (a.k.a. bias) added to the decision function.\n\n    If `fit\\_intercept` is set to `false`, the intercept is set to zero. `intercept\\_` is of shape (1,) when the given problem is binary. In particular, when `multi\\_class='multinomial'`, `intercept\\_` corresponds to outcome 1 (`true`) and `\\-intercept\\_` corresponds to outcome 0 (`false`).\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_intercept_ = bridgeLogisticRegression[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_intercept_.tolist() if hasattr(attr_LogisticRegression_intercept_, 'tolist') else attr_LogisticRegression_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_n_features_in_ = bridgeLogisticRegression[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_n_features_in_.tolist() if hasattr(attr_LogisticRegression_n_features_in_, 'tolist') else attr_LogisticRegression_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_feature_names_in_ = bridgeLogisticRegression[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_feature_names_in_.tolist() if hasattr(attr_LogisticRegression_feature_names_in_, 'tolist') else attr_LogisticRegression_feature_names_in_`\n    })()\n  }\n\n  /**\n    Actual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegression instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegression must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegression_n_iter_ = bridgeLogisticRegression[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegression_n_iter_.tolist() if hasattr(attr_LogisticRegression_n_iter_, 'tolist') else attr_LogisticRegression_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Logistic Regression CV (aka logit, MaxEnt) classifier.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  This class implements logistic regression using liblinear, newton-cg, sag of lbfgs optimizer. The newton-cg, sag and lbfgs solvers support only L2 regularization with primal formulation. The liblinear solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty. Elastic-Net penalty is only supported by the saga solver.\n\n  For the grid of `Cs` values and `l1\\_ratios` values, the best hyperparameter is selected by the cross-validator [`StratifiedKFold`](sklearn.model_selection.StratifiedKFold.html#sklearn.model_selection.StratifiedKFold \"sklearn.model_selection.StratifiedKFold\"), but it can be changed using the [cv](../../glossary.html#term-cv) parameter. The ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ solvers can warm-start the coefficients (see [Glossary](../../glossary.html#term-warm_start)).\n\n  Read more in the [User Guide](../linear_model.html#logistic-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegressionCV.html)\n */\nexport class LogisticRegressionCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Each of the values in Cs describes the inverse of regularization strength. If Cs is as an int, then a grid of Cs values are chosen in a logarithmic scale between 1e-4 and 1e4. Like in support vector machines, smaller values specify stronger regularization.\n\n      @defaultValue `10`\n     */\n    Cs?: number\n\n    /**\n      Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The default cross-validation generator used is Stratified K-Folds. If an integer is provided, then it is the number of folds used. See the module [`sklearn.model\\_selection`](../classes.html#module-sklearn.model_selection \"sklearn.model_selection\") module for the list of possible cross-validation objects.\n     */\n    cv?: number\n\n    /**\n      Dual (constrained) or primal (regularized, see also [this equation](../linear_model.html#regularized-logistic-loss)) formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=`false` when n\\_samples > n\\_features.\n\n      @defaultValue `false`\n     */\n    dual?: boolean\n\n    /**\n      Specify the norm of the penalty:\n\n      @defaultValue `'l2'`\n     */\n    penalty?: 'l1' | 'l2' | 'elasticnet'\n\n    /**\n      A string (see model evaluation documentation) or a scorer callable object / function with signature `scorer(estimator, X, y)`. For a list of scoring functions that can be used, look at [`sklearn.metrics`](../classes.html#module-sklearn.metrics \"sklearn.metrics\"). The default scoring option used is ‘accuracy’.\n     */\n    scoring?: string\n\n    /**\n      Algorithm to use in the optimization problem. Default is ‘lbfgs’. To choose a solver, you might want to consider the following aspects:\n\n      @defaultValue `'lbfgs'`\n     */\n    solver?:\n      | 'lbfgs'\n      | 'liblinear'\n      | 'newton-cg'\n      | 'newton-cholesky'\n      | 'sag'\n      | 'saga'\n\n    /**\n      Tolerance for stopping criteria.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations of the optimization algorithm.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Weights associated with classes in the form `{class\\_label: weight}`. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n\n      Note that these weights will be multiplied with sample\\_weight (passed through the fit method) if sample\\_weight is specified.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Number of CPU cores used during the cross-validation loop. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      For the ‘liblinear’, ‘sag’ and ‘lbfgs’ solvers set verbose to any positive number for verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      If set to `true`, the scores are averaged across all folds, and the coefs and the C that corresponds to the best score is taken, and a final refit is done using these parameters. Otherwise the coefs, intercepts and C that correspond to the best scores across folds are averaged.\n\n      @defaultValue `true`\n     */\n    refit?: boolean\n\n    /**\n      Useful only when the solver ‘liblinear’ is used and self.fit\\_intercept is set to `true`. In this case, x becomes \\[x, self.intercept\\_scaling\\], i.e. a “synthetic” feature with constant value equal to intercept\\_scaling is appended to the instance vector. The intercept becomes `intercept\\_scaling \\* synthetic\\_feature\\_weight`.\n\n      Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept\\_scaling has to be increased.\n\n      @defaultValue `1`\n     */\n    intercept_scaling?: number\n\n    /**\n      If the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, *even when the data is binary*. ‘multinomial’ is unavailable when solver=’liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=’liblinear’, and otherwise selects ‘multinomial’.\n\n      @defaultValue `'auto'`\n     */\n    multi_class?: 'ovr' | 'multinomial'\n\n    /**\n      Used when `solver='sag'`, ‘saga’ or ‘liblinear’ to shuffle the data. Note that this only applies to the solver and not the cross-validation generator. See [Glossary](../../glossary.html#term-random_state) for details.\n     */\n    random_state?: number\n\n    /**\n      The list of Elastic-Net mixing parameter, with `0 <= l1\\_ratio <= 1`. Only used if `penalty='elasticnet'`. A value of 0 is equivalent to using `penalty='l2'`, while 1 is equivalent to using `penalty='l1'`. For `0 < l1\\_ratio <1`, the penalty is a combination of L1 and L2.\n     */\n    l1_ratios?: any\n  }) {\n    this.id = `LogisticRegressionCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'LogisticRegressionCV.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegressionCV\ntry: bridgeLogisticRegressionCV\nexcept NameError: bridgeLogisticRegressionCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LogisticRegressionCV = {'Cs': ${\n      this.opts['Cs'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'dual': ${this.opts['dual'] ?? undefined}, 'penalty': ${\n      this.opts['penalty'] ?? undefined\n    }, 'scoring': ${this.opts['scoring'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'refit': ${\n      this.opts['refit'] ?? undefined\n    }, 'intercept_scaling': ${\n      this.opts['intercept_scaling'] ?? undefined\n    }, 'multi_class': ${\n      this.opts['multi_class'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'l1_ratios': ${this.opts['l1_ratios'] ?? undefined}}\n\nctor_LogisticRegressionCV = {k: v for k, v in ctor_LogisticRegressionCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLogisticRegressionCV[${this.id}] = LogisticRegressionCV(**ctor_LogisticRegressionCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLogisticRegressionCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegressionCV_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegressionCV_decision_function = {k: v for k, v in pms_LogisticRegressionCV_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_decision_function = bridgeLogisticRegressionCV[${this.id}].decision_function(**pms_LogisticRegressionCV_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_decision_function.tolist() if hasattr(res_LogisticRegressionCV_decision_function, 'tolist') else res_LogisticRegressionCV_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegressionCV must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_densify = {}\n\npms_LogisticRegressionCV_densify = {k: v for k, v in pms_LogisticRegressionCV_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_densify = bridgeLogisticRegressionCV[${this.id}].densify(**pms_LogisticRegressionCV_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_densify.tolist() if hasattr(res_LogisticRegressionCV_densify, 'tolist') else res_LogisticRegressionCV_densify`\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target vector relative to X.\n     */\n    y?: ArrayLike\n\n    /**\n      Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.\n     */\n    sample_weight?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegressionCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LogisticRegressionCV_fit = {k: v for k, v in pms_LogisticRegressionCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_fit = bridgeLogisticRegressionCV[${this.id}].fit(**pms_LogisticRegressionCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_fit.tolist() if hasattr(res_LogisticRegressionCV_fit, 'tolist') else res_LogisticRegressionCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegressionCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LogisticRegressionCV_get_metadata_routing = {k: v for k, v in pms_LogisticRegressionCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_get_metadata_routing = bridgeLogisticRegressionCV[${this.id}].get_metadata_routing(**pms_LogisticRegressionCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_get_metadata_routing.tolist() if hasattr(res_LogisticRegressionCV_get_metadata_routing, 'tolist') else res_LogisticRegressionCV_get_metadata_routing`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegressionCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegressionCV_predict = {k: v for k, v in pms_LogisticRegressionCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_predict = bridgeLogisticRegressionCV[${this.id}].predict(**pms_LogisticRegressionCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_predict.tolist() if hasattr(res_LogisticRegressionCV_predict, 'tolist') else res_LogisticRegressionCV_predict`\n  }\n\n  /**\n    Predict logarithm of probability estimates.\n\n    The returned estimates for all classes are ordered by the label of classes.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Vector to be scored, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegressionCV_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegressionCV_predict_log_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_predict_log_proba = bridgeLogisticRegressionCV[${this.id}].predict_log_proba(**pms_LogisticRegressionCV_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_predict_log_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_log_proba, 'tolist') else res_LogisticRegressionCV_predict_log_proba`\n  }\n\n  /**\n    Probability estimates.\n\n    The returned estimates for all classes are ordered by the label of classes.\n\n    For a multi\\_class problem, if multi\\_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.\n   */\n  async predict_proba(opts: {\n    /**\n      Vector to be scored, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LogisticRegressionCV_predict_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_predict_proba = bridgeLogisticRegressionCV[${this.id}].predict_proba(**pms_LogisticRegressionCV_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_predict_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_proba, 'tolist') else res_LogisticRegressionCV_predict_proba`\n  }\n\n  /**\n    Score using the `scoring` option on the given test data and labels.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for X.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegressionCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LogisticRegressionCV_score = {k: v for k, v in pms_LogisticRegressionCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_score = bridgeLogisticRegressionCV[${this.id}].score(**pms_LogisticRegressionCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_score.tolist() if hasattr(res_LogisticRegressionCV_score, 'tolist') else res_LogisticRegressionCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegressionCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LogisticRegressionCV_set_fit_request = {k: v for k, v in pms_LogisticRegressionCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_set_fit_request = bridgeLogisticRegressionCV[${this.id}].set_fit_request(**pms_LogisticRegressionCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_set_fit_request.tolist() if hasattr(res_LogisticRegressionCV_set_fit_request, 'tolist') else res_LogisticRegressionCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LogisticRegressionCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LogisticRegressionCV_set_score_request = {k: v for k, v in pms_LogisticRegressionCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_set_score_request = bridgeLogisticRegressionCV[${this.id}].set_score_request(**pms_LogisticRegressionCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_set_score_request.tolist() if hasattr(res_LogisticRegressionCV_set_score_request, 'tolist') else res_LogisticRegressionCV_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LogisticRegressionCV must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LogisticRegressionCV_sparsify = {}\n\npms_LogisticRegressionCV_sparsify = {k: v for k, v in pms_LogisticRegressionCV_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LogisticRegressionCV_sparsify = bridgeLogisticRegressionCV[${this.id}].sparsify(**pms_LogisticRegressionCV_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LogisticRegressionCV_sparsify.tolist() if hasattr(res_LogisticRegressionCV_sparsify, 'tolist') else res_LogisticRegressionCV_sparsify`\n  }\n\n  /**\n    A list of class labels known to the classifier.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_classes_ = bridgeLogisticRegressionCV[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_classes_.tolist() if hasattr(attr_LogisticRegressionCV_classes_, 'tolist') else attr_LogisticRegressionCV_classes_`\n    })()\n  }\n\n  /**\n    Coefficient of the features in the decision function.\n\n    `coef\\_` is of shape (1, n\\_features) when the given problem is binary.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_coef_ = bridgeLogisticRegressionCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_coef_.tolist() if hasattr(attr_LogisticRegressionCV_coef_, 'tolist') else attr_LogisticRegressionCV_coef_`\n    })()\n  }\n\n  /**\n    Intercept (a.k.a. bias) added to the decision function.\n\n    If `fit\\_intercept` is set to `false`, the intercept is set to zero. `intercept\\_` is of shape(1,) when the problem is binary.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_intercept_ = bridgeLogisticRegressionCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_intercept_.tolist() if hasattr(attr_LogisticRegressionCV_intercept_, 'tolist') else attr_LogisticRegressionCV_intercept_`\n    })()\n  }\n\n  /**\n    Array of C i.e. inverse of regularization parameter values used for cross-validation.\n   */\n  get Cs_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing Cs_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_Cs_ = bridgeLogisticRegressionCV[${this.id}].Cs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_Cs_.tolist() if hasattr(attr_LogisticRegressionCV_Cs_, 'tolist') else attr_LogisticRegressionCV_Cs_`\n    })()\n  }\n\n  /**\n    Array of l1\\_ratios used for cross-validation. If no l1\\_ratio is used (i.e. penalty is not ‘elasticnet’), this is set to `\\[`undefined`\\]`\n   */\n  get l1_ratios_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing l1_ratios_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_l1_ratios_ = bridgeLogisticRegressionCV[${this.id}].l1_ratios_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_l1_ratios_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratios_, 'tolist') else attr_LogisticRegressionCV_l1_ratios_`\n    })()\n  }\n\n  /**\n    dict with classes as the keys, and the path of coefficients obtained during cross-validating across each fold and then across each Cs after doing an OvR for the corresponding class as values. If the ‘multi\\_class’ option is set to ‘multinomial’, then the coefs\\_paths are the coefficients corresponding to each class. Each dict value has shape `(n\\_folds, n\\_cs, n\\_features)` or `(n\\_folds, n\\_cs, n\\_features + 1)` depending on whether the intercept is fit or not. If `penalty='elasticnet'`, the shape is `(n\\_folds, n\\_cs, n\\_l1\\_ratios\\_, n\\_features)` or `(n\\_folds, n\\_cs, n\\_l1\\_ratios\\_, n\\_features + 1)`.\n   */\n  get coefs_paths_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing coefs_paths_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_coefs_paths_ = bridgeLogisticRegressionCV[${this.id}].coefs_paths_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_coefs_paths_.tolist() if hasattr(attr_LogisticRegressionCV_coefs_paths_, 'tolist') else attr_LogisticRegressionCV_coefs_paths_`\n    })()\n  }\n\n  /**\n    dict with classes as the keys, and the values as the grid of scores obtained during cross-validating each fold, after doing an OvR for the corresponding class. If the ‘multi\\_class’ option given is ‘multinomial’ then the same scores are repeated across all classes, since this is the multinomial class. Each dict value has shape `(n\\_folds, n\\_cs)` or `(n\\_folds, n\\_cs, n\\_l1\\_ratios)` if `penalty='elasticnet'`.\n   */\n  get scores_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing scores_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_scores_ = bridgeLogisticRegressionCV[${this.id}].scores_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_scores_.tolist() if hasattr(attr_LogisticRegressionCV_scores_, 'tolist') else attr_LogisticRegressionCV_scores_`\n    })()\n  }\n\n  /**\n    Array of C that maps to the best scores across every class. If refit is set to `false`, then for each class, the best C is the average of the C’s that correspond to the best scores for each fold. `C\\_` is of shape(n\\_classes,) when the problem is binary.\n   */\n  get C_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing C_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_C_ = bridgeLogisticRegressionCV[${this.id}].C_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_C_.tolist() if hasattr(attr_LogisticRegressionCV_C_, 'tolist') else attr_LogisticRegressionCV_C_`\n    })()\n  }\n\n  /**\n    Array of l1\\_ratio that maps to the best scores across every class. If refit is set to `false`, then for each class, the best l1\\_ratio is the average of the l1\\_ratio’s that correspond to the best scores for each fold. `l1\\_ratio\\_` is of shape(n\\_classes,) when the problem is binary.\n   */\n  get l1_ratio_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing l1_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_l1_ratio_ = bridgeLogisticRegressionCV[${this.id}].l1_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_l1_ratio_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratio_, 'tolist') else attr_LogisticRegressionCV_l1_ratio_`\n    })()\n  }\n\n  /**\n    Actual number of iterations for all classes, folds and Cs. In the binary or multinomial cases, the first dimension is equal to 1. If `penalty='elasticnet'`, the shape is `(n\\_classes, n\\_folds, n\\_cs, n\\_l1\\_ratios)` or `(1, n\\_folds, n\\_cs, n\\_l1\\_ratios)`.\n   */\n  get n_iter_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_n_iter_ = bridgeLogisticRegressionCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_n_iter_.tolist() if hasattr(attr_LogisticRegressionCV_n_iter_, 'tolist') else attr_LogisticRegressionCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_n_features_in_ = bridgeLogisticRegressionCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_n_features_in_.tolist() if hasattr(attr_LogisticRegressionCV_n_features_in_, 'tolist') else attr_LogisticRegressionCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LogisticRegressionCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LogisticRegressionCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LogisticRegressionCV_feature_names_in_ = bridgeLogisticRegressionCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LogisticRegressionCV_feature_names_in_.tolist() if hasattr(attr_LogisticRegressionCV_feature_names_in_, 'tolist') else attr_LogisticRegressionCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multi-task ElasticNet model trained with L1/L2 mixed-norm as regularizer.\n\n  The optimization objective for MultiTaskElasticNet is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.MultiTaskElasticNet.html)\n */\nexport class MultiTaskElasticNet {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L1/L2 term. Defaults to 1.0.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      The ElasticNet mixing parameter, with 0 < l1\\_ratio <= 1. For l1\\_ratio = 1 the penalty is an L1/L2 penalty. For l1\\_ratio = 0 it is an L2 penalty. For `0 < l1\\_ratio < 1`, the penalty is a combination of L1/L2 and L2.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `MultiTaskElasticNet${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MultiTaskElasticNet.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import MultiTaskElasticNet\ntry: bridgeMultiTaskElasticNet\nexcept NameError: bridgeMultiTaskElasticNet = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MultiTaskElasticNet = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'l1_ratio': ${this.opts['l1_ratio'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_MultiTaskElasticNet = {k: v for k, v in ctor_MultiTaskElasticNet.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMultiTaskElasticNet[${this.id}] = MultiTaskElasticNet(**ctor_MultiTaskElasticNet)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMultiTaskElasticNet[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit MultiTaskElasticNet model with coordinate descent.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: NDArray[]\n\n    /**\n      Target. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNet must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNet_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_MultiTaskElasticNet_fit = {k: v for k, v in pms_MultiTaskElasticNet_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_fit = bridgeMultiTaskElasticNet[${this.id}].fit(**pms_MultiTaskElasticNet_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_fit.tolist() if hasattr(res_MultiTaskElasticNet_fit, 'tolist') else res_MultiTaskElasticNet_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNet_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MultiTaskElasticNet_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNet_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_get_metadata_routing = bridgeMultiTaskElasticNet[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNet_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNet_get_metadata_routing, 'tolist') else res_MultiTaskElasticNet_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNet must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNet_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_MultiTaskElasticNet_path = {k: v for k, v in pms_MultiTaskElasticNet_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_path = bridgeMultiTaskElasticNet[${this.id}].path(**pms_MultiTaskElasticNet_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_path.tolist() if hasattr(res_MultiTaskElasticNet_path, 'tolist') else res_MultiTaskElasticNet_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNet must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNet_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_MultiTaskElasticNet_predict = {k: v for k, v in pms_MultiTaskElasticNet_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_predict = bridgeMultiTaskElasticNet[${this.id}].predict(**pms_MultiTaskElasticNet_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_predict.tolist() if hasattr(res_MultiTaskElasticNet_predict, 'tolist') else res_MultiTaskElasticNet_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNet must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNet_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_MultiTaskElasticNet_score = {k: v for k, v in pms_MultiTaskElasticNet_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_score = bridgeMultiTaskElasticNet[${this.id}].score(**pms_MultiTaskElasticNet_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_score.tolist() if hasattr(res_MultiTaskElasticNet_score, 'tolist') else res_MultiTaskElasticNet_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `check\\_input` parameter in `fit`.\n     */\n    check_input?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNet_set_fit_request = {'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_MultiTaskElasticNet_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNet_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_set_fit_request = bridgeMultiTaskElasticNet[${this.id}].set_fit_request(**pms_MultiTaskElasticNet_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNet_set_fit_request, 'tolist') else res_MultiTaskElasticNet_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNet_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskElasticNet_set_score_request = {k: v for k, v in pms_MultiTaskElasticNet_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNet_set_score_request = bridgeMultiTaskElasticNet[${this.id}].set_score_request(**pms_MultiTaskElasticNet_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNet_set_score_request.tolist() if hasattr(res_MultiTaskElasticNet_set_score_request, 'tolist') else res_MultiTaskElasticNet_set_score_request`\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_intercept_ = bridgeMultiTaskElasticNet[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_intercept_.tolist() if hasattr(attr_MultiTaskElasticNet_intercept_, 'tolist') else attr_MultiTaskElasticNet_intercept_`\n    })()\n  }\n\n  /**\n    Parameter vector (W in the cost function formula). If a 1D y is passed in at fit (non multi-task usage), `coef\\_` is then a 1D array. Note that `coef\\_` stores the transpose of `W`, `W.T`.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_coef_ = bridgeMultiTaskElasticNet[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_coef_.tolist() if hasattr(attr_MultiTaskElasticNet_coef_, 'tolist') else attr_MultiTaskElasticNet_coef_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_n_iter_ = bridgeMultiTaskElasticNet[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNet_n_iter_, 'tolist') else attr_MultiTaskElasticNet_n_iter_`\n    })()\n  }\n\n  /**\n    The dual gaps at the end of the optimization.\n   */\n  get dual_gap_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing dual_gap_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_dual_gap_ = bridgeMultiTaskElasticNet[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNet_dual_gap_, 'tolist') else attr_MultiTaskElasticNet_dual_gap_`\n    })()\n  }\n\n  /**\n    The tolerance scaled scaled by the variance of the target `y`.\n   */\n  get eps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing eps_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_eps_ = bridgeMultiTaskElasticNet[${this.id}].eps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_eps_.tolist() if hasattr(attr_MultiTaskElasticNet_eps_, 'tolist') else attr_MultiTaskElasticNet_eps_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_n_features_in_ = bridgeMultiTaskElasticNet[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNet_n_features_in_, 'tolist') else attr_MultiTaskElasticNet_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNet instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNet must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNet_feature_names_in_ = bridgeMultiTaskElasticNet[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNet_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNet_feature_names_in_, 'tolist') else attr_MultiTaskElasticNet_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multi-task L1/L2 ElasticNet with built-in cross-validation.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  The optimization objective for MultiTaskElasticNet is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.MultiTaskElasticNetCV.html)\n */\nexport class MultiTaskElasticNetCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The ElasticNet mixing parameter, with 0 < l1\\_ratio <= 1. For l1\\_ratio = 1 the penalty is an L1/L2 penalty. For l1\\_ratio = 0 it is an L2 penalty. For `0 < l1\\_ratio < 1`, the penalty is a combination of L1/L2 and L2. This parameter can be a list, in which case the different values are tested by cross-validation and the one giving the best prediction score is used. Note that a good choice of list of values for l1\\_ratio is often to put more values close to 1 (i.e. Lasso) and less close to 0 (i.e. Ridge), as in `\\[.1, .5, .7, .9, .95, .99, 1\\]`.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If not provided, set automatically.\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: boolean | number\n\n    /**\n      Number of CPUs to use during the cross validation. Note that this is used only if multiple values for l1\\_ratio are given. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `MultiTaskElasticNetCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MultiTaskElasticNetCV.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import MultiTaskElasticNetCV\ntry: bridgeMultiTaskElasticNetCV\nexcept NameError: bridgeMultiTaskElasticNetCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MultiTaskElasticNetCV = {'l1_ratio': ${\n      this.opts['l1_ratio'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'n_alphas': ${\n      this.opts['n_alphas'] ?? undefined\n    }, 'alphas': ${this.opts['alphas'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_MultiTaskElasticNetCV = {k: v for k, v in ctor_MultiTaskElasticNetCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMultiTaskElasticNetCV[${this.id}] = MultiTaskElasticNetCV(**ctor_MultiTaskElasticNetCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMultiTaskElasticNetCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit MultiTaskElasticNet model with coordinate descent.\n\n    Fit is on grid of alphas and best alpha estimated by cross-validation.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: NDArray[]\n\n    /**\n      Training target variable. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNetCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNetCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_MultiTaskElasticNetCV_fit = {k: v for k, v in pms_MultiTaskElasticNetCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_fit = bridgeMultiTaskElasticNetCV[${this.id}].fit(**pms_MultiTaskElasticNetCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_fit.tolist() if hasattr(res_MultiTaskElasticNetCV_fit, 'tolist') else res_MultiTaskElasticNetCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNetCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MultiTaskElasticNetCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNetCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_get_metadata_routing = bridgeMultiTaskElasticNetCV[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNetCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNetCV_get_metadata_routing, 'tolist') else res_MultiTaskElasticNetCV_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNetCV must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNetCV_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_MultiTaskElasticNetCV_path = {k: v for k, v in pms_MultiTaskElasticNetCV_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_path = bridgeMultiTaskElasticNetCV[${this.id}].path(**pms_MultiTaskElasticNetCV_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_path.tolist() if hasattr(res_MultiTaskElasticNetCV_path, 'tolist') else res_MultiTaskElasticNetCV_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNetCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNetCV_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_MultiTaskElasticNetCV_predict = {k: v for k, v in pms_MultiTaskElasticNetCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_predict = bridgeMultiTaskElasticNetCV[${this.id}].predict(**pms_MultiTaskElasticNetCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_predict.tolist() if hasattr(res_MultiTaskElasticNetCV_predict, 'tolist') else res_MultiTaskElasticNetCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskElasticNetCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskElasticNetCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_MultiTaskElasticNetCV_score = {k: v for k, v in pms_MultiTaskElasticNetCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_score = bridgeMultiTaskElasticNetCV[${this.id}].score(**pms_MultiTaskElasticNetCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_score.tolist() if hasattr(res_MultiTaskElasticNetCV_score, 'tolist') else res_MultiTaskElasticNetCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNetCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskElasticNetCV_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_set_fit_request = bridgeMultiTaskElasticNetCV[${this.id}].set_fit_request(**pms_MultiTaskElasticNetCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_fit_request, 'tolist') else res_MultiTaskElasticNetCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskElasticNetCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskElasticNetCV_set_score_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskElasticNetCV_set_score_request = bridgeMultiTaskElasticNetCV[${this.id}].set_score_request(**pms_MultiTaskElasticNetCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskElasticNetCV_set_score_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_score_request, 'tolist') else res_MultiTaskElasticNetCV_set_score_request`\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_intercept_ = bridgeMultiTaskElasticNetCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_intercept_.tolist() if hasattr(attr_MultiTaskElasticNetCV_intercept_, 'tolist') else attr_MultiTaskElasticNetCV_intercept_`\n    })()\n  }\n\n  /**\n    Parameter vector (W in the cost function formula). Note that `coef\\_` stores the transpose of `W`, `W.T`.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_coef_ = bridgeMultiTaskElasticNetCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_coef_.tolist() if hasattr(attr_MultiTaskElasticNetCV_coef_, 'tolist') else attr_MultiTaskElasticNetCV_coef_`\n    })()\n  }\n\n  /**\n    The amount of penalization chosen by cross validation.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing alpha_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_alpha_ = bridgeMultiTaskElasticNetCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_alpha_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alpha_, 'tolist') else attr_MultiTaskElasticNetCV_alpha_`\n    })()\n  }\n\n  /**\n    Mean square error for the test set on each fold, varying alpha.\n   */\n  get mse_path_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing mse_path_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_mse_path_ = bridgeMultiTaskElasticNetCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_mse_path_.tolist() if hasattr(attr_MultiTaskElasticNetCV_mse_path_, 'tolist') else attr_MultiTaskElasticNetCV_mse_path_`\n    })()\n  }\n\n  /**\n    The grid of alphas used for fitting, for each l1\\_ratio.\n   */\n  get alphas_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing alphas_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_alphas_ = bridgeMultiTaskElasticNetCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_alphas_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alphas_, 'tolist') else attr_MultiTaskElasticNetCV_alphas_`\n    })()\n  }\n\n  /**\n    Best l1\\_ratio obtained by cross-validation.\n   */\n  get l1_ratio_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing l1_ratio_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_l1_ratio_ = bridgeMultiTaskElasticNetCV[${this.id}].l1_ratio_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_l1_ratio_.tolist() if hasattr(attr_MultiTaskElasticNetCV_l1_ratio_, 'tolist') else attr_MultiTaskElasticNetCV_l1_ratio_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_n_iter_ = bridgeMultiTaskElasticNetCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_iter_, 'tolist') else attr_MultiTaskElasticNetCV_n_iter_`\n    })()\n  }\n\n  /**\n    The dual gap at the end of the optimization for the optimal alpha.\n   */\n  get dual_gap_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing dual_gap_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_dual_gap_ = bridgeMultiTaskElasticNetCV[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNetCV_dual_gap_, 'tolist') else attr_MultiTaskElasticNetCV_dual_gap_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_n_features_in_ = bridgeMultiTaskElasticNetCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_features_in_, 'tolist') else attr_MultiTaskElasticNetCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskElasticNetCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskElasticNetCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskElasticNetCV_feature_names_in_ = bridgeMultiTaskElasticNetCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskElasticNetCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_feature_names_in_, 'tolist') else attr_MultiTaskElasticNetCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.\n\n  The optimization objective for Lasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.MultiTaskLasso.html)\n */\nexport class MultiTaskLasso {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L1/L2 term. Defaults to 1.0.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `MultiTaskLasso${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MultiTaskLasso.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import MultiTaskLasso\ntry: bridgeMultiTaskLasso\nexcept NameError: bridgeMultiTaskLasso = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MultiTaskLasso = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_MultiTaskLasso = {k: v for k, v in ctor_MultiTaskLasso.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMultiTaskLasso[${this.id}] = MultiTaskLasso(**ctor_MultiTaskLasso)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMultiTaskLasso[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit MultiTaskElasticNet model with coordinate descent.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: NDArray[]\n\n    /**\n      Target. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_MultiTaskLasso_fit = {k: v for k, v in pms_MultiTaskLasso_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_fit = bridgeMultiTaskLasso[${this.id}].fit(**pms_MultiTaskLasso_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_fit.tolist() if hasattr(res_MultiTaskLasso_fit, 'tolist') else res_MultiTaskLasso_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MultiTaskLasso_get_metadata_routing = {k: v for k, v in pms_MultiTaskLasso_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_get_metadata_routing = bridgeMultiTaskLasso[${this.id}].get_metadata_routing(**pms_MultiTaskLasso_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_get_metadata_routing.tolist() if hasattr(res_MultiTaskLasso_get_metadata_routing, 'tolist') else res_MultiTaskLasso_get_metadata_routing`\n  }\n\n  /**\n    Compute elastic net path with coordinate descent.\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Number between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). `l1\\_ratio=1` corresponds to the Lasso.\n\n      @defaultValue `0.5`\n     */\n    l1_ratio?: number\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      If set to `false`, the input validation checks are skipped (including the Gram matrix when provided). It is assumed that they are handled by the caller.\n\n      @defaultValue `true`\n     */\n    check_input?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'l1_ratio': ${\n      opts['l1_ratio'] ?? undefined\n    }, 'eps': ${opts['eps'] ?? undefined}, 'n_alphas': ${\n      opts['n_alphas'] ?? undefined\n    }, 'alphas': np.array(${opts['alphas'] ?? undefined}) if ${\n      opts['alphas'] !== undefined\n    } else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_MultiTaskLasso_path = {k: v for k, v in pms_MultiTaskLasso_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_path = bridgeMultiTaskLasso[${this.id}].path(**pms_MultiTaskLasso_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_path.tolist() if hasattr(res_MultiTaskLasso_path, 'tolist') else res_MultiTaskLasso_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_MultiTaskLasso_predict = {k: v for k, v in pms_MultiTaskLasso_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_predict = bridgeMultiTaskLasso[${this.id}].predict(**pms_MultiTaskLasso_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_predict.tolist() if hasattr(res_MultiTaskLasso_predict, 'tolist') else res_MultiTaskLasso_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_MultiTaskLasso_score = {k: v for k, v in pms_MultiTaskLasso_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_score = bridgeMultiTaskLasso[${this.id}].score(**pms_MultiTaskLasso_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_score.tolist() if hasattr(res_MultiTaskLasso_score, 'tolist') else res_MultiTaskLasso_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `check\\_input` parameter in `fit`.\n     */\n    check_input?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLasso_set_fit_request = {'check_input': ${\n      opts['check_input'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_MultiTaskLasso_set_fit_request = {k: v for k, v in pms_MultiTaskLasso_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_set_fit_request = bridgeMultiTaskLasso[${this.id}].set_fit_request(**pms_MultiTaskLasso_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_set_fit_request.tolist() if hasattr(res_MultiTaskLasso_set_fit_request, 'tolist') else res_MultiTaskLasso_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskLasso_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskLasso_set_score_request = {k: v for k, v in pms_MultiTaskLasso_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLasso_set_score_request = bridgeMultiTaskLasso[${this.id}].set_score_request(**pms_MultiTaskLasso_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLasso_set_score_request.tolist() if hasattr(res_MultiTaskLasso_set_score_request, 'tolist') else res_MultiTaskLasso_set_score_request`\n  }\n\n  /**\n    Parameter vector (W in the cost function formula). Note that `coef\\_` stores the transpose of `W`, `W.T`.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_coef_ = bridgeMultiTaskLasso[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_coef_.tolist() if hasattr(attr_MultiTaskLasso_coef_, 'tolist') else attr_MultiTaskLasso_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_intercept_ = bridgeMultiTaskLasso[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_intercept_.tolist() if hasattr(attr_MultiTaskLasso_intercept_, 'tolist') else attr_MultiTaskLasso_intercept_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_n_iter_ = bridgeMultiTaskLasso[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_n_iter_.tolist() if hasattr(attr_MultiTaskLasso_n_iter_, 'tolist') else attr_MultiTaskLasso_n_iter_`\n    })()\n  }\n\n  /**\n    The dual gaps at the end of the optimization for each alpha.\n   */\n  get dual_gap_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before accessing dual_gap_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_dual_gap_ = bridgeMultiTaskLasso[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_dual_gap_.tolist() if hasattr(attr_MultiTaskLasso_dual_gap_, 'tolist') else attr_MultiTaskLasso_dual_gap_`\n    })()\n  }\n\n  /**\n    The tolerance scaled scaled by the variance of the target `y`.\n   */\n  get eps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLasso must call init() before accessing eps_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_eps_ = bridgeMultiTaskLasso[${this.id}].eps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_eps_.tolist() if hasattr(attr_MultiTaskLasso_eps_, 'tolist') else attr_MultiTaskLasso_eps_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_n_features_in_ = bridgeMultiTaskLasso[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_n_features_in_.tolist() if hasattr(attr_MultiTaskLasso_n_features_in_, 'tolist') else attr_MultiTaskLasso_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MultiTaskLasso instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLasso must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLasso_feature_names_in_ = bridgeMultiTaskLasso[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLasso_feature_names_in_.tolist() if hasattr(attr_MultiTaskLasso_feature_names_in_, 'tolist') else attr_MultiTaskLasso_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  The optimization objective for MultiTaskLasso is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.MultiTaskLassoCV.html)\n */\nexport class MultiTaskLassoCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If not provided, set automatically.\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of iterations.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The tolerance for the optimization: if the updates are smaller than `tol`, the optimization code checks the dual gap for optimality and continues until it is smaller than `tol`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Number of CPUs to use during the cross validation. Note that this is used only if multiple values for l1\\_ratio are given. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The seed of the pseudo random number generator that selects a random feature to update. Used when `selection` == ‘random’. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If set to ‘random’, a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to ‘random’) often leads to significantly faster convergence especially when tol is higher than 1e-4.\n\n      @defaultValue `'cyclic'`\n     */\n    selection?: 'cyclic' | 'random'\n  }) {\n    this.id = `MultiTaskLassoCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MultiTaskLassoCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import MultiTaskLassoCV\ntry: bridgeMultiTaskLassoCV\nexcept NameError: bridgeMultiTaskLassoCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MultiTaskLassoCV = {'eps': ${\n      this.opts['eps'] ?? undefined\n    }, 'n_alphas': ${this.opts['n_alphas'] ?? undefined}, 'alphas': ${\n      this.opts['alphas'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'selection': ${this.opts['selection'] ?? undefined}}\n\nctor_MultiTaskLassoCV = {k: v for k, v in ctor_MultiTaskLassoCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMultiTaskLassoCV[${this.id}] = MultiTaskLassoCV(**ctor_MultiTaskLassoCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMultiTaskLassoCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit MultiTaskLasso model with coordinate descent.\n\n    Fit is on grid of alphas and best alpha estimated by cross-validation.\n   */\n  async fit(opts: {\n    /**\n      Data.\n     */\n    X?: NDArray[]\n\n    /**\n      Target. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLassoCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLassoCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_MultiTaskLassoCV_fit = {k: v for k, v in pms_MultiTaskLassoCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_fit = bridgeMultiTaskLassoCV[${this.id}].fit(**pms_MultiTaskLassoCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_fit.tolist() if hasattr(res_MultiTaskLassoCV_fit, 'tolist') else res_MultiTaskLassoCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLassoCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_MultiTaskLassoCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskLassoCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_get_metadata_routing = bridgeMultiTaskLassoCV[${this.id}].get_metadata_routing(**pms_MultiTaskLassoCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskLassoCV_get_metadata_routing, 'tolist') else res_MultiTaskLassoCV_get_metadata_routing`\n  }\n\n  /**\n    Compute Lasso path with coordinate descent.\n\n    The Lasso optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is:\n   */\n  async path(opts: {\n    /**\n      Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If `y` is mono-output then `X` can be sparse.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike | SparseMatrix\n\n    /**\n      Length of the path. `eps=1e-3` means that `alpha\\_min / alpha\\_max \\= 1e-3`.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      Number of alphas along the regularization path.\n\n      @defaultValue `100`\n     */\n    n_alphas?: number\n\n    /**\n      List of alphas where to compute the models. If `undefined` alphas are set automatically.\n     */\n    alphas?: NDArray\n\n    /**\n      Whether to use a precomputed Gram matrix to speed up calculations. If set to `'auto'` let us decide. The Gram matrix can also be passed as argument.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean | ArrayLike[]\n\n    /**\n      Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.\n     */\n    Xy?: ArrayLike\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The initial values of the coefficients.\n     */\n    coef_init?: NDArray\n\n    /**\n      Amount of verbosity.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to return the number of iterations or not.\n\n      @defaultValue `false`\n     */\n    return_n_iter?: boolean\n\n    /**\n      If set to `true`, forces coefficients to be positive. (Only allowed when `y.ndim \\== 1`).\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      Keyword arguments passed to the coordinate descent solver.\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLassoCV must call init() before path()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLassoCV_path = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'eps': ${\n      opts['eps'] ?? undefined\n    }, 'n_alphas': ${opts['n_alphas'] ?? undefined}, 'alphas': np.array(${\n      opts['alphas'] ?? undefined\n    }) if ${opts['alphas'] !== undefined} else None, 'precompute': np.array(${\n      opts['precompute'] ?? undefined\n    }) if ${opts['precompute'] !== undefined} else None, 'Xy': np.array(${\n      opts['Xy'] ?? undefined\n    }) if ${opts['Xy'] !== undefined} else None, 'copy_X': ${\n      opts['copy_X'] ?? undefined\n    }, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'verbose': ${opts['verbose'] ?? undefined}, 'return_n_iter': ${\n      opts['return_n_iter'] ?? undefined\n    }, 'positive': ${opts['positive'] ?? undefined}, 'params': ${\n      opts['params'] ?? undefined\n    }}\n\npms_MultiTaskLassoCV_path = {k: v for k, v in pms_MultiTaskLassoCV_path.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_path = bridgeMultiTaskLassoCV[${this.id}].path(**pms_MultiTaskLassoCV_path)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_path.tolist() if hasattr(res_MultiTaskLassoCV_path, 'tolist') else res_MultiTaskLassoCV_path`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLassoCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLassoCV_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_MultiTaskLassoCV_predict = {k: v for k, v in pms_MultiTaskLassoCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_predict = bridgeMultiTaskLassoCV[${this.id}].predict(**pms_MultiTaskLassoCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_predict.tolist() if hasattr(res_MultiTaskLassoCV_predict, 'tolist') else res_MultiTaskLassoCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MultiTaskLassoCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MultiTaskLassoCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_MultiTaskLassoCV_score = {k: v for k, v in pms_MultiTaskLassoCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_score = bridgeMultiTaskLassoCV[${this.id}].score(**pms_MultiTaskLassoCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_score.tolist() if hasattr(res_MultiTaskLassoCV_score, 'tolist') else res_MultiTaskLassoCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskLassoCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskLassoCV_set_fit_request = {k: v for k, v in pms_MultiTaskLassoCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_set_fit_request = bridgeMultiTaskLassoCV[${this.id}].set_fit_request(**pms_MultiTaskLassoCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_set_fit_request.tolist() if hasattr(res_MultiTaskLassoCV_set_fit_request, 'tolist') else res_MultiTaskLassoCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MultiTaskLassoCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_MultiTaskLassoCV_set_score_request = {k: v for k, v in pms_MultiTaskLassoCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MultiTaskLassoCV_set_score_request = bridgeMultiTaskLassoCV[${this.id}].set_score_request(**pms_MultiTaskLassoCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MultiTaskLassoCV_set_score_request.tolist() if hasattr(res_MultiTaskLassoCV_set_score_request, 'tolist') else res_MultiTaskLassoCV_set_score_request`\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_intercept_ = bridgeMultiTaskLassoCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_intercept_.tolist() if hasattr(attr_MultiTaskLassoCV_intercept_, 'tolist') else attr_MultiTaskLassoCV_intercept_`\n    })()\n  }\n\n  /**\n    Parameter vector (W in the cost function formula). Note that `coef\\_` stores the transpose of `W`, `W.T`.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_coef_ = bridgeMultiTaskLassoCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_coef_.tolist() if hasattr(attr_MultiTaskLassoCV_coef_, 'tolist') else attr_MultiTaskLassoCV_coef_`\n    })()\n  }\n\n  /**\n    The amount of penalization chosen by cross validation.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing alpha_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_alpha_ = bridgeMultiTaskLassoCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_alpha_.tolist() if hasattr(attr_MultiTaskLassoCV_alpha_, 'tolist') else attr_MultiTaskLassoCV_alpha_`\n    })()\n  }\n\n  /**\n    Mean square error for the test set on each fold, varying alpha.\n   */\n  get mse_path_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing mse_path_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_mse_path_ = bridgeMultiTaskLassoCV[${this.id}].mse_path_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_mse_path_.tolist() if hasattr(attr_MultiTaskLassoCV_mse_path_, 'tolist') else attr_MultiTaskLassoCV_mse_path_`\n    })()\n  }\n\n  /**\n    The grid of alphas used for fitting.\n   */\n  get alphas_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing alphas_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_alphas_ = bridgeMultiTaskLassoCV[${this.id}].alphas_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_alphas_.tolist() if hasattr(attr_MultiTaskLassoCV_alphas_, 'tolist') else attr_MultiTaskLassoCV_alphas_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_n_iter_ = bridgeMultiTaskLassoCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_n_iter_.tolist() if hasattr(attr_MultiTaskLassoCV_n_iter_, 'tolist') else attr_MultiTaskLassoCV_n_iter_`\n    })()\n  }\n\n  /**\n    The dual gap at the end of the optimization for the optimal alpha.\n   */\n  get dual_gap_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing dual_gap_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_dual_gap_ = bridgeMultiTaskLassoCV[${this.id}].dual_gap_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_dual_gap_.tolist() if hasattr(attr_MultiTaskLassoCV_dual_gap_, 'tolist') else attr_MultiTaskLassoCV_dual_gap_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_n_features_in_ = bridgeMultiTaskLassoCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_n_features_in_.tolist() if hasattr(attr_MultiTaskLassoCV_n_features_in_, 'tolist') else attr_MultiTaskLassoCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MultiTaskLassoCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MultiTaskLassoCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MultiTaskLassoCV_feature_names_in_ = bridgeMultiTaskLassoCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MultiTaskLassoCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskLassoCV_feature_names_in_, 'tolist') else attr_MultiTaskLassoCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Orthogonal Matching Pursuit model (OMP).\n\n  Read more in the [User Guide](../linear_model.html#omp).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.OrthogonalMatchingPursuit.html)\n */\nexport class OrthogonalMatchingPursuit {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Desired number of non-zero entries in the solution. If `undefined` (by default) this value is set to 10% of n\\_features.\n     */\n    n_nonzero_coefs?: number\n\n    /**\n      Maximum squared norm of the residual. If not `undefined`, overrides n\\_nonzero\\_coefs.\n     */\n    tol?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Whether to use a precomputed Gram and Xy matrix to speed up calculations. Improves performance when [n\\_targets](../../glossary.html#term-n_targets) or [n\\_samples](../../glossary.html#term-n_samples) is very large. Note that if you already have such matrices, you can pass them directly to the fit method.\n\n      @defaultValue `'auto'`\n     */\n    precompute?: 'auto' | boolean\n  }) {\n    this.id = `OrthogonalMatchingPursuit${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'OrthogonalMatchingPursuit.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import OrthogonalMatchingPursuit\ntry: bridgeOrthogonalMatchingPursuit\nexcept NameError: bridgeOrthogonalMatchingPursuit = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OrthogonalMatchingPursuit = {'n_nonzero_coefs': ${\n      this.opts['n_nonzero_coefs'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'normalize': ${this.opts['normalize'] ?? undefined}, 'precompute': ${\n      this.opts['precompute'] ?? undefined\n    }}\n\nctor_OrthogonalMatchingPursuit = {k: v for k, v in ctor_OrthogonalMatchingPursuit.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOrthogonalMatchingPursuit[${this.id}] = OrthogonalMatchingPursuit(**ctor_OrthogonalMatchingPursuit)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOrthogonalMatchingPursuit[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('OrthogonalMatchingPursuit must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuit_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_OrthogonalMatchingPursuit_fit = {k: v for k, v in pms_OrthogonalMatchingPursuit_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuit_fit = bridgeOrthogonalMatchingPursuit[${this.id}].fit(**pms_OrthogonalMatchingPursuit_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuit_fit.tolist() if hasattr(res_OrthogonalMatchingPursuit_fit, 'tolist') else res_OrthogonalMatchingPursuit_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OrthogonalMatchingPursuit_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuit_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuit_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuit_get_metadata_routing = bridgeOrthogonalMatchingPursuit[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuit_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuit_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuit_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuit_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuit_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuit_predict = {k: v for k, v in pms_OrthogonalMatchingPursuit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuit_predict = bridgeOrthogonalMatchingPursuit[${this.id}].predict(**pms_OrthogonalMatchingPursuit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuit_predict.tolist() if hasattr(res_OrthogonalMatchingPursuit_predict, 'tolist') else res_OrthogonalMatchingPursuit_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuit_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_OrthogonalMatchingPursuit_score = {k: v for k, v in pms_OrthogonalMatchingPursuit_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuit_score = bridgeOrthogonalMatchingPursuit[${this.id}].score(**pms_OrthogonalMatchingPursuit_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuit_score.tolist() if hasattr(res_OrthogonalMatchingPursuit_score, 'tolist') else res_OrthogonalMatchingPursuit_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OrthogonalMatchingPursuit_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuit_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuit_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuit_set_score_request = bridgeOrthogonalMatchingPursuit[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuit_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuit_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuit_set_score_request, 'tolist') else res_OrthogonalMatchingPursuit_set_score_request`\n  }\n\n  /**\n    Parameter vector (w in the formula).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_coef_ = bridgeOrthogonalMatchingPursuit[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_coef_, 'tolist') else attr_OrthogonalMatchingPursuit_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_intercept_ = bridgeOrthogonalMatchingPursuit[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_intercept_, 'tolist') else attr_OrthogonalMatchingPursuit_intercept_`\n    })()\n  }\n\n  /**\n    Number of active features across every target.\n   */\n  get n_iter_(): Promise<number | ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_n_iter_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuit_n_iter_`\n    })()\n  }\n\n  /**\n    The number of non-zero coefficients in the solution. If `n\\_nonzero\\_coefs` is `undefined` and `tol` is `undefined` this value is either set to 10% of `n\\_features` or 1, whichever is greater.\n   */\n  get n_nonzero_coefs_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing n_nonzero_coefs_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_nonzero_coefs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuit_n_nonzero_coefs_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_n_features_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuit_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuit instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuit must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuit_feature_names_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuit_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuit_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Cross-validated Orthogonal Matching Pursuit model (OMP).\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  Read more in the [User Guide](../linear_model.html#omp).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.OrthogonalMatchingPursuitCV.html)\n */\nexport class OrthogonalMatchingPursuitCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether the design matrix X must be copied by the algorithm. A false value is only helpful if X is already Fortran-ordered, otherwise a copy is made anyway.\n\n      @defaultValue `true`\n     */\n    copy?: boolean\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      This parameter is ignored when `fit\\_intercept` is set to `false`. If `true`, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use [`StandardScaler`](sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler \"sklearn.preprocessing.StandardScaler\") before calling `fit` on an estimator with `normalize=False`.\n\n      @defaultValue `false`\n     */\n    normalize?: boolean\n\n    /**\n      Maximum numbers of iterations to perform, therefore maximum features to include. 10% of `n\\_features` but at least 5 if available.\n     */\n    max_iter?: number\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Sets the verbosity amount.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n  }) {\n    this.id = `OrthogonalMatchingPursuitCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import OrthogonalMatchingPursuitCV\ntry: bridgeOrthogonalMatchingPursuitCV\nexcept NameError: bridgeOrthogonalMatchingPursuitCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_OrthogonalMatchingPursuitCV = {'copy': ${\n      this.opts['copy'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'normalize': ${this.opts['normalize'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'cv': ${this.opts['cv'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}}\n\nctor_OrthogonalMatchingPursuitCV = {k: v for k, v in ctor_OrthogonalMatchingPursuitCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeOrthogonalMatchingPursuitCV[${this.id}] = OrthogonalMatchingPursuitCV(**ctor_OrthogonalMatchingPursuitCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeOrthogonalMatchingPursuitCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model using X, y as training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuitCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_OrthogonalMatchingPursuitCV_fit = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuitCV_fit = bridgeOrthogonalMatchingPursuitCV[${this.id}].fit(**pms_OrthogonalMatchingPursuitCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuitCV_fit.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_fit, 'tolist') else res_OrthogonalMatchingPursuitCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OrthogonalMatchingPursuitCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuitCV_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuitCV_get_metadata_routing = bridgeOrthogonalMatchingPursuitCV[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuitCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuitCV_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuitCV_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuitCV_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuitCV_predict = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuitCV_predict = bridgeOrthogonalMatchingPursuitCV[${this.id}].predict(**pms_OrthogonalMatchingPursuitCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuitCV_predict.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_predict, 'tolist') else res_OrthogonalMatchingPursuitCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_OrthogonalMatchingPursuitCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_OrthogonalMatchingPursuitCV_score = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuitCV_score = bridgeOrthogonalMatchingPursuitCV[${this.id}].score(**pms_OrthogonalMatchingPursuitCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuitCV_score.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_score, 'tolist') else res_OrthogonalMatchingPursuitCV_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_OrthogonalMatchingPursuitCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_OrthogonalMatchingPursuitCV_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_OrthogonalMatchingPursuitCV_set_score_request = bridgeOrthogonalMatchingPursuitCV[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuitCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_OrthogonalMatchingPursuitCV_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_set_score_request, 'tolist') else res_OrthogonalMatchingPursuitCV_set_score_request`\n  }\n\n  /**\n    Independent term in decision function.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_intercept_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_intercept_, 'tolist') else attr_OrthogonalMatchingPursuitCV_intercept_`\n    })()\n  }\n\n  /**\n    Parameter vector (w in the problem formulation).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_coef_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_coef_, 'tolist') else attr_OrthogonalMatchingPursuitCV_coef_`\n    })()\n  }\n\n  /**\n    Estimated number of non-zero coefficients giving the best mean squared error over the cross-validation folds.\n   */\n  get n_nonzero_coefs_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing n_nonzero_coefs_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_nonzero_coefs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_`\n    })()\n  }\n\n  /**\n    Number of active features across every target for the model refit with the best hyperparameters got by cross-validating across all folds.\n   */\n  get n_iter_(): Promise<number | ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_n_iter_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_n_features_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This OrthogonalMatchingPursuitCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'OrthogonalMatchingPursuitCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_OrthogonalMatchingPursuitCV_feature_names_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_OrthogonalMatchingPursuitCV_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Passive Aggressive Classifier.\n\n  Read more in the [User Guide](../linear_model.html#passive-aggressive).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.PassiveAggressiveClassifier.html)\n */\nexport class PassiveAggressiveClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Maximum step size (regularization). Defaults to 1.0.\n\n      @defaultValue `1`\n     */\n    C?: number\n\n    /**\n      Whether the intercept should be estimated or not. If `false`, the data is assumed to be already centered.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the `fit` method, and not the `PassiveAggressive.partial\\_fit` method.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The stopping criterion. If it is not `undefined`, the iterations will stop when (loss > previous\\_loss - tol).\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Whether to use early stopping to terminate training when validation. score is not improving. If set to `true`, it will automatically set aside a stratified fraction of training data as validation and terminate training when validation score is not improving by at least tol for n\\_iter\\_no\\_change consecutive epochs.\n\n      @defaultValue `false`\n     */\n    early_stopping?: boolean\n\n    /**\n      The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if early\\_stopping is `true`.\n\n      @defaultValue `0.1`\n     */\n    validation_fraction?: number\n\n    /**\n      Number of iterations with no improvement to wait before early stopping.\n\n      @defaultValue `5`\n     */\n    n_iter_no_change?: number\n\n    /**\n      Whether or not the training data should be shuffled after each epoch.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      The verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      The loss function to be used: hinge: equivalent to PA-I in the reference paper. squared\\_hinge: equivalent to PA-II in the reference paper.\n\n      @defaultValue `'hinge'`\n     */\n    loss?: string\n\n    /**\n      The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Used to shuffle the training data, when `shuffle` is set to `true`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      Repeatedly calling fit or partial\\_fit when warm\\_start is `true` can result in a different solution than when calling fit a single time because of the way the data is shuffled.\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      Preset for the class\\_weight fit parameter.\n\n      Weights associated with classes. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      When set to `true`, computes the averaged SGD weights and stores the result in the `coef\\_` attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So average=10 will begin averaging after seeing 10 samples.\n\n      @defaultValue `false`\n     */\n    average?: boolean | number\n  }) {\n    this.id = `PassiveAggressiveClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'PassiveAggressiveClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import PassiveAggressiveClassifier\ntry: bridgePassiveAggressiveClassifier\nexcept NameError: bridgePassiveAggressiveClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PassiveAggressiveClassifier = {'C': ${\n      this.opts['C'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'early_stopping': ${\n      this.opts['early_stopping'] ?? undefined\n    }, 'validation_fraction': ${\n      this.opts['validation_fraction'] ?? undefined\n    }, 'n_iter_no_change': ${\n      this.opts['n_iter_no_change'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'loss': ${this.opts['loss'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'class_weight': ${\n      this.opts['class_weight'] ?? undefined\n    }, 'average': ${this.opts['average'] ?? undefined}}\n\nctor_PassiveAggressiveClassifier = {k: v for k, v in ctor_PassiveAggressiveClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePassiveAggressiveClassifier[${this.id}] = PassiveAggressiveClassifier(**ctor_PassiveAggressiveClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePassiveAggressiveClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PassiveAggressiveClassifier_decision_function = {k: v for k, v in pms_PassiveAggressiveClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_decision_function = bridgePassiveAggressiveClassifier[${this.id}].decision_function(**pms_PassiveAggressiveClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_decision_function.tolist() if hasattr(res_PassiveAggressiveClassifier_decision_function, 'tolist') else res_PassiveAggressiveClassifier_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before densify()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PassiveAggressiveClassifier_densify = {}\n\npms_PassiveAggressiveClassifier_densify = {k: v for k, v in pms_PassiveAggressiveClassifier_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_densify = bridgePassiveAggressiveClassifier[${this.id}].densify(**pms_PassiveAggressiveClassifier_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_densify.tolist() if hasattr(res_PassiveAggressiveClassifier_densify, 'tolist') else res_PassiveAggressiveClassifier_densify`\n  }\n\n  /**\n    Fit linear model with Passive Aggressive algorithm.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      The initial coefficients to warm-start the optimization.\n     */\n    coef_init?: NDArray[]\n\n    /**\n      The initial intercept to warm-start the optimization.\n     */\n    intercept_init?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PassiveAggressiveClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'coef_init': np.array(${\n      opts['coef_init'] ?? undefined\n    }) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'intercept_init': np.array(${\n      opts['intercept_init'] ?? undefined\n    }) if ${opts['intercept_init'] !== undefined} else None}\n\npms_PassiveAggressiveClassifier_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_fit = bridgePassiveAggressiveClassifier[${this.id}].fit(**pms_PassiveAggressiveClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_fit, 'tolist') else res_PassiveAggressiveClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PassiveAggressiveClassifier_get_metadata_routing = {k: v for k, v in pms_PassiveAggressiveClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_get_metadata_routing = bridgePassiveAggressiveClassifier[${this.id}].get_metadata_routing(**pms_PassiveAggressiveClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_get_metadata_routing.tolist() if hasattr(res_PassiveAggressiveClassifier_get_metadata_routing, 'tolist') else res_PassiveAggressiveClassifier_get_metadata_routing`\n  }\n\n  /**\n    Fit linear model with Passive Aggressive algorithm.\n   */\n  async partial_fit(opts: {\n    /**\n      Subset of the training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Subset of the target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Classes across all calls to partial\\_fit. Can be obtained by via `np.unique(y\\_all)`, where y\\_all is the target vector of the entire dataset. This argument is required for the first call to partial\\_fit and can be omitted in the subsequent calls. Note that y doesn’t need to contain all labels in `classes`.\n     */\n    classes?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'classes': np.array(${\n      opts['classes'] ?? undefined\n    }) if ${opts['classes'] !== undefined} else None}\n\npms_PassiveAggressiveClassifier_partial_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_partial_fit = bridgePassiveAggressiveClassifier[${this.id}].partial_fit(**pms_PassiveAggressiveClassifier_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_partial_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_partial_fit, 'tolist') else res_PassiveAggressiveClassifier_partial_fit`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PassiveAggressiveClassifier_predict = {k: v for k, v in pms_PassiveAggressiveClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_predict = bridgePassiveAggressiveClassifier[${this.id}].predict(**pms_PassiveAggressiveClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_predict.tolist() if hasattr(res_PassiveAggressiveClassifier_predict, 'tolist') else res_PassiveAggressiveClassifier_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PassiveAggressiveClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_PassiveAggressiveClassifier_score = {k: v for k, v in pms_PassiveAggressiveClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_score = bridgePassiveAggressiveClassifier[${this.id}].score(**pms_PassiveAggressiveClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_score.tolist() if hasattr(res_PassiveAggressiveClassifier_score, 'tolist') else res_PassiveAggressiveClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `coef\\_init` parameter in `fit`.\n     */\n    coef_init?: string | boolean\n\n    /**\n      Metadata routing for `intercept\\_init` parameter in `fit`.\n     */\n    intercept_init?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_set_fit_request = {'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'intercept_init': ${opts['intercept_init'] ?? undefined}}\n\npms_PassiveAggressiveClassifier_set_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_set_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_fit_request(**pms_PassiveAggressiveClassifier_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_set_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `classes` parameter in `partial\\_fit`.\n     */\n    classes?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_set_partial_fit_request = {'classes': ${\n      opts['classes'] ?? undefined\n    }}\n\npms_PassiveAggressiveClassifier_set_partial_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_set_partial_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_partial_fit_request(**pms_PassiveAggressiveClassifier_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_set_partial_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_partial_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PassiveAggressiveClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_PassiveAggressiveClassifier_set_score_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_set_score_request = bridgePassiveAggressiveClassifier[${this.id}].set_score_request(**pms_PassiveAggressiveClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_set_score_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_score_request, 'tolist') else res_PassiveAggressiveClassifier_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before sparsify()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PassiveAggressiveClassifier_sparsify = {}\n\npms_PassiveAggressiveClassifier_sparsify = {k: v for k, v in pms_PassiveAggressiveClassifier_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PassiveAggressiveClassifier_sparsify = bridgePassiveAggressiveClassifier[${this.id}].sparsify(**pms_PassiveAggressiveClassifier_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PassiveAggressiveClassifier_sparsify.tolist() if hasattr(res_PassiveAggressiveClassifier_sparsify, 'tolist') else res_PassiveAggressiveClassifier_sparsify`\n  }\n\n  /**\n    Weights assigned to the features.\n   */\n  get coef_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_coef_ = bridgePassiveAggressiveClassifier[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_coef_.tolist() if hasattr(attr_PassiveAggressiveClassifier_coef_, 'tolist') else attr_PassiveAggressiveClassifier_coef_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_intercept_ = bridgePassiveAggressiveClassifier[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_intercept_.tolist() if hasattr(attr_PassiveAggressiveClassifier_intercept_, 'tolist') else attr_PassiveAggressiveClassifier_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_n_features_in_ = bridgePassiveAggressiveClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_n_features_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_features_in_, 'tolist') else attr_PassiveAggressiveClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_feature_names_in_ = bridgePassiveAggressiveClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_feature_names_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_feature_names_in_, 'tolist') else attr_PassiveAggressiveClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_n_iter_ = bridgePassiveAggressiveClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_n_iter_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_iter_, 'tolist') else attr_PassiveAggressiveClassifier_n_iter_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_classes_ = bridgePassiveAggressiveClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_classes_.tolist() if hasattr(attr_PassiveAggressiveClassifier_classes_, 'tolist') else attr_PassiveAggressiveClassifier_classes_`\n    })()\n  }\n\n  /**\n    Number of weight updates performed during training. Same as `(n\\_iter\\_ \\* n\\_samples + 1)`.\n   */\n  get t_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing t_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_t_ = bridgePassiveAggressiveClassifier[${this.id}].t_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_t_.tolist() if hasattr(attr_PassiveAggressiveClassifier_t_, 'tolist') else attr_PassiveAggressiveClassifier_t_`\n    })()\n  }\n\n  /**\n    Loss function used by the algorithm.\n   */\n  get loss_function_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PassiveAggressiveClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PassiveAggressiveClassifier must call init() before accessing loss_function_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PassiveAggressiveClassifier_loss_function_ = bridgePassiveAggressiveClassifier[${this.id}].loss_function_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PassiveAggressiveClassifier_loss_function_.tolist() if hasattr(attr_PassiveAggressiveClassifier_loss_function_, 'tolist') else attr_PassiveAggressiveClassifier_loss_function_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear perceptron classifier.\n\n  Read more in the [User Guide](../linear_model.html#perceptron).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Perceptron.html)\n */\nexport class Perceptron {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The penalty (aka regularization term) to be used.\n     */\n    penalty?: 'l2' | 'l1' | 'elasticnet'\n\n    /**\n      Constant that multiplies the regularization term if regularization is used.\n\n      @defaultValue `0.0001`\n     */\n    alpha?: number\n\n    /**\n      The Elastic Net mixing parameter, with `0 <= l1\\_ratio <= 1`. `l1\\_ratio=0` corresponds to L2 penalty, `l1\\_ratio=1` to L1. Only used if `penalty='elasticnet'`.\n\n      @defaultValue `0.15`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether the intercept should be estimated or not. If `false`, the data is assumed to be already centered.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the `fit` method, and not the [`partial\\_fit`](#sklearn.linear_model.Perceptron.partial_fit \"sklearn.linear_model.Perceptron.partial_fit\") method.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The stopping criterion. If it is not `undefined`, the iterations will stop when (loss > previous\\_loss - tol).\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Whether or not the training data should be shuffled after each epoch.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      The verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Constant by which the updates are multiplied.\n\n      @defaultValue `1`\n     */\n    eta0?: number\n\n    /**\n      The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Used to shuffle the training data, when `shuffle` is set to `true`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n\n      @defaultValue `0`\n     */\n    random_state?: number\n\n    /**\n      Whether to use early stopping to terminate training when validation. score is not improving. If set to `true`, it will automatically set aside a stratified fraction of training data as validation and terminate training when validation score is not improving by at least tol for n\\_iter\\_no\\_change consecutive epochs.\n\n      @defaultValue `false`\n     */\n    early_stopping?: boolean\n\n    /**\n      The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if early\\_stopping is `true`.\n\n      @defaultValue `0.1`\n     */\n    validation_fraction?: number\n\n    /**\n      Number of iterations with no improvement to wait before early stopping.\n\n      @defaultValue `5`\n     */\n    n_iter_no_change?: number\n\n    /**\n      Preset for the class\\_weight fit parameter.\n\n      Weights associated with classes. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n  }) {\n    this.id = `Perceptron${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Perceptron.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import Perceptron\ntry: bridgePerceptron\nexcept NameError: bridgePerceptron = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Perceptron = {'penalty': ${\n      this.opts['penalty'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'l1_ratio': ${\n      this.opts['l1_ratio'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'eta0': ${this.opts['eta0'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'early_stopping': ${\n      this.opts['early_stopping'] ?? undefined\n    }, 'validation_fraction': ${\n      this.opts['validation_fraction'] ?? undefined\n    }, 'n_iter_no_change': ${\n      this.opts['n_iter_no_change'] ?? undefined\n    }, 'class_weight': ${\n      this.opts['class_weight'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}}\n\nctor_Perceptron = {k: v for k, v in ctor_Perceptron.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePerceptron[${this.id}] = Perceptron(**ctor_Perceptron)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePerceptron[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_Perceptron_decision_function = {k: v for k, v in pms_Perceptron_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_decision_function = bridgePerceptron[${this.id}].decision_function(**pms_Perceptron_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_decision_function.tolist() if hasattr(res_Perceptron_decision_function, 'tolist') else res_Perceptron_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_densify = {}\n\npms_Perceptron_densify = {k: v for k, v in pms_Perceptron_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_densify = bridgePerceptron[${this.id}].densify(**pms_Perceptron_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_densify.tolist() if hasattr(res_Perceptron_densify, 'tolist') else res_Perceptron_densify`\n  }\n\n  /**\n    Fit linear model with Stochastic Gradient Descent.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n\n    /**\n      The initial coefficients to warm-start the optimization.\n     */\n    coef_init?: NDArray[]\n\n    /**\n      The initial intercept to warm-start the optimization.\n     */\n    intercept_init?: NDArray\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed. These weights will be multiplied with class\\_weight (passed through the constructor) if class\\_weight is specified.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'intercept_init': np.array(${\n      opts['intercept_init'] ?? undefined\n    }) if ${opts['intercept_init'] !== undefined} else None, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Perceptron_fit = {k: v for k, v in pms_Perceptron_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_fit = bridgePerceptron[${this.id}].fit(**pms_Perceptron_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_fit.tolist() if hasattr(res_Perceptron_fit, 'tolist') else res_Perceptron_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Perceptron must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Perceptron_get_metadata_routing = {k: v for k, v in pms_Perceptron_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_get_metadata_routing = bridgePerceptron[${this.id}].get_metadata_routing(**pms_Perceptron_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_get_metadata_routing.tolist() if hasattr(res_Perceptron_get_metadata_routing, 'tolist') else res_Perceptron_get_metadata_routing`\n  }\n\n  /**\n    Perform one epoch of stochastic gradient descent on given samples.\n\n    Internally, this method uses `max\\_iter \\= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.\n   */\n  async partial_fit(opts: {\n    /**\n      Subset of the training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Subset of the target values.\n     */\n    y?: NDArray\n\n    /**\n      Classes across all calls to partial\\_fit. Can be obtained by via `np.unique(y\\_all)`, where y\\_all is the target vector of the entire dataset. This argument is required for the first call to partial\\_fit and can be omitted in the subsequent calls. Note that y doesn’t need to contain all labels in `classes`.\n     */\n    classes?: NDArray\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_partial_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'classes': np.array(${opts['classes'] ?? undefined}) if ${\n      opts['classes'] !== undefined\n    } else None, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_Perceptron_partial_fit = {k: v for k, v in pms_Perceptron_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_partial_fit = bridgePerceptron[${this.id}].partial_fit(**pms_Perceptron_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_partial_fit.tolist() if hasattr(res_Perceptron_partial_fit, 'tolist') else res_Perceptron_partial_fit`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_Perceptron_predict = {k: v for k, v in pms_Perceptron_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_predict = bridgePerceptron[${this.id}].predict(**pms_Perceptron_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_predict.tolist() if hasattr(res_Perceptron_predict, 'tolist') else res_Perceptron_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_Perceptron_score = {k: v for k, v in pms_Perceptron_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_score = bridgePerceptron[${this.id}].score(**pms_Perceptron_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_score.tolist() if hasattr(res_Perceptron_score, 'tolist') else res_Perceptron_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `coef\\_init` parameter in `fit`.\n     */\n    coef_init?: string | boolean\n\n    /**\n      Metadata routing for `intercept\\_init` parameter in `fit`.\n     */\n    intercept_init?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_set_fit_request = {'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'intercept_init': ${\n      opts['intercept_init'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_Perceptron_set_fit_request = {k: v for k, v in pms_Perceptron_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_set_fit_request = bridgePerceptron[${this.id}].set_fit_request(**pms_Perceptron_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_set_fit_request.tolist() if hasattr(res_Perceptron_set_fit_request, 'tolist') else res_Perceptron_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `classes` parameter in `partial\\_fit`.\n     */\n    classes?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Perceptron must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_set_partial_fit_request = {'classes': ${\n      opts['classes'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_Perceptron_set_partial_fit_request = {k: v for k, v in pms_Perceptron_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_set_partial_fit_request = bridgePerceptron[${this.id}].set_partial_fit_request(**pms_Perceptron_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_set_partial_fit_request.tolist() if hasattr(res_Perceptron_set_partial_fit_request, 'tolist') else res_Perceptron_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Perceptron_set_score_request = {k: v for k, v in pms_Perceptron_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_set_score_request = bridgePerceptron[${this.id}].set_score_request(**pms_Perceptron_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_set_score_request.tolist() if hasattr(res_Perceptron_set_score_request, 'tolist') else res_Perceptron_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Perceptron_sparsify = {}\n\npms_Perceptron_sparsify = {k: v for k, v in pms_Perceptron_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Perceptron_sparsify = bridgePerceptron[${this.id}].sparsify(**pms_Perceptron_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Perceptron_sparsify.tolist() if hasattr(res_Perceptron_sparsify, 'tolist') else res_Perceptron_sparsify`\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before accessing classes_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_classes_ = bridgePerceptron[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_classes_.tolist() if hasattr(attr_Perceptron_classes_, 'tolist') else attr_Perceptron_classes_`\n    })()\n  }\n\n  /**\n    Weights assigned to the features.\n   */\n  get coef_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_coef_ = bridgePerceptron[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_coef_.tolist() if hasattr(attr_Perceptron_coef_, 'tolist') else attr_Perceptron_coef_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_intercept_ = bridgePerceptron[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_intercept_.tolist() if hasattr(attr_Perceptron_intercept_, 'tolist') else attr_Perceptron_intercept_`\n    })()\n  }\n\n  /**\n    The function that determines the loss, or difference between the output of the algorithm and the target values.\n   */\n  get loss_function_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Perceptron must call init() before accessing loss_function_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_loss_function_ = bridgePerceptron[${this.id}].loss_function_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_loss_function_.tolist() if hasattr(attr_Perceptron_loss_function_, 'tolist') else attr_Perceptron_loss_function_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Perceptron must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_n_features_in_ = bridgePerceptron[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_n_features_in_.tolist() if hasattr(attr_Perceptron_n_features_in_, 'tolist') else attr_Perceptron_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Perceptron must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_feature_names_in_ = bridgePerceptron[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_feature_names_in_.tolist() if hasattr(attr_Perceptron_feature_names_in_, 'tolist') else attr_Perceptron_feature_names_in_`\n    })()\n  }\n\n  /**\n    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Perceptron_n_iter_ = bridgePerceptron[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_n_iter_.tolist() if hasattr(attr_Perceptron_n_iter_, 'tolist') else attr_Perceptron_n_iter_`\n    })()\n  }\n\n  /**\n    Number of weight updates performed during training. Same as `(n\\_iter\\_ \\* n\\_samples + 1)`.\n   */\n  get t_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Perceptron instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Perceptron must call init() before accessing t_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Perceptron_t_ = bridgePerceptron[${this.id}].t_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Perceptron_t_.tolist() if hasattr(attr_Perceptron_t_, 'tolist') else attr_Perceptron_t_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generalized Linear Model with a Poisson distribution.\n\n  This regressor uses the ‘log’ link function.\n\n  Read more in the [User Guide](../linear_model.html#generalized-linear-models).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.PoissonRegressor.html)\n */\nexport class PoissonRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L2 penalty term and determines the regularization strength. `alpha \\= 0` is equivalent to unpenalized GLMs. In this case, the design matrix `X` must have full column rank (no collinearities). Values of `alpha` must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Specifies if a constant (a.k.a. bias or intercept) should be added to the linear predictor (`X @ coef + intercept`).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Algorithm to use in the optimization problem:\n\n      @defaultValue `'lbfgs'`\n     */\n    solver?: 'lbfgs' | 'newton-cholesky'\n\n    /**\n      The maximal number of iterations for the solver. Values must be in the range `\\[1, inf)`.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Stopping criterion. For the lbfgs solver, the iteration will stop when `max{|g\\_j|, j \\= 1, ..., d} <= tol` where `g\\_j` is the j-th component of the gradient (derivative) of the objective function. Values must be in the range `(0.0, inf)`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      If set to `true`, reuse the solution of the previous call to `fit` as initialization for `coef\\_` and `intercept\\_` .\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      For the lbfgs solver set verbose to any positive number for verbosity. Values must be in the range `\\[0, inf)`.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n  }) {\n    this.id = `PoissonRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('PoissonRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import PoissonRegressor\ntry: bridgePoissonRegressor\nexcept NameError: bridgePoissonRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_PoissonRegressor = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_PoissonRegressor = {k: v for k, v in ctor_PoissonRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgePoissonRegressor[${this.id}] = PoissonRegressor(**ctor_PoissonRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePoissonRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a Generalized Linear Model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PoissonRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PoissonRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_PoissonRegressor_fit = {k: v for k, v in pms_PoissonRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_fit = bridgePoissonRegressor[${this.id}].fit(**pms_PoissonRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_fit.tolist() if hasattr(res_PoissonRegressor_fit, 'tolist') else res_PoissonRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_PoissonRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_PoissonRegressor_get_metadata_routing = {k: v for k, v in pms_PoissonRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_get_metadata_routing = bridgePoissonRegressor[${this.id}].get_metadata_routing(**pms_PoissonRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_get_metadata_routing.tolist() if hasattr(res_PoissonRegressor_get_metadata_routing, 'tolist') else res_PoissonRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using GLM with feature matrix X.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PoissonRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PoissonRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_PoissonRegressor_predict = {k: v for k, v in pms_PoissonRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_predict = bridgePoissonRegressor[${this.id}].predict(**pms_PoissonRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_predict.tolist() if hasattr(res_PoissonRegressor_predict, 'tolist') else res_PoissonRegressor_predict`\n  }\n\n  /**\n    Compute D^2, the percentage of deviance explained.\n\n    D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).\n\n    D^2 is defined as \\\\(D^2 = 1-\\\\frac{D(y\\_{true},y\\_{pred})}{D\\_{null}}\\\\), \\\\(D\\_{null}\\\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\\\(y\\_{pred} = \\\\bar{y}\\\\). The mean \\\\(\\\\bar{y}\\\\) is averaged by sample\\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      True values of target.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('PoissonRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_PoissonRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_PoissonRegressor_score = {k: v for k, v in pms_PoissonRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_score = bridgePoissonRegressor[${this.id}].score(**pms_PoissonRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_score.tolist() if hasattr(res_PoissonRegressor_score, 'tolist') else res_PoissonRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PoissonRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_PoissonRegressor_set_fit_request = {k: v for k, v in pms_PoissonRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_set_fit_request = bridgePoissonRegressor[${this.id}].set_fit_request(**pms_PoissonRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_set_fit_request.tolist() if hasattr(res_PoissonRegressor_set_fit_request, 'tolist') else res_PoissonRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_PoissonRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_PoissonRegressor_set_score_request = {k: v for k, v in pms_PoissonRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_PoissonRegressor_set_score_request = bridgePoissonRegressor[${this.id}].set_score_request(**pms_PoissonRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_PoissonRegressor_set_score_request.tolist() if hasattr(res_PoissonRegressor_set_score_request, 'tolist') else res_PoissonRegressor_set_score_request`\n  }\n\n  /**\n    Estimated coefficients for the linear predictor (`X @ coef\\_ + intercept\\_`) in the GLM.\n   */\n  get coef_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PoissonRegressor_coef_ = bridgePoissonRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PoissonRegressor_coef_.tolist() if hasattr(attr_PoissonRegressor_coef_, 'tolist') else attr_PoissonRegressor_coef_`\n    })()\n  }\n\n  /**\n    Intercept (a.k.a. bias) added to linear predictor.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PoissonRegressor_intercept_ = bridgePoissonRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PoissonRegressor_intercept_.tolist() if hasattr(attr_PoissonRegressor_intercept_, 'tolist') else attr_PoissonRegressor_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PoissonRegressor_n_features_in_ = bridgePoissonRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PoissonRegressor_n_features_in_.tolist() if hasattr(attr_PoissonRegressor_n_features_in_, 'tolist') else attr_PoissonRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PoissonRegressor_feature_names_in_ = bridgePoissonRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PoissonRegressor_feature_names_in_.tolist() if hasattr(attr_PoissonRegressor_feature_names_in_, 'tolist') else attr_PoissonRegressor_feature_names_in_`\n    })()\n  }\n\n  /**\n    Actual number of iterations used in the solver.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This PoissonRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'PoissonRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_PoissonRegressor_n_iter_ = bridgePoissonRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_PoissonRegressor_n_iter_.tolist() if hasattr(attr_PoissonRegressor_n_iter_, 'tolist') else attr_PoissonRegressor_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear regression model that predicts conditional quantiles.\n\n  The linear [`QuantileRegressor`](#sklearn.linear_model.QuantileRegressor \"sklearn.linear_model.QuantileRegressor\") optimizes the pinball loss for a desired `quantile` and is robust to outliers.\n\n  This model uses an L1 regularization like [`Lasso`](sklearn.linear_model.Lasso.html#sklearn.linear_model.Lasso \"sklearn.linear_model.Lasso\").\n\n  Read more in the [User Guide](../linear_model.html#quantile-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.QuantileRegressor.html)\n */\nexport class QuantileRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The quantile that the model tries to predict. It must be strictly between 0 and 1. If 0.5 (default), the model predicts the 50% quantile, i.e. the median.\n\n      @defaultValue `0.5`\n     */\n    quantile?: number\n\n    /**\n      Regularization constant that multiplies the L1 penalty term.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether or not to fit the intercept.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      Method used by [`scipy.optimize.linprog`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog \"(in SciPy v1.11.3)\") to solve the linear programming formulation.\n\n      From `scipy>=1.6.0`, it is recommended to use the highs methods because they are the fastest ones. Solvers “highs-ds”, “highs-ipm” and “highs” support sparse input data and, in fact, always convert to sparse csc.\n\n      From `scipy>=1.11.0`, “interior-point” is not available anymore.\n\n      @defaultValue `'interior-point'`\n     */\n    solver?:\n      | 'highs-ds'\n      | 'highs-ipm'\n      | 'highs'\n      | 'interior-point'\n      | 'revised simplex'\n\n    /**\n      Additional parameters passed to [`scipy.optimize.linprog`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog \"(in SciPy v1.11.3)\") as options. If `undefined` and if `solver='interior-point'`, then `{\"lstsq\": `true`}` is passed to [`scipy.optimize.linprog`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog \"(in SciPy v1.11.3)\") for the sake of stability.\n     */\n    solver_options?: any\n  }) {\n    this.id = `QuantileRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('QuantileRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import QuantileRegressor\ntry: bridgeQuantileRegressor\nexcept NameError: bridgeQuantileRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_QuantileRegressor = {'quantile': ${\n      this.opts['quantile'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'solver': ${this.opts['solver'] ?? undefined}, 'solver_options': ${\n      this.opts['solver_options'] ?? undefined\n    }}\n\nctor_QuantileRegressor = {k: v for k, v in ctor_QuantileRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeQuantileRegressor[${this.id}] = QuantileRegressor(**ctor_QuantileRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeQuantileRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('QuantileRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_QuantileRegressor_fit = {k: v for k, v in pms_QuantileRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_fit = bridgeQuantileRegressor[${this.id}].fit(**pms_QuantileRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_fit.tolist() if hasattr(res_QuantileRegressor_fit, 'tolist') else res_QuantileRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_QuantileRegressor_get_metadata_routing = {k: v for k, v in pms_QuantileRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_get_metadata_routing = bridgeQuantileRegressor[${this.id}].get_metadata_routing(**pms_QuantileRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_get_metadata_routing.tolist() if hasattr(res_QuantileRegressor_get_metadata_routing, 'tolist') else res_QuantileRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('QuantileRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileRegressor_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_QuantileRegressor_predict = {k: v for k, v in pms_QuantileRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_predict = bridgeQuantileRegressor[${this.id}].predict(**pms_QuantileRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_predict.tolist() if hasattr(res_QuantileRegressor_predict, 'tolist') else res_QuantileRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('QuantileRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuantileRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_QuantileRegressor_score = {k: v for k, v in pms_QuantileRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_score = bridgeQuantileRegressor[${this.id}].score(**pms_QuantileRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_score.tolist() if hasattr(res_QuantileRegressor_score, 'tolist') else res_QuantileRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_QuantileRegressor_set_fit_request = {k: v for k, v in pms_QuantileRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_set_fit_request = bridgeQuantileRegressor[${this.id}].set_fit_request(**pms_QuantileRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_set_fit_request.tolist() if hasattr(res_QuantileRegressor_set_fit_request, 'tolist') else res_QuantileRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuantileRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_QuantileRegressor_set_score_request = {k: v for k, v in pms_QuantileRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuantileRegressor_set_score_request = bridgeQuantileRegressor[${this.id}].set_score_request(**pms_QuantileRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuantileRegressor_set_score_request.tolist() if hasattr(res_QuantileRegressor_set_score_request, 'tolist') else res_QuantileRegressor_set_score_request`\n  }\n\n  /**\n    Estimated coefficients for the features.\n   */\n  get coef_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileRegressor_coef_ = bridgeQuantileRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileRegressor_coef_.tolist() if hasattr(attr_QuantileRegressor_coef_, 'tolist') else attr_QuantileRegressor_coef_`\n    })()\n  }\n\n  /**\n    The intercept of the model, aka bias term.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileRegressor_intercept_ = bridgeQuantileRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileRegressor_intercept_.tolist() if hasattr(attr_QuantileRegressor_intercept_, 'tolist') else attr_QuantileRegressor_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileRegressor_n_features_in_ = bridgeQuantileRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileRegressor_n_features_in_.tolist() if hasattr(attr_QuantileRegressor_n_features_in_, 'tolist') else attr_QuantileRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileRegressor_feature_names_in_ = bridgeQuantileRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileRegressor_feature_names_in_.tolist() if hasattr(attr_QuantileRegressor_feature_names_in_, 'tolist') else attr_QuantileRegressor_feature_names_in_`\n    })()\n  }\n\n  /**\n    The actual number of iterations performed by the solver.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuantileRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuantileRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuantileRegressor_n_iter_ = bridgeQuantileRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuantileRegressor_n_iter_.tolist() if hasattr(attr_QuantileRegressor_n_iter_, 'tolist') else attr_QuantileRegressor_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  RANSAC (RANdom SAmple Consensus) algorithm.\n\n  RANSAC is an iterative algorithm for the robust estimation of parameters from a subset of inliers from the complete data set.\n\n  Read more in the [User Guide](../linear_model.html#ransac-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RANSACRegressor.html)\n */\nexport class RANSACRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Base estimator object which implements the following methods:\n     */\n    estimator?: any\n\n    /**\n      Minimum number of samples chosen randomly from original data. Treated as an absolute number of samples for `min\\_samples >= 1`, treated as a relative number `ceil(min\\_samples \\* X.shape\\[0\\])` for `min\\_samples < 1`. This is typically chosen as the minimal number of samples necessary to estimate the given `estimator`. By default a [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") estimator is assumed and `min\\_samples` is chosen as `X.shape\\[1\\] + 1`. This parameter is highly dependent upon the model, so if a `estimator` other than [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") is used, the user must provide a value.\n     */\n    min_samples?: number\n\n    /**\n      Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values `y`. Points whose residuals are strictly equal to the threshold are considered as inliers.\n     */\n    residual_threshold?: number\n\n    /**\n      This function is called with the randomly selected data before the model is fitted to it: `is\\_data\\_valid(X, y)`. If its return value is `false` the current randomly chosen sub-sample is skipped.\n     */\n    is_data_valid?: any\n\n    /**\n      This function is called with the estimated model and the randomly selected data: `is\\_model\\_valid(model, X, y)`. If its return value is `false` the current randomly chosen sub-sample is skipped. Rejecting samples with this function is computationally costlier than with `is\\_data\\_valid`. `is\\_model\\_valid` should therefore only be used if the estimated model is needed for making the rejection decision.\n     */\n    is_model_valid?: any\n\n    /**\n      Maximum number of iterations for random sample selection.\n\n      @defaultValue `100`\n     */\n    max_trials?: number\n\n    /**\n      Maximum number of iterations that can be skipped due to finding zero inliers or invalid data defined by `is\\_data\\_valid` or invalid models defined by `is\\_model\\_valid`.\n     */\n    max_skips?: number\n\n    /**\n      Stop iteration if at least this number of inliers are found.\n     */\n    stop_n_inliers?: number\n\n    /**\n      Stop iteration if score is greater equal than this threshold.\n     */\n    stop_score?: number\n\n    /**\n      RANSAC iteration stops if at least one outlier-free set of the training data is sampled in RANSAC. This requires to generate at least N samples (iterations):\n\n      @defaultValue `0.99`\n     */\n    stop_probability?: number\n\n    /**\n      String inputs, ‘absolute\\_error’ and ‘squared\\_error’ are supported which find the absolute error and squared error per sample respectively.\n\n      If `loss` is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on `X\\[i\\]`.\n\n      If the loss on a sample is greater than the `residual\\_threshold`, then this sample is classified as an outlier.\n\n      @defaultValue `'absolute_error'`\n     */\n    loss?: string\n\n    /**\n      The generator used to initialize the centers. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `RANSACRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RANSACRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import RANSACRegressor\ntry: bridgeRANSACRegressor\nexcept NameError: bridgeRANSACRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RANSACRegressor = {'estimator': ${\n      this.opts['estimator'] ?? undefined\n    }, 'min_samples': ${\n      this.opts['min_samples'] ?? undefined\n    }, 'residual_threshold': ${\n      this.opts['residual_threshold'] ?? undefined\n    }, 'is_data_valid': ${\n      this.opts['is_data_valid'] ?? undefined\n    }, 'is_model_valid': ${\n      this.opts['is_model_valid'] ?? undefined\n    }, 'max_trials': ${this.opts['max_trials'] ?? undefined}, 'max_skips': ${\n      this.opts['max_skips'] ?? undefined\n    }, 'stop_n_inliers': ${\n      this.opts['stop_n_inliers'] ?? undefined\n    }, 'stop_score': ${\n      this.opts['stop_score'] ?? undefined\n    }, 'stop_probability': ${\n      this.opts['stop_probability'] ?? undefined\n    }, 'loss': ${this.opts['loss'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_RANSACRegressor = {k: v for k, v in ctor_RANSACRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRANSACRegressor[${this.id}] = RANSACRegressor(**ctor_RANSACRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRANSACRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit estimator using RANSAC algorithm.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Individual weights for each sample raises error if sample\\_weight is passed and estimator fit method does not support it.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RANSACRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RANSACRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RANSACRegressor_fit = {k: v for k, v in pms_RANSACRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RANSACRegressor_fit = bridgeRANSACRegressor[${this.id}].fit(**pms_RANSACRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RANSACRegressor_fit.tolist() if hasattr(res_RANSACRegressor_fit, 'tolist') else res_RANSACRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RANSACRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RANSACRegressor_get_metadata_routing = {k: v for k, v in pms_RANSACRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RANSACRegressor_get_metadata_routing = bridgeRANSACRegressor[${this.id}].get_metadata_routing(**pms_RANSACRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RANSACRegressor_get_metadata_routing.tolist() if hasattr(res_RANSACRegressor_get_metadata_routing, 'tolist') else res_RANSACRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using the estimated model.\n\n    This is a wrapper for `estimator\\_.predict(X)`.\n   */\n  async predict(opts: {\n    /**\n      Input data.\n     */\n    X?: any[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RANSACRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RANSACRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RANSACRegressor_predict = {k: v for k, v in pms_RANSACRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RANSACRegressor_predict = bridgeRANSACRegressor[${this.id}].predict(**pms_RANSACRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RANSACRegressor_predict.tolist() if hasattr(res_RANSACRegressor_predict, 'tolist') else res_RANSACRegressor_predict`\n  }\n\n  /**\n    Return the score of the prediction.\n\n    This is a wrapper for `estimator\\_.score(X, y)`.\n   */\n  async score(opts: {\n    /**\n      Training data.\n     */\n    X?: any[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RANSACRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RANSACRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_RANSACRegressor_score = {k: v for k, v in pms_RANSACRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RANSACRegressor_score = bridgeRANSACRegressor[${this.id}].score(**pms_RANSACRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RANSACRegressor_score.tolist() if hasattr(res_RANSACRegressor_score, 'tolist') else res_RANSACRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RANSACRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RANSACRegressor_set_fit_request = {k: v for k, v in pms_RANSACRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RANSACRegressor_set_fit_request = bridgeRANSACRegressor[${this.id}].set_fit_request(**pms_RANSACRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RANSACRegressor_set_fit_request.tolist() if hasattr(res_RANSACRegressor_set_fit_request, 'tolist') else res_RANSACRegressor_set_fit_request`\n  }\n\n  /**\n    Best fitted model (copy of the `estimator` object).\n   */\n  get estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing estimator_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_estimator_ = bridgeRANSACRegressor[${this.id}].estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_estimator_.tolist() if hasattr(attr_RANSACRegressor_estimator_, 'tolist') else attr_RANSACRegressor_estimator_`\n    })()\n  }\n\n  /**\n    Number of random selection trials until one of the stop criteria is met. It is always `<= max\\_trials`.\n   */\n  get n_trials_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing n_trials_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_n_trials_ = bridgeRANSACRegressor[${this.id}].n_trials_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_n_trials_.tolist() if hasattr(attr_RANSACRegressor_n_trials_, 'tolist') else attr_RANSACRegressor_n_trials_`\n    })()\n  }\n\n  /**\n    Boolean mask of inliers classified as `true`.\n   */\n  get inlier_mask_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing inlier_mask_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_inlier_mask_ = bridgeRANSACRegressor[${this.id}].inlier_mask_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_inlier_mask_.tolist() if hasattr(attr_RANSACRegressor_inlier_mask_, 'tolist') else attr_RANSACRegressor_inlier_mask_`\n    })()\n  }\n\n  /**\n    Number of iterations skipped due to finding zero inliers.\n   */\n  get n_skips_no_inliers_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing n_skips_no_inliers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_n_skips_no_inliers_ = bridgeRANSACRegressor[${this.id}].n_skips_no_inliers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_n_skips_no_inliers_.tolist() if hasattr(attr_RANSACRegressor_n_skips_no_inliers_, 'tolist') else attr_RANSACRegressor_n_skips_no_inliers_`\n    })()\n  }\n\n  /**\n    Number of iterations skipped due to invalid data defined by `is\\_data\\_valid`.\n   */\n  get n_skips_invalid_data_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing n_skips_invalid_data_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_n_skips_invalid_data_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_data_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_n_skips_invalid_data_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_data_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_data_`\n    })()\n  }\n\n  /**\n    Number of iterations skipped due to an invalid model defined by `is\\_model\\_valid`.\n   */\n  get n_skips_invalid_model_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing n_skips_invalid_model_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_n_skips_invalid_model_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_model_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_n_skips_invalid_model_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_model_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_model_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_n_features_in_ = bridgeRANSACRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_n_features_in_.tolist() if hasattr(attr_RANSACRegressor_n_features_in_, 'tolist') else attr_RANSACRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RANSACRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RANSACRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RANSACRegressor_feature_names_in_ = bridgeRANSACRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RANSACRegressor_feature_names_in_.tolist() if hasattr(attr_RANSACRegressor_feature_names_in_, 'tolist') else attr_RANSACRegressor_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear least squares with l2 regularization.\n\n  Minimizes the objective function:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html)\n */\nexport class Ridge {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Constant that multiplies the L2 term, controlling regularization strength. `alpha` must be a non-negative float i.e. in `\\[0, inf)`.\n\n      When `alpha \\= 0`, the objective is equivalent to ordinary least squares, solved by the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object. For numerical reasons, using `alpha \\= 0` with the `Ridge` object is not advised. Instead, you should use the [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") object.\n\n      If an array is passed, penalties are assumed to be specific to the targets. Hence they must correspond in number.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether to fit the intercept for this model. If set to false, no intercept will be used in calculations (i.e. `X` and `y` are expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Maximum number of iterations for conjugate gradient solver. For ‘sparse\\_cg’ and ‘lsqr’ solvers, the default value is determined by scipy.sparse.linalg. For ‘sag’ solver, the default value is 1000. For ‘lbfgs’ solver, the default value is 15000.\n     */\n    max_iter?: number\n\n    /**\n      The precision of the solution (`coef\\_`) is determined by `tol` which specifies a different convergence criterion for each solver:\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Solver to use in the computational routines:\n\n      @defaultValue `'auto'`\n     */\n    solver?:\n      | 'auto'\n      | 'svd'\n      | 'cholesky'\n      | 'lsqr'\n      | 'sparse_cg'\n      | 'sag'\n      | 'saga'\n      | 'lbfgs'\n\n    /**\n      When set to `true`, forces the coefficients to be positive. Only ‘lbfgs’ solver is supported in this case.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      Used when `solver` == ‘sag’ or ‘saga’ to shuffle the data. See [Glossary](../../glossary.html#term-random_state) for details.\n     */\n    random_state?: number\n  }) {\n    this.id = `Ridge${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Ridge.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import Ridge\ntry: bridgeRidge\nexcept NameError: bridgeRidge = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Ridge = {'alpha': np.array(${\n      this.opts['alpha'] ?? undefined\n    }) if ${this.opts['alpha'] !== undefined} else None, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_Ridge = {k: v for k, v in ctor_Ridge.items() if v is not None}`\n\n    await this._py.ex`bridgeRidge[${this.id}] = Ridge(**ctor_Ridge)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRidge[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit Ridge regression model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: NDArray | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n\n    /**\n      Individual weights for each sample. If given a float, every sample will have the same weight.\n     */\n    sample_weight?: number | NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_Ridge_fit = {k: v for k, v in pms_Ridge_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_fit = bridgeRidge[${this.id}].fit(**pms_Ridge_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_fit.tolist() if hasattr(res_Ridge_fit, 'tolist') else res_Ridge_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_Ridge_get_metadata_routing = {k: v for k, v in pms_Ridge_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_get_metadata_routing = bridgeRidge[${this.id}].get_metadata_routing(**pms_Ridge_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_get_metadata_routing.tolist() if hasattr(res_Ridge_get_metadata_routing, 'tolist') else res_Ridge_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_Ridge_predict = {k: v for k, v in pms_Ridge_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_predict = bridgeRidge[${this.id}].predict(**pms_Ridge_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_predict.tolist() if hasattr(res_Ridge_predict, 'tolist') else res_Ridge_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_Ridge_score = {k: v for k, v in pms_Ridge_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_score = bridgeRidge[${this.id}].score(**pms_Ridge_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_score.tolist() if hasattr(res_Ridge_score, 'tolist') else res_Ridge_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Ridge_set_fit_request = {k: v for k, v in pms_Ridge_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_set_fit_request = bridgeRidge[${this.id}].set_fit_request(**pms_Ridge_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_set_fit_request.tolist() if hasattr(res_Ridge_set_fit_request, 'tolist') else res_Ridge_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Ridge_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_Ridge_set_score_request = {k: v for k, v in pms_Ridge_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Ridge_set_score_request = bridgeRidge[${this.id}].set_score_request(**pms_Ridge_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Ridge_set_score_request.tolist() if hasattr(res_Ridge_set_score_request, 'tolist') else res_Ridge_set_score_request`\n  }\n\n  /**\n    Weight vector(s).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Ridge_coef_ = bridgeRidge[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Ridge_coef_.tolist() if hasattr(attr_Ridge_coef_, 'tolist') else attr_Ridge_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Ridge_intercept_ = bridgeRidge[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Ridge_intercept_.tolist() if hasattr(attr_Ridge_intercept_, 'tolist') else attr_Ridge_intercept_`\n    })()\n  }\n\n  /**\n    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Ridge_n_iter_ = bridgeRidge[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Ridge_n_iter_.tolist() if hasattr(attr_Ridge_n_iter_, 'tolist') else attr_Ridge_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Ridge must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Ridge_n_features_in_ = bridgeRidge[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Ridge_n_features_in_.tolist() if hasattr(attr_Ridge_n_features_in_, 'tolist') else attr_Ridge_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Ridge instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Ridge must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Ridge_feature_names_in_ = bridgeRidge[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Ridge_feature_names_in_.tolist() if hasattr(attr_Ridge_feature_names_in_, 'tolist') else attr_Ridge_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Classifier using Ridge regression.\n\n  This classifier first converts the target values into `{-1, 1}` and then treats the problem as a regression task (multi-output regression in the multiclass case).\n\n  Read more in the [User Guide](../linear_model.html#ridge-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeClassifier.html)\n */\nexport class RidgeClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Alpha corresponds to `1 / (2C)` in other linear models such as [`LogisticRegression`](sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression \"sklearn.linear_model.LogisticRegression\") or [`LinearSVC`](sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\").\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (e.g. data is expected to be already centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Maximum number of iterations for conjugate gradient solver. The default value is determined by scipy.sparse.linalg.\n     */\n    max_iter?: number\n\n    /**\n      The precision of the solution (`coef\\_`) is determined by `tol` which specifies a different convergence criterion for each solver:\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      Weights associated with classes in the form `{class\\_label: weight}`. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Solver to use in the computational routines:\n\n      @defaultValue `'auto'`\n     */\n    solver?:\n      | 'auto'\n      | 'svd'\n      | 'cholesky'\n      | 'lsqr'\n      | 'sparse_cg'\n      | 'sag'\n      | 'saga'\n      | 'lbfgs'\n\n    /**\n      When set to `true`, forces the coefficients to be positive. Only ‘lbfgs’ solver is supported in this case.\n\n      @defaultValue `false`\n     */\n    positive?: boolean\n\n    /**\n      Used when `solver` == ‘sag’ or ‘saga’ to shuffle the data. See [Glossary](../../glossary.html#term-random_state) for details.\n     */\n    random_state?: number\n  }) {\n    this.id = `RidgeClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RidgeClassifier.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import RidgeClassifier\ntry: bridgeRidgeClassifier\nexcept NameError: bridgeRidgeClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RidgeClassifier = {'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_intercept': ${this.opts['fit_intercept'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'positive': ${this.opts['positive'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_RidgeClassifier = {k: v for k, v in ctor_RidgeClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRidgeClassifier[${this.id}] = RidgeClassifier(**ctor_RidgeClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRidgeClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RidgeClassifier_decision_function = {k: v for k, v in pms_RidgeClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_decision_function = bridgeRidgeClassifier[${this.id}].decision_function(**pms_RidgeClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_decision_function.tolist() if hasattr(res_RidgeClassifier_decision_function, 'tolist') else res_RidgeClassifier_decision_function`\n  }\n\n  /**\n    Fit Ridge classifier model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: NDArray | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n\n    /**\n      Individual weights for each sample. If given a float, every sample will have the same weight.\n     */\n    sample_weight?: number | NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeClassifier_fit = {k: v for k, v in pms_RidgeClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_fit = bridgeRidgeClassifier[${this.id}].fit(**pms_RidgeClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_fit.tolist() if hasattr(res_RidgeClassifier_fit, 'tolist') else res_RidgeClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RidgeClassifier_get_metadata_routing = {k: v for k, v in pms_RidgeClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_get_metadata_routing = bridgeRidgeClassifier[${this.id}].get_metadata_routing(**pms_RidgeClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_get_metadata_routing.tolist() if hasattr(res_RidgeClassifier_get_metadata_routing, 'tolist') else res_RidgeClassifier_get_metadata_routing`\n  }\n\n  /**\n    Predict class labels for samples in `X`.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to predict the targets.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RidgeClassifier_predict = {k: v for k, v in pms_RidgeClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_predict = bridgeRidgeClassifier[${this.id}].predict(**pms_RidgeClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_predict.tolist() if hasattr(res_RidgeClassifier_predict, 'tolist') else res_RidgeClassifier_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeClassifier_score = {k: v for k, v in pms_RidgeClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_score = bridgeRidgeClassifier[${this.id}].score(**pms_RidgeClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_score.tolist() if hasattr(res_RidgeClassifier_score, 'tolist') else res_RidgeClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifier_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeClassifier_set_fit_request = {k: v for k, v in pms_RidgeClassifier_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_set_fit_request = bridgeRidgeClassifier[${this.id}].set_fit_request(**pms_RidgeClassifier_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_set_fit_request.tolist() if hasattr(res_RidgeClassifier_set_fit_request, 'tolist') else res_RidgeClassifier_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RidgeClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeClassifier_set_score_request = {k: v for k, v in pms_RidgeClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifier_set_score_request = bridgeRidgeClassifier[${this.id}].set_score_request(**pms_RidgeClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifier_set_score_request.tolist() if hasattr(res_RidgeClassifier_set_score_request, 'tolist') else res_RidgeClassifier_set_score_request`\n  }\n\n  /**\n    Coefficient of the features in the decision function.\n\n    `coef\\_` is of shape (1, n\\_features) when the given problem is binary.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifier must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifier_coef_ = bridgeRidgeClassifier[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifier_coef_.tolist() if hasattr(attr_RidgeClassifier_coef_, 'tolist') else attr_RidgeClassifier_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifier_intercept_ = bridgeRidgeClassifier[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifier_intercept_.tolist() if hasattr(attr_RidgeClassifier_intercept_, 'tolist') else attr_RidgeClassifier_intercept_`\n    })()\n  }\n\n  /**\n    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifier_n_iter_ = bridgeRidgeClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifier_n_iter_.tolist() if hasattr(attr_RidgeClassifier_n_iter_, 'tolist') else attr_RidgeClassifier_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifier_n_features_in_ = bridgeRidgeClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifier_n_features_in_.tolist() if hasattr(attr_RidgeClassifier_n_features_in_, 'tolist') else attr_RidgeClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifier_feature_names_in_ = bridgeRidgeClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifier_feature_names_in_.tolist() if hasattr(attr_RidgeClassifier_feature_names_in_, 'tolist') else attr_RidgeClassifier_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Ridge classifier with built-in cross-validation.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  By default, it performs Leave-One-Out Cross-Validation. Currently, only the n\\_features > n\\_samples case is handled efficiently.\n\n  Read more in the [User Guide](../linear_model.html#ridge-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeClassifierCV.html)\n */\nexport class RidgeClassifierCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Array of alpha values to try. Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Alpha corresponds to `1 / (2C)` in other linear models such as [`LogisticRegression`](sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression \"sklearn.linear_model.LogisticRegression\") or [`LinearSVC`](sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\").\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      A string (see model evaluation documentation) or a scorer callable object / function with signature `scorer(estimator, X, y)`.\n     */\n    scoring?: string\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Weights associated with classes in the form `{class\\_label: weight}`. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Flag indicating if the cross-validation values corresponding to each alpha should be stored in the `cv\\_values\\_` attribute (see below). This flag is only compatible with `cv=None` (i.e. using Leave-One-Out Cross-Validation).\n\n      @defaultValue `false`\n     */\n    store_cv_values?: boolean\n  }) {\n    this.id = `RidgeClassifierCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RidgeClassifierCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import RidgeClassifierCV\ntry: bridgeRidgeClassifierCV\nexcept NameError: bridgeRidgeClassifierCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RidgeClassifierCV = {'alphas': np.array(${\n      this.opts['alphas'] ?? undefined\n    }) if ${this.opts['alphas'] !== undefined} else None, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'scoring': ${this.opts['scoring'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'class_weight': ${\n      this.opts['class_weight'] ?? undefined\n    }, 'store_cv_values': ${this.opts['store_cv_values'] ?? undefined}}\n\nctor_RidgeClassifierCV = {k: v for k, v in ctor_RidgeClassifierCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeRidgeClassifierCV[${this.id}] = RidgeClassifierCV(**ctor_RidgeClassifierCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRidgeClassifierCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RidgeClassifierCV_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RidgeClassifierCV_decision_function = {k: v for k, v in pms_RidgeClassifierCV_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_decision_function = bridgeRidgeClassifierCV[${this.id}].decision_function(**pms_RidgeClassifierCV_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_decision_function.tolist() if hasattr(res_RidgeClassifierCV_decision_function, 'tolist') else res_RidgeClassifierCV_decision_function`\n  }\n\n  /**\n    Fit Ridge classifier with cv.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. When using GCV, will be cast to float64 if necessary.\n     */\n    X?: NDArray[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray\n\n    /**\n      Individual weights for each sample. If given a float, every sample will have the same weight.\n     */\n    sample_weight?: number | NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifierCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifierCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeClassifierCV_fit = {k: v for k, v in pms_RidgeClassifierCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_fit = bridgeRidgeClassifierCV[${this.id}].fit(**pms_RidgeClassifierCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_fit.tolist() if hasattr(res_RidgeClassifierCV_fit, 'tolist') else res_RidgeClassifierCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RidgeClassifierCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RidgeClassifierCV_get_metadata_routing = {k: v for k, v in pms_RidgeClassifierCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_get_metadata_routing = bridgeRidgeClassifierCV[${this.id}].get_metadata_routing(**pms_RidgeClassifierCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_get_metadata_routing.tolist() if hasattr(res_RidgeClassifierCV_get_metadata_routing, 'tolist') else res_RidgeClassifierCV_get_metadata_routing`\n  }\n\n  /**\n    Predict class labels for samples in `X`.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to predict the targets.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifierCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifierCV_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_RidgeClassifierCV_predict = {k: v for k, v in pms_RidgeClassifierCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_predict = bridgeRidgeClassifierCV[${this.id}].predict(**pms_RidgeClassifierCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_predict.tolist() if hasattr(res_RidgeClassifierCV_predict, 'tolist') else res_RidgeClassifierCV_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeClassifierCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeClassifierCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeClassifierCV_score = {k: v for k, v in pms_RidgeClassifierCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_score = bridgeRidgeClassifierCV[${this.id}].score(**pms_RidgeClassifierCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_score.tolist() if hasattr(res_RidgeClassifierCV_score, 'tolist') else res_RidgeClassifierCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RidgeClassifierCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeClassifierCV_set_fit_request = {k: v for k, v in pms_RidgeClassifierCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_set_fit_request = bridgeRidgeClassifierCV[${this.id}].set_fit_request(**pms_RidgeClassifierCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_set_fit_request.tolist() if hasattr(res_RidgeClassifierCV_set_fit_request, 'tolist') else res_RidgeClassifierCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_RidgeClassifierCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeClassifierCV_set_score_request = {k: v for k, v in pms_RidgeClassifierCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeClassifierCV_set_score_request = bridgeRidgeClassifierCV[${this.id}].set_score_request(**pms_RidgeClassifierCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeClassifierCV_set_score_request.tolist() if hasattr(res_RidgeClassifierCV_set_score_request, 'tolist') else res_RidgeClassifierCV_set_score_request`\n  }\n\n  /**\n    Cross-validation values for each alpha (only if `store\\_cv\\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.\n   */\n  get cv_values_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing cv_values_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_cv_values_ = bridgeRidgeClassifierCV[${this.id}].cv_values_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_cv_values_.tolist() if hasattr(attr_RidgeClassifierCV_cv_values_, 'tolist') else attr_RidgeClassifierCV_cv_values_`\n    })()\n  }\n\n  /**\n    Coefficient of the features in the decision function.\n\n    `coef\\_` is of shape (1, n\\_features) when the given problem is binary.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_coef_ = bridgeRidgeClassifierCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_coef_.tolist() if hasattr(attr_RidgeClassifierCV_coef_, 'tolist') else attr_RidgeClassifierCV_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_intercept_ = bridgeRidgeClassifierCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_intercept_.tolist() if hasattr(attr_RidgeClassifierCV_intercept_, 'tolist') else attr_RidgeClassifierCV_intercept_`\n    })()\n  }\n\n  /**\n    Estimated regularization parameter.\n   */\n  get alpha_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing alpha_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_alpha_ = bridgeRidgeClassifierCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_alpha_.tolist() if hasattr(attr_RidgeClassifierCV_alpha_, 'tolist') else attr_RidgeClassifierCV_alpha_`\n    })()\n  }\n\n  /**\n    Score of base estimator with best alpha.\n   */\n  get best_score_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing best_score_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_best_score_ = bridgeRidgeClassifierCV[${this.id}].best_score_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_best_score_.tolist() if hasattr(attr_RidgeClassifierCV_best_score_, 'tolist') else attr_RidgeClassifierCV_best_score_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_n_features_in_ = bridgeRidgeClassifierCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_n_features_in_.tolist() if hasattr(attr_RidgeClassifierCV_n_features_in_, 'tolist') else attr_RidgeClassifierCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This RidgeClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeClassifierCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeClassifierCV_feature_names_in_ = bridgeRidgeClassifierCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeClassifierCV_feature_names_in_.tolist() if hasattr(attr_RidgeClassifierCV_feature_names_in_, 'tolist') else attr_RidgeClassifierCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Ridge regression with built-in cross-validation.\n\n  See glossary entry for [cross-validation estimator](../../glossary.html#term-cross-validation-estimator).\n\n  By default, it performs efficient Leave-One-Out Cross-Validation.\n\n  Read more in the [User Guide](../linear_model.html#ridge-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeCV.html)\n */\nexport class RidgeCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Array of alpha values to try. Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Alpha corresponds to `1 / (2C)` in other linear models such as [`LogisticRegression`](sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression \"sklearn.linear_model.LogisticRegression\") or [`LinearSVC`](sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\"). If using Leave-One-Out cross-validation, alphas must be positive.\n     */\n    alphas?: ArrayLike\n\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (i.e. data is expected to be centered).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      A string (see model evaluation documentation) or a scorer callable object / function with signature `scorer(estimator, X, y)`. If `undefined`, the negative mean squared error if cv is ‘auto’ or `undefined` (i.e. when using leave-one-out cross-validation), and r2 score otherwise.\n     */\n    scoring?: string\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number\n\n    /**\n      Flag indicating which strategy to use when performing Leave-One-Out Cross-Validation. Options are:\n\n      @defaultValue `'auto'`\n     */\n    gcv_mode?: 'auto' | 'svd' | 'eigen'\n\n    /**\n      Flag indicating if the cross-validation values corresponding to each alpha should be stored in the `cv\\_values\\_` attribute (see below). This flag is only compatible with `cv=None` (i.e. using Leave-One-Out Cross-Validation).\n\n      @defaultValue `false`\n     */\n    store_cv_values?: boolean\n\n    /**\n      Flag indicating whether to optimize the alpha value (picked from the `alphas` parameter list) for each target separately (for multi-output settings: multiple prediction targets). When set to `true`, after fitting, the `alpha\\_` attribute will contain a value for each target. When set to `false`, a single alpha is used for all targets.\n\n      @defaultValue `false`\n     */\n    alpha_per_target?: boolean\n  }) {\n    this.id = `RidgeCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('RidgeCV.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import RidgeCV\ntry: bridgeRidgeCV\nexcept NameError: bridgeRidgeCV = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_RidgeCV = {'alphas': np.array(${\n      this.opts['alphas'] ?? undefined\n    }) if ${this.opts['alphas'] !== undefined} else None, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'scoring': ${this.opts['scoring'] ?? undefined}, 'cv': ${\n      this.opts['cv'] ?? undefined\n    }, 'gcv_mode': ${this.opts['gcv_mode'] ?? undefined}, 'store_cv_values': ${\n      this.opts['store_cv_values'] ?? undefined\n    }, 'alpha_per_target': ${this.opts['alpha_per_target'] ?? undefined}}\n\nctor_RidgeCV = {k: v for k, v in ctor_RidgeCV.items() if v is not None}`\n\n    await this._py.ex`bridgeRidgeCV[${this.id}] = RidgeCV(**ctor_RidgeCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeRidgeCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit Ridge regression model with cv.\n   */\n  async fit(opts: {\n    /**\n      Training data. If using GCV, will be cast to float64 if necessary.\n     */\n    X?: NDArray[]\n\n    /**\n      Target values. Will be cast to X’s dtype if necessary.\n     */\n    y?: NDArray\n\n    /**\n      Individual weights for each sample. If given a float, every sample will have the same weight.\n     */\n    sample_weight?: number | NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeCV_fit = {k: v for k, v in pms_RidgeCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_fit = bridgeRidgeCV[${this.id}].fit(**pms_RidgeCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_fit.tolist() if hasattr(res_RidgeCV_fit, 'tolist') else res_RidgeCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_RidgeCV_get_metadata_routing = {k: v for k, v in pms_RidgeCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_get_metadata_routing = bridgeRidgeCV[${this.id}].get_metadata_routing(**pms_RidgeCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_get_metadata_routing.tolist() if hasattr(res_RidgeCV_get_metadata_routing, 'tolist') else res_RidgeCV_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_predict = {'X': ${opts['X'] ?? undefined}}\n\npms_RidgeCV_predict = {k: v for k, v in pms_RidgeCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_predict = bridgeRidgeCV[${this.id}].predict(**pms_RidgeCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_predict.tolist() if hasattr(res_RidgeCV_predict, 'tolist') else res_RidgeCV_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_RidgeCV_score = {k: v for k, v in pms_RidgeCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_score = bridgeRidgeCV[${this.id}].score(**pms_RidgeCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_score.tolist() if hasattr(res_RidgeCV_score, 'tolist') else res_RidgeCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeCV_set_fit_request = {k: v for k, v in pms_RidgeCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_set_fit_request = bridgeRidgeCV[${this.id}].set_fit_request(**pms_RidgeCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_set_fit_request.tolist() if hasattr(res_RidgeCV_set_fit_request, 'tolist') else res_RidgeCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_RidgeCV_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_RidgeCV_set_score_request = {k: v for k, v in pms_RidgeCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_RidgeCV_set_score_request = bridgeRidgeCV[${this.id}].set_score_request(**pms_RidgeCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_RidgeCV_set_score_request.tolist() if hasattr(res_RidgeCV_set_score_request, 'tolist') else res_RidgeCV_set_score_request`\n  }\n\n  /**\n    Cross-validation values for each alpha (only available if `store\\_cv\\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.\n   */\n  get cv_values_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before accessing cv_values_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeCV_cv_values_ = bridgeRidgeCV[${this.id}].cv_values_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_cv_values_.tolist() if hasattr(attr_RidgeCV_cv_values_, 'tolist') else attr_RidgeCV_cv_values_`\n    })()\n  }\n\n  /**\n    Weight vector(s).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RidgeCV_coef_ = bridgeRidgeCV[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_coef_.tolist() if hasattr(attr_RidgeCV_coef_, 'tolist') else attr_RidgeCV_coef_`\n    })()\n  }\n\n  /**\n    Independent term in decision function. Set to 0.0 if `fit\\_intercept \\= False`.\n   */\n  get intercept_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeCV_intercept_ = bridgeRidgeCV[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_intercept_.tolist() if hasattr(attr_RidgeCV_intercept_, 'tolist') else attr_RidgeCV_intercept_`\n    })()\n  }\n\n  /**\n    Estimated regularization parameter, or, if `alpha\\_per\\_target=True`, the estimated regularization parameter for each target.\n   */\n  get alpha_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before accessing alpha_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_RidgeCV_alpha_ = bridgeRidgeCV[${this.id}].alpha_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_alpha_.tolist() if hasattr(attr_RidgeCV_alpha_, 'tolist') else attr_RidgeCV_alpha_`\n    })()\n  }\n\n  /**\n    Score of base estimator with best alpha, or, if `alpha\\_per\\_target=True`, a score for each target.\n   */\n  get best_score_(): Promise<number | NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('RidgeCV must call init() before accessing best_score_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeCV_best_score_ = bridgeRidgeCV[${this.id}].best_score_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_best_score_.tolist() if hasattr(attr_RidgeCV_best_score_, 'tolist') else attr_RidgeCV_best_score_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeCV_n_features_in_ = bridgeRidgeCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_n_features_in_.tolist() if hasattr(attr_RidgeCV_n_features_in_, 'tolist') else attr_RidgeCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This RidgeCV instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'RidgeCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_RidgeCV_feature_names_in_ = bridgeRidgeCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_RidgeCV_feature_names_in_.tolist() if hasattr(attr_RidgeCV_feature_names_in_, 'tolist') else attr_RidgeCV_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear classifiers (SVM, logistic regression, etc.) with SGD training.\n\n  This estimator implements regularized linear models with stochastic gradient descent (SGD) learning: the gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule (aka learning rate). SGD allows minibatch (online/out-of-core) learning via the `partial\\_fit` method. For best results using the default learning rate schedule, the data should have zero mean and unit variance.\n\n  This implementation works with data represented as dense or sparse arrays of floating point values for the features. The model it fits can be controlled with the loss parameter; by default, it fits a linear support vector machine (SVM).\n\n  The regularizer is a penalty added to the loss function that shrinks model parameters towards the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a combination of both (Elastic Net). If the parameter update crosses the 0.0 value because of the regularizer, the update is truncated to 0.0 to allow for learning sparse models and achieve online feature selection.\n\n  Read more in the [User Guide](../sgd.html#sgd).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html)\n */\nexport class SGDClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The loss function to be used.\n\n      @defaultValue `'hinge'`\n     */\n    loss?:\n      | 'hinge'\n      | 'log_loss'\n      | 'modified_huber'\n      | 'squared_hinge'\n      | 'perceptron'\n      | 'squared_error'\n      | 'huber'\n      | 'epsilon_insensitive'\n      | 'squared_epsilon_insensitive'\n\n    /**\n      The penalty (aka regularization term) to be used. Defaults to ‘l2’ which is the standard regularizer for linear SVM models. ‘l1’ and ‘elasticnet’ might bring sparsity to the model (feature selection) not achievable with ‘l2’. No penalty is added when set to `undefined`.\n\n      @defaultValue `'l2'`\n     */\n    penalty?: 'l2' | 'l1' | 'elasticnet'\n\n    /**\n      Constant that multiplies the regularization term. The higher the value, the stronger the regularization. Also used to compute the learning rate when `learning\\_rate` is set to ‘optimal’. Values must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `0.0001`\n     */\n    alpha?: number\n\n    /**\n      The Elastic Net mixing parameter, with 0 <= l1\\_ratio <= 1. l1\\_ratio=0 corresponds to L2 penalty, l1\\_ratio=1 to L1. Only used if `penalty` is ‘elasticnet’. Values must be in the range `\\[0.0, 1.0\\]`.\n\n      @defaultValue `0.15`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether the intercept should be estimated or not. If `false`, the data is assumed to be already centered.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the `fit` method, and not the [`partial\\_fit`](#sklearn.linear_model.SGDClassifier.partial_fit \"sklearn.linear_model.SGDClassifier.partial_fit\") method. Values must be in the range `\\[1, inf)`.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The stopping criterion. If it is not `undefined`, training will stop when (loss > best\\_loss - tol) for `n\\_iter\\_no\\_change` consecutive epochs. Convergence is checked against the training loss or the validation loss depending on the `early\\_stopping` parameter. Values must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Whether or not the training data should be shuffled after each epoch.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      The verbosity level. Values must be in the range `\\[0, inf)`.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Epsilon in the epsilon-insensitive loss functions; only if `loss` is ‘huber’, ‘epsilon\\_insensitive’, or ‘squared\\_epsilon\\_insensitive’. For ‘huber’, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold. Values must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `0.1`\n     */\n    epsilon?: number\n\n    /**\n      The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Used for shuffling the data, when `shuffle` is set to `true`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state). Integer values must be in the range `\\[0, 2\\*\\*32 \\- 1\\]`.\n     */\n    random_state?: number\n\n    /**\n      The learning rate schedule:\n\n      @defaultValue `'optimal'`\n     */\n    learning_rate?: string\n\n    /**\n      The initial learning rate for the ‘constant’, ‘invscaling’ or ‘adaptive’ schedules. The default value is 0.0 as eta0 is not used by the default schedule ‘optimal’. Values must be in the range `(0.0, inf)`.\n\n      @defaultValue `0`\n     */\n    eta0?: number\n\n    /**\n      The exponent for inverse scaling learning rate \\[default 0.5\\]. Values must be in the range `(-inf, inf)`.\n\n      @defaultValue `0.5`\n     */\n    power_t?: number\n\n    /**\n      Whether to use early stopping to terminate training when validation score is not improving. If set to `true`, it will automatically set aside a stratified fraction of training data as validation and terminate training when validation score returned by the `score` method is not improving by at least tol for n\\_iter\\_no\\_change consecutive epochs.\n\n      @defaultValue `false`\n     */\n    early_stopping?: boolean\n\n    /**\n      The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if `early\\_stopping` is `true`. Values must be in the range `(0.0, 1.0)`.\n\n      @defaultValue `0.1`\n     */\n    validation_fraction?: number\n\n    /**\n      Number of iterations with no improvement to wait before stopping fitting. Convergence is checked against the training loss or the validation loss depending on the `early\\_stopping` parameter. Integer values must be in the range `\\[1, max\\_iter)`.\n\n      @defaultValue `5`\n     */\n    n_iter_no_change?: number\n\n    /**\n      Preset for the class\\_weight fit parameter.\n\n      Weights associated with classes. If not given, all classes are supposed to have weight one.\n\n      The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      Repeatedly calling fit or partial\\_fit when warm\\_start is `true` can result in a different solution than when calling fit a single time because of the way the data is shuffled. If a dynamic learning rate is used, the learning rate is adapted depending on the number of samples already seen. Calling `fit` resets this counter, while `partial\\_fit` will result in increasing the existing counter.\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      When set to `true`, computes the averaged SGD weights across all updates and stores the result in the `coef\\_` attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches `average`. So `average=10` will begin averaging after seeing 10 samples. Integer values must be in the range `\\[1, n\\_samples\\]`.\n\n      @defaultValue `false`\n     */\n    average?: boolean | number\n  }) {\n    this.id = `SGDClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SGDClassifier.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import SGDClassifier\ntry: bridgeSGDClassifier\nexcept NameError: bridgeSGDClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SGDClassifier = {'loss': ${\n      this.opts['loss'] ?? undefined\n    }, 'penalty': ${this.opts['penalty'] ?? undefined}, 'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'l1_ratio': ${this.opts['l1_ratio'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'epsilon': ${this.opts['epsilon'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'learning_rate': ${this.opts['learning_rate'] ?? undefined}, 'eta0': ${\n      this.opts['eta0'] ?? undefined\n    }, 'power_t': ${this.opts['power_t'] ?? undefined}, 'early_stopping': ${\n      this.opts['early_stopping'] ?? undefined\n    }, 'validation_fraction': ${\n      this.opts['validation_fraction'] ?? undefined\n    }, 'n_iter_no_change': ${\n      this.opts['n_iter_no_change'] ?? undefined\n    }, 'class_weight': ${\n      this.opts['class_weight'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'average': ${\n      this.opts['average'] ?? undefined\n    }}\n\nctor_SGDClassifier = {k: v for k, v in ctor_SGDClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSGDClassifier[${this.id}] = SGDClassifier(**ctor_SGDClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSGDClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Predict confidence scores for samples.\n\n    The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n   */\n  async decision_function(opts: {\n    /**\n      The data matrix for which we want to get the confidence scores.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SGDClassifier_decision_function = {k: v for k, v in pms_SGDClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_decision_function = bridgeSGDClassifier[${this.id}].decision_function(**pms_SGDClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_decision_function.tolist() if hasattr(res_SGDClassifier_decision_function, 'tolist') else res_SGDClassifier_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_densify = {}\n\npms_SGDClassifier_densify = {k: v for k, v in pms_SGDClassifier_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_densify = bridgeSGDClassifier[${this.id}].densify(**pms_SGDClassifier_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_densify.tolist() if hasattr(res_SGDClassifier_densify, 'tolist') else res_SGDClassifier_densify`\n  }\n\n  /**\n    Fit linear model with Stochastic Gradient Descent.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n\n    /**\n      The initial coefficients to warm-start the optimization.\n     */\n    coef_init?: NDArray[]\n\n    /**\n      The initial intercept to warm-start the optimization.\n     */\n    intercept_init?: NDArray\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed. These weights will be multiplied with class\\_weight (passed through the constructor) if class\\_weight is specified.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'intercept_init': np.array(${\n      opts['intercept_init'] ?? undefined\n    }) if ${opts['intercept_init'] !== undefined} else None, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDClassifier_fit = {k: v for k, v in pms_SGDClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_fit = bridgeSGDClassifier[${this.id}].fit(**pms_SGDClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_fit.tolist() if hasattr(res_SGDClassifier_fit, 'tolist') else res_SGDClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SGDClassifier_get_metadata_routing = {k: v for k, v in pms_SGDClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_get_metadata_routing = bridgeSGDClassifier[${this.id}].get_metadata_routing(**pms_SGDClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_get_metadata_routing.tolist() if hasattr(res_SGDClassifier_get_metadata_routing, 'tolist') else res_SGDClassifier_get_metadata_routing`\n  }\n\n  /**\n    Perform one epoch of stochastic gradient descent on given samples.\n\n    Internally, this method uses `max\\_iter \\= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.\n   */\n  async partial_fit(opts: {\n    /**\n      Subset of the training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Subset of the target values.\n     */\n    y?: NDArray\n\n    /**\n      Classes across all calls to partial\\_fit. Can be obtained by via `np.unique(y\\_all)`, where y\\_all is the target vector of the entire dataset. This argument is required for the first call to partial\\_fit and can be omitted in the subsequent calls. Note that y doesn’t need to contain all labels in `classes`.\n     */\n    classes?: NDArray\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_partial_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'classes': np.array(${opts['classes'] ?? undefined}) if ${\n      opts['classes'] !== undefined\n    } else None, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_SGDClassifier_partial_fit = {k: v for k, v in pms_SGDClassifier_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_partial_fit = bridgeSGDClassifier[${this.id}].partial_fit(**pms_SGDClassifier_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_partial_fit.tolist() if hasattr(res_SGDClassifier_partial_fit, 'tolist') else res_SGDClassifier_partial_fit`\n  }\n\n  /**\n    Predict class labels for samples in X.\n   */\n  async predict(opts: {\n    /**\n      The data matrix for which we want to get the predictions.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SGDClassifier_predict = {k: v for k, v in pms_SGDClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_predict = bridgeSGDClassifier[${this.id}].predict(**pms_SGDClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_predict.tolist() if hasattr(res_SGDClassifier_predict, 'tolist') else res_SGDClassifier_predict`\n  }\n\n  /**\n    Log of probability estimates.\n\n    This method is only available for log loss and modified Huber loss.\n\n    When loss=”modified\\_huber”, probability estimates may be hard zeros and ones, so taking the logarithm is not possible.\n\n    See `predict\\_proba` for details.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Input data for prediction.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SGDClassifier_predict_log_proba = {k: v for k, v in pms_SGDClassifier_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_predict_log_proba = bridgeSGDClassifier[${this.id}].predict_log_proba(**pms_SGDClassifier_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_predict_log_proba.tolist() if hasattr(res_SGDClassifier_predict_log_proba, 'tolist') else res_SGDClassifier_predict_log_proba`\n  }\n\n  /**\n    Probability estimates.\n\n    This method is only available for log loss and modified Huber loss.\n\n    Multiclass probability estimates are derived from binary (one-vs.-rest) estimates by simple normalization, as recommended by Zadrozny and Elkan.\n\n    Binary probability estimates for loss=”modified\\_huber” are given by (clip(decision\\_function(X), -1, 1) + 1) / 2. For other loss functions it is necessary to perform proper probability calibration by wrapping the classifier with [`CalibratedClassifierCV`](sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV \"sklearn.calibration.CalibratedClassifierCV\") instead.\n   */\n  async predict_proba(opts: {\n    /**\n      Input data for prediction.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_predict_proba = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SGDClassifier_predict_proba = {k: v for k, v in pms_SGDClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_predict_proba = bridgeSGDClassifier[${this.id}].predict_proba(**pms_SGDClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_predict_proba.tolist() if hasattr(res_SGDClassifier_predict_proba, 'tolist') else res_SGDClassifier_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SGDClassifier_score = {k: v for k, v in pms_SGDClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_score = bridgeSGDClassifier[${this.id}].score(**pms_SGDClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_score.tolist() if hasattr(res_SGDClassifier_score, 'tolist') else res_SGDClassifier_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `coef\\_init` parameter in `fit`.\n     */\n    coef_init?: string | boolean\n\n    /**\n      Metadata routing for `intercept\\_init` parameter in `fit`.\n     */\n    intercept_init?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_set_fit_request = {'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'intercept_init': ${\n      opts['intercept_init'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_SGDClassifier_set_fit_request = {k: v for k, v in pms_SGDClassifier_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_set_fit_request = bridgeSGDClassifier[${this.id}].set_fit_request(**pms_SGDClassifier_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_set_fit_request.tolist() if hasattr(res_SGDClassifier_set_fit_request, 'tolist') else res_SGDClassifier_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `classes` parameter in `partial\\_fit`.\n     */\n    classes?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_set_partial_fit_request = {'classes': ${\n      opts['classes'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_SGDClassifier_set_partial_fit_request = {k: v for k, v in pms_SGDClassifier_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_set_partial_fit_request = bridgeSGDClassifier[${this.id}].set_partial_fit_request(**pms_SGDClassifier_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_set_partial_fit_request.tolist() if hasattr(res_SGDClassifier_set_partial_fit_request, 'tolist') else res_SGDClassifier_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDClassifier_set_score_request = {k: v for k, v in pms_SGDClassifier_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_set_score_request = bridgeSGDClassifier[${this.id}].set_score_request(**pms_SGDClassifier_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_set_score_request.tolist() if hasattr(res_SGDClassifier_set_score_request, 'tolist') else res_SGDClassifier_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDClassifier_sparsify = {}\n\npms_SGDClassifier_sparsify = {k: v for k, v in pms_SGDClassifier_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDClassifier_sparsify = bridgeSGDClassifier[${this.id}].sparsify(**pms_SGDClassifier_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDClassifier_sparsify.tolist() if hasattr(res_SGDClassifier_sparsify, 'tolist') else res_SGDClassifier_sparsify`\n  }\n\n  /**\n    Weights assigned to the features.\n   */\n  get coef_(): Promise<NDArray[][]> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_coef_ = bridgeSGDClassifier[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_coef_.tolist() if hasattr(attr_SGDClassifier_coef_, 'tolist') else attr_SGDClassifier_coef_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_intercept_ = bridgeSGDClassifier[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_intercept_.tolist() if hasattr(attr_SGDClassifier_intercept_, 'tolist') else attr_SGDClassifier_intercept_`\n    })()\n  }\n\n  /**\n    The actual number of iterations before reaching the stopping criterion. For multiclass fits, it is the maximum over every binary fit.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_n_iter_ = bridgeSGDClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_n_iter_.tolist() if hasattr(attr_SGDClassifier_n_iter_, 'tolist') else attr_SGDClassifier_n_iter_`\n    })()\n  }\n\n  get loss_function_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before accessing loss_function_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_loss_function_ = bridgeSGDClassifier[${this.id}].loss_function_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_loss_function_.tolist() if hasattr(attr_SGDClassifier_loss_function_, 'tolist') else attr_SGDClassifier_loss_function_`\n    })()\n  }\n\n  get classes_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_classes_ = bridgeSGDClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_classes_.tolist() if hasattr(attr_SGDClassifier_classes_, 'tolist') else attr_SGDClassifier_classes_`\n    })()\n  }\n\n  /**\n    Number of weight updates performed during training. Same as `(n\\_iter\\_ \\* n\\_samples + 1)`.\n   */\n  get t_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDClassifier must call init() before accessing t_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_t_ = bridgeSGDClassifier[${this.id}].t_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_t_.tolist() if hasattr(attr_SGDClassifier_t_, 'tolist') else attr_SGDClassifier_t_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_n_features_in_ = bridgeSGDClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_n_features_in_.tolist() if hasattr(attr_SGDClassifier_n_features_in_, 'tolist') else attr_SGDClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDClassifier instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDClassifier_feature_names_in_ = bridgeSGDClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDClassifier_feature_names_in_.tolist() if hasattr(attr_SGDClassifier_feature_names_in_, 'tolist') else attr_SGDClassifier_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Solves linear One-Class SVM using Stochastic Gradient Descent.\n\n  This implementation is meant to be used with a kernel approximation technique (e.g. `sklearn.kernel\\_approximation.Nystroem`) to obtain results similar to `sklearn.svm.OneClassSVM` which uses a Gaussian kernel by default.\n\n  Read more in the [User Guide](../sgd.html#sgd-online-one-class-svm).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDOneClassSVM.html)\n */\nexport class SGDOneClassSVM {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The nu parameter of the One Class SVM: an upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1\\]. By default 0.5 will be taken.\n\n      @defaultValue `0.5`\n     */\n    nu?: number\n\n    /**\n      Whether the intercept should be estimated or not. Defaults to `true`.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the `fit` method, and not the `partial\\_fit`. Defaults to 1000.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The stopping criterion. If it is not `undefined`, the iterations will stop when (loss > previous\\_loss - tol). Defaults to 1e-3.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Whether or not the training data should be shuffled after each epoch. Defaults to `true`.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      The verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      The seed of the pseudo random number generator to use when shuffling the data. If int, random\\_state is the seed used by the random number generator; If RandomState instance, random\\_state is the random number generator; If `undefined`, the random number generator is the RandomState instance used by `np.random`.\n     */\n    random_state?: number\n\n    /**\n      The learning rate schedule to use with `fit`. (If using `partial\\_fit`, learning rate must be controlled directly).\n\n      @defaultValue `'optimal'`\n     */\n    learning_rate?: 'constant' | 'optimal' | 'invscaling' | 'adaptive'\n\n    /**\n      The initial learning rate for the ‘constant’, ‘invscaling’ or ‘adaptive’ schedules. The default value is 0.0 as eta0 is not used by the default schedule ‘optimal’.\n\n      @defaultValue `0`\n     */\n    eta0?: number\n\n    /**\n      The exponent for inverse scaling learning rate \\[default 0.5\\].\n\n      @defaultValue `0.5`\n     */\n    power_t?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      Repeatedly calling fit or partial\\_fit when warm\\_start is `true` can result in a different solution than when calling fit a single time because of the way the data is shuffled. If a dynamic learning rate is used, the learning rate is adapted depending on the number of samples already seen. Calling `fit` resets this counter, while `partial\\_fit` will result in increasing the existing counter.\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      When set to `true`, computes the averaged SGD weights and stores the result in the `coef\\_` attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So `average=10` will begin averaging after seeing 10 samples.\n\n      @defaultValue `false`\n     */\n    average?: boolean | number\n  }) {\n    this.id = `SGDOneClassSVM${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SGDOneClassSVM.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import SGDOneClassSVM\ntry: bridgeSGDOneClassSVM\nexcept NameError: bridgeSGDOneClassSVM = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SGDOneClassSVM = {'nu': ${\n      this.opts['nu'] ?? undefined\n    }, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'learning_rate': ${this.opts['learning_rate'] ?? undefined}, 'eta0': ${\n      this.opts['eta0'] ?? undefined\n    }, 'power_t': ${this.opts['power_t'] ?? undefined}, 'warm_start': ${\n      this.opts['warm_start'] ?? undefined\n    }, 'average': ${this.opts['average'] ?? undefined}}\n\nctor_SGDOneClassSVM = {k: v for k, v in ctor_SGDOneClassSVM.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSGDOneClassSVM[${this.id}] = SGDOneClassSVM(**ctor_SGDOneClassSVM)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSGDOneClassSVM[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Signed distance to the separating hyperplane.\n\n    Signed distance is positive for an inlier and negative for an outlier.\n   */\n  async decision_function(opts: {\n    /**\n      Testing data.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_decision_function = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_decision_function = {k: v for k, v in pms_SGDOneClassSVM_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_decision_function = bridgeSGDOneClassSVM[${this.id}].decision_function(**pms_SGDOneClassSVM_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_decision_function.tolist() if hasattr(res_SGDOneClassSVM_decision_function, 'tolist') else res_SGDOneClassSVM_decision_function`\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_densify = {}\n\npms_SGDOneClassSVM_densify = {k: v for k, v in pms_SGDOneClassSVM_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_densify = bridgeSGDOneClassSVM[${this.id}].densify(**pms_SGDOneClassSVM_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_densify.tolist() if hasattr(res_SGDOneClassSVM_densify, 'tolist') else res_SGDOneClassSVM_densify`\n  }\n\n  /**\n    Fit linear One-Class SVM with Stochastic Gradient Descent.\n\n    This solves an equivalent optimization problem of the One-Class SVM primal optimization problem and returns a weight vector w and an offset rho such that the decision function is given by <w, x> - rho.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The initial coefficients to warm-start the optimization.\n     */\n    coef_init?: any\n\n    /**\n      The initial offset to warm-start the optimization.\n     */\n    offset_init?: any\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed. These weights will be multiplied with class\\_weight (passed through the constructor) if class\\_weight is specified.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}, 'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'offset_init': ${opts['offset_init'] ?? undefined}, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_fit = {k: v for k, v in pms_SGDOneClassSVM_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_fit = bridgeSGDOneClassSVM[${this.id}].fit(**pms_SGDOneClassSVM_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_fit.tolist() if hasattr(res_SGDOneClassSVM_fit, 'tolist') else res_SGDOneClassSVM_fit`\n  }\n\n  /**\n    Perform fit on X and returns labels for X.\n\n    Returns -1 for outliers and 1 for inliers.\n   */\n  async fit_predict(opts: {\n    /**\n      The input samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_fit_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SGDOneClassSVM_fit_predict = {k: v for k, v in pms_SGDOneClassSVM_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_fit_predict = bridgeSGDOneClassSVM[${this.id}].fit_predict(**pms_SGDOneClassSVM_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_fit_predict.tolist() if hasattr(res_SGDOneClassSVM_fit_predict, 'tolist') else res_SGDOneClassSVM_fit_predict`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_get_metadata_routing = {k: v for k, v in pms_SGDOneClassSVM_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_get_metadata_routing = bridgeSGDOneClassSVM[${this.id}].get_metadata_routing(**pms_SGDOneClassSVM_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_get_metadata_routing.tolist() if hasattr(res_SGDOneClassSVM_get_metadata_routing, 'tolist') else res_SGDOneClassSVM_get_metadata_routing`\n  }\n\n  /**\n    Fit linear One-Class SVM with Stochastic Gradient Descent.\n   */\n  async partial_fit(opts: {\n    /**\n      Subset of the training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_partial_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_partial_fit = {k: v for k, v in pms_SGDOneClassSVM_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_partial_fit = bridgeSGDOneClassSVM[${this.id}].partial_fit(**pms_SGDOneClassSVM_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_partial_fit.tolist() if hasattr(res_SGDOneClassSVM_partial_fit, 'tolist') else res_SGDOneClassSVM_partial_fit`\n  }\n\n  /**\n    Return labels (1 inlier, -1 outlier) of the samples.\n   */\n  async predict(opts: {\n    /**\n      Testing data.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_predict = {k: v for k, v in pms_SGDOneClassSVM_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_predict = bridgeSGDOneClassSVM[${this.id}].predict(**pms_SGDOneClassSVM_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_predict.tolist() if hasattr(res_SGDOneClassSVM_predict, 'tolist') else res_SGDOneClassSVM_predict`\n  }\n\n  /**\n    Raw scoring function of the samples.\n   */\n  async score_samples(opts: {\n    /**\n      Testing data.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_score_samples = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_score_samples = {k: v for k, v in pms_SGDOneClassSVM_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_score_samples = bridgeSGDOneClassSVM[${this.id}].score_samples(**pms_SGDOneClassSVM_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_score_samples.tolist() if hasattr(res_SGDOneClassSVM_score_samples, 'tolist') else res_SGDOneClassSVM_score_samples`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `coef\\_init` parameter in `fit`.\n     */\n    coef_init?: string | boolean\n\n    /**\n      Metadata routing for `offset\\_init` parameter in `fit`.\n     */\n    offset_init?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_set_fit_request = {'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'offset_init': ${opts['offset_init'] ?? undefined}, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_set_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_set_fit_request = bridgeSGDOneClassSVM[${this.id}].set_fit_request(**pms_SGDOneClassSVM_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_set_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_fit_request, 'tolist') else res_SGDOneClassSVM_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SGDOneClassSVM_set_partial_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDOneClassSVM_set_partial_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_set_partial_fit_request = bridgeSGDOneClassSVM[${this.id}].set_partial_fit_request(**pms_SGDOneClassSVM_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_set_partial_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_partial_fit_request, 'tolist') else res_SGDOneClassSVM_set_partial_fit_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDOneClassSVM_sparsify = {}\n\npms_SGDOneClassSVM_sparsify = {k: v for k, v in pms_SGDOneClassSVM_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDOneClassSVM_sparsify = bridgeSGDOneClassSVM[${this.id}].sparsify(**pms_SGDOneClassSVM_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDOneClassSVM_sparsify.tolist() if hasattr(res_SGDOneClassSVM_sparsify, 'tolist') else res_SGDOneClassSVM_sparsify`\n  }\n\n  /**\n    Weights assigned to the features.\n   */\n  get coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_coef_ = bridgeSGDOneClassSVM[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_coef_.tolist() if hasattr(attr_SGDOneClassSVM_coef_, 'tolist') else attr_SGDOneClassSVM_coef_`\n    })()\n  }\n\n  /**\n    Offset used to define the decision function from the raw scores. We have the relation: decision\\_function = score\\_samples - offset.\n   */\n  get offset_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before accessing offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_offset_ = bridgeSGDOneClassSVM[${this.id}].offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_offset_.tolist() if hasattr(attr_SGDOneClassSVM_offset_, 'tolist') else attr_SGDOneClassSVM_offset_`\n    })()\n  }\n\n  /**\n    The actual number of iterations to reach the stopping criterion.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_n_iter_ = bridgeSGDOneClassSVM[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_n_iter_.tolist() if hasattr(attr_SGDOneClassSVM_n_iter_, 'tolist') else attr_SGDOneClassSVM_n_iter_`\n    })()\n  }\n\n  /**\n    Number of weight updates performed during training. Same as `(n\\_iter\\_ \\* n\\_samples + 1)`.\n   */\n  get t_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDOneClassSVM must call init() before accessing t_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_t_ = bridgeSGDOneClassSVM[${this.id}].t_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_t_.tolist() if hasattr(attr_SGDOneClassSVM_t_, 'tolist') else attr_SGDOneClassSVM_t_`\n    })()\n  }\n\n  get loss_function_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before accessing loss_function_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_loss_function_ = bridgeSGDOneClassSVM[${this.id}].loss_function_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_loss_function_.tolist() if hasattr(attr_SGDOneClassSVM_loss_function_, 'tolist') else attr_SGDOneClassSVM_loss_function_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_n_features_in_ = bridgeSGDOneClassSVM[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_n_features_in_.tolist() if hasattr(attr_SGDOneClassSVM_n_features_in_, 'tolist') else attr_SGDOneClassSVM_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDOneClassSVM instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDOneClassSVM must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDOneClassSVM_feature_names_in_ = bridgeSGDOneClassSVM[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDOneClassSVM_feature_names_in_.tolist() if hasattr(attr_SGDOneClassSVM_feature_names_in_, 'tolist') else attr_SGDOneClassSVM_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Linear model fitted by minimizing a regularized empirical loss with SGD.\n\n  SGD stands for Stochastic Gradient Descent: the gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule (aka learning rate).\n\n  The regularizer is a penalty added to the loss function that shrinks model parameters towards the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a combination of both (Elastic Net). If the parameter update crosses the 0.0 value because of the regularizer, the update is truncated to 0.0 to allow for learning sparse models and achieve online feature selection.\n\n  This implementation works with data represented as dense numpy arrays of floating point values for the features.\n\n  Read more in the [User Guide](../sgd.html#sgd).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html)\n */\nexport class SGDRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The loss function to be used. The possible values are ‘squared\\_error’, ‘huber’, ‘epsilon\\_insensitive’, or ‘squared\\_epsilon\\_insensitive’\n\n      The ‘squared\\_error’ refers to the ordinary least squares fit. ‘huber’ modifies ‘squared\\_error’ to focus less on getting outliers correct by switching from squared to linear loss past a distance of epsilon. ‘epsilon\\_insensitive’ ignores errors less than epsilon and is linear past that; this is the loss function used in SVR. ‘squared\\_epsilon\\_insensitive’ is the same but becomes squared loss past a tolerance of epsilon.\n\n      More details about the losses formulas can be found in the [User Guide](../sgd.html#sgd-mathematical-formulation).\n\n      @defaultValue `'squared_error'`\n     */\n    loss?: string\n\n    /**\n      The penalty (aka regularization term) to be used. Defaults to ‘l2’ which is the standard regularizer for linear SVM models. ‘l1’ and ‘elasticnet’ might bring sparsity to the model (feature selection) not achievable with ‘l2’. No penalty is added when set to `undefined`.\n\n      @defaultValue `'l2'`\n     */\n    penalty?: 'l2' | 'l1' | 'elasticnet'\n\n    /**\n      Constant that multiplies the regularization term. The higher the value, the stronger the regularization. Also used to compute the learning rate when set to `learning\\_rate` is set to ‘optimal’.\n\n      @defaultValue `0.0001`\n     */\n    alpha?: number\n\n    /**\n      The Elastic Net mixing parameter, with 0 <= l1\\_ratio <= 1. l1\\_ratio=0 corresponds to L2 penalty, l1\\_ratio=1 to L1. Only used if `penalty` is ‘elasticnet’.\n\n      @defaultValue `0.15`\n     */\n    l1_ratio?: number\n\n    /**\n      Whether the intercept should be estimated or not. If `false`, the data is assumed to be already centered.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the `fit` method, and not the [`partial\\_fit`](#sklearn.linear_model.SGDRegressor.partial_fit \"sklearn.linear_model.SGDRegressor.partial_fit\") method.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      The stopping criterion. If it is not `undefined`, training will stop when (loss > best\\_loss - tol) for `n\\_iter\\_no\\_change` consecutive epochs. Convergence is checked against the training loss or the validation loss depending on the `early\\_stopping` parameter.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Whether or not the training data should be shuffled after each epoch.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      The verbosity level.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Epsilon in the epsilon-insensitive loss functions; only if `loss` is ‘huber’, ‘epsilon\\_insensitive’, or ‘squared\\_epsilon\\_insensitive’. For ‘huber’, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold.\n\n      @defaultValue `0.1`\n     */\n    epsilon?: number\n\n    /**\n      Used for shuffling the data, when `shuffle` is set to `true`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      The learning rate schedule:\n\n      @defaultValue `'invscaling'`\n     */\n    learning_rate?: string\n\n    /**\n      The initial learning rate for the ‘constant’, ‘invscaling’ or ‘adaptive’ schedules. The default value is 0.01.\n\n      @defaultValue `0.01`\n     */\n    eta0?: number\n\n    /**\n      The exponent for inverse scaling learning rate.\n\n      @defaultValue `0.25`\n     */\n    power_t?: number\n\n    /**\n      Whether to use early stopping to terminate training when validation score is not improving. If set to `true`, it will automatically set aside a fraction of training data as validation and terminate training when validation score returned by the `score` method is not improving by at least `tol` for `n\\_iter\\_no\\_change` consecutive epochs.\n\n      @defaultValue `false`\n     */\n    early_stopping?: boolean\n\n    /**\n      The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if `early\\_stopping` is `true`.\n\n      @defaultValue `0.1`\n     */\n    validation_fraction?: number\n\n    /**\n      Number of iterations with no improvement to wait before stopping fitting. Convergence is checked against the training loss or the validation loss depending on the `early\\_stopping` parameter.\n\n      @defaultValue `5`\n     */\n    n_iter_no_change?: number\n\n    /**\n      When set to `true`, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See [the Glossary](../../glossary.html#term-warm_start).\n\n      Repeatedly calling fit or partial\\_fit when warm\\_start is `true` can result in a different solution than when calling fit a single time because of the way the data is shuffled. If a dynamic learning rate is used, the learning rate is adapted depending on the number of samples already seen. Calling `fit` resets this counter, while `partial\\_fit` will result in increasing the existing counter.\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      When set to `true`, computes the averaged SGD weights across all updates and stores the result in the `coef\\_` attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches `average`. So `average=10` will begin averaging after seeing 10 samples.\n\n      @defaultValue `false`\n     */\n    average?: boolean | number\n  }) {\n    this.id = `SGDRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('SGDRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import SGDRegressor\ntry: bridgeSGDRegressor\nexcept NameError: bridgeSGDRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SGDRegressor = {'loss': ${\n      this.opts['loss'] ?? undefined\n    }, 'penalty': ${this.opts['penalty'] ?? undefined}, 'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'l1_ratio': ${this.opts['l1_ratio'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'epsilon': ${this.opts['epsilon'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'learning_rate': ${this.opts['learning_rate'] ?? undefined}, 'eta0': ${\n      this.opts['eta0'] ?? undefined\n    }, 'power_t': ${this.opts['power_t'] ?? undefined}, 'early_stopping': ${\n      this.opts['early_stopping'] ?? undefined\n    }, 'validation_fraction': ${\n      this.opts['validation_fraction'] ?? undefined\n    }, 'n_iter_no_change': ${\n      this.opts['n_iter_no_change'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'average': ${\n      this.opts['average'] ?? undefined\n    }}\n\nctor_SGDRegressor = {k: v for k, v in ctor_SGDRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSGDRegressor[${this.id}] = SGDRegressor(**ctor_SGDRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSGDRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Convert coefficient matrix to dense array format.\n\n    Converts the `coef\\_` member (back) to a numpy.ndarray. This is the default format of `coef\\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n   */\n  async densify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before densify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_densify = {}\n\npms_SGDRegressor_densify = {k: v for k, v in pms_SGDRegressor_densify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_densify = bridgeSGDRegressor[${this.id}].densify(**pms_SGDRegressor_densify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_densify.tolist() if hasattr(res_SGDRegressor_densify, 'tolist') else res_SGDRegressor_densify`\n  }\n\n  /**\n    Fit linear model with Stochastic Gradient Descent.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n\n    /**\n      The initial coefficients to warm-start the optimization.\n     */\n    coef_init?: NDArray\n\n    /**\n      The initial intercept to warm-start the optimization.\n     */\n    intercept_init?: NDArray\n\n    /**\n      Weights applied to individual samples (1. for unweighted).\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'coef_init': np.array(${opts['coef_init'] ?? undefined}) if ${\n      opts['coef_init'] !== undefined\n    } else None, 'intercept_init': np.array(${\n      opts['intercept_init'] ?? undefined\n    }) if ${opts['intercept_init'] !== undefined} else None, 'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDRegressor_fit = {k: v for k, v in pms_SGDRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_fit = bridgeSGDRegressor[${this.id}].fit(**pms_SGDRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_fit.tolist() if hasattr(res_SGDRegressor_fit, 'tolist') else res_SGDRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SGDRegressor_get_metadata_routing = {k: v for k, v in pms_SGDRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_get_metadata_routing = bridgeSGDRegressor[${this.id}].get_metadata_routing(**pms_SGDRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_get_metadata_routing.tolist() if hasattr(res_SGDRegressor_get_metadata_routing, 'tolist') else res_SGDRegressor_get_metadata_routing`\n  }\n\n  /**\n    Perform one epoch of stochastic gradient descent on given samples.\n\n    Internally, this method uses `max\\_iter \\= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence and early stopping should be handled by the user.\n   */\n  async partial_fit(opts: {\n    /**\n      Subset of training data.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Subset of target values.\n     */\n    y?: any[]\n\n    /**\n      Weights applied to individual samples. If not provided, uniform weights are assumed.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before partial_fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_partial_fit = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': np.array(${opts['y'] ?? undefined}) if ${\n      opts['y'] !== undefined\n    } else None, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_SGDRegressor_partial_fit = {k: v for k, v in pms_SGDRegressor_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_partial_fit = bridgeSGDRegressor[${this.id}].partial_fit(**pms_SGDRegressor_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_partial_fit.tolist() if hasattr(res_SGDRegressor_partial_fit, 'tolist') else res_SGDRegressor_partial_fit`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Input data.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_SGDRegressor_predict = {k: v for k, v in pms_SGDRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_predict = bridgeSGDRegressor[${this.id}].predict(**pms_SGDRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_predict.tolist() if hasattr(res_SGDRegressor_predict, 'tolist') else res_SGDRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_SGDRegressor_score = {k: v for k, v in pms_SGDRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_score = bridgeSGDRegressor[${this.id}].score(**pms_SGDRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_score.tolist() if hasattr(res_SGDRegressor_score, 'tolist') else res_SGDRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `coef\\_init` parameter in `fit`.\n     */\n    coef_init?: string | boolean\n\n    /**\n      Metadata routing for `intercept\\_init` parameter in `fit`.\n     */\n    intercept_init?: string | boolean\n\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before set_fit_request()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_set_fit_request = {'coef_init': ${\n      opts['coef_init'] ?? undefined\n    }, 'intercept_init': ${\n      opts['intercept_init'] ?? undefined\n    }, 'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_SGDRegressor_set_fit_request = {k: v for k, v in pms_SGDRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_set_fit_request = bridgeSGDRegressor[${this.id}].set_fit_request(**pms_SGDRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_set_fit_request.tolist() if hasattr(res_SGDRegressor_set_fit_request, 'tolist') else res_SGDRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `partial\\_fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_partial_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `partial\\_fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before set_partial_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SGDRegressor_set_partial_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDRegressor_set_partial_fit_request = {k: v for k, v in pms_SGDRegressor_set_partial_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_set_partial_fit_request = bridgeSGDRegressor[${this.id}].set_partial_fit_request(**pms_SGDRegressor_set_partial_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_set_partial_fit_request.tolist() if hasattr(res_SGDRegressor_set_partial_fit_request, 'tolist') else res_SGDRegressor_set_partial_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_SGDRegressor_set_score_request = {k: v for k, v in pms_SGDRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_set_score_request = bridgeSGDRegressor[${this.id}].set_score_request(**pms_SGDRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_set_score_request.tolist() if hasattr(res_SGDRegressor_set_score_request, 'tolist') else res_SGDRegressor_set_score_request`\n  }\n\n  /**\n    Convert coefficient matrix to sparse format.\n\n    Converts the `coef\\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\n    The `intercept\\_` member is not converted.\n   */\n  async sparsify(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before sparsify()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SGDRegressor_sparsify = {}\n\npms_SGDRegressor_sparsify = {k: v for k, v in pms_SGDRegressor_sparsify.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SGDRegressor_sparsify = bridgeSGDRegressor[${this.id}].sparsify(**pms_SGDRegressor_sparsify)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SGDRegressor_sparsify.tolist() if hasattr(res_SGDRegressor_sparsify, 'tolist') else res_SGDRegressor_sparsify`\n  }\n\n  /**\n    Weights assigned to the features.\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before accessing coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_coef_ = bridgeSGDRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_coef_.tolist() if hasattr(attr_SGDRegressor_coef_, 'tolist') else attr_SGDRegressor_coef_`\n    })()\n  }\n\n  /**\n    The intercept term.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_intercept_ = bridgeSGDRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_intercept_.tolist() if hasattr(attr_SGDRegressor_intercept_, 'tolist') else attr_SGDRegressor_intercept_`\n    })()\n  }\n\n  /**\n    The actual number of iterations before reaching the stopping criterion.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_n_iter_ = bridgeSGDRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_n_iter_.tolist() if hasattr(attr_SGDRegressor_n_iter_, 'tolist') else attr_SGDRegressor_n_iter_`\n    })()\n  }\n\n  /**\n    Number of weight updates performed during training. Same as `(n\\_iter\\_ \\* n\\_samples + 1)`.\n   */\n  get t_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SGDRegressor must call init() before accessing t_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_t_ = bridgeSGDRegressor[${this.id}].t_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_t_.tolist() if hasattr(attr_SGDRegressor_t_, 'tolist') else attr_SGDRegressor_t_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_n_features_in_ = bridgeSGDRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_n_features_in_.tolist() if hasattr(attr_SGDRegressor_n_features_in_, 'tolist') else attr_SGDRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This SGDRegressor instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SGDRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SGDRegressor_feature_names_in_ = bridgeSGDRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SGDRegressor_feature_names_in_.tolist() if hasattr(attr_SGDRegressor_feature_names_in_, 'tolist') else attr_SGDRegressor_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Theil-Sen Estimator: robust multivariate regression model.\n\n  The algorithm calculates least square solutions on subsets with size n\\_subsamples of the samples in X. Any value of n\\_subsamples between the number of features and samples leads to an estimator with a compromise between robustness and efficiency. Since the number of least square solutions is “n\\_samples choose n\\_subsamples”, it can be extremely large and can therefore be limited with max\\_subpopulation. If this limit is reached, the subsets are chosen randomly. In a final step, the spatial median (or L1 median) is calculated of all least square solutions.\n\n  Read more in the [User Guide](../linear_model.html#theil-sen-regression).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.TheilSenRegressor.html)\n */\nexport class TheilSenRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations.\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      If `true`, X will be copied; else, it may be overwritten.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      Instead of computing with a set of cardinality ‘n choose k’, where n is the number of samples and k is the number of subsamples (at least number of features), consider only a stochastic subpopulation of a given maximal size if ‘n choose k’ is larger than max\\_subpopulation. For other than small problem sizes this parameter will determine memory usage and runtime if n\\_subsamples is not changed. Note that the data type should be int but floats such as 1e4 can be accepted too.\n\n      @defaultValue `10000`\n     */\n    max_subpopulation?: number\n\n    /**\n      Number of samples to calculate the parameters. This is at least the number of features (plus 1 if fit\\_intercept=`true`) and the number of samples as a maximum. A lower number leads to a higher breakdown point and a low efficiency while a high number leads to a low breakdown point and a high efficiency. If `undefined`, take the minimum number of subsamples leading to maximal robustness. If n\\_subsamples is set to n\\_samples, Theil-Sen is identical to least squares.\n     */\n    n_subsamples?: number\n\n    /**\n      Maximum number of iterations for the calculation of spatial median.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n\n    /**\n      Tolerance when calculating spatial median.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      A random number generator instance to define the state of the random permutations generator. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Number of CPUs to use during the cross validation. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Verbose mode when fitting the model.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `TheilSenRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('TheilSenRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import TheilSenRegressor\ntry: bridgeTheilSenRegressor\nexcept NameError: bridgeTheilSenRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_TheilSenRegressor = {'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'copy_X': ${this.opts['copy_X'] ?? undefined}, 'max_subpopulation': ${\n      this.opts['max_subpopulation'] ?? undefined\n    }, 'n_subsamples': ${this.opts['n_subsamples'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_TheilSenRegressor = {k: v for k, v in ctor_TheilSenRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeTheilSenRegressor[${this.id}] = TheilSenRegressor(**ctor_TheilSenRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTheilSenRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit linear model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: NDArray[]\n\n    /**\n      Target values.\n     */\n    y?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TheilSenRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TheilSenRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_TheilSenRegressor_fit = {k: v for k, v in pms_TheilSenRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TheilSenRegressor_fit = bridgeTheilSenRegressor[${this.id}].fit(**pms_TheilSenRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TheilSenRegressor_fit.tolist() if hasattr(res_TheilSenRegressor_fit, 'tolist') else res_TheilSenRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TheilSenRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_TheilSenRegressor_get_metadata_routing = {k: v for k, v in pms_TheilSenRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TheilSenRegressor_get_metadata_routing = bridgeTheilSenRegressor[${this.id}].get_metadata_routing(**pms_TheilSenRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TheilSenRegressor_get_metadata_routing.tolist() if hasattr(res_TheilSenRegressor_get_metadata_routing, 'tolist') else res_TheilSenRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using the linear model.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TheilSenRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TheilSenRegressor_predict = {'X': ${\n      opts['X'] ?? undefined\n    }}\n\npms_TheilSenRegressor_predict = {k: v for k, v in pms_TheilSenRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TheilSenRegressor_predict = bridgeTheilSenRegressor[${this.id}].predict(**pms_TheilSenRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TheilSenRegressor_predict.tolist() if hasattr(res_TheilSenRegressor_predict, 'tolist') else res_TheilSenRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y\\_true \\- y\\_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y\\_true \\- y\\_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n\\_samples, n\\_samples\\_fitted)`, where `n\\_samples\\_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TheilSenRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TheilSenRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_TheilSenRegressor_score = {k: v for k, v in pms_TheilSenRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TheilSenRegressor_score = bridgeTheilSenRegressor[${this.id}].score(**pms_TheilSenRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TheilSenRegressor_score.tolist() if hasattr(res_TheilSenRegressor_score, 'tolist') else res_TheilSenRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TheilSenRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_TheilSenRegressor_set_score_request = {k: v for k, v in pms_TheilSenRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TheilSenRegressor_set_score_request = bridgeTheilSenRegressor[${this.id}].set_score_request(**pms_TheilSenRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TheilSenRegressor_set_score_request.tolist() if hasattr(res_TheilSenRegressor_set_score_request, 'tolist') else res_TheilSenRegressor_set_score_request`\n  }\n\n  /**\n    Coefficients of the regression model (median of distribution).\n   */\n  get coef_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_coef_ = bridgeTheilSenRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_coef_.tolist() if hasattr(attr_TheilSenRegressor_coef_, 'tolist') else attr_TheilSenRegressor_coef_`\n    })()\n  }\n\n  /**\n    Estimated intercept of regression model.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_intercept_ = bridgeTheilSenRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_intercept_.tolist() if hasattr(attr_TheilSenRegressor_intercept_, 'tolist') else attr_TheilSenRegressor_intercept_`\n    })()\n  }\n\n  /**\n    Approximated breakdown point.\n   */\n  get breakdown_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing breakdown_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_breakdown_ = bridgeTheilSenRegressor[${this.id}].breakdown_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_breakdown_.tolist() if hasattr(attr_TheilSenRegressor_breakdown_, 'tolist') else attr_TheilSenRegressor_breakdown_`\n    })()\n  }\n\n  /**\n    Number of iterations needed for the spatial median.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_n_iter_ = bridgeTheilSenRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_n_iter_.tolist() if hasattr(attr_TheilSenRegressor_n_iter_, 'tolist') else attr_TheilSenRegressor_n_iter_`\n    })()\n  }\n\n  /**\n    Number of combinations taken into account from ‘n choose k’, where n is the number of samples and k is the number of subsamples.\n   */\n  get n_subpopulation_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing n_subpopulation_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_n_subpopulation_ = bridgeTheilSenRegressor[${this.id}].n_subpopulation_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_n_subpopulation_.tolist() if hasattr(attr_TheilSenRegressor_n_subpopulation_, 'tolist') else attr_TheilSenRegressor_n_subpopulation_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_n_features_in_ = bridgeTheilSenRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_n_features_in_.tolist() if hasattr(attr_TheilSenRegressor_n_features_in_, 'tolist') else attr_TheilSenRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TheilSenRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TheilSenRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TheilSenRegressor_feature_names_in_ = bridgeTheilSenRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TheilSenRegressor_feature_names_in_.tolist() if hasattr(attr_TheilSenRegressor_feature_names_in_, 'tolist') else attr_TheilSenRegressor_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generalized Linear Model with a Tweedie distribution.\n\n  This estimator can be used to model different GLMs depending on the `power` parameter, which determines the underlying distribution.\n\n  Read more in the [User Guide](../linear_model.html#generalized-linear-models).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.TweedieRegressor.html)\n */\nexport class TweedieRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The power determines the underlying target distribution according to the following table:\n\n      @defaultValue `0`\n     */\n    power?: number\n\n    /**\n      Constant that multiplies the L2 penalty term and determines the regularization strength. `alpha \\= 0` is equivalent to unpenalized GLMs. In this case, the design matrix `X` must have full column rank (no collinearities). Values of `alpha` must be in the range `\\[0.0, inf)`.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Specifies if a constant (a.k.a. bias or intercept) should be added to the linear predictor (`X @ coef + intercept`).\n\n      @defaultValue `true`\n     */\n    fit_intercept?: boolean\n\n    /**\n      The link function of the GLM, i.e. mapping from linear predictor `X @ coeff + intercept` to prediction `y\\_pred`. Option ‘auto’ sets the link depending on the chosen `power` parameter as follows:\n\n      @defaultValue `'auto'`\n     */\n    link?: 'auto' | 'identity' | 'log'\n\n    /**\n      Algorithm to use in the optimization problem:\n\n      @defaultValue `'lbfgs'`\n     */\n    solver?: 'lbfgs' | 'newton-cholesky'\n\n    /**\n      The maximal number of iterations for the solver. Values must be in the range `\\[1, inf)`.\n\n      @defaultValue `100`\n     */\n    max_iter?: number\n\n    /**\n      Stopping criterion. For the lbfgs solver, the iteration will stop when `max{|g\\_j|, j \\= 1, ..., d} <= tol` where `g\\_j` is the j-th component of the gradient (derivative) of the objective function. Values must be in the range `(0.0, inf)`.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n\n    /**\n      If set to `true`, reuse the solution of the previous call to `fit` as initialization for `coef\\_` and `intercept\\_` .\n\n      @defaultValue `false`\n     */\n    warm_start?: boolean\n\n    /**\n      For the lbfgs solver set verbose to any positive number for verbosity. Values must be in the range `\\[0, inf)`.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n  }) {\n    this.id = `TweedieRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('TweedieRegressor.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.linear_model import TweedieRegressor\ntry: bridgeTweedieRegressor\nexcept NameError: bridgeTweedieRegressor = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_TweedieRegressor = {'power': ${\n      this.opts['power'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'fit_intercept': ${\n      this.opts['fit_intercept'] ?? undefined\n    }, 'link': ${this.opts['link'] ?? undefined}, 'solver': ${\n      this.opts['solver'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'warm_start': ${this.opts['warm_start'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }}\n\nctor_TweedieRegressor = {k: v for k, v in ctor_TweedieRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeTweedieRegressor[${this.id}] = TweedieRegressor(**ctor_TweedieRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTweedieRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a Generalized Linear Model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TweedieRegressor must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TweedieRegressor_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_TweedieRegressor_fit = {k: v for k, v in pms_TweedieRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_fit = bridgeTweedieRegressor[${this.id}].fit(**pms_TweedieRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_fit.tolist() if hasattr(res_TweedieRegressor_fit, 'tolist') else res_TweedieRegressor_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_TweedieRegressor_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_TweedieRegressor_get_metadata_routing = {k: v for k, v in pms_TweedieRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_get_metadata_routing = bridgeTweedieRegressor[${this.id}].get_metadata_routing(**pms_TweedieRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_get_metadata_routing.tolist() if hasattr(res_TweedieRegressor_get_metadata_routing, 'tolist') else res_TweedieRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using GLM with feature matrix X.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TweedieRegressor must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TweedieRegressor_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_TweedieRegressor_predict = {k: v for k, v in pms_TweedieRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_predict = bridgeTweedieRegressor[${this.id}].predict(**pms_TweedieRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_predict.tolist() if hasattr(res_TweedieRegressor_predict, 'tolist') else res_TweedieRegressor_predict`\n  }\n\n  /**\n    Compute D^2, the percentage of deviance explained.\n\n    D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).\n\n    D^2 is defined as \\\\(D^2 = 1-\\\\frac{D(y\\_{true},y\\_{pred})}{D\\_{null}}\\\\), \\\\(D\\_{null}\\\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\\\(y\\_{pred} = \\\\bar{y}\\\\). The mean \\\\(\\\\bar{y}\\\\) is averaged by sample\\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      True values of target.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('TweedieRegressor must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_TweedieRegressor_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_TweedieRegressor_score = {k: v for k, v in pms_TweedieRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_score = bridgeTweedieRegressor[${this.id}].score(**pms_TweedieRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_score.tolist() if hasattr(res_TweedieRegressor_score, 'tolist') else res_TweedieRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TweedieRegressor_set_fit_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_TweedieRegressor_set_fit_request = {k: v for k, v in pms_TweedieRegressor_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_set_fit_request = bridgeTweedieRegressor[${this.id}].set_fit_request(**pms_TweedieRegressor_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_set_fit_request.tolist() if hasattr(res_TweedieRegressor_set_fit_request, 'tolist') else res_TweedieRegressor_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TweedieRegressor_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_TweedieRegressor_set_score_request = {k: v for k, v in pms_TweedieRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TweedieRegressor_set_score_request = bridgeTweedieRegressor[${this.id}].set_score_request(**pms_TweedieRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TweedieRegressor_set_score_request.tolist() if hasattr(res_TweedieRegressor_set_score_request, 'tolist') else res_TweedieRegressor_set_score_request`\n  }\n\n  /**\n    Estimated coefficients for the linear predictor (`X @ coef\\_ + intercept\\_`) in the GLM.\n   */\n  get coef_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before accessing coef_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TweedieRegressor_coef_ = bridgeTweedieRegressor[${this.id}].coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TweedieRegressor_coef_.tolist() if hasattr(attr_TweedieRegressor_coef_, 'tolist') else attr_TweedieRegressor_coef_`\n    })()\n  }\n\n  /**\n    Intercept (a.k.a. bias) added to linear predictor.\n   */\n  get intercept_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before accessing intercept_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TweedieRegressor_intercept_ = bridgeTweedieRegressor[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TweedieRegressor_intercept_.tolist() if hasattr(attr_TweedieRegressor_intercept_, 'tolist') else attr_TweedieRegressor_intercept_`\n    })()\n  }\n\n  /**\n    Actual number of iterations used in the solver.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TweedieRegressor_n_iter_ = bridgeTweedieRegressor[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TweedieRegressor_n_iter_.tolist() if hasattr(attr_TweedieRegressor_n_iter_, 'tolist') else attr_TweedieRegressor_n_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TweedieRegressor_n_features_in_ = bridgeTweedieRegressor[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TweedieRegressor_n_features_in_.tolist() if hasattr(attr_TweedieRegressor_n_features_in_, 'tolist') else attr_TweedieRegressor_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TweedieRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TweedieRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TweedieRegressor_feature_names_in_ = bridgeTweedieRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TweedieRegressor_feature_names_in_.tolist() if hasattr(attr_TweedieRegressor_feature_names_in_, 'tolist') else attr_TweedieRegressor_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto","crypto"]}