// src/generated/linear_model/ARDRegression.ts
import crypto from "node:crypto";
var ARDRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ARDRegression${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ARDRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ARDRegression
try: bridgeARDRegression
except NameError: bridgeARDRegression = {}
`;
    await this._py.ex`ctor_ARDRegression = {'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'alpha_1': ${this.opts["alpha_1"] ?? void 0}, 'alpha_2': ${this.opts["alpha_2"] ?? void 0}, 'lambda_1': ${this.opts["lambda_1"] ?? void 0}, 'lambda_2': ${this.opts["lambda_2"] ?? void 0}, 'compute_score': ${this.opts["compute_score"] ?? void 0}, 'threshold_lambda': ${this.opts["threshold_lambda"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}}

ctor_ARDRegression = {k: v for k, v in ctor_ARDRegression.items() if v is not None}`;
    await this._py.ex`bridgeARDRegression[${this.id}] = ARDRegression(**ctor_ARDRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeARDRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit the model according to the given training data and parameters.
  
      Iterative procedure to maximize the evidence
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before fit()");
    }
    await this._py.ex`pms_ARDRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_ARDRegression_fit = {k: v for k, v in pms_ARDRegression_fit.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_fit = bridgeARDRegression[${this.id}].fit(**pms_ARDRegression_fit)`;
    return this._py`res_ARDRegression_fit.tolist() if hasattr(res_ARDRegression_fit, 'tolist') else res_ARDRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ARDRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ARDRegression_get_metadata_routing = {k: v for k, v in pms_ARDRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_get_metadata_routing = bridgeARDRegression[${this.id}].get_metadata_routing(**pms_ARDRegression_get_metadata_routing)`;
    return this._py`res_ARDRegression_get_metadata_routing.tolist() if hasattr(res_ARDRegression_get_metadata_routing, 'tolist') else res_ARDRegression_get_metadata_routing`;
  }
  /**
      Predict using the linear model.
  
      In addition to the mean of the predictive distribution, also its standard deviation can be returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before predict()");
    }
    await this._py.ex`pms_ARDRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_ARDRegression_predict = {k: v for k, v in pms_ARDRegression_predict.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_predict = bridgeARDRegression[${this.id}].predict(**pms_ARDRegression_predict)`;
    return this._py`res_ARDRegression_predict.tolist() if hasattr(res_ARDRegression_predict, 'tolist') else res_ARDRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before score()");
    }
    await this._py.ex`pms_ARDRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ARDRegression_score = {k: v for k, v in pms_ARDRegression_score.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_score = bridgeARDRegression[${this.id}].score(**pms_ARDRegression_score)`;
    return this._py`res_ARDRegression_score.tolist() if hasattr(res_ARDRegression_score, 'tolist') else res_ARDRegression_score`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_ARDRegression_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_ARDRegression_set_predict_request = {k: v for k, v in pms_ARDRegression_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_set_predict_request = bridgeARDRegression[${this.id}].set_predict_request(**pms_ARDRegression_set_predict_request)`;
    return this._py`res_ARDRegression_set_predict_request.tolist() if hasattr(res_ARDRegression_set_predict_request, 'tolist') else res_ARDRegression_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ARDRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ARDRegression_set_score_request = {k: v for k, v in pms_ARDRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ARDRegression_set_score_request = bridgeARDRegression[${this.id}].set_score_request(**pms_ARDRegression_set_score_request)`;
    return this._py`res_ARDRegression_set_score_request.tolist() if hasattr(res_ARDRegression_set_score_request, 'tolist') else res_ARDRegression_set_score_request`;
  }
  /**
    Coefficients of the regression model (mean of distribution)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_coef_ = bridgeARDRegression[${this.id}].coef_`;
      return this._py`attr_ARDRegression_coef_.tolist() if hasattr(attr_ARDRegression_coef_, 'tolist') else attr_ARDRegression_coef_`;
    })();
  }
  /**
    estimated precision of the noise.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_alpha_ = bridgeARDRegression[${this.id}].alpha_`;
      return this._py`attr_ARDRegression_alpha_.tolist() if hasattr(attr_ARDRegression_alpha_, 'tolist') else attr_ARDRegression_alpha_`;
    })();
  }
  /**
    estimated precisions of the weights.
   */
  get lambda_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing lambda_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_lambda_ = bridgeARDRegression[${this.id}].lambda_`;
      return this._py`attr_ARDRegression_lambda_.tolist() if hasattr(attr_ARDRegression_lambda_, 'tolist') else attr_ARDRegression_lambda_`;
    })();
  }
  /**
    estimated variance-covariance matrix of the weights
   */
  get sigma_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing sigma_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_sigma_ = bridgeARDRegression[${this.id}].sigma_`;
      return this._py`attr_ARDRegression_sigma_.tolist() if hasattr(attr_ARDRegression_sigma_, 'tolist') else attr_ARDRegression_sigma_`;
    })();
  }
  /**
    if computed, value of the objective function (to be maximized)
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_scores_ = bridgeARDRegression[${this.id}].scores_`;
      return this._py`attr_ARDRegression_scores_.tolist() if hasattr(attr_ARDRegression_scores_, 'tolist') else attr_ARDRegression_scores_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ARDRegression must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_n_iter_ = bridgeARDRegression[${this.id}].n_iter_`;
      return this._py`attr_ARDRegression_n_iter_.tolist() if hasattr(attr_ARDRegression_n_iter_, 'tolist') else attr_ARDRegression_n_iter_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_intercept_ = bridgeARDRegression[${this.id}].intercept_`;
      return this._py`attr_ARDRegression_intercept_.tolist() if hasattr(attr_ARDRegression_intercept_, 'tolist') else attr_ARDRegression_intercept_`;
    })();
  }
  /**
    If `fit\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\_features) otherwise.
   */
  get X_offset_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing X_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_X_offset_ = bridgeARDRegression[${this.id}].X_offset_`;
      return this._py`attr_ARDRegression_X_offset_.tolist() if hasattr(attr_ARDRegression_X_offset_, 'tolist') else attr_ARDRegression_X_offset_`;
    })();
  }
  /**
    Set to np.ones(n\_features).
   */
  get X_scale_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing X_scale_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_X_scale_ = bridgeARDRegression[${this.id}].X_scale_`;
      return this._py`attr_ARDRegression_X_scale_.tolist() if hasattr(attr_ARDRegression_X_scale_, 'tolist') else attr_ARDRegression_X_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_n_features_in_ = bridgeARDRegression[${this.id}].n_features_in_`;
      return this._py`attr_ARDRegression_n_features_in_.tolist() if hasattr(attr_ARDRegression_n_features_in_, 'tolist') else attr_ARDRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ARDRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ARDRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ARDRegression_feature_names_in_ = bridgeARDRegression[${this.id}].feature_names_in_`;
      return this._py`attr_ARDRegression_feature_names_in_.tolist() if hasattr(attr_ARDRegression_feature_names_in_, 'tolist') else attr_ARDRegression_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/BayesianRidge.ts
import crypto2 from "node:crypto";
var BayesianRidge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BayesianRidge${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BayesianRidge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import BayesianRidge
try: bridgeBayesianRidge
except NameError: bridgeBayesianRidge = {}
`;
    await this._py.ex`ctor_BayesianRidge = {'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'alpha_1': ${this.opts["alpha_1"] ?? void 0}, 'alpha_2': ${this.opts["alpha_2"] ?? void 0}, 'lambda_1': ${this.opts["lambda_1"] ?? void 0}, 'lambda_2': ${this.opts["lambda_2"] ?? void 0}, 'alpha_init': ${this.opts["alpha_init"] ?? void 0}, 'lambda_init': ${this.opts["lambda_init"] ?? void 0}, 'compute_score': ${this.opts["compute_score"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}}

ctor_BayesianRidge = {k: v for k, v in ctor_BayesianRidge.items() if v is not None}`;
    await this._py.ex`bridgeBayesianRidge[${this.id}] = BayesianRidge(**ctor_BayesianRidge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBayesianRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before fit()");
    }
    await this._py.ex`pms_BayesianRidge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_fit = {k: v for k, v in pms_BayesianRidge_fit.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_fit = bridgeBayesianRidge[${this.id}].fit(**pms_BayesianRidge_fit)`;
    return this._py`res_BayesianRidge_fit.tolist() if hasattr(res_BayesianRidge_fit, 'tolist') else res_BayesianRidge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BayesianRidge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BayesianRidge_get_metadata_routing = {k: v for k, v in pms_BayesianRidge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_get_metadata_routing = bridgeBayesianRidge[${this.id}].get_metadata_routing(**pms_BayesianRidge_get_metadata_routing)`;
    return this._py`res_BayesianRidge_get_metadata_routing.tolist() if hasattr(res_BayesianRidge_get_metadata_routing, 'tolist') else res_BayesianRidge_get_metadata_routing`;
  }
  /**
      Predict using the linear model.
  
      In addition to the mean of the predictive distribution, also its standard deviation can be returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before predict()");
    }
    await this._py.ex`pms_BayesianRidge_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_predict = {k: v for k, v in pms_BayesianRidge_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_predict = bridgeBayesianRidge[${this.id}].predict(**pms_BayesianRidge_predict)`;
    return this._py`res_BayesianRidge_predict.tolist() if hasattr(res_BayesianRidge_predict, 'tolist') else res_BayesianRidge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before score()");
    }
    await this._py.ex`pms_BayesianRidge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_score = {k: v for k, v in pms_BayesianRidge_score.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_score = bridgeBayesianRidge[${this.id}].score(**pms_BayesianRidge_score)`;
    return this._py`res_BayesianRidge_score.tolist() if hasattr(res_BayesianRidge_score, 'tolist') else res_BayesianRidge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_BayesianRidge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_fit_request = {k: v for k, v in pms_BayesianRidge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_fit_request = bridgeBayesianRidge[${this.id}].set_fit_request(**pms_BayesianRidge_set_fit_request)`;
    return this._py`res_BayesianRidge_set_fit_request.tolist() if hasattr(res_BayesianRidge_set_fit_request, 'tolist') else res_BayesianRidge_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_set_predict_request = {k: v for k, v in pms_BayesianRidge_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_predict_request = bridgeBayesianRidge[${this.id}].set_predict_request(**pms_BayesianRidge_set_predict_request)`;
    return this._py`res_BayesianRidge_set_predict_request.tolist() if hasattr(res_BayesianRidge_set_predict_request, 'tolist') else res_BayesianRidge_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_score_request = {k: v for k, v in pms_BayesianRidge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_score_request = bridgeBayesianRidge[${this.id}].set_score_request(**pms_BayesianRidge_set_score_request)`;
    return this._py`res_BayesianRidge_set_score_request.tolist() if hasattr(res_BayesianRidge_set_score_request, 'tolist') else res_BayesianRidge_set_score_request`;
  }
  /**
    Coefficients of the regression model (mean of distribution)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_coef_ = bridgeBayesianRidge[${this.id}].coef_`;
      return this._py`attr_BayesianRidge_coef_.tolist() if hasattr(attr_BayesianRidge_coef_, 'tolist') else attr_BayesianRidge_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_intercept_ = bridgeBayesianRidge[${this.id}].intercept_`;
      return this._py`attr_BayesianRidge_intercept_.tolist() if hasattr(attr_BayesianRidge_intercept_, 'tolist') else attr_BayesianRidge_intercept_`;
    })();
  }
  /**
    Estimated precision of the noise.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_alpha_ = bridgeBayesianRidge[${this.id}].alpha_`;
      return this._py`attr_BayesianRidge_alpha_.tolist() if hasattr(attr_BayesianRidge_alpha_, 'tolist') else attr_BayesianRidge_alpha_`;
    })();
  }
  /**
    Estimated precision of the weights.
   */
  get lambda_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing lambda_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_lambda_ = bridgeBayesianRidge[${this.id}].lambda_`;
      return this._py`attr_BayesianRidge_lambda_.tolist() if hasattr(attr_BayesianRidge_lambda_, 'tolist') else attr_BayesianRidge_lambda_`;
    })();
  }
  /**
    Estimated variance-covariance matrix of the weights
   */
  get sigma_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing sigma_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_sigma_ = bridgeBayesianRidge[${this.id}].sigma_`;
      return this._py`attr_BayesianRidge_sigma_.tolist() if hasattr(attr_BayesianRidge_sigma_, 'tolist') else attr_BayesianRidge_sigma_`;
    })();
  }
  /**
    If computed\_score is `true`, value of the log marginal likelihood (to be maximized) at each iteration of the optimization. The array starts with the value of the log marginal likelihood obtained for the initial values of alpha and lambda and ends with the value obtained for the estimated alpha and lambda.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_scores_ = bridgeBayesianRidge[${this.id}].scores_`;
      return this._py`attr_BayesianRidge_scores_.tolist() if hasattr(attr_BayesianRidge_scores_, 'tolist') else attr_BayesianRidge_scores_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_iter_ = bridgeBayesianRidge[${this.id}].n_iter_`;
      return this._py`attr_BayesianRidge_n_iter_.tolist() if hasattr(attr_BayesianRidge_n_iter_, 'tolist') else attr_BayesianRidge_n_iter_`;
    })();
  }
  /**
    If `fit\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\_features) otherwise.
   */
  get X_offset_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_offset_ = bridgeBayesianRidge[${this.id}].X_offset_`;
      return this._py`attr_BayesianRidge_X_offset_.tolist() if hasattr(attr_BayesianRidge_X_offset_, 'tolist') else attr_BayesianRidge_X_offset_`;
    })();
  }
  /**
    Set to np.ones(n\_features).
   */
  get X_scale_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_scale_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_scale_ = bridgeBayesianRidge[${this.id}].X_scale_`;
      return this._py`attr_BayesianRidge_X_scale_.tolist() if hasattr(attr_BayesianRidge_X_scale_, 'tolist') else attr_BayesianRidge_X_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_features_in_ = bridgeBayesianRidge[${this.id}].n_features_in_`;
      return this._py`attr_BayesianRidge_n_features_in_.tolist() if hasattr(attr_BayesianRidge_n_features_in_, 'tolist') else attr_BayesianRidge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_feature_names_in_ = bridgeBayesianRidge[${this.id}].feature_names_in_`;
      return this._py`attr_BayesianRidge_feature_names_in_.tolist() if hasattr(attr_BayesianRidge_feature_names_in_, 'tolist') else attr_BayesianRidge_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/ElasticNet.ts
import crypto3 from "node:crypto";
var ElasticNet = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ElasticNet${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ElasticNet.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ElasticNet
try: bridgeElasticNet
except NameError: bridgeElasticNet = {}
`;
    await this._py.ex`ctor_ElasticNet = {'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_ElasticNet = {k: v for k, v in ctor_ElasticNet.items() if v is not None}`;
    await this._py.ex`bridgeElasticNet[${this.id}] = ElasticNet(**ctor_ElasticNet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeElasticNet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before fit()");
    }
    await this._py.ex`pms_ElasticNet_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_ElasticNet_fit = {k: v for k, v in pms_ElasticNet_fit.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_fit = bridgeElasticNet[${this.id}].fit(**pms_ElasticNet_fit)`;
    return this._py`res_ElasticNet_fit.tolist() if hasattr(res_ElasticNet_fit, 'tolist') else res_ElasticNet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ElasticNet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ElasticNet_get_metadata_routing = {k: v for k, v in pms_ElasticNet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_get_metadata_routing = bridgeElasticNet[${this.id}].get_metadata_routing(**pms_ElasticNet_get_metadata_routing)`;
    return this._py`res_ElasticNet_get_metadata_routing.tolist() if hasattr(res_ElasticNet_get_metadata_routing, 'tolist') else res_ElasticNet_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before path()");
    }
    await this._py.ex`pms_ElasticNet_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_ElasticNet_path = {k: v for k, v in pms_ElasticNet_path.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_path = bridgeElasticNet[${this.id}].path(**pms_ElasticNet_path)`;
    return this._py`res_ElasticNet_path.tolist() if hasattr(res_ElasticNet_path, 'tolist') else res_ElasticNet_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before predict()");
    }
    await this._py.ex`pms_ElasticNet_predict = {'X': ${opts["X"] ?? void 0}}

pms_ElasticNet_predict = {k: v for k, v in pms_ElasticNet_predict.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_predict = bridgeElasticNet[${this.id}].predict(**pms_ElasticNet_predict)`;
    return this._py`res_ElasticNet_predict.tolist() if hasattr(res_ElasticNet_predict, 'tolist') else res_ElasticNet_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before score()");
    }
    await this._py.ex`pms_ElasticNet_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNet_score = {k: v for k, v in pms_ElasticNet_score.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_score = bridgeElasticNet[${this.id}].score(**pms_ElasticNet_score)`;
    return this._py`res_ElasticNet_score.tolist() if hasattr(res_ElasticNet_score, 'tolist') else res_ElasticNet_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before set_fit_request()");
    }
    await this._py.ex`pms_ElasticNet_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNet_set_fit_request = {k: v for k, v in pms_ElasticNet_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_set_fit_request = bridgeElasticNet[${this.id}].set_fit_request(**pms_ElasticNet_set_fit_request)`;
    return this._py`res_ElasticNet_set_fit_request.tolist() if hasattr(res_ElasticNet_set_fit_request, 'tolist') else res_ElasticNet_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before set_score_request()");
    }
    await this._py.ex`pms_ElasticNet_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNet_set_score_request = {k: v for k, v in pms_ElasticNet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNet_set_score_request = bridgeElasticNet[${this.id}].set_score_request(**pms_ElasticNet_set_score_request)`;
    return this._py`res_ElasticNet_set_score_request.tolist() if hasattr(res_ElasticNet_set_score_request, 'tolist') else res_ElasticNet_set_score_request`;
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_coef_ = bridgeElasticNet[${this.id}].coef_`;
      return this._py`attr_ElasticNet_coef_.tolist() if hasattr(attr_ElasticNet_coef_, 'tolist') else attr_ElasticNet_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_intercept_ = bridgeElasticNet[${this.id}].intercept_`;
      return this._py`attr_ElasticNet_intercept_.tolist() if hasattr(attr_ElasticNet_intercept_, 'tolist') else attr_ElasticNet_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_n_iter_ = bridgeElasticNet[${this.id}].n_iter_`;
      return this._py`attr_ElasticNet_n_iter_.tolist() if hasattr(attr_ElasticNet_n_iter_, 'tolist') else attr_ElasticNet_n_iter_`;
    })();
  }
  /**
    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNet must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_dual_gap_ = bridgeElasticNet[${this.id}].dual_gap_`;
      return this._py`attr_ElasticNet_dual_gap_.tolist() if hasattr(attr_ElasticNet_dual_gap_, 'tolist') else attr_ElasticNet_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_n_features_in_ = bridgeElasticNet[${this.id}].n_features_in_`;
      return this._py`attr_ElasticNet_n_features_in_.tolist() if hasattr(attr_ElasticNet_n_features_in_, 'tolist') else attr_ElasticNet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNet_feature_names_in_ = bridgeElasticNet[${this.id}].feature_names_in_`;
      return this._py`attr_ElasticNet_feature_names_in_.tolist() if hasattr(attr_ElasticNet_feature_names_in_, 'tolist') else attr_ElasticNet_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/ElasticNetCV.ts
import crypto4 from "node:crypto";
var ElasticNetCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ElasticNetCV${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ElasticNetCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import ElasticNetCV
try: bridgeElasticNetCV
except NameError: bridgeElasticNetCV = {}
`;
    await this._py.ex`ctor_ElasticNetCV = {'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_ElasticNetCV = {k: v for k, v in ctor_ElasticNetCV.items() if v is not None}`;
    await this._py.ex`bridgeElasticNetCV[${this.id}] = ElasticNetCV(**ctor_ElasticNetCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeElasticNetCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit linear model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before fit()");
    }
    await this._py.ex`pms_ElasticNetCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNetCV_fit = {k: v for k, v in pms_ElasticNetCV_fit.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_fit = bridgeElasticNetCV[${this.id}].fit(**pms_ElasticNetCV_fit)`;
    return this._py`res_ElasticNetCV_fit.tolist() if hasattr(res_ElasticNetCV_fit, 'tolist') else res_ElasticNetCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ElasticNetCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ElasticNetCV_get_metadata_routing = {k: v for k, v in pms_ElasticNetCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_get_metadata_routing = bridgeElasticNetCV[${this.id}].get_metadata_routing(**pms_ElasticNetCV_get_metadata_routing)`;
    return this._py`res_ElasticNetCV_get_metadata_routing.tolist() if hasattr(res_ElasticNetCV_get_metadata_routing, 'tolist') else res_ElasticNetCV_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before path()");
    }
    await this._py.ex`pms_ElasticNetCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_ElasticNetCV_path = {k: v for k, v in pms_ElasticNetCV_path.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_path = bridgeElasticNetCV[${this.id}].path(**pms_ElasticNetCV_path)`;
    return this._py`res_ElasticNetCV_path.tolist() if hasattr(res_ElasticNetCV_path, 'tolist') else res_ElasticNetCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before predict()");
    }
    await this._py.ex`pms_ElasticNetCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_ElasticNetCV_predict = {k: v for k, v in pms_ElasticNetCV_predict.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_predict = bridgeElasticNetCV[${this.id}].predict(**pms_ElasticNetCV_predict)`;
    return this._py`res_ElasticNetCV_predict.tolist() if hasattr(res_ElasticNetCV_predict, 'tolist') else res_ElasticNetCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before score()");
    }
    await this._py.ex`pms_ElasticNetCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ElasticNetCV_score = {k: v for k, v in pms_ElasticNetCV_score.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_score = bridgeElasticNetCV[${this.id}].score(**pms_ElasticNetCV_score)`;
    return this._py`res_ElasticNetCV_score.tolist() if hasattr(res_ElasticNetCV_score, 'tolist') else res_ElasticNetCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_ElasticNetCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNetCV_set_fit_request = {k: v for k, v in pms_ElasticNetCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_set_fit_request = bridgeElasticNetCV[${this.id}].set_fit_request(**pms_ElasticNetCV_set_fit_request)`;
    return this._py`res_ElasticNetCV_set_fit_request.tolist() if hasattr(res_ElasticNetCV_set_fit_request, 'tolist') else res_ElasticNetCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ElasticNetCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ElasticNetCV_set_score_request = {k: v for k, v in pms_ElasticNetCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ElasticNetCV_set_score_request = bridgeElasticNetCV[${this.id}].set_score_request(**pms_ElasticNetCV_set_score_request)`;
    return this._py`res_ElasticNetCV_set_score_request.tolist() if hasattr(res_ElasticNetCV_set_score_request, 'tolist') else res_ElasticNetCV_set_score_request`;
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_alpha_ = bridgeElasticNetCV[${this.id}].alpha_`;
      return this._py`attr_ElasticNetCV_alpha_.tolist() if hasattr(attr_ElasticNetCV_alpha_, 'tolist') else attr_ElasticNetCV_alpha_`;
    })();
  }
  /**
    The compromise between l1 and l2 penalization chosen by cross validation.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_l1_ratio_ = bridgeElasticNetCV[${this.id}].l1_ratio_`;
      return this._py`attr_ElasticNetCV_l1_ratio_.tolist() if hasattr(attr_ElasticNetCV_l1_ratio_, 'tolist') else attr_ElasticNetCV_l1_ratio_`;
    })();
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_coef_ = bridgeElasticNetCV[${this.id}].coef_`;
      return this._py`attr_ElasticNetCV_coef_.tolist() if hasattr(attr_ElasticNetCV_coef_, 'tolist') else attr_ElasticNetCV_coef_`;
    })();
  }
  /**
    Independent term in the decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_intercept_ = bridgeElasticNetCV[${this.id}].intercept_`;
      return this._py`attr_ElasticNetCV_intercept_.tolist() if hasattr(attr_ElasticNetCV_intercept_, 'tolist') else attr_ElasticNetCV_intercept_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying l1\_ratio and alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_mse_path_ = bridgeElasticNetCV[${this.id}].mse_path_`;
      return this._py`attr_ElasticNetCV_mse_path_.tolist() if hasattr(attr_ElasticNetCV_mse_path_, 'tolist') else attr_ElasticNetCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting, for each l1\_ratio.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_alphas_ = bridgeElasticNetCV[${this.id}].alphas_`;
      return this._py`attr_ElasticNetCV_alphas_.tolist() if hasattr(attr_ElasticNetCV_alphas_, 'tolist') else attr_ElasticNetCV_alphas_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_dual_gap_ = bridgeElasticNetCV[${this.id}].dual_gap_`;
      return this._py`attr_ElasticNetCV_dual_gap_.tolist() if hasattr(attr_ElasticNetCV_dual_gap_, 'tolist') else attr_ElasticNetCV_dual_gap_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ElasticNetCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_n_iter_ = bridgeElasticNetCV[${this.id}].n_iter_`;
      return this._py`attr_ElasticNetCV_n_iter_.tolist() if hasattr(attr_ElasticNetCV_n_iter_, 'tolist') else attr_ElasticNetCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_n_features_in_ = bridgeElasticNetCV[${this.id}].n_features_in_`;
      return this._py`attr_ElasticNetCV_n_features_in_.tolist() if hasattr(attr_ElasticNetCV_n_features_in_, 'tolist') else attr_ElasticNetCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This ElasticNetCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ElasticNetCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ElasticNetCV_feature_names_in_ = bridgeElasticNetCV[${this.id}].feature_names_in_`;
      return this._py`attr_ElasticNetCV_feature_names_in_.tolist() if hasattr(attr_ElasticNetCV_feature_names_in_, 'tolist') else attr_ElasticNetCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/GammaRegressor.ts
import crypto5 from "node:crypto";
var GammaRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GammaRegressor${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GammaRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import GammaRegressor
try: bridgeGammaRegressor
except NameError: bridgeGammaRegressor = {}
`;
    await this._py.ex`ctor_GammaRegressor = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_GammaRegressor = {k: v for k, v in ctor_GammaRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGammaRegressor[${this.id}] = GammaRegressor(**ctor_GammaRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGammaRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GammaRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GammaRegressor_fit = {k: v for k, v in pms_GammaRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_fit = bridgeGammaRegressor[${this.id}].fit(**pms_GammaRegressor_fit)`;
    return this._py`res_GammaRegressor_fit.tolist() if hasattr(res_GammaRegressor_fit, 'tolist') else res_GammaRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GammaRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GammaRegressor_get_metadata_routing = {k: v for k, v in pms_GammaRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_get_metadata_routing = bridgeGammaRegressor[${this.id}].get_metadata_routing(**pms_GammaRegressor_get_metadata_routing)`;
    return this._py`res_GammaRegressor_get_metadata_routing.tolist() if hasattr(res_GammaRegressor_get_metadata_routing, 'tolist') else res_GammaRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before predict()");
    }
    await this._py.ex`pms_GammaRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GammaRegressor_predict = {k: v for k, v in pms_GammaRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_predict = bridgeGammaRegressor[${this.id}].predict(**pms_GammaRegressor_predict)`;
    return this._py`res_GammaRegressor_predict.tolist() if hasattr(res_GammaRegressor_predict, 'tolist') else res_GammaRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before score()");
    }
    await this._py.ex`pms_GammaRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GammaRegressor_score = {k: v for k, v in pms_GammaRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_score = bridgeGammaRegressor[${this.id}].score(**pms_GammaRegressor_score)`;
    return this._py`res_GammaRegressor_score.tolist() if hasattr(res_GammaRegressor_score, 'tolist') else res_GammaRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GammaRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GammaRegressor_set_fit_request = {k: v for k, v in pms_GammaRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_set_fit_request = bridgeGammaRegressor[${this.id}].set_fit_request(**pms_GammaRegressor_set_fit_request)`;
    return this._py`res_GammaRegressor_set_fit_request.tolist() if hasattr(res_GammaRegressor_set_fit_request, 'tolist') else res_GammaRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GammaRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GammaRegressor_set_score_request = {k: v for k, v in pms_GammaRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GammaRegressor_set_score_request = bridgeGammaRegressor[${this.id}].set_score_request(**pms_GammaRegressor_set_score_request)`;
    return this._py`res_GammaRegressor_set_score_request.tolist() if hasattr(res_GammaRegressor_set_score_request, 'tolist') else res_GammaRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GammaRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_coef_ = bridgeGammaRegressor[${this.id}].coef_`;
      return this._py`attr_GammaRegressor_coef_.tolist() if hasattr(attr_GammaRegressor_coef_, 'tolist') else attr_GammaRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_intercept_ = bridgeGammaRegressor[${this.id}].intercept_`;
      return this._py`attr_GammaRegressor_intercept_.tolist() if hasattr(attr_GammaRegressor_intercept_, 'tolist') else attr_GammaRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_n_features_in_ = bridgeGammaRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GammaRegressor_n_features_in_.tolist() if hasattr(attr_GammaRegressor_n_features_in_, 'tolist') else attr_GammaRegressor_n_features_in_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_n_iter_ = bridgeGammaRegressor[${this.id}].n_iter_`;
      return this._py`attr_GammaRegressor_n_iter_.tolist() if hasattr(attr_GammaRegressor_n_iter_, 'tolist') else attr_GammaRegressor_n_iter_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GammaRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GammaRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GammaRegressor_feature_names_in_ = bridgeGammaRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GammaRegressor_feature_names_in_.tolist() if hasattr(attr_GammaRegressor_feature_names_in_, 'tolist') else attr_GammaRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/HuberRegressor.ts
import crypto6 from "node:crypto";
var HuberRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HuberRegressor${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HuberRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import HuberRegressor
try: bridgeHuberRegressor
except NameError: bridgeHuberRegressor = {}
`;
    await this._py.ex`ctor_HuberRegressor = {'epsilon': ${this.opts["epsilon"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_HuberRegressor = {k: v for k, v in ctor_HuberRegressor.items() if v is not None}`;
    await this._py.ex`bridgeHuberRegressor[${this.id}] = HuberRegressor(**ctor_HuberRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHuberRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before fit()");
    }
    await this._py.ex`pms_HuberRegressor_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_fit = {k: v for k, v in pms_HuberRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_fit = bridgeHuberRegressor[${this.id}].fit(**pms_HuberRegressor_fit)`;
    return this._py`res_HuberRegressor_fit.tolist() if hasattr(res_HuberRegressor_fit, 'tolist') else res_HuberRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HuberRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HuberRegressor_get_metadata_routing = {k: v for k, v in pms_HuberRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_get_metadata_routing = bridgeHuberRegressor[${this.id}].get_metadata_routing(**pms_HuberRegressor_get_metadata_routing)`;
    return this._py`res_HuberRegressor_get_metadata_routing.tolist() if hasattr(res_HuberRegressor_get_metadata_routing, 'tolist') else res_HuberRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before predict()");
    }
    await this._py.ex`pms_HuberRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_HuberRegressor_predict = {k: v for k, v in pms_HuberRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_predict = bridgeHuberRegressor[${this.id}].predict(**pms_HuberRegressor_predict)`;
    return this._py`res_HuberRegressor_predict.tolist() if hasattr(res_HuberRegressor_predict, 'tolist') else res_HuberRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before score()");
    }
    await this._py.ex`pms_HuberRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HuberRegressor_score = {k: v for k, v in pms_HuberRegressor_score.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_score = bridgeHuberRegressor[${this.id}].score(**pms_HuberRegressor_score)`;
    return this._py`res_HuberRegressor_score.tolist() if hasattr(res_HuberRegressor_score, 'tolist') else res_HuberRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HuberRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_set_fit_request = {k: v for k, v in pms_HuberRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_set_fit_request = bridgeHuberRegressor[${this.id}].set_fit_request(**pms_HuberRegressor_set_fit_request)`;
    return this._py`res_HuberRegressor_set_fit_request.tolist() if hasattr(res_HuberRegressor_set_fit_request, 'tolist') else res_HuberRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HuberRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HuberRegressor_set_score_request = {k: v for k, v in pms_HuberRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HuberRegressor_set_score_request = bridgeHuberRegressor[${this.id}].set_score_request(**pms_HuberRegressor_set_score_request)`;
    return this._py`res_HuberRegressor_set_score_request.tolist() if hasattr(res_HuberRegressor_set_score_request, 'tolist') else res_HuberRegressor_set_score_request`;
  }
  /**
    Features got by optimizing the L2-regularized Huber loss.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_coef_ = bridgeHuberRegressor[${this.id}].coef_`;
      return this._py`attr_HuberRegressor_coef_.tolist() if hasattr(attr_HuberRegressor_coef_, 'tolist') else attr_HuberRegressor_coef_`;
    })();
  }
  /**
    Bias.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_intercept_ = bridgeHuberRegressor[${this.id}].intercept_`;
      return this._py`attr_HuberRegressor_intercept_.tolist() if hasattr(attr_HuberRegressor_intercept_, 'tolist') else attr_HuberRegressor_intercept_`;
    })();
  }
  /**
    The value by which `|y \- Xw \- c|` is scaled down.
   */
  get scale_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HuberRegressor must call init() before accessing scale_");
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_scale_ = bridgeHuberRegressor[${this.id}].scale_`;
      return this._py`attr_HuberRegressor_scale_.tolist() if hasattr(attr_HuberRegressor_scale_, 'tolist') else attr_HuberRegressor_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_n_features_in_ = bridgeHuberRegressor[${this.id}].n_features_in_`;
      return this._py`attr_HuberRegressor_n_features_in_.tolist() if hasattr(attr_HuberRegressor_n_features_in_, 'tolist') else attr_HuberRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_feature_names_in_ = bridgeHuberRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_HuberRegressor_feature_names_in_.tolist() if hasattr(attr_HuberRegressor_feature_names_in_, 'tolist') else attr_HuberRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of iterations that `scipy.optimize.minimize(method="L-BFGS-B")` has run for.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_n_iter_ = bridgeHuberRegressor[${this.id}].n_iter_`;
      return this._py`attr_HuberRegressor_n_iter_.tolist() if hasattr(attr_HuberRegressor_n_iter_, 'tolist') else attr_HuberRegressor_n_iter_`;
    })();
  }
  /**
    A boolean mask which is set to `true` where the samples are identified as outliers.
   */
  get outliers_() {
    if (this._isDisposed) {
      throw new Error("This HuberRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HuberRegressor must call init() before accessing outliers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HuberRegressor_outliers_ = bridgeHuberRegressor[${this.id}].outliers_`;
      return this._py`attr_HuberRegressor_outliers_.tolist() if hasattr(attr_HuberRegressor_outliers_, 'tolist') else attr_HuberRegressor_outliers_`;
    })();
  }
};

// src/generated/linear_model/Lars.ts
import crypto7 from "node:crypto";
var Lars = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Lars${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Lars.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Lars
try: bridgeLars
except NameError: bridgeLars = {}
`;
    await this._py.ex`ctor_Lars = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'n_nonzero_coefs': ${this.opts["n_nonzero_coefs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'fit_path': ${this.opts["fit_path"] ?? void 0}, 'jitter': ${this.opts["jitter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_Lars = {k: v for k, v in ctor_Lars.items() if v is not None}`;
    await this._py.ex`bridgeLars[${this.id}] = Lars(**ctor_Lars)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLars[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before fit()");
    }
    await this._py.ex`pms_Lars_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None}

pms_Lars_fit = {k: v for k, v in pms_Lars_fit.items() if v is not None}`;
    await this._py.ex`res_Lars_fit = bridgeLars[${this.id}].fit(**pms_Lars_fit)`;
    return this._py`res_Lars_fit.tolist() if hasattr(res_Lars_fit, 'tolist') else res_Lars_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Lars_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Lars_get_metadata_routing = {k: v for k, v in pms_Lars_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Lars_get_metadata_routing = bridgeLars[${this.id}].get_metadata_routing(**pms_Lars_get_metadata_routing)`;
    return this._py`res_Lars_get_metadata_routing.tolist() if hasattr(res_Lars_get_metadata_routing, 'tolist') else res_Lars_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before predict()");
    }
    await this._py.ex`pms_Lars_predict = {'X': ${opts["X"] ?? void 0}}

pms_Lars_predict = {k: v for k, v in pms_Lars_predict.items() if v is not None}`;
    await this._py.ex`res_Lars_predict = bridgeLars[${this.id}].predict(**pms_Lars_predict)`;
    return this._py`res_Lars_predict.tolist() if hasattr(res_Lars_predict, 'tolist') else res_Lars_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before score()");
    }
    await this._py.ex`pms_Lars_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Lars_score = {k: v for k, v in pms_Lars_score.items() if v is not None}`;
    await this._py.ex`res_Lars_score = bridgeLars[${this.id}].score(**pms_Lars_score)`;
    return this._py`res_Lars_score.tolist() if hasattr(res_Lars_score, 'tolist') else res_Lars_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Lars_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_Lars_set_fit_request = {k: v for k, v in pms_Lars_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Lars_set_fit_request = bridgeLars[${this.id}].set_fit_request(**pms_Lars_set_fit_request)`;
    return this._py`res_Lars_set_fit_request.tolist() if hasattr(res_Lars_set_fit_request, 'tolist') else res_Lars_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before set_score_request()");
    }
    await this._py.ex`pms_Lars_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lars_set_score_request = {k: v for k, v in pms_Lars_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Lars_set_score_request = bridgeLars[${this.id}].set_score_request(**pms_Lars_set_score_request)`;
    return this._py`res_Lars_set_score_request.tolist() if hasattr(res_Lars_set_score_request, 'tolist') else res_Lars_set_score_request`;
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_alphas_ = bridgeLars[${this.id}].alphas_`;
      return this._py`attr_Lars_alphas_.tolist() if hasattr(attr_Lars_alphas_, 'tolist') else attr_Lars_alphas_`;
    })();
  }
  /**
    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_active_ = bridgeLars[${this.id}].active_`;
      return this._py`attr_Lars_active_.tolist() if hasattr(attr_Lars_active_, 'tolist') else attr_Lars_active_`;
    })();
  }
  /**
    The varying values of the coefficients along the path. It is not present if the `fit\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_coef_path_ = bridgeLars[${this.id}].coef_path_`;
      return this._py`attr_Lars_coef_path_.tolist() if hasattr(attr_Lars_coef_path_, 'tolist') else attr_Lars_coef_path_`;
    })();
  }
  /**
    Parameter vector (w in the formulation formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_coef_ = bridgeLars[${this.id}].coef_`;
      return this._py`attr_Lars_coef_.tolist() if hasattr(attr_Lars_coef_, 'tolist') else attr_Lars_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_intercept_ = bridgeLars[${this.id}].intercept_`;
      return this._py`attr_Lars_intercept_.tolist() if hasattr(attr_Lars_intercept_, 'tolist') else attr_Lars_intercept_`;
    })();
  }
  /**
    The number of iterations taken by lars\_path to find the grid of alphas for each target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_n_iter_ = bridgeLars[${this.id}].n_iter_`;
      return this._py`attr_Lars_n_iter_.tolist() if hasattr(attr_Lars_n_iter_, 'tolist') else attr_Lars_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lars must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Lars_n_features_in_ = bridgeLars[${this.id}].n_features_in_`;
      return this._py`attr_Lars_n_features_in_.tolist() if hasattr(attr_Lars_n_features_in_, 'tolist') else attr_Lars_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Lars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Lars must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Lars_feature_names_in_ = bridgeLars[${this.id}].feature_names_in_`;
      return this._py`attr_Lars_feature_names_in_.tolist() if hasattr(attr_Lars_feature_names_in_, 'tolist') else attr_Lars_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LarsCV.ts
import crypto8 from "node:crypto";
var LarsCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LarsCV${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LarsCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LarsCV
try: bridgeLarsCV
except NameError: bridgeLarsCV = {}
`;
    await this._py.ex`ctor_LarsCV = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'max_n_alphas': ${this.opts["max_n_alphas"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}}

ctor_LarsCV = {k: v for k, v in ctor_LarsCV.items() if v is not None}`;
    await this._py.ex`bridgeLarsCV[${this.id}] = LarsCV(**ctor_LarsCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLarsCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before fit()");
    }
    await this._py.ex`pms_LarsCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LarsCV_fit = {k: v for k, v in pms_LarsCV_fit.items() if v is not None}`;
    await this._py.ex`res_LarsCV_fit = bridgeLarsCV[${this.id}].fit(**pms_LarsCV_fit)`;
    return this._py`res_LarsCV_fit.tolist() if hasattr(res_LarsCV_fit, 'tolist') else res_LarsCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_LarsCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LarsCV_get_metadata_routing = {k: v for k, v in pms_LarsCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LarsCV_get_metadata_routing = bridgeLarsCV[${this.id}].get_metadata_routing(**pms_LarsCV_get_metadata_routing)`;
    return this._py`res_LarsCV_get_metadata_routing.tolist() if hasattr(res_LarsCV_get_metadata_routing, 'tolist') else res_LarsCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before predict()");
    }
    await this._py.ex`pms_LarsCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LarsCV_predict = {k: v for k, v in pms_LarsCV_predict.items() if v is not None}`;
    await this._py.ex`res_LarsCV_predict = bridgeLarsCV[${this.id}].predict(**pms_LarsCV_predict)`;
    return this._py`res_LarsCV_predict.tolist() if hasattr(res_LarsCV_predict, 'tolist') else res_LarsCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before score()");
    }
    await this._py.ex`pms_LarsCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LarsCV_score = {k: v for k, v in pms_LarsCV_score.items() if v is not None}`;
    await this._py.ex`res_LarsCV_score = bridgeLarsCV[${this.id}].score(**pms_LarsCV_score)`;
    return this._py`res_LarsCV_score.tolist() if hasattr(res_LarsCV_score, 'tolist') else res_LarsCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LarsCV_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LarsCV_set_fit_request = {k: v for k, v in pms_LarsCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LarsCV_set_fit_request = bridgeLarsCV[${this.id}].set_fit_request(**pms_LarsCV_set_fit_request)`;
    return this._py`res_LarsCV_set_fit_request.tolist() if hasattr(res_LarsCV_set_fit_request, 'tolist') else res_LarsCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LarsCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LarsCV_set_score_request = {k: v for k, v in pms_LarsCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LarsCV_set_score_request = bridgeLarsCV[${this.id}].set_score_request(**pms_LarsCV_set_score_request)`;
    return this._py`res_LarsCV_set_score_request.tolist() if hasattr(res_LarsCV_set_score_request, 'tolist') else res_LarsCV_set_score_request`;
  }
  /**
    Indices of active variables at the end of the path. If this is a list of lists, the outer list length is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_active_ = bridgeLarsCV[${this.id}].active_`;
      return this._py`attr_LarsCV_active_.tolist() if hasattr(attr_LarsCV_active_, 'tolist') else attr_LarsCV_active_`;
    })();
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_coef_ = bridgeLarsCV[${this.id}].coef_`;
      return this._py`attr_LarsCV_coef_.tolist() if hasattr(attr_LarsCV_coef_, 'tolist') else attr_LarsCV_coef_`;
    })();
  }
  /**
    independent term in decision function
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_intercept_ = bridgeLarsCV[${this.id}].intercept_`;
      return this._py`attr_LarsCV_intercept_.tolist() if hasattr(attr_LarsCV_intercept_, 'tolist') else attr_LarsCV_intercept_`;
    })();
  }
  /**
    the varying values of the coefficients along the path
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_coef_path_ = bridgeLarsCV[${this.id}].coef_path_`;
      return this._py`attr_LarsCV_coef_path_.tolist() if hasattr(attr_LarsCV_coef_path_, 'tolist') else attr_LarsCV_coef_path_`;
    })();
  }
  /**
    the estimated regularization parameter alpha
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_alpha_ = bridgeLarsCV[${this.id}].alpha_`;
      return this._py`attr_LarsCV_alpha_.tolist() if hasattr(attr_LarsCV_alpha_, 'tolist') else attr_LarsCV_alpha_`;
    })();
  }
  /**
    the different values of alpha along the path
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_alphas_ = bridgeLarsCV[${this.id}].alphas_`;
      return this._py`attr_LarsCV_alphas_.tolist() if hasattr(attr_LarsCV_alphas_, 'tolist') else attr_LarsCV_alphas_`;
    })();
  }
  /**
    all the values of alpha along the path for the different folds
   */
  get cv_alphas_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing cv_alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_cv_alphas_ = bridgeLarsCV[${this.id}].cv_alphas_`;
      return this._py`attr_LarsCV_cv_alphas_.tolist() if hasattr(attr_LarsCV_cv_alphas_, 'tolist') else attr_LarsCV_cv_alphas_`;
    })();
  }
  /**
    the mean square error on left-out for each fold along the path (alpha values given by `cv\_alphas`)
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_mse_path_ = bridgeLarsCV[${this.id}].mse_path_`;
      return this._py`attr_LarsCV_mse_path_.tolist() if hasattr(attr_LarsCV_mse_path_, 'tolist') else attr_LarsCV_mse_path_`;
    })();
  }
  /**
    the number of iterations run by Lars with the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_n_iter_ = bridgeLarsCV[${this.id}].n_iter_`;
      return this._py`attr_LarsCV_n_iter_.tolist() if hasattr(attr_LarsCV_n_iter_, 'tolist') else attr_LarsCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LarsCV must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_n_features_in_ = bridgeLarsCV[${this.id}].n_features_in_`;
      return this._py`attr_LarsCV_n_features_in_.tolist() if hasattr(attr_LarsCV_n_features_in_, 'tolist') else attr_LarsCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LarsCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LarsCV_feature_names_in_ = bridgeLarsCV[${this.id}].feature_names_in_`;
      return this._py`attr_LarsCV_feature_names_in_.tolist() if hasattr(attr_LarsCV_feature_names_in_, 'tolist') else attr_LarsCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/Lasso.ts
import crypto9 from "node:crypto";
var Lasso = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Lasso${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Lasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Lasso
try: bridgeLasso
except NameError: bridgeLasso = {}
`;
    await this._py.ex`ctor_Lasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_Lasso = {k: v for k, v in ctor_Lasso.items() if v is not None}`;
    await this._py.ex`bridgeLasso[${this.id}] = Lasso(**ctor_Lasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before fit()");
    }
    await this._py.ex`pms_Lasso_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'check_input': ${opts["check_input"] ?? void 0}}

pms_Lasso_fit = {k: v for k, v in pms_Lasso_fit.items() if v is not None}`;
    await this._py.ex`res_Lasso_fit = bridgeLasso[${this.id}].fit(**pms_Lasso_fit)`;
    return this._py`res_Lasso_fit.tolist() if hasattr(res_Lasso_fit, 'tolist') else res_Lasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Lasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Lasso_get_metadata_routing = {k: v for k, v in pms_Lasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Lasso_get_metadata_routing = bridgeLasso[${this.id}].get_metadata_routing(**pms_Lasso_get_metadata_routing)`;
    return this._py`res_Lasso_get_metadata_routing.tolist() if hasattr(res_Lasso_get_metadata_routing, 'tolist') else res_Lasso_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before path()");
    }
    await this._py.ex`pms_Lasso_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_Lasso_path = {k: v for k, v in pms_Lasso_path.items() if v is not None}`;
    await this._py.ex`res_Lasso_path = bridgeLasso[${this.id}].path(**pms_Lasso_path)`;
    return this._py`res_Lasso_path.tolist() if hasattr(res_Lasso_path, 'tolist') else res_Lasso_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before predict()");
    }
    await this._py.ex`pms_Lasso_predict = {'X': ${opts["X"] ?? void 0}}

pms_Lasso_predict = {k: v for k, v in pms_Lasso_predict.items() if v is not None}`;
    await this._py.ex`res_Lasso_predict = bridgeLasso[${this.id}].predict(**pms_Lasso_predict)`;
    return this._py`res_Lasso_predict.tolist() if hasattr(res_Lasso_predict, 'tolist') else res_Lasso_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before score()");
    }
    await this._py.ex`pms_Lasso_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Lasso_score = {k: v for k, v in pms_Lasso_score.items() if v is not None}`;
    await this._py.ex`res_Lasso_score = bridgeLasso[${this.id}].score(**pms_Lasso_score)`;
    return this._py`res_Lasso_score.tolist() if hasattr(res_Lasso_score, 'tolist') else res_Lasso_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Lasso_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lasso_set_fit_request = {k: v for k, v in pms_Lasso_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Lasso_set_fit_request = bridgeLasso[${this.id}].set_fit_request(**pms_Lasso_set_fit_request)`;
    return this._py`res_Lasso_set_fit_request.tolist() if hasattr(res_Lasso_set_fit_request, 'tolist') else res_Lasso_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before set_score_request()");
    }
    await this._py.ex`pms_Lasso_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Lasso_set_score_request = {k: v for k, v in pms_Lasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Lasso_set_score_request = bridgeLasso[${this.id}].set_score_request(**pms_Lasso_set_score_request)`;
    return this._py`res_Lasso_set_score_request.tolist() if hasattr(res_Lasso_set_score_request, 'tolist') else res_Lasso_set_score_request`;
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_coef_ = bridgeLasso[${this.id}].coef_`;
      return this._py`attr_Lasso_coef_.tolist() if hasattr(attr_Lasso_coef_, 'tolist') else attr_Lasso_coef_`;
    })();
  }
  /**
    Given param alpha, the dual gaps at the end of the optimization, same shape as each observation of y.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_dual_gap_ = bridgeLasso[${this.id}].dual_gap_`;
      return this._py`attr_Lasso_dual_gap_.tolist() if hasattr(attr_Lasso_dual_gap_, 'tolist') else attr_Lasso_dual_gap_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_intercept_ = bridgeLasso[${this.id}].intercept_`;
      return this._py`attr_Lasso_intercept_.tolist() if hasattr(attr_Lasso_intercept_, 'tolist') else attr_Lasso_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_n_iter_ = bridgeLasso[${this.id}].n_iter_`;
      return this._py`attr_Lasso_n_iter_.tolist() if hasattr(attr_Lasso_n_iter_, 'tolist') else attr_Lasso_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Lasso must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Lasso_n_features_in_ = bridgeLasso[${this.id}].n_features_in_`;
      return this._py`attr_Lasso_n_features_in_.tolist() if hasattr(attr_Lasso_n_features_in_, 'tolist') else attr_Lasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Lasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Lasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Lasso_feature_names_in_ = bridgeLasso[${this.id}].feature_names_in_`;
      return this._py`attr_Lasso_feature_names_in_.tolist() if hasattr(attr_Lasso_feature_names_in_, 'tolist') else attr_Lasso_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoCV.ts
import crypto10 from "node:crypto";
var LassoCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoCV${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoCV
try: bridgeLassoCV
except NameError: bridgeLassoCV = {}
`;
    await this._py.ex`ctor_LassoCV = {'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'precompute': np.array(${this.opts["precompute"] ?? void 0}) if ${this.opts["precompute"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_LassoCV = {k: v for k, v in ctor_LassoCV.items() if v is not None}`;
    await this._py.ex`bridgeLassoCV[${this.id}] = LassoCV(**ctor_LassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit linear model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before fit()");
    }
    await this._py.ex`pms_LassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoCV_fit = {k: v for k, v in pms_LassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_LassoCV_fit = bridgeLassoCV[${this.id}].fit(**pms_LassoCV_fit)`;
    return this._py`res_LassoCV_fit.tolist() if hasattr(res_LassoCV_fit, 'tolist') else res_LassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_LassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoCV_get_metadata_routing = {k: v for k, v in pms_LassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoCV_get_metadata_routing = bridgeLassoCV[${this.id}].get_metadata_routing(**pms_LassoCV_get_metadata_routing)`;
    return this._py`res_LassoCV_get_metadata_routing.tolist() if hasattr(res_LassoCV_get_metadata_routing, 'tolist') else res_LassoCV_get_metadata_routing`;
  }
  /**
      Compute Lasso path with coordinate descent.
  
      The Lasso optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before path()");
    }
    await this._py.ex`pms_LassoCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_LassoCV_path = {k: v for k, v in pms_LassoCV_path.items() if v is not None}`;
    await this._py.ex`res_LassoCV_path = bridgeLassoCV[${this.id}].path(**pms_LassoCV_path)`;
    return this._py`res_LassoCV_path.tolist() if hasattr(res_LassoCV_path, 'tolist') else res_LassoCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before predict()");
    }
    await this._py.ex`pms_LassoCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoCV_predict = {k: v for k, v in pms_LassoCV_predict.items() if v is not None}`;
    await this._py.ex`res_LassoCV_predict = bridgeLassoCV[${this.id}].predict(**pms_LassoCV_predict)`;
    return this._py`res_LassoCV_predict.tolist() if hasattr(res_LassoCV_predict, 'tolist') else res_LassoCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before score()");
    }
    await this._py.ex`pms_LassoCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoCV_score = {k: v for k, v in pms_LassoCV_score.items() if v is not None}`;
    await this._py.ex`res_LassoCV_score = bridgeLassoCV[${this.id}].score(**pms_LassoCV_score)`;
    return this._py`res_LassoCV_score.tolist() if hasattr(res_LassoCV_score, 'tolist') else res_LassoCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoCV_set_fit_request = {k: v for k, v in pms_LassoCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoCV_set_fit_request = bridgeLassoCV[${this.id}].set_fit_request(**pms_LassoCV_set_fit_request)`;
    return this._py`res_LassoCV_set_fit_request.tolist() if hasattr(res_LassoCV_set_fit_request, 'tolist') else res_LassoCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoCV_set_score_request = {k: v for k, v in pms_LassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoCV_set_score_request = bridgeLassoCV[${this.id}].set_score_request(**pms_LassoCV_set_score_request)`;
    return this._py`res_LassoCV_set_score_request.tolist() if hasattr(res_LassoCV_set_score_request, 'tolist') else res_LassoCV_set_score_request`;
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_alpha_ = bridgeLassoCV[${this.id}].alpha_`;
      return this._py`attr_LassoCV_alpha_.tolist() if hasattr(attr_LassoCV_alpha_, 'tolist') else attr_LassoCV_alpha_`;
    })();
  }
  /**
    Parameter vector (w in the cost function formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_coef_ = bridgeLassoCV[${this.id}].coef_`;
      return this._py`attr_LassoCV_coef_.tolist() if hasattr(attr_LassoCV_coef_, 'tolist') else attr_LassoCV_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_intercept_ = bridgeLassoCV[${this.id}].intercept_`;
      return this._py`attr_LassoCV_intercept_.tolist() if hasattr(attr_LassoCV_intercept_, 'tolist') else attr_LassoCV_intercept_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_mse_path_ = bridgeLassoCV[${this.id}].mse_path_`;
      return this._py`attr_LassoCV_mse_path_.tolist() if hasattr(attr_LassoCV_mse_path_, 'tolist') else attr_LassoCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_alphas_ = bridgeLassoCV[${this.id}].alphas_`;
      return this._py`attr_LassoCV_alphas_.tolist() if hasattr(attr_LassoCV_alphas_, 'tolist') else attr_LassoCV_alphas_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha (`alpha\_`).
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing dual_gap_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_dual_gap_ = bridgeLassoCV[${this.id}].dual_gap_`;
      return this._py`attr_LassoCV_dual_gap_.tolist() if hasattr(attr_LassoCV_dual_gap_, 'tolist') else attr_LassoCV_dual_gap_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_n_iter_ = bridgeLassoCV[${this.id}].n_iter_`;
      return this._py`attr_LassoCV_n_iter_.tolist() if hasattr(attr_LassoCV_n_iter_, 'tolist') else attr_LassoCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_n_features_in_ = bridgeLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_LassoCV_n_features_in_.tolist() if hasattr(attr_LassoCV_n_features_in_, 'tolist') else attr_LassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoCV_feature_names_in_ = bridgeLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_LassoCV_feature_names_in_.tolist() if hasattr(attr_LassoCV_feature_names_in_, 'tolist') else attr_LassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLars.ts
import crypto11 from "node:crypto";
var LassoLars = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLars${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLars.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLars
try: bridgeLassoLars
except NameError: bridgeLassoLars = {}
`;
    await this._py.ex`ctor_LassoLars = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'fit_path': ${this.opts["fit_path"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'jitter': ${this.opts["jitter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_LassoLars = {k: v for k, v in ctor_LassoLars.items() if v is not None}`;
    await this._py.ex`bridgeLassoLars[${this.id}] = LassoLars(**ctor_LassoLars)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLars[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before fit()");
    }
    await this._py.ex`pms_LassoLars_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None}

pms_LassoLars_fit = {k: v for k, v in pms_LassoLars_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLars_fit = bridgeLassoLars[${this.id}].fit(**pms_LassoLars_fit)`;
    return this._py`res_LassoLars_fit.tolist() if hasattr(res_LassoLars_fit, 'tolist') else res_LassoLars_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLars_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLars_get_metadata_routing = {k: v for k, v in pms_LassoLars_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLars_get_metadata_routing = bridgeLassoLars[${this.id}].get_metadata_routing(**pms_LassoLars_get_metadata_routing)`;
    return this._py`res_LassoLars_get_metadata_routing.tolist() if hasattr(res_LassoLars_get_metadata_routing, 'tolist') else res_LassoLars_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before predict()");
    }
    await this._py.ex`pms_LassoLars_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLars_predict = {k: v for k, v in pms_LassoLars_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLars_predict = bridgeLassoLars[${this.id}].predict(**pms_LassoLars_predict)`;
    return this._py`res_LassoLars_predict.tolist() if hasattr(res_LassoLars_predict, 'tolist') else res_LassoLars_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before score()");
    }
    await this._py.ex`pms_LassoLars_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLars_score = {k: v for k, v in pms_LassoLars_score.items() if v is not None}`;
    await this._py.ex`res_LassoLars_score = bridgeLassoLars[${this.id}].score(**pms_LassoLars_score)`;
    return this._py`res_LassoLars_score.tolist() if hasattr(res_LassoLars_score, 'tolist') else res_LassoLars_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLars_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LassoLars_set_fit_request = {k: v for k, v in pms_LassoLars_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLars_set_fit_request = bridgeLassoLars[${this.id}].set_fit_request(**pms_LassoLars_set_fit_request)`;
    return this._py`res_LassoLars_set_fit_request.tolist() if hasattr(res_LassoLars_set_fit_request, 'tolist') else res_LassoLars_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLars_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLars_set_score_request = {k: v for k, v in pms_LassoLars_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLars_set_score_request = bridgeLassoLars[${this.id}].set_score_request(**pms_LassoLars_set_score_request)`;
    return this._py`res_LassoLars_set_score_request.tolist() if hasattr(res_LassoLars_set_score_request, 'tolist') else res_LassoLars_set_score_request`;
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_alphas_ = bridgeLassoLars[${this.id}].alphas_`;
      return this._py`attr_LassoLars_alphas_.tolist() if hasattr(attr_LassoLars_alphas_, 'tolist') else attr_LassoLars_alphas_`;
    })();
  }
  /**
    Indices of active variables at the end of the path. If this is a list of list, the length of the outer list is `n\_targets`.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_active_ = bridgeLassoLars[${this.id}].active_`;
      return this._py`attr_LassoLars_active_.tolist() if hasattr(attr_LassoLars_active_, 'tolist') else attr_LassoLars_active_`;
    })();
  }
  /**
    If a list is passed its expected to be one of n\_targets such arrays. The varying values of the coefficients along the path. It is not present if the `fit\_path` parameter is `false`. If this is a list of array-like, the length of the outer list is `n\_targets`.
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing coef_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_coef_path_ = bridgeLassoLars[${this.id}].coef_path_`;
      return this._py`attr_LassoLars_coef_path_.tolist() if hasattr(attr_LassoLars_coef_path_, 'tolist') else attr_LassoLars_coef_path_`;
    })();
  }
  /**
    Parameter vector (w in the formulation formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_coef_ = bridgeLassoLars[${this.id}].coef_`;
      return this._py`attr_LassoLars_coef_.tolist() if hasattr(attr_LassoLars_coef_, 'tolist') else attr_LassoLars_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_intercept_ = bridgeLassoLars[${this.id}].intercept_`;
      return this._py`attr_LassoLars_intercept_.tolist() if hasattr(attr_LassoLars_intercept_, 'tolist') else attr_LassoLars_intercept_`;
    })();
  }
  /**
    The number of iterations taken by lars\_path to find the grid of alphas for each target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLars must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_n_iter_ = bridgeLassoLars[${this.id}].n_iter_`;
      return this._py`attr_LassoLars_n_iter_.tolist() if hasattr(attr_LassoLars_n_iter_, 'tolist') else attr_LassoLars_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_n_features_in_ = bridgeLassoLars[${this.id}].n_features_in_`;
      return this._py`attr_LassoLars_n_features_in_.tolist() if hasattr(attr_LassoLars_n_features_in_, 'tolist') else attr_LassoLars_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLars instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLars must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLars_feature_names_in_ = bridgeLassoLars[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLars_feature_names_in_.tolist() if hasattr(attr_LassoLars_feature_names_in_, 'tolist') else attr_LassoLars_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLarsCV.ts
import crypto12 from "node:crypto";
var LassoLarsCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLarsCV${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLarsCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLarsCV
try: bridgeLassoLarsCV
except NameError: bridgeLassoLarsCV = {}
`;
    await this._py.ex`ctor_LassoLarsCV = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'max_n_alphas': ${this.opts["max_n_alphas"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}}

ctor_LassoLarsCV = {k: v for k, v in ctor_LassoLarsCV.items() if v is not None}`;
    await this._py.ex`bridgeLassoLarsCV[${this.id}] = LassoLarsCV(**ctor_LassoLarsCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLarsCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before fit()");
    }
    await this._py.ex`pms_LassoLarsCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LassoLarsCV_fit = {k: v for k, v in pms_LassoLarsCV_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_fit = bridgeLassoLarsCV[${this.id}].fit(**pms_LassoLarsCV_fit)`;
    return this._py`res_LassoLarsCV_fit.tolist() if hasattr(res_LassoLarsCV_fit, 'tolist') else res_LassoLarsCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLarsCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLarsCV_get_metadata_routing = {k: v for k, v in pms_LassoLarsCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_get_metadata_routing = bridgeLassoLarsCV[${this.id}].get_metadata_routing(**pms_LassoLarsCV_get_metadata_routing)`;
    return this._py`res_LassoLarsCV_get_metadata_routing.tolist() if hasattr(res_LassoLarsCV_get_metadata_routing, 'tolist') else res_LassoLarsCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before predict()");
    }
    await this._py.ex`pms_LassoLarsCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLarsCV_predict = {k: v for k, v in pms_LassoLarsCV_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_predict = bridgeLassoLarsCV[${this.id}].predict(**pms_LassoLarsCV_predict)`;
    return this._py`res_LassoLarsCV_predict.tolist() if hasattr(res_LassoLarsCV_predict, 'tolist') else res_LassoLarsCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before score()");
    }
    await this._py.ex`pms_LassoLarsCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLarsCV_score = {k: v for k, v in pms_LassoLarsCV_score.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_score = bridgeLassoLarsCV[${this.id}].score(**pms_LassoLarsCV_score)`;
    return this._py`res_LassoLarsCV_score.tolist() if hasattr(res_LassoLarsCV_score, 'tolist') else res_LassoLarsCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLarsCV_set_fit_request = {'Xy': ${opts["Xy"] ?? void 0}}

pms_LassoLarsCV_set_fit_request = {k: v for k, v in pms_LassoLarsCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_set_fit_request = bridgeLassoLarsCV[${this.id}].set_fit_request(**pms_LassoLarsCV_set_fit_request)`;
    return this._py`res_LassoLarsCV_set_fit_request.tolist() if hasattr(res_LassoLarsCV_set_fit_request, 'tolist') else res_LassoLarsCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLarsCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLarsCV_set_score_request = {k: v for k, v in pms_LassoLarsCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsCV_set_score_request = bridgeLassoLarsCV[${this.id}].set_score_request(**pms_LassoLarsCV_set_score_request)`;
    return this._py`res_LassoLarsCV_set_score_request.tolist() if hasattr(res_LassoLarsCV_set_score_request, 'tolist') else res_LassoLarsCV_set_score_request`;
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_coef_ = bridgeLassoLarsCV[${this.id}].coef_`;
      return this._py`attr_LassoLarsCV_coef_.tolist() if hasattr(attr_LassoLarsCV_coef_, 'tolist') else attr_LassoLarsCV_coef_`;
    })();
  }
  /**
    independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_intercept_ = bridgeLassoLarsCV[${this.id}].intercept_`;
      return this._py`attr_LassoLarsCV_intercept_.tolist() if hasattr(attr_LassoLarsCV_intercept_, 'tolist') else attr_LassoLarsCV_intercept_`;
    })();
  }
  /**
    the varying values of the coefficients along the path
   */
  get coef_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing coef_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_coef_path_ = bridgeLassoLarsCV[${this.id}].coef_path_`;
      return this._py`attr_LassoLarsCV_coef_path_.tolist() if hasattr(attr_LassoLarsCV_coef_path_, 'tolist') else attr_LassoLarsCV_coef_path_`;
    })();
  }
  /**
    the estimated regularization parameter alpha
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_alpha_ = bridgeLassoLarsCV[${this.id}].alpha_`;
      return this._py`attr_LassoLarsCV_alpha_.tolist() if hasattr(attr_LassoLarsCV_alpha_, 'tolist') else attr_LassoLarsCV_alpha_`;
    })();
  }
  /**
    the different values of alpha along the path
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_alphas_ = bridgeLassoLarsCV[${this.id}].alphas_`;
      return this._py`attr_LassoLarsCV_alphas_.tolist() if hasattr(attr_LassoLarsCV_alphas_, 'tolist') else attr_LassoLarsCV_alphas_`;
    })();
  }
  /**
    all the values of alpha along the path for the different folds
   */
  get cv_alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing cv_alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_cv_alphas_ = bridgeLassoLarsCV[${this.id}].cv_alphas_`;
      return this._py`attr_LassoLarsCV_cv_alphas_.tolist() if hasattr(attr_LassoLarsCV_cv_alphas_, 'tolist') else attr_LassoLarsCV_cv_alphas_`;
    })();
  }
  /**
    the mean square error on left-out for each fold along the path (alpha values given by `cv\_alphas`)
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing mse_path_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_mse_path_ = bridgeLassoLarsCV[${this.id}].mse_path_`;
      return this._py`attr_LassoLarsCV_mse_path_.tolist() if hasattr(attr_LassoLarsCV_mse_path_, 'tolist') else attr_LassoLarsCV_mse_path_`;
    })();
  }
  /**
    the number of iterations run by Lars with the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_n_iter_ = bridgeLassoLarsCV[${this.id}].n_iter_`;
      return this._py`attr_LassoLarsCV_n_iter_.tolist() if hasattr(attr_LassoLarsCV_n_iter_, 'tolist') else attr_LassoLarsCV_n_iter_`;
    })();
  }
  /**
    Indices of active variables at the end of the path.
   */
  get active_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsCV must call init() before accessing active_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_active_ = bridgeLassoLarsCV[${this.id}].active_`;
      return this._py`attr_LassoLarsCV_active_.tolist() if hasattr(attr_LassoLarsCV_active_, 'tolist') else attr_LassoLarsCV_active_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_n_features_in_ = bridgeLassoLarsCV[${this.id}].n_features_in_`;
      return this._py`attr_LassoLarsCV_n_features_in_.tolist() if hasattr(attr_LassoLarsCV_n_features_in_, 'tolist') else attr_LassoLarsCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsCV_feature_names_in_ = bridgeLassoLarsCV[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLarsCV_feature_names_in_.tolist() if hasattr(attr_LassoLarsCV_feature_names_in_, 'tolist') else attr_LassoLarsCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LassoLarsIC.ts
import crypto13 from "node:crypto";
var LassoLarsIC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LassoLarsIC${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LassoLarsIC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LassoLarsIC
try: bridgeLassoLarsIC
except NameError: bridgeLassoLarsIC = {}
`;
    await this._py.ex`ctor_LassoLarsIC = {'criterion': ${this.opts["criterion"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'noise_variance': ${this.opts["noise_variance"] ?? void 0}}

ctor_LassoLarsIC = {k: v for k, v in ctor_LassoLarsIC.items() if v is not None}`;
    await this._py.ex`bridgeLassoLarsIC[${this.id}] = LassoLarsIC(**ctor_LassoLarsIC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLassoLarsIC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before fit()");
    }
    await this._py.ex`pms_LassoLarsIC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}}

pms_LassoLarsIC_fit = {k: v for k, v in pms_LassoLarsIC_fit.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_fit = bridgeLassoLarsIC[${this.id}].fit(**pms_LassoLarsIC_fit)`;
    return this._py`res_LassoLarsIC_fit.tolist() if hasattr(res_LassoLarsIC_fit, 'tolist') else res_LassoLarsIC_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LassoLarsIC_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LassoLarsIC_get_metadata_routing = {k: v for k, v in pms_LassoLarsIC_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_get_metadata_routing = bridgeLassoLarsIC[${this.id}].get_metadata_routing(**pms_LassoLarsIC_get_metadata_routing)`;
    return this._py`res_LassoLarsIC_get_metadata_routing.tolist() if hasattr(res_LassoLarsIC_get_metadata_routing, 'tolist') else res_LassoLarsIC_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before predict()");
    }
    await this._py.ex`pms_LassoLarsIC_predict = {'X': ${opts["X"] ?? void 0}}

pms_LassoLarsIC_predict = {k: v for k, v in pms_LassoLarsIC_predict.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_predict = bridgeLassoLarsIC[${this.id}].predict(**pms_LassoLarsIC_predict)`;
    return this._py`res_LassoLarsIC_predict.tolist() if hasattr(res_LassoLarsIC_predict, 'tolist') else res_LassoLarsIC_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before score()");
    }
    await this._py.ex`pms_LassoLarsIC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LassoLarsIC_score = {k: v for k, v in pms_LassoLarsIC_score.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_score = bridgeLassoLarsIC[${this.id}].score(**pms_LassoLarsIC_score)`;
    return this._py`res_LassoLarsIC_score.tolist() if hasattr(res_LassoLarsIC_score, 'tolist') else res_LassoLarsIC_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before set_fit_request()");
    }
    await this._py.ex`pms_LassoLarsIC_set_fit_request = {'copy_X': ${opts["copy_X"] ?? void 0}}

pms_LassoLarsIC_set_fit_request = {k: v for k, v in pms_LassoLarsIC_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_set_fit_request = bridgeLassoLarsIC[${this.id}].set_fit_request(**pms_LassoLarsIC_set_fit_request)`;
    return this._py`res_LassoLarsIC_set_fit_request.tolist() if hasattr(res_LassoLarsIC_set_fit_request, 'tolist') else res_LassoLarsIC_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before set_score_request()");
    }
    await this._py.ex`pms_LassoLarsIC_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LassoLarsIC_set_score_request = {k: v for k, v in pms_LassoLarsIC_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LassoLarsIC_set_score_request = bridgeLassoLarsIC[${this.id}].set_score_request(**pms_LassoLarsIC_set_score_request)`;
    return this._py`res_LassoLarsIC_set_score_request.tolist() if hasattr(res_LassoLarsIC_set_score_request, 'tolist') else res_LassoLarsIC_set_score_request`;
  }
  /**
    parameter vector (w in the formulation formula)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_coef_ = bridgeLassoLarsIC[${this.id}].coef_`;
      return this._py`attr_LassoLarsIC_coef_.tolist() if hasattr(attr_LassoLarsIC_coef_, 'tolist') else attr_LassoLarsIC_coef_`;
    })();
  }
  /**
    independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_intercept_ = bridgeLassoLarsIC[${this.id}].intercept_`;
      return this._py`attr_LassoLarsIC_intercept_.tolist() if hasattr(attr_LassoLarsIC_intercept_, 'tolist') else attr_LassoLarsIC_intercept_`;
    })();
  }
  /**
    the alpha parameter chosen by the information criterion
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_alpha_ = bridgeLassoLarsIC[${this.id}].alpha_`;
      return this._py`attr_LassoLarsIC_alpha_.tolist() if hasattr(attr_LassoLarsIC_alpha_, 'tolist') else attr_LassoLarsIC_alpha_`;
    })();
  }
  /**
    Maximum of covariances (in absolute value) at each iteration. `n\_alphas` is either `max\_iter`, `n\_features` or the number of nodes in the path with `alpha >= alpha\_min`, whichever is smaller. If a list, it will be of length `n\_targets`.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing alphas_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_alphas_ = bridgeLassoLarsIC[${this.id}].alphas_`;
      return this._py`attr_LassoLarsIC_alphas_.tolist() if hasattr(attr_LassoLarsIC_alphas_, 'tolist') else attr_LassoLarsIC_alphas_`;
    })();
  }
  /**
    number of iterations run by lars\_path to find the grid of alphas.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LassoLarsIC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_n_iter_ = bridgeLassoLarsIC[${this.id}].n_iter_`;
      return this._py`attr_LassoLarsIC_n_iter_.tolist() if hasattr(attr_LassoLarsIC_n_iter_, 'tolist') else attr_LassoLarsIC_n_iter_`;
    })();
  }
  /**
    The value of the information criteria (aic, bic) across all alphas. The alpha which has the smallest information criterion is chosen, as specified in [\[1\]](#rde9cc43d0d41-1).
   */
  get criterion_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing criterion_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_criterion_ = bridgeLassoLarsIC[${this.id}].criterion_`;
      return this._py`attr_LassoLarsIC_criterion_.tolist() if hasattr(attr_LassoLarsIC_criterion_, 'tolist') else attr_LassoLarsIC_criterion_`;
    })();
  }
  /**
    The estimated noise variance from the data used to compute the criterion.
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_noise_variance_ = bridgeLassoLarsIC[${this.id}].noise_variance_`;
      return this._py`attr_LassoLarsIC_noise_variance_.tolist() if hasattr(attr_LassoLarsIC_noise_variance_, 'tolist') else attr_LassoLarsIC_noise_variance_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_n_features_in_ = bridgeLassoLarsIC[${this.id}].n_features_in_`;
      return this._py`attr_LassoLarsIC_n_features_in_.tolist() if hasattr(attr_LassoLarsIC_n_features_in_, 'tolist') else attr_LassoLarsIC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LassoLarsIC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LassoLarsIC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LassoLarsIC_feature_names_in_ = bridgeLassoLarsIC[${this.id}].feature_names_in_`;
      return this._py`attr_LassoLarsIC_feature_names_in_.tolist() if hasattr(attr_LassoLarsIC_feature_names_in_, 'tolist') else attr_LassoLarsIC_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LinearRegression.ts
import crypto14 from "node:crypto";
var LinearRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearRegression${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LinearRegression
try: bridgeLinearRegression
except NameError: bridgeLinearRegression = {}
`;
    await this._py.ex`ctor_LinearRegression = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}}

ctor_LinearRegression = {k: v for k, v in ctor_LinearRegression.items() if v is not None}`;
    await this._py.ex`bridgeLinearRegression[${this.id}] = LinearRegression(**ctor_LinearRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit linear model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before fit()");
    }
    await this._py.ex`pms_LinearRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearRegression_fit = {k: v for k, v in pms_LinearRegression_fit.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_fit = bridgeLinearRegression[${this.id}].fit(**pms_LinearRegression_fit)`;
    return this._py`res_LinearRegression_fit.tolist() if hasattr(res_LinearRegression_fit, 'tolist') else res_LinearRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearRegression_get_metadata_routing = {k: v for k, v in pms_LinearRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_get_metadata_routing = bridgeLinearRegression[${this.id}].get_metadata_routing(**pms_LinearRegression_get_metadata_routing)`;
    return this._py`res_LinearRegression_get_metadata_routing.tolist() if hasattr(res_LinearRegression_get_metadata_routing, 'tolist') else res_LinearRegression_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before predict()");
    }
    await this._py.ex`pms_LinearRegression_predict = {'X': ${opts["X"] ?? void 0}}

pms_LinearRegression_predict = {k: v for k, v in pms_LinearRegression_predict.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_predict = bridgeLinearRegression[${this.id}].predict(**pms_LinearRegression_predict)`;
    return this._py`res_LinearRegression_predict.tolist() if hasattr(res_LinearRegression_predict, 'tolist') else res_LinearRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LinearRegression must call init() before score()");
    }
    await this._py.ex`pms_LinearRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearRegression_score = {k: v for k, v in pms_LinearRegression_score.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_score = bridgeLinearRegression[${this.id}].score(**pms_LinearRegression_score)`;
    return this._py`res_LinearRegression_score.tolist() if hasattr(res_LinearRegression_score, 'tolist') else res_LinearRegression_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LinearRegression_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearRegression_set_fit_request = {k: v for k, v in pms_LinearRegression_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_set_fit_request = bridgeLinearRegression[${this.id}].set_fit_request(**pms_LinearRegression_set_fit_request)`;
    return this._py`res_LinearRegression_set_fit_request.tolist() if hasattr(res_LinearRegression_set_fit_request, 'tolist') else res_LinearRegression_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LinearRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearRegression_set_score_request = {k: v for k, v in pms_LinearRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearRegression_set_score_request = bridgeLinearRegression[${this.id}].set_score_request(**pms_LinearRegression_set_score_request)`;
    return this._py`res_LinearRegression_set_score_request.tolist() if hasattr(res_LinearRegression_set_score_request, 'tolist') else res_LinearRegression_set_score_request`;
  }
  /**
    Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n\_targets, n\_features), while if only one target is passed, this is a 1D array of length n\_features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_coef_ = bridgeLinearRegression[${this.id}].coef_`;
      return this._py`attr_LinearRegression_coef_.tolist() if hasattr(attr_LinearRegression_coef_, 'tolist') else attr_LinearRegression_coef_`;
    })();
  }
  /**
    Rank of matrix `X`. Only available when `X` is dense.
   */
  get rank_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing rank_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_rank_ = bridgeLinearRegression[${this.id}].rank_`;
      return this._py`attr_LinearRegression_rank_.tolist() if hasattr(attr_LinearRegression_rank_, 'tolist') else attr_LinearRegression_rank_`;
    })();
  }
  /**
    Singular values of `X`. Only available when `X` is dense.
   */
  get singular_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing singular_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_singular_ = bridgeLinearRegression[${this.id}].singular_`;
      return this._py`attr_LinearRegression_singular_.tolist() if hasattr(attr_LinearRegression_singular_, 'tolist') else attr_LinearRegression_singular_`;
    })();
  }
  /**
    Independent term in the linear model. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_intercept_ = bridgeLinearRegression[${this.id}].intercept_`;
      return this._py`attr_LinearRegression_intercept_.tolist() if hasattr(attr_LinearRegression_intercept_, 'tolist') else attr_LinearRegression_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_n_features_in_ = bridgeLinearRegression[${this.id}].n_features_in_`;
      return this._py`attr_LinearRegression_n_features_in_.tolist() if hasattr(attr_LinearRegression_n_features_in_, 'tolist') else attr_LinearRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearRegression_feature_names_in_ = bridgeLinearRegression[${this.id}].feature_names_in_`;
      return this._py`attr_LinearRegression_feature_names_in_.tolist() if hasattr(attr_LinearRegression_feature_names_in_, 'tolist') else attr_LinearRegression_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/LogisticRegression.ts
import crypto15 from "node:crypto";
var LogisticRegression = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LogisticRegression${crypto15.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LogisticRegression.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LogisticRegression
try: bridgeLogisticRegression
except NameError: bridgeLogisticRegression = {}
`;
    await this._py.ex`ctor_LogisticRegression = {'penalty': ${this.opts["penalty"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}}

ctor_LogisticRegression = {k: v for k, v in ctor_LogisticRegression.items() if v is not None}`;
    await this._py.ex`bridgeLogisticRegression[${this.id}] = LogisticRegression(**ctor_LogisticRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLogisticRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LogisticRegression_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_decision_function = {k: v for k, v in pms_LogisticRegression_decision_function.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_decision_function = bridgeLogisticRegression[${this.id}].decision_function(**pms_LogisticRegression_decision_function)`;
    return this._py`res_LogisticRegression_decision_function.tolist() if hasattr(res_LogisticRegression_decision_function, 'tolist') else res_LogisticRegression_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before densify()");
    }
    await this._py.ex`pms_LogisticRegression_densify = {}

pms_LogisticRegression_densify = {k: v for k, v in pms_LogisticRegression_densify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_densify = bridgeLogisticRegression[${this.id}].densify(**pms_LogisticRegression_densify)`;
    return this._py`res_LogisticRegression_densify.tolist() if hasattr(res_LogisticRegression_densify, 'tolist') else res_LogisticRegression_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before fit()");
    }
    await this._py.ex`pms_LogisticRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegression_fit = {k: v for k, v in pms_LogisticRegression_fit.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_fit = bridgeLogisticRegression[${this.id}].fit(**pms_LogisticRegression_fit)`;
    return this._py`res_LogisticRegression_fit.tolist() if hasattr(res_LogisticRegression_fit, 'tolist') else res_LogisticRegression_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LogisticRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LogisticRegression_get_metadata_routing = {k: v for k, v in pms_LogisticRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_get_metadata_routing = bridgeLogisticRegression[${this.id}].get_metadata_routing(**pms_LogisticRegression_get_metadata_routing)`;
    return this._py`res_LogisticRegression_get_metadata_routing.tolist() if hasattr(res_LogisticRegression_get_metadata_routing, 'tolist') else res_LogisticRegression_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before predict()");
    }
    await this._py.ex`pms_LogisticRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict = {k: v for k, v in pms_LogisticRegression_predict.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict = bridgeLogisticRegression[${this.id}].predict(**pms_LogisticRegression_predict)`;
    return this._py`res_LogisticRegression_predict.tolist() if hasattr(res_LogisticRegression_predict, 'tolist') else res_LogisticRegression_predict`;
  }
  /**
      Predict logarithm of probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegression_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict_log_proba = {k: v for k, v in pms_LogisticRegression_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict_log_proba = bridgeLogisticRegression[${this.id}].predict_log_proba(**pms_LogisticRegression_predict_log_proba)`;
    return this._py`res_LogisticRegression_predict_log_proba.tolist() if hasattr(res_LogisticRegression_predict_log_proba, 'tolist') else res_LogisticRegression_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
  
      For a multi\_class problem, if multi\_class is set to be multinomial the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegression_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegression_predict_proba = {k: v for k, v in pms_LogisticRegression_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_predict_proba = bridgeLogisticRegression[${this.id}].predict_proba(**pms_LogisticRegression_predict_proba)`;
    return this._py`res_LogisticRegression_predict_proba.tolist() if hasattr(res_LogisticRegression_predict_proba, 'tolist') else res_LogisticRegression_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before score()");
    }
    await this._py.ex`pms_LogisticRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegression_score = {k: v for k, v in pms_LogisticRegression_score.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_score = bridgeLogisticRegression[${this.id}].score(**pms_LogisticRegression_score)`;
    return this._py`res_LogisticRegression_score.tolist() if hasattr(res_LogisticRegression_score, 'tolist') else res_LogisticRegression_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LogisticRegression_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegression_set_fit_request = {k: v for k, v in pms_LogisticRegression_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_set_fit_request = bridgeLogisticRegression[${this.id}].set_fit_request(**pms_LogisticRegression_set_fit_request)`;
    return this._py`res_LogisticRegression_set_fit_request.tolist() if hasattr(res_LogisticRegression_set_fit_request, 'tolist') else res_LogisticRegression_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LogisticRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegression_set_score_request = {k: v for k, v in pms_LogisticRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_set_score_request = bridgeLogisticRegression[${this.id}].set_score_request(**pms_LogisticRegression_set_score_request)`;
    return this._py`res_LogisticRegression_set_score_request.tolist() if hasattr(res_LogisticRegression_set_score_request, 'tolist') else res_LogisticRegression_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegression must call init() before sparsify()");
    }
    await this._py.ex`pms_LogisticRegression_sparsify = {}

pms_LogisticRegression_sparsify = {k: v for k, v in pms_LogisticRegression_sparsify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegression_sparsify = bridgeLogisticRegression[${this.id}].sparsify(**pms_LogisticRegression_sparsify)`;
    return this._py`res_LogisticRegression_sparsify.tolist() if hasattr(res_LogisticRegression_sparsify, 'tolist') else res_LogisticRegression_sparsify`;
  }
  /**
    A list of class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_classes_ = bridgeLogisticRegression[${this.id}].classes_`;
      return this._py`attr_LogisticRegression_classes_.tolist() if hasattr(attr_LogisticRegression_classes_, 'tolist') else attr_LogisticRegression_classes_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary. In particular, when `multi\_class='multinomial'`, `coef\_` corresponds to outcome 1 (`true`) and `\-coef\_` corresponds to outcome 0 (`false`).
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_coef_ = bridgeLogisticRegression[${this.id}].coef_`;
      return this._py`attr_LogisticRegression_coef_.tolist() if hasattr(attr_LogisticRegression_coef_, 'tolist') else attr_LogisticRegression_coef_`;
    })();
  }
  /**
      Intercept (a.k.a. bias) added to the decision function.
  
      If `fit\_intercept` is set to `false`, the intercept is set to zero. `intercept\_` is of shape (1,) when the given problem is binary. In particular, when `multi\_class='multinomial'`, `intercept\_` corresponds to outcome 1 (`true`) and `\-intercept\_` corresponds to outcome 0 (`false`).
     */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_intercept_ = bridgeLogisticRegression[${this.id}].intercept_`;
      return this._py`attr_LogisticRegression_intercept_.tolist() if hasattr(attr_LogisticRegression_intercept_, 'tolist') else attr_LogisticRegression_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_n_features_in_ = bridgeLogisticRegression[${this.id}].n_features_in_`;
      return this._py`attr_LogisticRegression_n_features_in_.tolist() if hasattr(attr_LogisticRegression_n_features_in_, 'tolist') else attr_LogisticRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_feature_names_in_ = bridgeLogisticRegression[${this.id}].feature_names_in_`;
      return this._py`attr_LogisticRegression_feature_names_in_.tolist() if hasattr(attr_LogisticRegression_feature_names_in_, 'tolist') else attr_LogisticRegression_feature_names_in_`;
    })();
  }
  /**
    Actual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegression instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegression must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegression_n_iter_ = bridgeLogisticRegression[${this.id}].n_iter_`;
      return this._py`attr_LogisticRegression_n_iter_.tolist() if hasattr(attr_LogisticRegression_n_iter_, 'tolist') else attr_LogisticRegression_n_iter_`;
    })();
  }
};

// src/generated/linear_model/LogisticRegressionCV.ts
import crypto16 from "node:crypto";
var LogisticRegressionCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LogisticRegressionCV${crypto16.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LogisticRegressionCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import LogisticRegressionCV
try: bridgeLogisticRegressionCV
except NameError: bridgeLogisticRegressionCV = {}
`;
    await this._py.ex`ctor_LogisticRegressionCV = {'Cs': ${this.opts["Cs"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'refit': ${this.opts["refit"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'l1_ratios': ${this.opts["l1_ratios"] ?? void 0}}

ctor_LogisticRegressionCV = {k: v for k, v in ctor_LogisticRegressionCV.items() if v is not None}`;
    await this._py.ex`bridgeLogisticRegressionCV[${this.id}] = LogisticRegressionCV(**ctor_LogisticRegressionCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLogisticRegressionCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_decision_function = {k: v for k, v in pms_LogisticRegressionCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_decision_function = bridgeLogisticRegressionCV[${this.id}].decision_function(**pms_LogisticRegressionCV_decision_function)`;
    return this._py`res_LogisticRegressionCV_decision_function.tolist() if hasattr(res_LogisticRegressionCV_decision_function, 'tolist') else res_LogisticRegressionCV_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before densify()");
    }
    await this._py.ex`pms_LogisticRegressionCV_densify = {}

pms_LogisticRegressionCV_densify = {k: v for k, v in pms_LogisticRegressionCV_densify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_densify = bridgeLogisticRegressionCV[${this.id}].densify(**pms_LogisticRegressionCV_densify)`;
    return this._py`res_LogisticRegressionCV_densify.tolist() if hasattr(res_LogisticRegressionCV_densify, 'tolist') else res_LogisticRegressionCV_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before fit()");
    }
    await this._py.ex`pms_LogisticRegressionCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegressionCV_fit = {k: v for k, v in pms_LogisticRegressionCV_fit.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_fit = bridgeLogisticRegressionCV[${this.id}].fit(**pms_LogisticRegressionCV_fit)`;
    return this._py`res_LogisticRegressionCV_fit.tolist() if hasattr(res_LogisticRegressionCV_fit, 'tolist') else res_LogisticRegressionCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LogisticRegressionCV_get_metadata_routing = {k: v for k, v in pms_LogisticRegressionCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_get_metadata_routing = bridgeLogisticRegressionCV[${this.id}].get_metadata_routing(**pms_LogisticRegressionCV_get_metadata_routing)`;
    return this._py`res_LogisticRegressionCV_get_metadata_routing.tolist() if hasattr(res_LogisticRegressionCV_get_metadata_routing, 'tolist') else res_LogisticRegressionCV_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before predict()");
    }
    await this._py.ex`pms_LogisticRegressionCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict = {k: v for k, v in pms_LogisticRegressionCV_predict.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict = bridgeLogisticRegressionCV[${this.id}].predict(**pms_LogisticRegressionCV_predict)`;
    return this._py`res_LogisticRegressionCV_predict.tolist() if hasattr(res_LogisticRegressionCV_predict, 'tolist') else res_LogisticRegressionCV_predict`;
  }
  /**
      Predict logarithm of probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict_log_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict_log_proba = bridgeLogisticRegressionCV[${this.id}].predict_log_proba(**pms_LogisticRegressionCV_predict_log_proba)`;
    return this._py`res_LogisticRegressionCV_predict_log_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_log_proba, 'tolist') else res_LogisticRegressionCV_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by the label of classes.
  
      For a multi\_class problem, if multi\_class is set to be multinomial the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e calculate the probability of each class assuming it to be positive using the logistic function. and normalize these values across all the classes.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LogisticRegressionCV_predict_proba = {k: v for k, v in pms_LogisticRegressionCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_predict_proba = bridgeLogisticRegressionCV[${this.id}].predict_proba(**pms_LogisticRegressionCV_predict_proba)`;
    return this._py`res_LogisticRegressionCV_predict_proba.tolist() if hasattr(res_LogisticRegressionCV_predict_proba, 'tolist') else res_LogisticRegressionCV_predict_proba`;
  }
  /**
    Score using the `scoring` option on the given test data and labels.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before score()");
    }
    await this._py.ex`pms_LogisticRegressionCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LogisticRegressionCV_score = {k: v for k, v in pms_LogisticRegressionCV_score.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_score = bridgeLogisticRegressionCV[${this.id}].score(**pms_LogisticRegressionCV_score)`;
    return this._py`res_LogisticRegressionCV_score.tolist() if hasattr(res_LogisticRegressionCV_score, 'tolist') else res_LogisticRegressionCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegressionCV_set_fit_request = {k: v for k, v in pms_LogisticRegressionCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_set_fit_request = bridgeLogisticRegressionCV[${this.id}].set_fit_request(**pms_LogisticRegressionCV_set_fit_request)`;
    return this._py`res_LogisticRegressionCV_set_fit_request.tolist() if hasattr(res_LogisticRegressionCV_set_fit_request, 'tolist') else res_LogisticRegressionCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LogisticRegressionCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LogisticRegressionCV_set_score_request = {k: v for k, v in pms_LogisticRegressionCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_set_score_request = bridgeLogisticRegressionCV[${this.id}].set_score_request(**pms_LogisticRegressionCV_set_score_request)`;
    return this._py`res_LogisticRegressionCV_set_score_request.tolist() if hasattr(res_LogisticRegressionCV_set_score_request, 'tolist') else res_LogisticRegressionCV_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LogisticRegressionCV must call init() before sparsify()");
    }
    await this._py.ex`pms_LogisticRegressionCV_sparsify = {}

pms_LogisticRegressionCV_sparsify = {k: v for k, v in pms_LogisticRegressionCV_sparsify.items() if v is not None}`;
    await this._py.ex`res_LogisticRegressionCV_sparsify = bridgeLogisticRegressionCV[${this.id}].sparsify(**pms_LogisticRegressionCV_sparsify)`;
    return this._py`res_LogisticRegressionCV_sparsify.tolist() if hasattr(res_LogisticRegressionCV_sparsify, 'tolist') else res_LogisticRegressionCV_sparsify`;
  }
  /**
    A list of class labels known to the classifier.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_classes_ = bridgeLogisticRegressionCV[${this.id}].classes_`;
      return this._py`attr_LogisticRegressionCV_classes_.tolist() if hasattr(attr_LogisticRegressionCV_classes_, 'tolist') else attr_LogisticRegressionCV_classes_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_coef_ = bridgeLogisticRegressionCV[${this.id}].coef_`;
      return this._py`attr_LogisticRegressionCV_coef_.tolist() if hasattr(attr_LogisticRegressionCV_coef_, 'tolist') else attr_LogisticRegressionCV_coef_`;
    })();
  }
  /**
      Intercept (a.k.a. bias) added to the decision function.
  
      If `fit\_intercept` is set to `false`, the intercept is set to zero. `intercept\_` is of shape(1,) when the problem is binary.
     */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_intercept_ = bridgeLogisticRegressionCV[${this.id}].intercept_`;
      return this._py`attr_LogisticRegressionCV_intercept_.tolist() if hasattr(attr_LogisticRegressionCV_intercept_, 'tolist') else attr_LogisticRegressionCV_intercept_`;
    })();
  }
  /**
    Array of C i.e. inverse of regularization parameter values used for cross-validation.
   */
  get Cs_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing Cs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_Cs_ = bridgeLogisticRegressionCV[${this.id}].Cs_`;
      return this._py`attr_LogisticRegressionCV_Cs_.tolist() if hasattr(attr_LogisticRegressionCV_Cs_, 'tolist') else attr_LogisticRegressionCV_Cs_`;
    })();
  }
  /**
    Array of l1\_ratios used for cross-validation. If no l1\_ratio is used (i.e. penalty is not elasticnet), this is set to `\[`undefined`\]`
   */
  get l1_ratios_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing l1_ratios_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_l1_ratios_ = bridgeLogisticRegressionCV[${this.id}].l1_ratios_`;
      return this._py`attr_LogisticRegressionCV_l1_ratios_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratios_, 'tolist') else attr_LogisticRegressionCV_l1_ratios_`;
    })();
  }
  /**
    dict with classes as the keys, and the path of coefficients obtained during cross-validating across each fold and then across each Cs after doing an OvR for the corresponding class as values. If the multi\_class option is set to multinomial, then the coefs\_paths are the coefficients corresponding to each class. Each dict value has shape `(n\_folds, n\_cs, n\_features)` or `(n\_folds, n\_cs, n\_features + 1)` depending on whether the intercept is fit or not. If `penalty='elasticnet'`, the shape is `(n\_folds, n\_cs, n\_l1\_ratios\_, n\_features)` or `(n\_folds, n\_cs, n\_l1\_ratios\_, n\_features + 1)`.
   */
  get coefs_paths_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing coefs_paths_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_coefs_paths_ = bridgeLogisticRegressionCV[${this.id}].coefs_paths_`;
      return this._py`attr_LogisticRegressionCV_coefs_paths_.tolist() if hasattr(attr_LogisticRegressionCV_coefs_paths_, 'tolist') else attr_LogisticRegressionCV_coefs_paths_`;
    })();
  }
  /**
    dict with classes as the keys, and the values as the grid of scores obtained during cross-validating each fold, after doing an OvR for the corresponding class. If the multi\_class option given is multinomial then the same scores are repeated across all classes, since this is the multinomial class. Each dict value has shape `(n\_folds, n\_cs)` or `(n\_folds, n\_cs, n\_l1\_ratios)` if `penalty='elasticnet'`.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_scores_ = bridgeLogisticRegressionCV[${this.id}].scores_`;
      return this._py`attr_LogisticRegressionCV_scores_.tolist() if hasattr(attr_LogisticRegressionCV_scores_, 'tolist') else attr_LogisticRegressionCV_scores_`;
    })();
  }
  /**
    Array of C that maps to the best scores across every class. If refit is set to `false`, then for each class, the best C is the average of the Cs that correspond to the best scores for each fold. `C\_` is of shape(n\_classes,) when the problem is binary.
   */
  get C_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing C_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_C_ = bridgeLogisticRegressionCV[${this.id}].C_`;
      return this._py`attr_LogisticRegressionCV_C_.tolist() if hasattr(attr_LogisticRegressionCV_C_, 'tolist') else attr_LogisticRegressionCV_C_`;
    })();
  }
  /**
    Array of l1\_ratio that maps to the best scores across every class. If refit is set to `false`, then for each class, the best l1\_ratio is the average of the l1\_ratios that correspond to the best scores for each fold. `l1\_ratio\_` is of shape(n\_classes,) when the problem is binary.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_l1_ratio_ = bridgeLogisticRegressionCV[${this.id}].l1_ratio_`;
      return this._py`attr_LogisticRegressionCV_l1_ratio_.tolist() if hasattr(attr_LogisticRegressionCV_l1_ratio_, 'tolist') else attr_LogisticRegressionCV_l1_ratio_`;
    })();
  }
  /**
    Actual number of iterations for all classes, folds and Cs. In the binary or multinomial cases, the first dimension is equal to 1. If `penalty='elasticnet'`, the shape is `(n\_classes, n\_folds, n\_cs, n\_l1\_ratios)` or `(1, n\_folds, n\_cs, n\_l1\_ratios)`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_n_iter_ = bridgeLogisticRegressionCV[${this.id}].n_iter_`;
      return this._py`attr_LogisticRegressionCV_n_iter_.tolist() if hasattr(attr_LogisticRegressionCV_n_iter_, 'tolist') else attr_LogisticRegressionCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_n_features_in_ = bridgeLogisticRegressionCV[${this.id}].n_features_in_`;
      return this._py`attr_LogisticRegressionCV_n_features_in_.tolist() if hasattr(attr_LogisticRegressionCV_n_features_in_, 'tolist') else attr_LogisticRegressionCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LogisticRegressionCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LogisticRegressionCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LogisticRegressionCV_feature_names_in_ = bridgeLogisticRegressionCV[${this.id}].feature_names_in_`;
      return this._py`attr_LogisticRegressionCV_feature_names_in_.tolist() if hasattr(attr_LogisticRegressionCV_feature_names_in_, 'tolist') else attr_LogisticRegressionCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskElasticNet.ts
import crypto17 from "node:crypto";
var MultiTaskElasticNet = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskElasticNet${crypto17.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiTaskElasticNet.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskElasticNet
try: bridgeMultiTaskElasticNet
except NameError: bridgeMultiTaskElasticNet = {}
`;
    await this._py.ex`ctor_MultiTaskElasticNet = {'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskElasticNet = {k: v for k, v in ctor_MultiTaskElasticNet.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskElasticNet[${this.id}] = MultiTaskElasticNet(**ctor_MultiTaskElasticNet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskElasticNet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit MultiTaskElasticNet model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskElasticNet_fit = {k: v for k, v in pms_MultiTaskElasticNet_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_fit = bridgeMultiTaskElasticNet[${this.id}].fit(**pms_MultiTaskElasticNet_fit)`;
    return this._py`res_MultiTaskElasticNet_fit.tolist() if hasattr(res_MultiTaskElasticNet_fit, 'tolist') else res_MultiTaskElasticNet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskElasticNet_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_get_metadata_routing = bridgeMultiTaskElasticNet[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNet_get_metadata_routing)`;
    return this._py`res_MultiTaskElasticNet_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNet_get_metadata_routing, 'tolist') else res_MultiTaskElasticNet_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskElasticNet_path = {k: v for k, v in pms_MultiTaskElasticNet_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_path = bridgeMultiTaskElasticNet[${this.id}].path(**pms_MultiTaskElasticNet_path)`;
    return this._py`res_MultiTaskElasticNet_path.tolist() if hasattr(res_MultiTaskElasticNet_path, 'tolist') else res_MultiTaskElasticNet_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskElasticNet_predict = {k: v for k, v in pms_MultiTaskElasticNet_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_predict = bridgeMultiTaskElasticNet[${this.id}].predict(**pms_MultiTaskElasticNet_predict)`;
    return this._py`res_MultiTaskElasticNet_predict.tolist() if hasattr(res_MultiTaskElasticNet_predict, 'tolist') else res_MultiTaskElasticNet_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNet must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskElasticNet_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskElasticNet_score = {k: v for k, v in pms_MultiTaskElasticNet_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_score = bridgeMultiTaskElasticNet[${this.id}].score(**pms_MultiTaskElasticNet_score)`;
    return this._py`res_MultiTaskElasticNet_score.tolist() if hasattr(res_MultiTaskElasticNet_score, 'tolist') else res_MultiTaskElasticNet_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNet_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNet_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_set_fit_request = bridgeMultiTaskElasticNet[${this.id}].set_fit_request(**pms_MultiTaskElasticNet_set_fit_request)`;
    return this._py`res_MultiTaskElasticNet_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNet_set_fit_request, 'tolist') else res_MultiTaskElasticNet_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNet_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNet_set_score_request = {k: v for k, v in pms_MultiTaskElasticNet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNet_set_score_request = bridgeMultiTaskElasticNet[${this.id}].set_score_request(**pms_MultiTaskElasticNet_set_score_request)`;
    return this._py`res_MultiTaskElasticNet_set_score_request.tolist() if hasattr(res_MultiTaskElasticNet_set_score_request, 'tolist') else res_MultiTaskElasticNet_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_intercept_ = bridgeMultiTaskElasticNet[${this.id}].intercept_`;
      return this._py`attr_MultiTaskElasticNet_intercept_.tolist() if hasattr(attr_MultiTaskElasticNet_intercept_, 'tolist') else attr_MultiTaskElasticNet_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). If a 1D y is passed in at fit (non multi-task usage), `coef\_` is then a 1D array. Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_coef_ = bridgeMultiTaskElasticNet[${this.id}].coef_`;
      return this._py`attr_MultiTaskElasticNet_coef_.tolist() if hasattr(attr_MultiTaskElasticNet_coef_, 'tolist') else attr_MultiTaskElasticNet_coef_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_n_iter_ = bridgeMultiTaskElasticNet[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskElasticNet_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNet_n_iter_, 'tolist') else attr_MultiTaskElasticNet_n_iter_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_dual_gap_ = bridgeMultiTaskElasticNet[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskElasticNet_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNet_dual_gap_, 'tolist') else attr_MultiTaskElasticNet_dual_gap_`;
    })();
  }
  /**
    The tolerance scaled scaled by the variance of the target `y`.
   */
  get eps_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing eps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_eps_ = bridgeMultiTaskElasticNet[${this.id}].eps_`;
      return this._py`attr_MultiTaskElasticNet_eps_.tolist() if hasattr(attr_MultiTaskElasticNet_eps_, 'tolist') else attr_MultiTaskElasticNet_eps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_n_features_in_ = bridgeMultiTaskElasticNet[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskElasticNet_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNet_n_features_in_, 'tolist') else attr_MultiTaskElasticNet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNet instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNet_feature_names_in_ = bridgeMultiTaskElasticNet[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskElasticNet_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNet_feature_names_in_, 'tolist') else attr_MultiTaskElasticNet_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskElasticNetCV.ts
import crypto18 from "node:crypto";
var MultiTaskElasticNetCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskElasticNetCV${crypto18.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MultiTaskElasticNetCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskElasticNetCV
try: bridgeMultiTaskElasticNetCV
except NameError: bridgeMultiTaskElasticNetCV = {}
`;
    await this._py.ex`ctor_MultiTaskElasticNetCV = {'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskElasticNetCV = {k: v for k, v in ctor_MultiTaskElasticNetCV.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskElasticNetCV[${this.id}] = MultiTaskElasticNetCV(**ctor_MultiTaskElasticNetCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskElasticNetCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit MultiTaskElasticNet model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskElasticNetCV_fit = {k: v for k, v in pms_MultiTaskElasticNetCV_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_fit = bridgeMultiTaskElasticNetCV[${this.id}].fit(**pms_MultiTaskElasticNetCV_fit)`;
    return this._py`res_MultiTaskElasticNetCV_fit.tolist() if hasattr(res_MultiTaskElasticNetCV_fit, 'tolist') else res_MultiTaskElasticNetCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskElasticNetCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskElasticNetCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_get_metadata_routing = bridgeMultiTaskElasticNetCV[${this.id}].get_metadata_routing(**pms_MultiTaskElasticNetCV_get_metadata_routing)`;
    return this._py`res_MultiTaskElasticNetCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskElasticNetCV_get_metadata_routing, 'tolist') else res_MultiTaskElasticNetCV_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskElasticNetCV_path = {k: v for k, v in pms_MultiTaskElasticNetCV_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_path = bridgeMultiTaskElasticNetCV[${this.id}].path(**pms_MultiTaskElasticNetCV_path)`;
    return this._py`res_MultiTaskElasticNetCV_path.tolist() if hasattr(res_MultiTaskElasticNetCV_path, 'tolist') else res_MultiTaskElasticNetCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskElasticNetCV_predict = {k: v for k, v in pms_MultiTaskElasticNetCV_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_predict = bridgeMultiTaskElasticNetCV[${this.id}].predict(**pms_MultiTaskElasticNetCV_predict)`;
    return this._py`res_MultiTaskElasticNetCV_predict.tolist() if hasattr(res_MultiTaskElasticNetCV_predict, 'tolist') else res_MultiTaskElasticNetCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskElasticNetCV must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskElasticNetCV_score = {k: v for k, v in pms_MultiTaskElasticNetCV_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_score = bridgeMultiTaskElasticNetCV[${this.id}].score(**pms_MultiTaskElasticNetCV_score)`;
    return this._py`res_MultiTaskElasticNetCV_score.tolist() if hasattr(res_MultiTaskElasticNetCV_score, 'tolist') else res_MultiTaskElasticNetCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNetCV_set_fit_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_set_fit_request = bridgeMultiTaskElasticNetCV[${this.id}].set_fit_request(**pms_MultiTaskElasticNetCV_set_fit_request)`;
    return this._py`res_MultiTaskElasticNetCV_set_fit_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_fit_request, 'tolist') else res_MultiTaskElasticNetCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskElasticNetCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskElasticNetCV_set_score_request = {k: v for k, v in pms_MultiTaskElasticNetCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskElasticNetCV_set_score_request = bridgeMultiTaskElasticNetCV[${this.id}].set_score_request(**pms_MultiTaskElasticNetCV_set_score_request)`;
    return this._py`res_MultiTaskElasticNetCV_set_score_request.tolist() if hasattr(res_MultiTaskElasticNetCV_set_score_request, 'tolist') else res_MultiTaskElasticNetCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_intercept_ = bridgeMultiTaskElasticNetCV[${this.id}].intercept_`;
      return this._py`attr_MultiTaskElasticNetCV_intercept_.tolist() if hasattr(attr_MultiTaskElasticNetCV_intercept_, 'tolist') else attr_MultiTaskElasticNetCV_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_coef_ = bridgeMultiTaskElasticNetCV[${this.id}].coef_`;
      return this._py`attr_MultiTaskElasticNetCV_coef_.tolist() if hasattr(attr_MultiTaskElasticNetCV_coef_, 'tolist') else attr_MultiTaskElasticNetCV_coef_`;
    })();
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_alpha_ = bridgeMultiTaskElasticNetCV[${this.id}].alpha_`;
      return this._py`attr_MultiTaskElasticNetCV_alpha_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alpha_, 'tolist') else attr_MultiTaskElasticNetCV_alpha_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_mse_path_ = bridgeMultiTaskElasticNetCV[${this.id}].mse_path_`;
      return this._py`attr_MultiTaskElasticNetCV_mse_path_.tolist() if hasattr(attr_MultiTaskElasticNetCV_mse_path_, 'tolist') else attr_MultiTaskElasticNetCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting, for each l1\_ratio.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_alphas_ = bridgeMultiTaskElasticNetCV[${this.id}].alphas_`;
      return this._py`attr_MultiTaskElasticNetCV_alphas_.tolist() if hasattr(attr_MultiTaskElasticNetCV_alphas_, 'tolist') else attr_MultiTaskElasticNetCV_alphas_`;
    })();
  }
  /**
    Best l1\_ratio obtained by cross-validation.
   */
  get l1_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing l1_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_l1_ratio_ = bridgeMultiTaskElasticNetCV[${this.id}].l1_ratio_`;
      return this._py`attr_MultiTaskElasticNetCV_l1_ratio_.tolist() if hasattr(attr_MultiTaskElasticNetCV_l1_ratio_, 'tolist') else attr_MultiTaskElasticNetCV_l1_ratio_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_n_iter_ = bridgeMultiTaskElasticNetCV[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskElasticNetCV_n_iter_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_iter_, 'tolist') else attr_MultiTaskElasticNetCV_n_iter_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_dual_gap_ = bridgeMultiTaskElasticNetCV[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskElasticNetCV_dual_gap_.tolist() if hasattr(attr_MultiTaskElasticNetCV_dual_gap_, 'tolist') else attr_MultiTaskElasticNetCV_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_n_features_in_ = bridgeMultiTaskElasticNetCV[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskElasticNetCV_n_features_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_n_features_in_, 'tolist') else attr_MultiTaskElasticNetCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskElasticNetCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskElasticNetCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskElasticNetCV_feature_names_in_ = bridgeMultiTaskElasticNetCV[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskElasticNetCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskElasticNetCV_feature_names_in_, 'tolist') else attr_MultiTaskElasticNetCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskLasso.ts
import crypto19 from "node:crypto";
var MultiTaskLasso = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskLasso${crypto19.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MultiTaskLasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskLasso
try: bridgeMultiTaskLasso
except NameError: bridgeMultiTaskLasso = {}
`;
    await this._py.ex`ctor_MultiTaskLasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskLasso = {k: v for k, v in ctor_MultiTaskLasso.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskLasso[${this.id}] = MultiTaskLasso(**ctor_MultiTaskLasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit MultiTaskElasticNet model with coordinate descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskLasso_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskLasso_fit = {k: v for k, v in pms_MultiTaskLasso_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_fit = bridgeMultiTaskLasso[${this.id}].fit(**pms_MultiTaskLasso_fit)`;
    return this._py`res_MultiTaskLasso_fit.tolist() if hasattr(res_MultiTaskLasso_fit, 'tolist') else res_MultiTaskLasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskLasso_get_metadata_routing = {k: v for k, v in pms_MultiTaskLasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_get_metadata_routing = bridgeMultiTaskLasso[${this.id}].get_metadata_routing(**pms_MultiTaskLasso_get_metadata_routing)`;
    return this._py`res_MultiTaskLasso_get_metadata_routing.tolist() if hasattr(res_MultiTaskLasso_get_metadata_routing, 'tolist') else res_MultiTaskLasso_get_metadata_routing`;
  }
  /**
      Compute elastic net path with coordinate descent.
  
      The elastic net optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskLasso_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'l1_ratio': ${opts["l1_ratio"] ?? void 0}, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskLasso_path = {k: v for k, v in pms_MultiTaskLasso_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_path = bridgeMultiTaskLasso[${this.id}].path(**pms_MultiTaskLasso_path)`;
    return this._py`res_MultiTaskLasso_path.tolist() if hasattr(res_MultiTaskLasso_path, 'tolist') else res_MultiTaskLasso_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskLasso_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskLasso_predict = {k: v for k, v in pms_MultiTaskLasso_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_predict = bridgeMultiTaskLasso[${this.id}].predict(**pms_MultiTaskLasso_predict)`;
    return this._py`res_MultiTaskLasso_predict.tolist() if hasattr(res_MultiTaskLasso_predict, 'tolist') else res_MultiTaskLasso_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskLasso_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskLasso_score = {k: v for k, v in pms_MultiTaskLasso_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_score = bridgeMultiTaskLasso[${this.id}].score(**pms_MultiTaskLasso_score)`;
    return this._py`res_MultiTaskLasso_score.tolist() if hasattr(res_MultiTaskLasso_score, 'tolist') else res_MultiTaskLasso_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_set_fit_request = {'check_input': ${opts["check_input"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLasso_set_fit_request = {k: v for k, v in pms_MultiTaskLasso_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_set_fit_request = bridgeMultiTaskLasso[${this.id}].set_fit_request(**pms_MultiTaskLasso_set_fit_request)`;
    return this._py`res_MultiTaskLasso_set_fit_request.tolist() if hasattr(res_MultiTaskLasso_set_fit_request, 'tolist') else res_MultiTaskLasso_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLasso_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLasso_set_score_request = {k: v for k, v in pms_MultiTaskLasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLasso_set_score_request = bridgeMultiTaskLasso[${this.id}].set_score_request(**pms_MultiTaskLasso_set_score_request)`;
    return this._py`res_MultiTaskLasso_set_score_request.tolist() if hasattr(res_MultiTaskLasso_set_score_request, 'tolist') else res_MultiTaskLasso_set_score_request`;
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_coef_ = bridgeMultiTaskLasso[${this.id}].coef_`;
      return this._py`attr_MultiTaskLasso_coef_.tolist() if hasattr(attr_MultiTaskLasso_coef_, 'tolist') else attr_MultiTaskLasso_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_intercept_ = bridgeMultiTaskLasso[${this.id}].intercept_`;
      return this._py`attr_MultiTaskLasso_intercept_.tolist() if hasattr(attr_MultiTaskLasso_intercept_, 'tolist') else attr_MultiTaskLasso_intercept_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_n_iter_ = bridgeMultiTaskLasso[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskLasso_n_iter_.tolist() if hasattr(attr_MultiTaskLasso_n_iter_, 'tolist') else attr_MultiTaskLasso_n_iter_`;
    })();
  }
  /**
    The dual gaps at the end of the optimization for each alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_dual_gap_ = bridgeMultiTaskLasso[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskLasso_dual_gap_.tolist() if hasattr(attr_MultiTaskLasso_dual_gap_, 'tolist') else attr_MultiTaskLasso_dual_gap_`;
    })();
  }
  /**
    The tolerance scaled scaled by the variance of the target `y`.
   */
  get eps_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLasso must call init() before accessing eps_");
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_eps_ = bridgeMultiTaskLasso[${this.id}].eps_`;
      return this._py`attr_MultiTaskLasso_eps_.tolist() if hasattr(attr_MultiTaskLasso_eps_, 'tolist') else attr_MultiTaskLasso_eps_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_n_features_in_ = bridgeMultiTaskLasso[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskLasso_n_features_in_.tolist() if hasattr(attr_MultiTaskLasso_n_features_in_, 'tolist') else attr_MultiTaskLasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MultiTaskLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLasso_feature_names_in_ = bridgeMultiTaskLasso[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskLasso_feature_names_in_.tolist() if hasattr(attr_MultiTaskLasso_feature_names_in_, 'tolist') else attr_MultiTaskLasso_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/MultiTaskLassoCV.ts
import crypto20 from "node:crypto";
var MultiTaskLassoCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `MultiTaskLassoCV${crypto20.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MultiTaskLassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import MultiTaskLassoCV
try: bridgeMultiTaskLassoCV
except NameError: bridgeMultiTaskLassoCV = {}
`;
    await this._py.ex`ctor_MultiTaskLassoCV = {'eps': ${this.opts["eps"] ?? void 0}, 'n_alphas': ${this.opts["n_alphas"] ?? void 0}, 'alphas': ${this.opts["alphas"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'selection': ${this.opts["selection"] ?? void 0}}

ctor_MultiTaskLassoCV = {k: v for k, v in ctor_MultiTaskLassoCV.items() if v is not None}`;
    await this._py.ex`bridgeMultiTaskLassoCV[${this.id}] = MultiTaskLassoCV(**ctor_MultiTaskLassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMultiTaskLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Fit MultiTaskLasso model with coordinate descent.
  
      Fit is on grid of alphas and best alpha estimated by cross-validation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before fit()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_MultiTaskLassoCV_fit = {k: v for k, v in pms_MultiTaskLassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_fit = bridgeMultiTaskLassoCV[${this.id}].fit(**pms_MultiTaskLassoCV_fit)`;
    return this._py`res_MultiTaskLassoCV_fit.tolist() if hasattr(res_MultiTaskLassoCV_fit, 'tolist') else res_MultiTaskLassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MultiTaskLassoCV_get_metadata_routing = {k: v for k, v in pms_MultiTaskLassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_get_metadata_routing = bridgeMultiTaskLassoCV[${this.id}].get_metadata_routing(**pms_MultiTaskLassoCV_get_metadata_routing)`;
    return this._py`res_MultiTaskLassoCV_get_metadata_routing.tolist() if hasattr(res_MultiTaskLassoCV_get_metadata_routing, 'tolist') else res_MultiTaskLassoCV_get_metadata_routing`;
  }
  /**
      Compute Lasso path with coordinate descent.
  
      The Lasso optimization function varies for mono and multi-outputs.
  
      For mono-output tasks it is:
     */
  async path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before path()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'eps': ${opts["eps"] ?? void 0}, 'n_alphas': ${opts["n_alphas"] ?? void 0}, 'alphas': np.array(${opts["alphas"] ?? void 0}) if ${opts["alphas"] !== void 0} else None, 'precompute': np.array(${opts["precompute"] ?? void 0}) if ${opts["precompute"] !== void 0} else None, 'Xy': np.array(${opts["Xy"] ?? void 0}) if ${opts["Xy"] !== void 0} else None, 'copy_X': ${opts["copy_X"] ?? void 0}, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'verbose': ${opts["verbose"] ?? void 0}, 'return_n_iter': ${opts["return_n_iter"] ?? void 0}, 'positive': ${opts["positive"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MultiTaskLassoCV_path = {k: v for k, v in pms_MultiTaskLassoCV_path.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_path = bridgeMultiTaskLassoCV[${this.id}].path(**pms_MultiTaskLassoCV_path)`;
    return this._py`res_MultiTaskLassoCV_path.tolist() if hasattr(res_MultiTaskLassoCV_path, 'tolist') else res_MultiTaskLassoCV_path`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before predict()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_MultiTaskLassoCV_predict = {k: v for k, v in pms_MultiTaskLassoCV_predict.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_predict = bridgeMultiTaskLassoCV[${this.id}].predict(**pms_MultiTaskLassoCV_predict)`;
    return this._py`res_MultiTaskLassoCV_predict.tolist() if hasattr(res_MultiTaskLassoCV_predict, 'tolist') else res_MultiTaskLassoCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MultiTaskLassoCV must call init() before score()");
    }
    await this._py.ex`pms_MultiTaskLassoCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MultiTaskLassoCV_score = {k: v for k, v in pms_MultiTaskLassoCV_score.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_score = bridgeMultiTaskLassoCV[${this.id}].score(**pms_MultiTaskLassoCV_score)`;
    return this._py`res_MultiTaskLassoCV_score.tolist() if hasattr(res_MultiTaskLassoCV_score, 'tolist') else res_MultiTaskLassoCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLassoCV_set_fit_request = {k: v for k, v in pms_MultiTaskLassoCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_set_fit_request = bridgeMultiTaskLassoCV[${this.id}].set_fit_request(**pms_MultiTaskLassoCV_set_fit_request)`;
    return this._py`res_MultiTaskLassoCV_set_fit_request.tolist() if hasattr(res_MultiTaskLassoCV_set_fit_request, 'tolist') else res_MultiTaskLassoCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MultiTaskLassoCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MultiTaskLassoCV_set_score_request = {k: v for k, v in pms_MultiTaskLassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MultiTaskLassoCV_set_score_request = bridgeMultiTaskLassoCV[${this.id}].set_score_request(**pms_MultiTaskLassoCV_set_score_request)`;
    return this._py`res_MultiTaskLassoCV_set_score_request.tolist() if hasattr(res_MultiTaskLassoCV_set_score_request, 'tolist') else res_MultiTaskLassoCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_intercept_ = bridgeMultiTaskLassoCV[${this.id}].intercept_`;
      return this._py`attr_MultiTaskLassoCV_intercept_.tolist() if hasattr(attr_MultiTaskLassoCV_intercept_, 'tolist') else attr_MultiTaskLassoCV_intercept_`;
    })();
  }
  /**
    Parameter vector (W in the cost function formula). Note that `coef\_` stores the transpose of `W`, `W.T`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_coef_ = bridgeMultiTaskLassoCV[${this.id}].coef_`;
      return this._py`attr_MultiTaskLassoCV_coef_.tolist() if hasattr(attr_MultiTaskLassoCV_coef_, 'tolist') else attr_MultiTaskLassoCV_coef_`;
    })();
  }
  /**
    The amount of penalization chosen by cross validation.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_alpha_ = bridgeMultiTaskLassoCV[${this.id}].alpha_`;
      return this._py`attr_MultiTaskLassoCV_alpha_.tolist() if hasattr(attr_MultiTaskLassoCV_alpha_, 'tolist') else attr_MultiTaskLassoCV_alpha_`;
    })();
  }
  /**
    Mean square error for the test set on each fold, varying alpha.
   */
  get mse_path_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing mse_path_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_mse_path_ = bridgeMultiTaskLassoCV[${this.id}].mse_path_`;
      return this._py`attr_MultiTaskLassoCV_mse_path_.tolist() if hasattr(attr_MultiTaskLassoCV_mse_path_, 'tolist') else attr_MultiTaskLassoCV_mse_path_`;
    })();
  }
  /**
    The grid of alphas used for fitting.
   */
  get alphas_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing alphas_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_alphas_ = bridgeMultiTaskLassoCV[${this.id}].alphas_`;
      return this._py`attr_MultiTaskLassoCV_alphas_.tolist() if hasattr(attr_MultiTaskLassoCV_alphas_, 'tolist') else attr_MultiTaskLassoCV_alphas_`;
    })();
  }
  /**
    Number of iterations run by the coordinate descent solver to reach the specified tolerance for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_n_iter_ = bridgeMultiTaskLassoCV[${this.id}].n_iter_`;
      return this._py`attr_MultiTaskLassoCV_n_iter_.tolist() if hasattr(attr_MultiTaskLassoCV_n_iter_, 'tolist') else attr_MultiTaskLassoCV_n_iter_`;
    })();
  }
  /**
    The dual gap at the end of the optimization for the optimal alpha.
   */
  get dual_gap_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing dual_gap_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_dual_gap_ = bridgeMultiTaskLassoCV[${this.id}].dual_gap_`;
      return this._py`attr_MultiTaskLassoCV_dual_gap_.tolist() if hasattr(attr_MultiTaskLassoCV_dual_gap_, 'tolist') else attr_MultiTaskLassoCV_dual_gap_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_n_features_in_ = bridgeMultiTaskLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_MultiTaskLassoCV_n_features_in_.tolist() if hasattr(attr_MultiTaskLassoCV_n_features_in_, 'tolist') else attr_MultiTaskLassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MultiTaskLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MultiTaskLassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MultiTaskLassoCV_feature_names_in_ = bridgeMultiTaskLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_MultiTaskLassoCV_feature_names_in_.tolist() if hasattr(attr_MultiTaskLassoCV_feature_names_in_, 'tolist') else attr_MultiTaskLassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/OrthogonalMatchingPursuit.ts
import crypto21 from "node:crypto";
var OrthogonalMatchingPursuit = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrthogonalMatchingPursuit${crypto21.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OrthogonalMatchingPursuit.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import OrthogonalMatchingPursuit
try: bridgeOrthogonalMatchingPursuit
except NameError: bridgeOrthogonalMatchingPursuit = {}
`;
    await this._py.ex`ctor_OrthogonalMatchingPursuit = {'n_nonzero_coefs': ${this.opts["n_nonzero_coefs"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'precompute': ${this.opts["precompute"] ?? void 0}}

ctor_OrthogonalMatchingPursuit = {k: v for k, v in ctor_OrthogonalMatchingPursuit.items() if v is not None}`;
    await this._py.ex`bridgeOrthogonalMatchingPursuit[${this.id}] = OrthogonalMatchingPursuit(**ctor_OrthogonalMatchingPursuit)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrthogonalMatchingPursuit[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OrthogonalMatchingPursuit must call init() before fit()");
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OrthogonalMatchingPursuit_fit = {k: v for k, v in pms_OrthogonalMatchingPursuit_fit.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_fit = bridgeOrthogonalMatchingPursuit[${this.id}].fit(**pms_OrthogonalMatchingPursuit_fit)`;
    return this._py`res_OrthogonalMatchingPursuit_fit.tolist() if hasattr(res_OrthogonalMatchingPursuit_fit, 'tolist') else res_OrthogonalMatchingPursuit_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrthogonalMatchingPursuit_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuit_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_get_metadata_routing = bridgeOrthogonalMatchingPursuit[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuit_get_metadata_routing)`;
    return this._py`res_OrthogonalMatchingPursuit_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuit_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuit_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before predict()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_predict = {'X': ${opts["X"] ?? void 0}}

pms_OrthogonalMatchingPursuit_predict = {k: v for k, v in pms_OrthogonalMatchingPursuit_predict.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_predict = bridgeOrthogonalMatchingPursuit[${this.id}].predict(**pms_OrthogonalMatchingPursuit_predict)`;
    return this._py`res_OrthogonalMatchingPursuit_predict.tolist() if hasattr(res_OrthogonalMatchingPursuit_predict, 'tolist') else res_OrthogonalMatchingPursuit_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before score()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OrthogonalMatchingPursuit_score = {k: v for k, v in pms_OrthogonalMatchingPursuit_score.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_score = bridgeOrthogonalMatchingPursuit[${this.id}].score(**pms_OrthogonalMatchingPursuit_score)`;
    return this._py`res_OrthogonalMatchingPursuit_score.tolist() if hasattr(res_OrthogonalMatchingPursuit_score, 'tolist') else res_OrthogonalMatchingPursuit_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuit_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OrthogonalMatchingPursuit_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuit_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuit_set_score_request = bridgeOrthogonalMatchingPursuit[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuit_set_score_request)`;
    return this._py`res_OrthogonalMatchingPursuit_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuit_set_score_request, 'tolist') else res_OrthogonalMatchingPursuit_set_score_request`;
  }
  /**
    Parameter vector (w in the formula).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_coef_ = bridgeOrthogonalMatchingPursuit[${this.id}].coef_`;
      return this._py`attr_OrthogonalMatchingPursuit_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_coef_, 'tolist') else attr_OrthogonalMatchingPursuit_coef_`;
    })();
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_intercept_ = bridgeOrthogonalMatchingPursuit[${this.id}].intercept_`;
      return this._py`attr_OrthogonalMatchingPursuit_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_intercept_, 'tolist') else attr_OrthogonalMatchingPursuit_intercept_`;
    })();
  }
  /**
    Number of active features across every target.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_iter_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_iter_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuit_n_iter_`;
    })();
  }
  /**
    The number of non-zero coefficients in the solution. If `n\_nonzero\_coefs` is `undefined` and `tol` is `undefined` this value is either set to 10% of `n\_features` or 1, whichever is greater.
   */
  get n_nonzero_coefs_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_nonzero_coefs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_nonzero_coefs_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuit_n_nonzero_coefs_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_n_features_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].n_features_in_`;
      return this._py`attr_OrthogonalMatchingPursuit_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuit_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuit instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuit must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuit_feature_names_in_ = bridgeOrthogonalMatchingPursuit[${this.id}].feature_names_in_`;
      return this._py`attr_OrthogonalMatchingPursuit_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuit_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuit_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/OrthogonalMatchingPursuitCV.ts
import crypto22 from "node:crypto";
var OrthogonalMatchingPursuitCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OrthogonalMatchingPursuitCV${crypto22.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OrthogonalMatchingPursuitCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import OrthogonalMatchingPursuitCV
try: bridgeOrthogonalMatchingPursuitCV
except NameError: bridgeOrthogonalMatchingPursuitCV = {}
`;
    await this._py.ex`ctor_OrthogonalMatchingPursuitCV = {'copy': ${this.opts["copy"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'normalize': ${this.opts["normalize"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_OrthogonalMatchingPursuitCV = {k: v for k, v in ctor_OrthogonalMatchingPursuitCV.items() if v is not None}`;
    await this._py.ex`bridgeOrthogonalMatchingPursuitCV[${this.id}] = OrthogonalMatchingPursuitCV(**ctor_OrthogonalMatchingPursuitCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOrthogonalMatchingPursuitCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model using X, y as training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before fit()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OrthogonalMatchingPursuitCV_fit = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_fit.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_fit = bridgeOrthogonalMatchingPursuitCV[${this.id}].fit(**pms_OrthogonalMatchingPursuitCV_fit)`;
    return this._py`res_OrthogonalMatchingPursuitCV_fit.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_fit, 'tolist') else res_OrthogonalMatchingPursuitCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_get_metadata_routing = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_get_metadata_routing = bridgeOrthogonalMatchingPursuitCV[${this.id}].get_metadata_routing(**pms_OrthogonalMatchingPursuitCV_get_metadata_routing)`;
    return this._py`res_OrthogonalMatchingPursuitCV_get_metadata_routing.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_get_metadata_routing, 'tolist') else res_OrthogonalMatchingPursuitCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before predict()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_predict = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_predict.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_predict = bridgeOrthogonalMatchingPursuitCV[${this.id}].predict(**pms_OrthogonalMatchingPursuitCV_predict)`;
    return this._py`res_OrthogonalMatchingPursuitCV_predict.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_predict, 'tolist') else res_OrthogonalMatchingPursuitCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before score()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OrthogonalMatchingPursuitCV_score = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_score.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_score = bridgeOrthogonalMatchingPursuitCV[${this.id}].score(**pms_OrthogonalMatchingPursuitCV_score)`;
    return this._py`res_OrthogonalMatchingPursuitCV_score.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_score, 'tolist') else res_OrthogonalMatchingPursuitCV_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_OrthogonalMatchingPursuitCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_OrthogonalMatchingPursuitCV_set_score_request = {k: v for k, v in pms_OrthogonalMatchingPursuitCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OrthogonalMatchingPursuitCV_set_score_request = bridgeOrthogonalMatchingPursuitCV[${this.id}].set_score_request(**pms_OrthogonalMatchingPursuitCV_set_score_request)`;
    return this._py`res_OrthogonalMatchingPursuitCV_set_score_request.tolist() if hasattr(res_OrthogonalMatchingPursuitCV_set_score_request, 'tolist') else res_OrthogonalMatchingPursuitCV_set_score_request`;
  }
  /**
    Independent term in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_intercept_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].intercept_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_intercept_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_intercept_, 'tolist') else attr_OrthogonalMatchingPursuitCV_intercept_`;
    })();
  }
  /**
    Parameter vector (w in the problem formulation).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_coef_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].coef_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_coef_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_coef_, 'tolist') else attr_OrthogonalMatchingPursuitCV_coef_`;
    })();
  }
  /**
    Estimated number of non-zero coefficients giving the best mean squared error over the cross-validation folds.
   */
  get n_nonzero_coefs_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_nonzero_coefs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_nonzero_coefs_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_nonzero_coefs_`;
    })();
  }
  /**
    Number of active features across every target for the model refit with the best hyperparameters got by cross-validating across all folds.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_iter_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_iter_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_iter_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_iter_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_n_features_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].n_features_in_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_n_features_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_n_features_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OrthogonalMatchingPursuitCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OrthogonalMatchingPursuitCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OrthogonalMatchingPursuitCV_feature_names_in_ = bridgeOrthogonalMatchingPursuitCV[${this.id}].feature_names_in_`;
      return this._py`attr_OrthogonalMatchingPursuitCV_feature_names_in_.tolist() if hasattr(attr_OrthogonalMatchingPursuitCV_feature_names_in_, 'tolist') else attr_OrthogonalMatchingPursuitCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/PassiveAggressiveClassifier.ts
import crypto23 from "node:crypto";
var PassiveAggressiveClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PassiveAggressiveClassifier${crypto23.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "PassiveAggressiveClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import PassiveAggressiveClassifier
try: bridgePassiveAggressiveClassifier
except NameError: bridgePassiveAggressiveClassifier = {}
`;
    await this._py.ex`ctor_PassiveAggressiveClassifier = {'C': ${this.opts["C"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_PassiveAggressiveClassifier = {k: v for k, v in ctor_PassiveAggressiveClassifier.items() if v is not None}`;
    await this._py.ex`bridgePassiveAggressiveClassifier[${this.id}] = PassiveAggressiveClassifier(**ctor_PassiveAggressiveClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePassiveAggressiveClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PassiveAggressiveClassifier_decision_function = {k: v for k, v in pms_PassiveAggressiveClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_decision_function = bridgePassiveAggressiveClassifier[${this.id}].decision_function(**pms_PassiveAggressiveClassifier_decision_function)`;
    return this._py`res_PassiveAggressiveClassifier_decision_function.tolist() if hasattr(res_PassiveAggressiveClassifier_decision_function, 'tolist') else res_PassiveAggressiveClassifier_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before densify()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_densify = {}

pms_PassiveAggressiveClassifier_densify = {k: v for k, v in pms_PassiveAggressiveClassifier_densify.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_densify = bridgePassiveAggressiveClassifier[${this.id}].densify(**pms_PassiveAggressiveClassifier_densify)`;
    return this._py`res_PassiveAggressiveClassifier_densify.tolist() if hasattr(res_PassiveAggressiveClassifier_densify, 'tolist') else res_PassiveAggressiveClassifier_densify`;
  }
  /**
    Fit linear model with Passive Aggressive algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None}

pms_PassiveAggressiveClassifier_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_fit = bridgePassiveAggressiveClassifier[${this.id}].fit(**pms_PassiveAggressiveClassifier_fit)`;
    return this._py`res_PassiveAggressiveClassifier_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_fit, 'tolist') else res_PassiveAggressiveClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PassiveAggressiveClassifier_get_metadata_routing = {k: v for k, v in pms_PassiveAggressiveClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_get_metadata_routing = bridgePassiveAggressiveClassifier[${this.id}].get_metadata_routing(**pms_PassiveAggressiveClassifier_get_metadata_routing)`;
    return this._py`res_PassiveAggressiveClassifier_get_metadata_routing.tolist() if hasattr(res_PassiveAggressiveClassifier_get_metadata_routing, 'tolist') else res_PassiveAggressiveClassifier_get_metadata_routing`;
  }
  /**
    Fit linear model with Passive Aggressive algorithm.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None}

pms_PassiveAggressiveClassifier_partial_fit = {k: v for k, v in pms_PassiveAggressiveClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_partial_fit = bridgePassiveAggressiveClassifier[${this.id}].partial_fit(**pms_PassiveAggressiveClassifier_partial_fit)`;
    return this._py`res_PassiveAggressiveClassifier_partial_fit.tolist() if hasattr(res_PassiveAggressiveClassifier_partial_fit, 'tolist') else res_PassiveAggressiveClassifier_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PassiveAggressiveClassifier_predict = {k: v for k, v in pms_PassiveAggressiveClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_predict = bridgePassiveAggressiveClassifier[${this.id}].predict(**pms_PassiveAggressiveClassifier_predict)`;
    return this._py`res_PassiveAggressiveClassifier_predict.tolist() if hasattr(res_PassiveAggressiveClassifier_predict, 'tolist') else res_PassiveAggressiveClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PassiveAggressiveClassifier_score = {k: v for k, v in pms_PassiveAggressiveClassifier_score.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_score = bridgePassiveAggressiveClassifier[${this.id}].score(**pms_PassiveAggressiveClassifier_score)`;
    return this._py`res_PassiveAggressiveClassifier_score.tolist() if hasattr(res_PassiveAggressiveClassifier_score, 'tolist') else res_PassiveAggressiveClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_fit_request(**pms_PassiveAggressiveClassifier_set_fit_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_partial_fit_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_partial_fit_request = bridgePassiveAggressiveClassifier[${this.id}].set_partial_fit_request(**pms_PassiveAggressiveClassifier_set_partial_fit_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_partial_fit_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_partial_fit_request, 'tolist') else res_PassiveAggressiveClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PassiveAggressiveClassifier_set_score_request = {k: v for k, v in pms_PassiveAggressiveClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_set_score_request = bridgePassiveAggressiveClassifier[${this.id}].set_score_request(**pms_PassiveAggressiveClassifier_set_score_request)`;
    return this._py`res_PassiveAggressiveClassifier_set_score_request.tolist() if hasattr(res_PassiveAggressiveClassifier_set_score_request, 'tolist') else res_PassiveAggressiveClassifier_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before sparsify()"
      );
    }
    await this._py.ex`pms_PassiveAggressiveClassifier_sparsify = {}

pms_PassiveAggressiveClassifier_sparsify = {k: v for k, v in pms_PassiveAggressiveClassifier_sparsify.items() if v is not None}`;
    await this._py.ex`res_PassiveAggressiveClassifier_sparsify = bridgePassiveAggressiveClassifier[${this.id}].sparsify(**pms_PassiveAggressiveClassifier_sparsify)`;
    return this._py`res_PassiveAggressiveClassifier_sparsify.tolist() if hasattr(res_PassiveAggressiveClassifier_sparsify, 'tolist') else res_PassiveAggressiveClassifier_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_coef_ = bridgePassiveAggressiveClassifier[${this.id}].coef_`;
      return this._py`attr_PassiveAggressiveClassifier_coef_.tolist() if hasattr(attr_PassiveAggressiveClassifier_coef_, 'tolist') else attr_PassiveAggressiveClassifier_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_intercept_ = bridgePassiveAggressiveClassifier[${this.id}].intercept_`;
      return this._py`attr_PassiveAggressiveClassifier_intercept_.tolist() if hasattr(attr_PassiveAggressiveClassifier_intercept_, 'tolist') else attr_PassiveAggressiveClassifier_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_n_features_in_ = bridgePassiveAggressiveClassifier[${this.id}].n_features_in_`;
      return this._py`attr_PassiveAggressiveClassifier_n_features_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_features_in_, 'tolist') else attr_PassiveAggressiveClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_feature_names_in_ = bridgePassiveAggressiveClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_PassiveAggressiveClassifier_feature_names_in_.tolist() if hasattr(attr_PassiveAggressiveClassifier_feature_names_in_, 'tolist') else attr_PassiveAggressiveClassifier_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_n_iter_ = bridgePassiveAggressiveClassifier[${this.id}].n_iter_`;
      return this._py`attr_PassiveAggressiveClassifier_n_iter_.tolist() if hasattr(attr_PassiveAggressiveClassifier_n_iter_, 'tolist') else attr_PassiveAggressiveClassifier_n_iter_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_classes_ = bridgePassiveAggressiveClassifier[${this.id}].classes_`;
      return this._py`attr_PassiveAggressiveClassifier_classes_.tolist() if hasattr(attr_PassiveAggressiveClassifier_classes_, 'tolist') else attr_PassiveAggressiveClassifier_classes_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing t_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_t_ = bridgePassiveAggressiveClassifier[${this.id}].t_`;
      return this._py`attr_PassiveAggressiveClassifier_t_.tolist() if hasattr(attr_PassiveAggressiveClassifier_t_, 'tolist') else attr_PassiveAggressiveClassifier_t_`;
    })();
  }
  /**
    Loss function used by the algorithm.
   */
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This PassiveAggressiveClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PassiveAggressiveClassifier must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PassiveAggressiveClassifier_loss_function_ = bridgePassiveAggressiveClassifier[${this.id}].loss_function_`;
      return this._py`attr_PassiveAggressiveClassifier_loss_function_.tolist() if hasattr(attr_PassiveAggressiveClassifier_loss_function_, 'tolist') else attr_PassiveAggressiveClassifier_loss_function_`;
    })();
  }
};

// src/generated/linear_model/Perceptron.ts
import crypto24 from "node:crypto";
var Perceptron = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Perceptron${crypto24.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Perceptron.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Perceptron
try: bridgePerceptron
except NameError: bridgePerceptron = {}
`;
    await this._py.ex`ctor_Perceptron = {'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}}

ctor_Perceptron = {k: v for k, v in ctor_Perceptron.items() if v is not None}`;
    await this._py.ex`bridgePerceptron[${this.id}] = Perceptron(**ctor_Perceptron)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePerceptron[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before decision_function()");
    }
    await this._py.ex`pms_Perceptron_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Perceptron_decision_function = {k: v for k, v in pms_Perceptron_decision_function.items() if v is not None}`;
    await this._py.ex`res_Perceptron_decision_function = bridgePerceptron[${this.id}].decision_function(**pms_Perceptron_decision_function)`;
    return this._py`res_Perceptron_decision_function.tolist() if hasattr(res_Perceptron_decision_function, 'tolist') else res_Perceptron_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before densify()");
    }
    await this._py.ex`pms_Perceptron_densify = {}

pms_Perceptron_densify = {k: v for k, v in pms_Perceptron_densify.items() if v is not None}`;
    await this._py.ex`res_Perceptron_densify = bridgePerceptron[${this.id}].densify(**pms_Perceptron_densify)`;
    return this._py`res_Perceptron_densify.tolist() if hasattr(res_Perceptron_densify, 'tolist') else res_Perceptron_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before fit()");
    }
    await this._py.ex`pms_Perceptron_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_fit = {k: v for k, v in pms_Perceptron_fit.items() if v is not None}`;
    await this._py.ex`res_Perceptron_fit = bridgePerceptron[${this.id}].fit(**pms_Perceptron_fit)`;
    return this._py`res_Perceptron_fit.tolist() if hasattr(res_Perceptron_fit, 'tolist') else res_Perceptron_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_Perceptron_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Perceptron_get_metadata_routing = {k: v for k, v in pms_Perceptron_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Perceptron_get_metadata_routing = bridgePerceptron[${this.id}].get_metadata_routing(**pms_Perceptron_get_metadata_routing)`;
    return this._py`res_Perceptron_get_metadata_routing.tolist() if hasattr(res_Perceptron_get_metadata_routing, 'tolist') else res_Perceptron_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before partial_fit()");
    }
    await this._py.ex`pms_Perceptron_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_partial_fit = {k: v for k, v in pms_Perceptron_partial_fit.items() if v is not None}`;
    await this._py.ex`res_Perceptron_partial_fit = bridgePerceptron[${this.id}].partial_fit(**pms_Perceptron_partial_fit)`;
    return this._py`res_Perceptron_partial_fit.tolist() if hasattr(res_Perceptron_partial_fit, 'tolist') else res_Perceptron_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before predict()");
    }
    await this._py.ex`pms_Perceptron_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Perceptron_predict = {k: v for k, v in pms_Perceptron_predict.items() if v is not None}`;
    await this._py.ex`res_Perceptron_predict = bridgePerceptron[${this.id}].predict(**pms_Perceptron_predict)`;
    return this._py`res_Perceptron_predict.tolist() if hasattr(res_Perceptron_predict, 'tolist') else res_Perceptron_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before score()");
    }
    await this._py.ex`pms_Perceptron_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Perceptron_score = {k: v for k, v in pms_Perceptron_score.items() if v is not None}`;
    await this._py.ex`res_Perceptron_score = bridgePerceptron[${this.id}].score(**pms_Perceptron_score)`;
    return this._py`res_Perceptron_score.tolist() if hasattr(res_Perceptron_score, 'tolist') else res_Perceptron_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Perceptron_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_fit_request = {k: v for k, v in pms_Perceptron_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_fit_request = bridgePerceptron[${this.id}].set_fit_request(**pms_Perceptron_set_fit_request)`;
    return this._py`res_Perceptron_set_fit_request.tolist() if hasattr(res_Perceptron_set_fit_request, 'tolist') else res_Perceptron_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_Perceptron_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_partial_fit_request = {k: v for k, v in pms_Perceptron_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_partial_fit_request = bridgePerceptron[${this.id}].set_partial_fit_request(**pms_Perceptron_set_partial_fit_request)`;
    return this._py`res_Perceptron_set_partial_fit_request.tolist() if hasattr(res_Perceptron_set_partial_fit_request, 'tolist') else res_Perceptron_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before set_score_request()");
    }
    await this._py.ex`pms_Perceptron_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Perceptron_set_score_request = {k: v for k, v in pms_Perceptron_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Perceptron_set_score_request = bridgePerceptron[${this.id}].set_score_request(**pms_Perceptron_set_score_request)`;
    return this._py`res_Perceptron_set_score_request.tolist() if hasattr(res_Perceptron_set_score_request, 'tolist') else res_Perceptron_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before sparsify()");
    }
    await this._py.ex`pms_Perceptron_sparsify = {}

pms_Perceptron_sparsify = {k: v for k, v in pms_Perceptron_sparsify.items() if v is not None}`;
    await this._py.ex`res_Perceptron_sparsify = bridgePerceptron[${this.id}].sparsify(**pms_Perceptron_sparsify)`;
    return this._py`res_Perceptron_sparsify.tolist() if hasattr(res_Perceptron_sparsify, 'tolist') else res_Perceptron_sparsify`;
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_classes_ = bridgePerceptron[${this.id}].classes_`;
      return this._py`attr_Perceptron_classes_.tolist() if hasattr(attr_Perceptron_classes_, 'tolist') else attr_Perceptron_classes_`;
    })();
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_coef_ = bridgePerceptron[${this.id}].coef_`;
      return this._py`attr_Perceptron_coef_.tolist() if hasattr(attr_Perceptron_coef_, 'tolist') else attr_Perceptron_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_intercept_ = bridgePerceptron[${this.id}].intercept_`;
      return this._py`attr_Perceptron_intercept_.tolist() if hasattr(attr_Perceptron_intercept_, 'tolist') else attr_Perceptron_intercept_`;
    })();
  }
  /**
    The function that determines the loss, or difference between the output of the algorithm and the target values.
   */
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_loss_function_ = bridgePerceptron[${this.id}].loss_function_`;
      return this._py`attr_Perceptron_loss_function_.tolist() if hasattr(attr_Perceptron_loss_function_, 'tolist') else attr_Perceptron_loss_function_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_n_features_in_ = bridgePerceptron[${this.id}].n_features_in_`;
      return this._py`attr_Perceptron_n_features_in_.tolist() if hasattr(attr_Perceptron_n_features_in_, 'tolist') else attr_Perceptron_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Perceptron must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_feature_names_in_ = bridgePerceptron[${this.id}].feature_names_in_`;
      return this._py`attr_Perceptron_feature_names_in_.tolist() if hasattr(attr_Perceptron_feature_names_in_, 'tolist') else attr_Perceptron_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_n_iter_ = bridgePerceptron[${this.id}].n_iter_`;
      return this._py`attr_Perceptron_n_iter_.tolist() if hasattr(attr_Perceptron_n_iter_, 'tolist') else attr_Perceptron_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This Perceptron instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Perceptron must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_Perceptron_t_ = bridgePerceptron[${this.id}].t_`;
      return this._py`attr_Perceptron_t_.tolist() if hasattr(attr_Perceptron_t_, 'tolist') else attr_Perceptron_t_`;
    })();
  }
};

// src/generated/linear_model/PoissonRegressor.ts
import crypto25 from "node:crypto";
var PoissonRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PoissonRegressor${crypto25.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PoissonRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import PoissonRegressor
try: bridgePoissonRegressor
except NameError: bridgePoissonRegressor = {}
`;
    await this._py.ex`ctor_PoissonRegressor = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_PoissonRegressor = {k: v for k, v in ctor_PoissonRegressor.items() if v is not None}`;
    await this._py.ex`bridgePoissonRegressor[${this.id}] = PoissonRegressor(**ctor_PoissonRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePoissonRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before fit()");
    }
    await this._py.ex`pms_PoissonRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PoissonRegressor_fit = {k: v for k, v in pms_PoissonRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_fit = bridgePoissonRegressor[${this.id}].fit(**pms_PoissonRegressor_fit)`;
    return this._py`res_PoissonRegressor_fit.tolist() if hasattr(res_PoissonRegressor_fit, 'tolist') else res_PoissonRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PoissonRegressor_get_metadata_routing = {k: v for k, v in pms_PoissonRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_get_metadata_routing = bridgePoissonRegressor[${this.id}].get_metadata_routing(**pms_PoissonRegressor_get_metadata_routing)`;
    return this._py`res_PoissonRegressor_get_metadata_routing.tolist() if hasattr(res_PoissonRegressor_get_metadata_routing, 'tolist') else res_PoissonRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before predict()");
    }
    await this._py.ex`pms_PoissonRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PoissonRegressor_predict = {k: v for k, v in pms_PoissonRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_predict = bridgePoissonRegressor[${this.id}].predict(**pms_PoissonRegressor_predict)`;
    return this._py`res_PoissonRegressor_predict.tolist() if hasattr(res_PoissonRegressor_predict, 'tolist') else res_PoissonRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("PoissonRegressor must call init() before score()");
    }
    await this._py.ex`pms_PoissonRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PoissonRegressor_score = {k: v for k, v in pms_PoissonRegressor_score.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_score = bridgePoissonRegressor[${this.id}].score(**pms_PoissonRegressor_score)`;
    return this._py`res_PoissonRegressor_score.tolist() if hasattr(res_PoissonRegressor_score, 'tolist') else res_PoissonRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PoissonRegressor_set_fit_request = {k: v for k, v in pms_PoissonRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_set_fit_request = bridgePoissonRegressor[${this.id}].set_fit_request(**pms_PoissonRegressor_set_fit_request)`;
    return this._py`res_PoissonRegressor_set_fit_request.tolist() if hasattr(res_PoissonRegressor_set_fit_request, 'tolist') else res_PoissonRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PoissonRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PoissonRegressor_set_score_request = {k: v for k, v in pms_PoissonRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PoissonRegressor_set_score_request = bridgePoissonRegressor[${this.id}].set_score_request(**pms_PoissonRegressor_set_score_request)`;
    return this._py`res_PoissonRegressor_set_score_request.tolist() if hasattr(res_PoissonRegressor_set_score_request, 'tolist') else res_PoissonRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_coef_ = bridgePoissonRegressor[${this.id}].coef_`;
      return this._py`attr_PoissonRegressor_coef_.tolist() if hasattr(attr_PoissonRegressor_coef_, 'tolist') else attr_PoissonRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_intercept_ = bridgePoissonRegressor[${this.id}].intercept_`;
      return this._py`attr_PoissonRegressor_intercept_.tolist() if hasattr(attr_PoissonRegressor_intercept_, 'tolist') else attr_PoissonRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_n_features_in_ = bridgePoissonRegressor[${this.id}].n_features_in_`;
      return this._py`attr_PoissonRegressor_n_features_in_.tolist() if hasattr(attr_PoissonRegressor_n_features_in_, 'tolist') else attr_PoissonRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_feature_names_in_ = bridgePoissonRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_PoissonRegressor_feature_names_in_.tolist() if hasattr(attr_PoissonRegressor_feature_names_in_, 'tolist') else attr_PoissonRegressor_feature_names_in_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This PoissonRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "PoissonRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PoissonRegressor_n_iter_ = bridgePoissonRegressor[${this.id}].n_iter_`;
      return this._py`attr_PoissonRegressor_n_iter_.tolist() if hasattr(attr_PoissonRegressor_n_iter_, 'tolist') else attr_PoissonRegressor_n_iter_`;
    })();
  }
};

// src/generated/linear_model/QuantileRegressor.ts
import crypto26 from "node:crypto";
var QuantileRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `QuantileRegressor${crypto26.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("QuantileRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import QuantileRegressor
try: bridgeQuantileRegressor
except NameError: bridgeQuantileRegressor = {}
`;
    await this._py.ex`ctor_QuantileRegressor = {'quantile': ${this.opts["quantile"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'solver_options': ${this.opts["solver_options"] ?? void 0}}

ctor_QuantileRegressor = {k: v for k, v in ctor_QuantileRegressor.items() if v is not None}`;
    await this._py.ex`bridgeQuantileRegressor[${this.id}] = QuantileRegressor(**ctor_QuantileRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuantileRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before fit()");
    }
    await this._py.ex`pms_QuantileRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuantileRegressor_fit = {k: v for k, v in pms_QuantileRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_fit = bridgeQuantileRegressor[${this.id}].fit(**pms_QuantileRegressor_fit)`;
    return this._py`res_QuantileRegressor_fit.tolist() if hasattr(res_QuantileRegressor_fit, 'tolist') else res_QuantileRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuantileRegressor_get_metadata_routing = {k: v for k, v in pms_QuantileRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_get_metadata_routing = bridgeQuantileRegressor[${this.id}].get_metadata_routing(**pms_QuantileRegressor_get_metadata_routing)`;
    return this._py`res_QuantileRegressor_get_metadata_routing.tolist() if hasattr(res_QuantileRegressor_get_metadata_routing, 'tolist') else res_QuantileRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before predict()");
    }
    await this._py.ex`pms_QuantileRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_QuantileRegressor_predict = {k: v for k, v in pms_QuantileRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_predict = bridgeQuantileRegressor[${this.id}].predict(**pms_QuantileRegressor_predict)`;
    return this._py`res_QuantileRegressor_predict.tolist() if hasattr(res_QuantileRegressor_predict, 'tolist') else res_QuantileRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("QuantileRegressor must call init() before score()");
    }
    await this._py.ex`pms_QuantileRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuantileRegressor_score = {k: v for k, v in pms_QuantileRegressor_score.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_score = bridgeQuantileRegressor[${this.id}].score(**pms_QuantileRegressor_score)`;
    return this._py`res_QuantileRegressor_score.tolist() if hasattr(res_QuantileRegressor_score, 'tolist') else res_QuantileRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuantileRegressor_set_fit_request = {k: v for k, v in pms_QuantileRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_set_fit_request = bridgeQuantileRegressor[${this.id}].set_fit_request(**pms_QuantileRegressor_set_fit_request)`;
    return this._py`res_QuantileRegressor_set_fit_request.tolist() if hasattr(res_QuantileRegressor_set_fit_request, 'tolist') else res_QuantileRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_QuantileRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuantileRegressor_set_score_request = {k: v for k, v in pms_QuantileRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_QuantileRegressor_set_score_request = bridgeQuantileRegressor[${this.id}].set_score_request(**pms_QuantileRegressor_set_score_request)`;
    return this._py`res_QuantileRegressor_set_score_request.tolist() if hasattr(res_QuantileRegressor_set_score_request, 'tolist') else res_QuantileRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_coef_ = bridgeQuantileRegressor[${this.id}].coef_`;
      return this._py`attr_QuantileRegressor_coef_.tolist() if hasattr(attr_QuantileRegressor_coef_, 'tolist') else attr_QuantileRegressor_coef_`;
    })();
  }
  /**
    The intercept of the model, aka bias term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_intercept_ = bridgeQuantileRegressor[${this.id}].intercept_`;
      return this._py`attr_QuantileRegressor_intercept_.tolist() if hasattr(attr_QuantileRegressor_intercept_, 'tolist') else attr_QuantileRegressor_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_n_features_in_ = bridgeQuantileRegressor[${this.id}].n_features_in_`;
      return this._py`attr_QuantileRegressor_n_features_in_.tolist() if hasattr(attr_QuantileRegressor_n_features_in_, 'tolist') else attr_QuantileRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_feature_names_in_ = bridgeQuantileRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_QuantileRegressor_feature_names_in_.tolist() if hasattr(attr_QuantileRegressor_feature_names_in_, 'tolist') else attr_QuantileRegressor_feature_names_in_`;
    })();
  }
  /**
    The actual number of iterations performed by the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuantileRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuantileRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuantileRegressor_n_iter_ = bridgeQuantileRegressor[${this.id}].n_iter_`;
      return this._py`attr_QuantileRegressor_n_iter_.tolist() if hasattr(attr_QuantileRegressor_n_iter_, 'tolist') else attr_QuantileRegressor_n_iter_`;
    })();
  }
};

// src/generated/linear_model/RANSACRegressor.ts
import crypto27 from "node:crypto";
var RANSACRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RANSACRegressor${crypto27.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RANSACRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RANSACRegressor
try: bridgeRANSACRegressor
except NameError: bridgeRANSACRegressor = {}
`;
    await this._py.ex`ctor_RANSACRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'residual_threshold': ${this.opts["residual_threshold"] ?? void 0}, 'is_data_valid': ${this.opts["is_data_valid"] ?? void 0}, 'is_model_valid': ${this.opts["is_model_valid"] ?? void 0}, 'max_trials': ${this.opts["max_trials"] ?? void 0}, 'max_skips': ${this.opts["max_skips"] ?? void 0}, 'stop_n_inliers': ${this.opts["stop_n_inliers"] ?? void 0}, 'stop_score': ${this.opts["stop_score"] ?? void 0}, 'stop_probability': ${this.opts["stop_probability"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RANSACRegressor = {k: v for k, v in ctor_RANSACRegressor.items() if v is not None}`;
    await this._py.ex`bridgeRANSACRegressor[${this.id}] = RANSACRegressor(**ctor_RANSACRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRANSACRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit estimator using RANSAC algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before fit()");
    }
    await this._py.ex`pms_RANSACRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RANSACRegressor_fit = {k: v for k, v in pms_RANSACRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_fit = bridgeRANSACRegressor[${this.id}].fit(**pms_RANSACRegressor_fit)`;
    return this._py`res_RANSACRegressor_fit.tolist() if hasattr(res_RANSACRegressor_fit, 'tolist') else res_RANSACRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RANSACRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RANSACRegressor_get_metadata_routing = {k: v for k, v in pms_RANSACRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_get_metadata_routing = bridgeRANSACRegressor[${this.id}].get_metadata_routing(**pms_RANSACRegressor_get_metadata_routing)`;
    return this._py`res_RANSACRegressor_get_metadata_routing.tolist() if hasattr(res_RANSACRegressor_get_metadata_routing, 'tolist') else res_RANSACRegressor_get_metadata_routing`;
  }
  /**
      Predict using the estimated model.
  
      This is a wrapper for `estimator\_.predict(X)`.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before predict()");
    }
    await this._py.ex`pms_RANSACRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RANSACRegressor_predict = {k: v for k, v in pms_RANSACRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_predict = bridgeRANSACRegressor[${this.id}].predict(**pms_RANSACRegressor_predict)`;
    return this._py`res_RANSACRegressor_predict.tolist() if hasattr(res_RANSACRegressor_predict, 'tolist') else res_RANSACRegressor_predict`;
  }
  /**
      Return the score of the prediction.
  
      This is a wrapper for `estimator\_.score(X, y)`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RANSACRegressor must call init() before score()");
    }
    await this._py.ex`pms_RANSACRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_RANSACRegressor_score = {k: v for k, v in pms_RANSACRegressor_score.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_score = bridgeRANSACRegressor[${this.id}].score(**pms_RANSACRegressor_score)`;
    return this._py`res_RANSACRegressor_score.tolist() if hasattr(res_RANSACRegressor_score, 'tolist') else res_RANSACRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RANSACRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RANSACRegressor_set_fit_request = {k: v for k, v in pms_RANSACRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RANSACRegressor_set_fit_request = bridgeRANSACRegressor[${this.id}].set_fit_request(**pms_RANSACRegressor_set_fit_request)`;
    return this._py`res_RANSACRegressor_set_fit_request.tolist() if hasattr(res_RANSACRegressor_set_fit_request, 'tolist') else res_RANSACRegressor_set_fit_request`;
  }
  /**
    Best fitted model (copy of the `estimator` object).
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_estimator_ = bridgeRANSACRegressor[${this.id}].estimator_`;
      return this._py`attr_RANSACRegressor_estimator_.tolist() if hasattr(attr_RANSACRegressor_estimator_, 'tolist') else attr_RANSACRegressor_estimator_`;
    })();
  }
  /**
    Number of random selection trials until one of the stop criteria is met. It is always `<= max\_trials`.
   */
  get n_trials_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_trials_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_trials_ = bridgeRANSACRegressor[${this.id}].n_trials_`;
      return this._py`attr_RANSACRegressor_n_trials_.tolist() if hasattr(attr_RANSACRegressor_n_trials_, 'tolist') else attr_RANSACRegressor_n_trials_`;
    })();
  }
  /**
    Boolean mask of inliers classified as `true`.
   */
  get inlier_mask_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing inlier_mask_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_inlier_mask_ = bridgeRANSACRegressor[${this.id}].inlier_mask_`;
      return this._py`attr_RANSACRegressor_inlier_mask_.tolist() if hasattr(attr_RANSACRegressor_inlier_mask_, 'tolist') else attr_RANSACRegressor_inlier_mask_`;
    })();
  }
  /**
    Number of iterations skipped due to finding zero inliers.
   */
  get n_skips_no_inliers_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_no_inliers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_no_inliers_ = bridgeRANSACRegressor[${this.id}].n_skips_no_inliers_`;
      return this._py`attr_RANSACRegressor_n_skips_no_inliers_.tolist() if hasattr(attr_RANSACRegressor_n_skips_no_inliers_, 'tolist') else attr_RANSACRegressor_n_skips_no_inliers_`;
    })();
  }
  /**
    Number of iterations skipped due to invalid data defined by `is\_data\_valid`.
   */
  get n_skips_invalid_data_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_invalid_data_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_invalid_data_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_data_`;
      return this._py`attr_RANSACRegressor_n_skips_invalid_data_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_data_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_data_`;
    })();
  }
  /**
    Number of iterations skipped due to an invalid model defined by `is\_model\_valid`.
   */
  get n_skips_invalid_model_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_skips_invalid_model_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_skips_invalid_model_ = bridgeRANSACRegressor[${this.id}].n_skips_invalid_model_`;
      return this._py`attr_RANSACRegressor_n_skips_invalid_model_.tolist() if hasattr(attr_RANSACRegressor_n_skips_invalid_model_, 'tolist') else attr_RANSACRegressor_n_skips_invalid_model_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_n_features_in_ = bridgeRANSACRegressor[${this.id}].n_features_in_`;
      return this._py`attr_RANSACRegressor_n_features_in_.tolist() if hasattr(attr_RANSACRegressor_n_features_in_, 'tolist') else attr_RANSACRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RANSACRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RANSACRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RANSACRegressor_feature_names_in_ = bridgeRANSACRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_RANSACRegressor_feature_names_in_.tolist() if hasattr(attr_RANSACRegressor_feature_names_in_, 'tolist') else attr_RANSACRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/Ridge.ts
import crypto28 from "node:crypto";
var Ridge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Ridge${crypto28.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Ridge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import Ridge
try: bridgeRidge
except NameError: bridgeRidge = {}
`;
    await this._py.ex`ctor_Ridge = {'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_Ridge = {k: v for k, v in ctor_Ridge.items() if v is not None}`;
    await this._py.ex`bridgeRidge[${this.id}] = Ridge(**ctor_Ridge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Ridge regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before fit()");
    }
    await this._py.ex`pms_Ridge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Ridge_fit = {k: v for k, v in pms_Ridge_fit.items() if v is not None}`;
    await this._py.ex`res_Ridge_fit = bridgeRidge[${this.id}].fit(**pms_Ridge_fit)`;
    return this._py`res_Ridge_fit.tolist() if hasattr(res_Ridge_fit, 'tolist') else res_Ridge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Ridge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Ridge_get_metadata_routing = {k: v for k, v in pms_Ridge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Ridge_get_metadata_routing = bridgeRidge[${this.id}].get_metadata_routing(**pms_Ridge_get_metadata_routing)`;
    return this._py`res_Ridge_get_metadata_routing.tolist() if hasattr(res_Ridge_get_metadata_routing, 'tolist') else res_Ridge_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before predict()");
    }
    await this._py.ex`pms_Ridge_predict = {'X': ${opts["X"] ?? void 0}}

pms_Ridge_predict = {k: v for k, v in pms_Ridge_predict.items() if v is not None}`;
    await this._py.ex`res_Ridge_predict = bridgeRidge[${this.id}].predict(**pms_Ridge_predict)`;
    return this._py`res_Ridge_predict.tolist() if hasattr(res_Ridge_predict, 'tolist') else res_Ridge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before score()");
    }
    await this._py.ex`pms_Ridge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_Ridge_score = {k: v for k, v in pms_Ridge_score.items() if v is not None}`;
    await this._py.ex`res_Ridge_score = bridgeRidge[${this.id}].score(**pms_Ridge_score)`;
    return this._py`res_Ridge_score.tolist() if hasattr(res_Ridge_score, 'tolist') else res_Ridge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_Ridge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Ridge_set_fit_request = {k: v for k, v in pms_Ridge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_Ridge_set_fit_request = bridgeRidge[${this.id}].set_fit_request(**pms_Ridge_set_fit_request)`;
    return this._py`res_Ridge_set_fit_request.tolist() if hasattr(res_Ridge_set_fit_request, 'tolist') else res_Ridge_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before set_score_request()");
    }
    await this._py.ex`pms_Ridge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_Ridge_set_score_request = {k: v for k, v in pms_Ridge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_Ridge_set_score_request = bridgeRidge[${this.id}].set_score_request(**pms_Ridge_set_score_request)`;
    return this._py`res_Ridge_set_score_request.tolist() if hasattr(res_Ridge_set_score_request, 'tolist') else res_Ridge_set_score_request`;
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_coef_ = bridgeRidge[${this.id}].coef_`;
      return this._py`attr_Ridge_coef_.tolist() if hasattr(attr_Ridge_coef_, 'tolist') else attr_Ridge_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_intercept_ = bridgeRidge[${this.id}].intercept_`;
      return this._py`attr_Ridge_intercept_.tolist() if hasattr(attr_Ridge_intercept_, 'tolist') else attr_Ridge_intercept_`;
    })();
  }
  /**
    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_n_iter_ = bridgeRidge[${this.id}].n_iter_`;
      return this._py`attr_Ridge_n_iter_.tolist() if hasattr(attr_Ridge_n_iter_, 'tolist') else attr_Ridge_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Ridge must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Ridge_n_features_in_ = bridgeRidge[${this.id}].n_features_in_`;
      return this._py`attr_Ridge_n_features_in_.tolist() if hasattr(attr_Ridge_n_features_in_, 'tolist') else attr_Ridge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Ridge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Ridge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Ridge_feature_names_in_ = bridgeRidge[${this.id}].feature_names_in_`;
      return this._py`attr_Ridge_feature_names_in_.tolist() if hasattr(attr_Ridge_feature_names_in_, 'tolist') else attr_Ridge_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeClassifier.ts
import crypto29 from "node:crypto";
var RidgeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeClassifier${crypto29.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeClassifier
try: bridgeRidgeClassifier
except NameError: bridgeRidgeClassifier = {}
`;
    await this._py.ex`ctor_RidgeClassifier = {'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'positive': ${this.opts["positive"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_RidgeClassifier = {k: v for k, v in ctor_RidgeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRidgeClassifier[${this.id}] = RidgeClassifier(**ctor_RidgeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifier_decision_function = {k: v for k, v in pms_RidgeClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_decision_function = bridgeRidgeClassifier[${this.id}].decision_function(**pms_RidgeClassifier_decision_function)`;
    return this._py`res_RidgeClassifier_decision_function.tolist() if hasattr(res_RidgeClassifier_decision_function, 'tolist') else res_RidgeClassifier_decision_function`;
  }
  /**
    Fit Ridge classifier model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RidgeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifier_fit = {k: v for k, v in pms_RidgeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_fit = bridgeRidgeClassifier[${this.id}].fit(**pms_RidgeClassifier_fit)`;
    return this._py`res_RidgeClassifier_fit.tolist() if hasattr(res_RidgeClassifier_fit, 'tolist') else res_RidgeClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeClassifier_get_metadata_routing = {k: v for k, v in pms_RidgeClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_get_metadata_routing = bridgeRidgeClassifier[${this.id}].get_metadata_routing(**pms_RidgeClassifier_get_metadata_routing)`;
    return this._py`res_RidgeClassifier_get_metadata_routing.tolist() if hasattr(res_RidgeClassifier_get_metadata_routing, 'tolist') else res_RidgeClassifier_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in `X`.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before predict()");
    }
    await this._py.ex`pms_RidgeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifier_predict = {k: v for k, v in pms_RidgeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_predict = bridgeRidgeClassifier[${this.id}].predict(**pms_RidgeClassifier_predict)`;
    return this._py`res_RidgeClassifier_predict.tolist() if hasattr(res_RidgeClassifier_predict, 'tolist') else res_RidgeClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before score()");
    }
    await this._py.ex`pms_RidgeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifier_score = {k: v for k, v in pms_RidgeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_score = bridgeRidgeClassifier[${this.id}].score(**pms_RidgeClassifier_score)`;
    return this._py`res_RidgeClassifier_score.tolist() if hasattr(res_RidgeClassifier_score, 'tolist') else res_RidgeClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifier_set_fit_request = {k: v for k, v in pms_RidgeClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_set_fit_request = bridgeRidgeClassifier[${this.id}].set_fit_request(**pms_RidgeClassifier_set_fit_request)`;
    return this._py`res_RidgeClassifier_set_fit_request.tolist() if hasattr(res_RidgeClassifier_set_fit_request, 'tolist') else res_RidgeClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifier_set_score_request = {k: v for k, v in pms_RidgeClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifier_set_score_request = bridgeRidgeClassifier[${this.id}].set_score_request(**pms_RidgeClassifier_set_score_request)`;
    return this._py`res_RidgeClassifier_set_score_request.tolist() if hasattr(res_RidgeClassifier_set_score_request, 'tolist') else res_RidgeClassifier_set_score_request`;
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifier must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_coef_ = bridgeRidgeClassifier[${this.id}].coef_`;
      return this._py`attr_RidgeClassifier_coef_.tolist() if hasattr(attr_RidgeClassifier_coef_, 'tolist') else attr_RidgeClassifier_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_intercept_ = bridgeRidgeClassifier[${this.id}].intercept_`;
      return this._py`attr_RidgeClassifier_intercept_.tolist() if hasattr(attr_RidgeClassifier_intercept_, 'tolist') else attr_RidgeClassifier_intercept_`;
    })();
  }
  /**
    Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return `undefined`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_n_iter_ = bridgeRidgeClassifier[${this.id}].n_iter_`;
      return this._py`attr_RidgeClassifier_n_iter_.tolist() if hasattr(attr_RidgeClassifier_n_iter_, 'tolist') else attr_RidgeClassifier_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_n_features_in_ = bridgeRidgeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RidgeClassifier_n_features_in_.tolist() if hasattr(attr_RidgeClassifier_n_features_in_, 'tolist') else attr_RidgeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifier_feature_names_in_ = bridgeRidgeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeClassifier_feature_names_in_.tolist() if hasattr(attr_RidgeClassifier_feature_names_in_, 'tolist') else attr_RidgeClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeClassifierCV.ts
import crypto30 from "node:crypto";
var RidgeClassifierCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeClassifierCV${crypto30.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeClassifierCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeClassifierCV
try: bridgeRidgeClassifierCV
except NameError: bridgeRidgeClassifierCV = {}
`;
    await this._py.ex`ctor_RidgeClassifierCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'store_cv_values': ${this.opts["store_cv_values"] ?? void 0}}

ctor_RidgeClassifierCV = {k: v for k, v in ctor_RidgeClassifierCV.items() if v is not None}`;
    await this._py.ex`bridgeRidgeClassifierCV[${this.id}] = RidgeClassifierCV(**ctor_RidgeClassifierCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeClassifierCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifierCV_decision_function = {k: v for k, v in pms_RidgeClassifierCV_decision_function.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_decision_function = bridgeRidgeClassifierCV[${this.id}].decision_function(**pms_RidgeClassifierCV_decision_function)`;
    return this._py`res_RidgeClassifierCV_decision_function.tolist() if hasattr(res_RidgeClassifierCV_decision_function, 'tolist') else res_RidgeClassifierCV_decision_function`;
  }
  /**
    Fit Ridge classifier with cv.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before fit()");
    }
    await this._py.ex`pms_RidgeClassifierCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifierCV_fit = {k: v for k, v in pms_RidgeClassifierCV_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_fit = bridgeRidgeClassifierCV[${this.id}].fit(**pms_RidgeClassifierCV_fit)`;
    return this._py`res_RidgeClassifierCV_fit.tolist() if hasattr(res_RidgeClassifierCV_fit, 'tolist') else res_RidgeClassifierCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeClassifierCV_get_metadata_routing = {k: v for k, v in pms_RidgeClassifierCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_get_metadata_routing = bridgeRidgeClassifierCV[${this.id}].get_metadata_routing(**pms_RidgeClassifierCV_get_metadata_routing)`;
    return this._py`res_RidgeClassifierCV_get_metadata_routing.tolist() if hasattr(res_RidgeClassifierCV_get_metadata_routing, 'tolist') else res_RidgeClassifierCV_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in `X`.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before predict()");
    }
    await this._py.ex`pms_RidgeClassifierCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RidgeClassifierCV_predict = {k: v for k, v in pms_RidgeClassifierCV_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_predict = bridgeRidgeClassifierCV[${this.id}].predict(**pms_RidgeClassifierCV_predict)`;
    return this._py`res_RidgeClassifierCV_predict.tolist() if hasattr(res_RidgeClassifierCV_predict, 'tolist') else res_RidgeClassifierCV_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RidgeClassifierCV must call init() before score()");
    }
    await this._py.ex`pms_RidgeClassifierCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeClassifierCV_score = {k: v for k, v in pms_RidgeClassifierCV_score.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_score = bridgeRidgeClassifierCV[${this.id}].score(**pms_RidgeClassifierCV_score)`;
    return this._py`res_RidgeClassifierCV_score.tolist() if hasattr(res_RidgeClassifierCV_score, 'tolist') else res_RidgeClassifierCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifierCV_set_fit_request = {k: v for k, v in pms_RidgeClassifierCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_set_fit_request = bridgeRidgeClassifierCV[${this.id}].set_fit_request(**pms_RidgeClassifierCV_set_fit_request)`;
    return this._py`res_RidgeClassifierCV_set_fit_request.tolist() if hasattr(res_RidgeClassifierCV_set_fit_request, 'tolist') else res_RidgeClassifierCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_RidgeClassifierCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeClassifierCV_set_score_request = {k: v for k, v in pms_RidgeClassifierCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeClassifierCV_set_score_request = bridgeRidgeClassifierCV[${this.id}].set_score_request(**pms_RidgeClassifierCV_set_score_request)`;
    return this._py`res_RidgeClassifierCV_set_score_request.tolist() if hasattr(res_RidgeClassifierCV_set_score_request, 'tolist') else res_RidgeClassifierCV_set_score_request`;
  }
  /**
    Cross-validation values for each alpha (only if `store\_cv\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.
   */
  get cv_values_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing cv_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_cv_values_ = bridgeRidgeClassifierCV[${this.id}].cv_values_`;
      return this._py`attr_RidgeClassifierCV_cv_values_.tolist() if hasattr(attr_RidgeClassifierCV_cv_values_, 'tolist') else attr_RidgeClassifierCV_cv_values_`;
    })();
  }
  /**
      Coefficient of the features in the decision function.
  
      `coef\_` is of shape (1, n\_features) when the given problem is binary.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_coef_ = bridgeRidgeClassifierCV[${this.id}].coef_`;
      return this._py`attr_RidgeClassifierCV_coef_.tolist() if hasattr(attr_RidgeClassifierCV_coef_, 'tolist') else attr_RidgeClassifierCV_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_intercept_ = bridgeRidgeClassifierCV[${this.id}].intercept_`;
      return this._py`attr_RidgeClassifierCV_intercept_.tolist() if hasattr(attr_RidgeClassifierCV_intercept_, 'tolist') else attr_RidgeClassifierCV_intercept_`;
    })();
  }
  /**
    Estimated regularization parameter.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_alpha_ = bridgeRidgeClassifierCV[${this.id}].alpha_`;
      return this._py`attr_RidgeClassifierCV_alpha_.tolist() if hasattr(attr_RidgeClassifierCV_alpha_, 'tolist') else attr_RidgeClassifierCV_alpha_`;
    })();
  }
  /**
    Score of base estimator with best alpha.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing best_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_best_score_ = bridgeRidgeClassifierCV[${this.id}].best_score_`;
      return this._py`attr_RidgeClassifierCV_best_score_.tolist() if hasattr(attr_RidgeClassifierCV_best_score_, 'tolist') else attr_RidgeClassifierCV_best_score_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_n_features_in_ = bridgeRidgeClassifierCV[${this.id}].n_features_in_`;
      return this._py`attr_RidgeClassifierCV_n_features_in_.tolist() if hasattr(attr_RidgeClassifierCV_n_features_in_, 'tolist') else attr_RidgeClassifierCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RidgeClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeClassifierCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeClassifierCV_feature_names_in_ = bridgeRidgeClassifierCV[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeClassifierCV_feature_names_in_.tolist() if hasattr(attr_RidgeClassifierCV_feature_names_in_, 'tolist') else attr_RidgeClassifierCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/RidgeCV.ts
import crypto31 from "node:crypto";
var RidgeCV = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RidgeCV${crypto31.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RidgeCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import RidgeCV
try: bridgeRidgeCV
except NameError: bridgeRidgeCV = {}
`;
    await this._py.ex`ctor_RidgeCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'gcv_mode': ${this.opts["gcv_mode"] ?? void 0}, 'store_cv_values': ${this.opts["store_cv_values"] ?? void 0}, 'alpha_per_target': ${this.opts["alpha_per_target"] ?? void 0}}

ctor_RidgeCV = {k: v for k, v in ctor_RidgeCV.items() if v is not None}`;
    await this._py.ex`bridgeRidgeCV[${this.id}] = RidgeCV(**ctor_RidgeCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRidgeCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Ridge regression model with cv.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before fit()");
    }
    await this._py.ex`pms_RidgeCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeCV_fit = {k: v for k, v in pms_RidgeCV_fit.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_fit = bridgeRidgeCV[${this.id}].fit(**pms_RidgeCV_fit)`;
    return this._py`res_RidgeCV_fit.tolist() if hasattr(res_RidgeCV_fit, 'tolist') else res_RidgeCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_RidgeCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_RidgeCV_get_metadata_routing = {k: v for k, v in pms_RidgeCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_get_metadata_routing = bridgeRidgeCV[${this.id}].get_metadata_routing(**pms_RidgeCV_get_metadata_routing)`;
    return this._py`res_RidgeCV_get_metadata_routing.tolist() if hasattr(res_RidgeCV_get_metadata_routing, 'tolist') else res_RidgeCV_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before predict()");
    }
    await this._py.ex`pms_RidgeCV_predict = {'X': ${opts["X"] ?? void 0}}

pms_RidgeCV_predict = {k: v for k, v in pms_RidgeCV_predict.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_predict = bridgeRidgeCV[${this.id}].predict(**pms_RidgeCV_predict)`;
    return this._py`res_RidgeCV_predict.tolist() if hasattr(res_RidgeCV_predict, 'tolist') else res_RidgeCV_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before score()");
    }
    await this._py.ex`pms_RidgeCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RidgeCV_score = {k: v for k, v in pms_RidgeCV_score.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_score = bridgeRidgeCV[${this.id}].score(**pms_RidgeCV_score)`;
    return this._py`res_RidgeCV_score.tolist() if hasattr(res_RidgeCV_score, 'tolist') else res_RidgeCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before set_fit_request()");
    }
    await this._py.ex`pms_RidgeCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeCV_set_fit_request = {k: v for k, v in pms_RidgeCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_set_fit_request = bridgeRidgeCV[${this.id}].set_fit_request(**pms_RidgeCV_set_fit_request)`;
    return this._py`res_RidgeCV_set_fit_request.tolist() if hasattr(res_RidgeCV_set_fit_request, 'tolist') else res_RidgeCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before set_score_request()");
    }
    await this._py.ex`pms_RidgeCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_RidgeCV_set_score_request = {k: v for k, v in pms_RidgeCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_RidgeCV_set_score_request = bridgeRidgeCV[${this.id}].set_score_request(**pms_RidgeCV_set_score_request)`;
    return this._py`res_RidgeCV_set_score_request.tolist() if hasattr(res_RidgeCV_set_score_request, 'tolist') else res_RidgeCV_set_score_request`;
  }
  /**
    Cross-validation values for each alpha (only available if `store\_cv\_values=True` and `cv=None`). After `fit()` has been called, this attribute will contain the mean squared errors if `scoring is None` otherwise it will contain standardized per point prediction values.
   */
  get cv_values_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing cv_values_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_cv_values_ = bridgeRidgeCV[${this.id}].cv_values_`;
      return this._py`attr_RidgeCV_cv_values_.tolist() if hasattr(attr_RidgeCV_cv_values_, 'tolist') else attr_RidgeCV_cv_values_`;
    })();
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_coef_ = bridgeRidgeCV[${this.id}].coef_`;
      return this._py`attr_RidgeCV_coef_.tolist() if hasattr(attr_RidgeCV_coef_, 'tolist') else attr_RidgeCV_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_intercept_ = bridgeRidgeCV[${this.id}].intercept_`;
      return this._py`attr_RidgeCV_intercept_.tolist() if hasattr(attr_RidgeCV_intercept_, 'tolist') else attr_RidgeCV_intercept_`;
    })();
  }
  /**
    Estimated regularization parameter, or, if `alpha\_per\_target=True`, the estimated regularization parameter for each target.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_alpha_ = bridgeRidgeCV[${this.id}].alpha_`;
      return this._py`attr_RidgeCV_alpha_.tolist() if hasattr(attr_RidgeCV_alpha_, 'tolist') else attr_RidgeCV_alpha_`;
    })();
  }
  /**
    Score of base estimator with best alpha, or, if `alpha\_per\_target=True`, a score for each target.
   */
  get best_score_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RidgeCV must call init() before accessing best_score_");
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_best_score_ = bridgeRidgeCV[${this.id}].best_score_`;
      return this._py`attr_RidgeCV_best_score_.tolist() if hasattr(attr_RidgeCV_best_score_, 'tolist') else attr_RidgeCV_best_score_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_n_features_in_ = bridgeRidgeCV[${this.id}].n_features_in_`;
      return this._py`attr_RidgeCV_n_features_in_.tolist() if hasattr(attr_RidgeCV_n_features_in_, 'tolist') else attr_RidgeCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This RidgeCV instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RidgeCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RidgeCV_feature_names_in_ = bridgeRidgeCV[${this.id}].feature_names_in_`;
      return this._py`attr_RidgeCV_feature_names_in_.tolist() if hasattr(attr_RidgeCV_feature_names_in_, 'tolist') else attr_RidgeCV_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDClassifier.ts
import crypto32 from "node:crypto";
var SGDClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDClassifier${crypto32.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDClassifier
try: bridgeSGDClassifier
except NameError: bridgeSGDClassifier = {}
`;
    await this._py.ex`ctor_SGDClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDClassifier = {k: v for k, v in ctor_SGDClassifier.items() if v is not None}`;
    await this._py.ex`bridgeSGDClassifier[${this.id}] = SGDClassifier(**ctor_SGDClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_SGDClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_decision_function = {k: v for k, v in pms_SGDClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_decision_function = bridgeSGDClassifier[${this.id}].decision_function(**pms_SGDClassifier_decision_function)`;
    return this._py`res_SGDClassifier_decision_function.tolist() if hasattr(res_SGDClassifier_decision_function, 'tolist') else res_SGDClassifier_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before densify()");
    }
    await this._py.ex`pms_SGDClassifier_densify = {}

pms_SGDClassifier_densify = {k: v for k, v in pms_SGDClassifier_densify.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_densify = bridgeSGDClassifier[${this.id}].densify(**pms_SGDClassifier_densify)`;
    return this._py`res_SGDClassifier_densify.tolist() if hasattr(res_SGDClassifier_densify, 'tolist') else res_SGDClassifier_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before fit()");
    }
    await this._py.ex`pms_SGDClassifier_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_fit = {k: v for k, v in pms_SGDClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_fit = bridgeSGDClassifier[${this.id}].fit(**pms_SGDClassifier_fit)`;
    return this._py`res_SGDClassifier_fit.tolist() if hasattr(res_SGDClassifier_fit, 'tolist') else res_SGDClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDClassifier_get_metadata_routing = {k: v for k, v in pms_SGDClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_get_metadata_routing = bridgeSGDClassifier[${this.id}].get_metadata_routing(**pms_SGDClassifier_get_metadata_routing)`;
    return this._py`res_SGDClassifier_get_metadata_routing.tolist() if hasattr(res_SGDClassifier_get_metadata_routing, 'tolist') else res_SGDClassifier_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence, early stopping, and learning rate adjustments should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDClassifier_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': np.array(${opts["classes"] ?? void 0}) if ${opts["classes"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_partial_fit = {k: v for k, v in pms_SGDClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_partial_fit = bridgeSGDClassifier[${this.id}].partial_fit(**pms_SGDClassifier_partial_fit)`;
    return this._py`res_SGDClassifier_partial_fit.tolist() if hasattr(res_SGDClassifier_partial_fit, 'tolist') else res_SGDClassifier_partial_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before predict()");
    }
    await this._py.ex`pms_SGDClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_predict = {k: v for k, v in pms_SGDClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict = bridgeSGDClassifier[${this.id}].predict(**pms_SGDClassifier_predict)`;
    return this._py`res_SGDClassifier_predict.tolist() if hasattr(res_SGDClassifier_predict, 'tolist') else res_SGDClassifier_predict`;
  }
  /**
      Log of probability estimates.
  
      This method is only available for log loss and modified Huber loss.
  
      When loss=modified\_huber, probability estimates may be hard zeros and ones, so taking the logarithm is not possible.
  
      See `predict\_proba` for details.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_SGDClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SGDClassifier_predict_log_proba = {k: v for k, v in pms_SGDClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict_log_proba = bridgeSGDClassifier[${this.id}].predict_log_proba(**pms_SGDClassifier_predict_log_proba)`;
    return this._py`res_SGDClassifier_predict_log_proba.tolist() if hasattr(res_SGDClassifier_predict_log_proba, 'tolist') else res_SGDClassifier_predict_log_proba`;
  }
  /**
      Probability estimates.
  
      This method is only available for log loss and modified Huber loss.
  
      Multiclass probability estimates are derived from binary (one-vs.-rest) estimates by simple normalization, as recommended by Zadrozny and Elkan.
  
      Binary probability estimates for loss=modified\_huber are given by (clip(decision\_function(X), -1, 1) + 1) / 2. For other loss functions it is necessary to perform proper probability calibration by wrapping the classifier with [`CalibratedClassifierCV`](sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV "sklearn.calibration.CalibratedClassifierCV") instead.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before predict_proba()");
    }
    await this._py.ex`pms_SGDClassifier_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_SGDClassifier_predict_proba = {k: v for k, v in pms_SGDClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_predict_proba = bridgeSGDClassifier[${this.id}].predict_proba(**pms_SGDClassifier_predict_proba)`;
    return this._py`res_SGDClassifier_predict_proba.tolist() if hasattr(res_SGDClassifier_predict_proba, 'tolist') else res_SGDClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before score()");
    }
    await this._py.ex`pms_SGDClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SGDClassifier_score = {k: v for k, v in pms_SGDClassifier_score.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_score = bridgeSGDClassifier[${this.id}].score(**pms_SGDClassifier_score)`;
    return this._py`res_SGDClassifier_score.tolist() if hasattr(res_SGDClassifier_score, 'tolist') else res_SGDClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SGDClassifier_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_fit_request = {k: v for k, v in pms_SGDClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_fit_request = bridgeSGDClassifier[${this.id}].set_fit_request(**pms_SGDClassifier_set_fit_request)`;
    return this._py`res_SGDClassifier_set_fit_request.tolist() if hasattr(res_SGDClassifier_set_fit_request, 'tolist') else res_SGDClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDClassifier_set_partial_fit_request = {'classes': ${opts["classes"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_partial_fit_request = {k: v for k, v in pms_SGDClassifier_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_partial_fit_request = bridgeSGDClassifier[${this.id}].set_partial_fit_request(**pms_SGDClassifier_set_partial_fit_request)`;
    return this._py`res_SGDClassifier_set_partial_fit_request.tolist() if hasattr(res_SGDClassifier_set_partial_fit_request, 'tolist') else res_SGDClassifier_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_SGDClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDClassifier_set_score_request = {k: v for k, v in pms_SGDClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_set_score_request = bridgeSGDClassifier[${this.id}].set_score_request(**pms_SGDClassifier_set_score_request)`;
    return this._py`res_SGDClassifier_set_score_request.tolist() if hasattr(res_SGDClassifier_set_score_request, 'tolist') else res_SGDClassifier_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDClassifier_sparsify = {}

pms_SGDClassifier_sparsify = {k: v for k, v in pms_SGDClassifier_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDClassifier_sparsify = bridgeSGDClassifier[${this.id}].sparsify(**pms_SGDClassifier_sparsify)`;
    return this._py`res_SGDClassifier_sparsify.tolist() if hasattr(res_SGDClassifier_sparsify, 'tolist') else res_SGDClassifier_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_coef_ = bridgeSGDClassifier[${this.id}].coef_`;
      return this._py`attr_SGDClassifier_coef_.tolist() if hasattr(attr_SGDClassifier_coef_, 'tolist') else attr_SGDClassifier_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_intercept_ = bridgeSGDClassifier[${this.id}].intercept_`;
      return this._py`attr_SGDClassifier_intercept_.tolist() if hasattr(attr_SGDClassifier_intercept_, 'tolist') else attr_SGDClassifier_intercept_`;
    })();
  }
  /**
    The actual number of iterations before reaching the stopping criterion. For multiclass fits, it is the maximum over every binary fit.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_n_iter_ = bridgeSGDClassifier[${this.id}].n_iter_`;
      return this._py`attr_SGDClassifier_n_iter_.tolist() if hasattr(attr_SGDClassifier_n_iter_, 'tolist') else attr_SGDClassifier_n_iter_`;
    })();
  }
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_loss_function_ = bridgeSGDClassifier[${this.id}].loss_function_`;
      return this._py`attr_SGDClassifier_loss_function_.tolist() if hasattr(attr_SGDClassifier_loss_function_, 'tolist') else attr_SGDClassifier_loss_function_`;
    })();
  }
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_classes_ = bridgeSGDClassifier[${this.id}].classes_`;
      return this._py`attr_SGDClassifier_classes_.tolist() if hasattr(attr_SGDClassifier_classes_, 'tolist') else attr_SGDClassifier_classes_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDClassifier must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_t_ = bridgeSGDClassifier[${this.id}].t_`;
      return this._py`attr_SGDClassifier_t_.tolist() if hasattr(attr_SGDClassifier_t_, 'tolist') else attr_SGDClassifier_t_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_n_features_in_ = bridgeSGDClassifier[${this.id}].n_features_in_`;
      return this._py`attr_SGDClassifier_n_features_in_.tolist() if hasattr(attr_SGDClassifier_n_features_in_, 'tolist') else attr_SGDClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDClassifier_feature_names_in_ = bridgeSGDClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_SGDClassifier_feature_names_in_.tolist() if hasattr(attr_SGDClassifier_feature_names_in_, 'tolist') else attr_SGDClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDOneClassSVM.ts
import crypto33 from "node:crypto";
var SGDOneClassSVM = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDOneClassSVM${crypto33.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDOneClassSVM.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDOneClassSVM
try: bridgeSGDOneClassSVM
except NameError: bridgeSGDOneClassSVM = {}
`;
    await this._py.ex`ctor_SGDOneClassSVM = {'nu': ${this.opts["nu"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDOneClassSVM = {k: v for k, v in ctor_SGDOneClassSVM.items() if v is not None}`;
    await this._py.ex`bridgeSGDOneClassSVM[${this.id}] = SGDOneClassSVM(**ctor_SGDOneClassSVM)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDOneClassSVM[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Signed distance to the separating hyperplane.
  
      Signed distance is positive for an inlier and negative for an outlier.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_decision_function = {k: v for k, v in pms_SGDOneClassSVM_decision_function.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_decision_function = bridgeSGDOneClassSVM[${this.id}].decision_function(**pms_SGDOneClassSVM_decision_function)`;
    return this._py`res_SGDOneClassSVM_decision_function.tolist() if hasattr(res_SGDOneClassSVM_decision_function, 'tolist') else res_SGDOneClassSVM_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before densify()");
    }
    await this._py.ex`pms_SGDOneClassSVM_densify = {}

pms_SGDOneClassSVM_densify = {k: v for k, v in pms_SGDOneClassSVM_densify.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_densify = bridgeSGDOneClassSVM[${this.id}].densify(**pms_SGDOneClassSVM_densify)`;
    return this._py`res_SGDOneClassSVM_densify.tolist() if hasattr(res_SGDOneClassSVM_densify, 'tolist') else res_SGDOneClassSVM_densify`;
  }
  /**
      Fit linear One-Class SVM with Stochastic Gradient Descent.
  
      This solves an equivalent optimization problem of the One-Class SVM primal optimization problem and returns a weight vector w and an offset rho such that the decision function is given by <w, x> - rho.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before fit()");
    }
    await this._py.ex`pms_SGDOneClassSVM_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'coef_init': ${opts["coef_init"] ?? void 0}, 'offset_init': ${opts["offset_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_fit = {k: v for k, v in pms_SGDOneClassSVM_fit.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_fit = bridgeSGDOneClassSVM[${this.id}].fit(**pms_SGDOneClassSVM_fit)`;
    return this._py`res_SGDOneClassSVM_fit.tolist() if hasattr(res_SGDOneClassSVM_fit, 'tolist') else res_SGDOneClassSVM_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before fit_predict()");
    }
    await this._py.ex`pms_SGDOneClassSVM_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SGDOneClassSVM_fit_predict = {k: v for k, v in pms_SGDOneClassSVM_fit_predict.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_fit_predict = bridgeSGDOneClassSVM[${this.id}].fit_predict(**pms_SGDOneClassSVM_fit_predict)`;
    return this._py`res_SGDOneClassSVM_fit_predict.tolist() if hasattr(res_SGDOneClassSVM_fit_predict, 'tolist') else res_SGDOneClassSVM_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDOneClassSVM_get_metadata_routing = {k: v for k, v in pms_SGDOneClassSVM_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_get_metadata_routing = bridgeSGDOneClassSVM[${this.id}].get_metadata_routing(**pms_SGDOneClassSVM_get_metadata_routing)`;
    return this._py`res_SGDOneClassSVM_get_metadata_routing.tolist() if hasattr(res_SGDOneClassSVM_get_metadata_routing, 'tolist') else res_SGDOneClassSVM_get_metadata_routing`;
  }
  /**
    Fit linear One-Class SVM with Stochastic Gradient Descent.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDOneClassSVM_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_partial_fit = {k: v for k, v in pms_SGDOneClassSVM_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_partial_fit = bridgeSGDOneClassSVM[${this.id}].partial_fit(**pms_SGDOneClassSVM_partial_fit)`;
    return this._py`res_SGDOneClassSVM_partial_fit.tolist() if hasattr(res_SGDOneClassSVM_partial_fit, 'tolist') else res_SGDOneClassSVM_partial_fit`;
  }
  /**
    Return labels (1 inlier, -1 outlier) of the samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before predict()");
    }
    await this._py.ex`pms_SGDOneClassSVM_predict = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_predict = {k: v for k, v in pms_SGDOneClassSVM_predict.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_predict = bridgeSGDOneClassSVM[${this.id}].predict(**pms_SGDOneClassSVM_predict)`;
    return this._py`res_SGDOneClassSVM_predict.tolist() if hasattr(res_SGDOneClassSVM_predict, 'tolist') else res_SGDOneClassSVM_predict`;
  }
  /**
    Raw scoring function of the samples.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before score_samples()");
    }
    await this._py.ex`pms_SGDOneClassSVM_score_samples = {'X': ${opts["X"] ?? void 0}}

pms_SGDOneClassSVM_score_samples = {k: v for k, v in pms_SGDOneClassSVM_score_samples.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_score_samples = bridgeSGDOneClassSVM[${this.id}].score_samples(**pms_SGDOneClassSVM_score_samples)`;
    return this._py`res_SGDOneClassSVM_score_samples.tolist() if hasattr(res_SGDOneClassSVM_score_samples, 'tolist') else res_SGDOneClassSVM_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'offset_init': ${opts["offset_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_set_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_set_fit_request = bridgeSGDOneClassSVM[${this.id}].set_fit_request(**pms_SGDOneClassSVM_set_fit_request)`;
    return this._py`res_SGDOneClassSVM_set_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_fit_request, 'tolist') else res_SGDOneClassSVM_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDOneClassSVM_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDOneClassSVM_set_partial_fit_request = {k: v for k, v in pms_SGDOneClassSVM_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_set_partial_fit_request = bridgeSGDOneClassSVM[${this.id}].set_partial_fit_request(**pms_SGDOneClassSVM_set_partial_fit_request)`;
    return this._py`res_SGDOneClassSVM_set_partial_fit_request.tolist() if hasattr(res_SGDOneClassSVM_set_partial_fit_request, 'tolist') else res_SGDOneClassSVM_set_partial_fit_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDOneClassSVM_sparsify = {}

pms_SGDOneClassSVM_sparsify = {k: v for k, v in pms_SGDOneClassSVM_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDOneClassSVM_sparsify = bridgeSGDOneClassSVM[${this.id}].sparsify(**pms_SGDOneClassSVM_sparsify)`;
    return this._py`res_SGDOneClassSVM_sparsify.tolist() if hasattr(res_SGDOneClassSVM_sparsify, 'tolist') else res_SGDOneClassSVM_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_coef_ = bridgeSGDOneClassSVM[${this.id}].coef_`;
      return this._py`attr_SGDOneClassSVM_coef_.tolist() if hasattr(attr_SGDOneClassSVM_coef_, 'tolist') else attr_SGDOneClassSVM_coef_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: decision\_function = score\_samples - offset.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_offset_ = bridgeSGDOneClassSVM[${this.id}].offset_`;
      return this._py`attr_SGDOneClassSVM_offset_.tolist() if hasattr(attr_SGDOneClassSVM_offset_, 'tolist') else attr_SGDOneClassSVM_offset_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_n_iter_ = bridgeSGDOneClassSVM[${this.id}].n_iter_`;
      return this._py`attr_SGDOneClassSVM_n_iter_.tolist() if hasattr(attr_SGDOneClassSVM_n_iter_, 'tolist') else attr_SGDOneClassSVM_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDOneClassSVM must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_t_ = bridgeSGDOneClassSVM[${this.id}].t_`;
      return this._py`attr_SGDOneClassSVM_t_.tolist() if hasattr(attr_SGDOneClassSVM_t_, 'tolist') else attr_SGDOneClassSVM_t_`;
    })();
  }
  get loss_function_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing loss_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_loss_function_ = bridgeSGDOneClassSVM[${this.id}].loss_function_`;
      return this._py`attr_SGDOneClassSVM_loss_function_.tolist() if hasattr(attr_SGDOneClassSVM_loss_function_, 'tolist') else attr_SGDOneClassSVM_loss_function_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_n_features_in_ = bridgeSGDOneClassSVM[${this.id}].n_features_in_`;
      return this._py`attr_SGDOneClassSVM_n_features_in_.tolist() if hasattr(attr_SGDOneClassSVM_n_features_in_, 'tolist') else attr_SGDOneClassSVM_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDOneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDOneClassSVM must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDOneClassSVM_feature_names_in_ = bridgeSGDOneClassSVM[${this.id}].feature_names_in_`;
      return this._py`attr_SGDOneClassSVM_feature_names_in_.tolist() if hasattr(attr_SGDOneClassSVM_feature_names_in_, 'tolist') else attr_SGDOneClassSVM_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/SGDRegressor.ts
import crypto34 from "node:crypto";
var SGDRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SGDRegressor${crypto34.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SGDRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import SGDRegressor
try: bridgeSGDRegressor
except NameError: bridgeSGDRegressor = {}
`;
    await this._py.ex`ctor_SGDRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'penalty': ${this.opts["penalty"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'eta0': ${this.opts["eta0"] ?? void 0}, 'power_t': ${this.opts["power_t"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'average': ${this.opts["average"] ?? void 0}}

ctor_SGDRegressor = {k: v for k, v in ctor_SGDRegressor.items() if v is not None}`;
    await this._py.ex`bridgeSGDRegressor[${this.id}] = SGDRegressor(**ctor_SGDRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSGDRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before densify()");
    }
    await this._py.ex`pms_SGDRegressor_densify = {}

pms_SGDRegressor_densify = {k: v for k, v in pms_SGDRegressor_densify.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_densify = bridgeSGDRegressor[${this.id}].densify(**pms_SGDRegressor_densify)`;
    return this._py`res_SGDRegressor_densify.tolist() if hasattr(res_SGDRegressor_densify, 'tolist') else res_SGDRegressor_densify`;
  }
  /**
    Fit linear model with Stochastic Gradient Descent.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before fit()");
    }
    await this._py.ex`pms_SGDRegressor_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'coef_init': np.array(${opts["coef_init"] ?? void 0}) if ${opts["coef_init"] !== void 0} else None, 'intercept_init': np.array(${opts["intercept_init"] ?? void 0}) if ${opts["intercept_init"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_fit = {k: v for k, v in pms_SGDRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_fit = bridgeSGDRegressor[${this.id}].fit(**pms_SGDRegressor_fit)`;
    return this._py`res_SGDRegressor_fit.tolist() if hasattr(res_SGDRegressor_fit, 'tolist') else res_SGDRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SGDRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SGDRegressor_get_metadata_routing = {k: v for k, v in pms_SGDRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_get_metadata_routing = bridgeSGDRegressor[${this.id}].get_metadata_routing(**pms_SGDRegressor_get_metadata_routing)`;
    return this._py`res_SGDRegressor_get_metadata_routing.tolist() if hasattr(res_SGDRegressor_get_metadata_routing, 'tolist') else res_SGDRegressor_get_metadata_routing`;
  }
  /**
      Perform one epoch of stochastic gradient descent on given samples.
  
      Internally, this method uses `max\_iter \= 1`. Therefore, it is not guaranteed that a minimum of the cost function is reached after calling it once. Matters such as objective convergence and early stopping should be handled by the user.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before partial_fit()");
    }
    await this._py.ex`pms_SGDRegressor_partial_fit = {'X': ${opts["X"] ?? void 0}, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_partial_fit = {k: v for k, v in pms_SGDRegressor_partial_fit.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_partial_fit = bridgeSGDRegressor[${this.id}].partial_fit(**pms_SGDRegressor_partial_fit)`;
    return this._py`res_SGDRegressor_partial_fit.tolist() if hasattr(res_SGDRegressor_partial_fit, 'tolist') else res_SGDRegressor_partial_fit`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before predict()");
    }
    await this._py.ex`pms_SGDRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_SGDRegressor_predict = {k: v for k, v in pms_SGDRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_predict = bridgeSGDRegressor[${this.id}].predict(**pms_SGDRegressor_predict)`;
    return this._py`res_SGDRegressor_predict.tolist() if hasattr(res_SGDRegressor_predict, 'tolist') else res_SGDRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before score()");
    }
    await this._py.ex`pms_SGDRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SGDRegressor_score = {k: v for k, v in pms_SGDRegressor_score.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_score = bridgeSGDRegressor[${this.id}].score(**pms_SGDRegressor_score)`;
    return this._py`res_SGDRegressor_score.tolist() if hasattr(res_SGDRegressor_score, 'tolist') else res_SGDRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before set_fit_request()");
    }
    await this._py.ex`pms_SGDRegressor_set_fit_request = {'coef_init': ${opts["coef_init"] ?? void 0}, 'intercept_init': ${opts["intercept_init"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_fit_request = {k: v for k, v in pms_SGDRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_fit_request = bridgeSGDRegressor[${this.id}].set_fit_request(**pms_SGDRegressor_set_fit_request)`;
    return this._py`res_SGDRegressor_set_fit_request.tolist() if hasattr(res_SGDRegressor_set_fit_request, 'tolist') else res_SGDRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `partial\_fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_SGDRegressor_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_partial_fit_request = {k: v for k, v in pms_SGDRegressor_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_partial_fit_request = bridgeSGDRegressor[${this.id}].set_partial_fit_request(**pms_SGDRegressor_set_partial_fit_request)`;
    return this._py`res_SGDRegressor_set_partial_fit_request.tolist() if hasattr(res_SGDRegressor_set_partial_fit_request, 'tolist') else res_SGDRegressor_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_SGDRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_SGDRegressor_set_score_request = {k: v for k, v in pms_SGDRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_set_score_request = bridgeSGDRegressor[${this.id}].set_score_request(**pms_SGDRegressor_set_score_request)`;
    return this._py`res_SGDRegressor_set_score_request.tolist() if hasattr(res_SGDRegressor_set_score_request, 'tolist') else res_SGDRegressor_set_score_request`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before sparsify()");
    }
    await this._py.ex`pms_SGDRegressor_sparsify = {}

pms_SGDRegressor_sparsify = {k: v for k, v in pms_SGDRegressor_sparsify.items() if v is not None}`;
    await this._py.ex`res_SGDRegressor_sparsify = bridgeSGDRegressor[${this.id}].sparsify(**pms_SGDRegressor_sparsify)`;
    return this._py`res_SGDRegressor_sparsify.tolist() if hasattr(res_SGDRegressor_sparsify, 'tolist') else res_SGDRegressor_sparsify`;
  }
  /**
    Weights assigned to the features.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_coef_ = bridgeSGDRegressor[${this.id}].coef_`;
      return this._py`attr_SGDRegressor_coef_.tolist() if hasattr(attr_SGDRegressor_coef_, 'tolist') else attr_SGDRegressor_coef_`;
    })();
  }
  /**
    The intercept term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_intercept_ = bridgeSGDRegressor[${this.id}].intercept_`;
      return this._py`attr_SGDRegressor_intercept_.tolist() if hasattr(attr_SGDRegressor_intercept_, 'tolist') else attr_SGDRegressor_intercept_`;
    })();
  }
  /**
    The actual number of iterations before reaching the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_n_iter_ = bridgeSGDRegressor[${this.id}].n_iter_`;
      return this._py`attr_SGDRegressor_n_iter_.tolist() if hasattr(attr_SGDRegressor_n_iter_, 'tolist') else attr_SGDRegressor_n_iter_`;
    })();
  }
  /**
    Number of weight updates performed during training. Same as `(n\_iter\_ \* n\_samples + 1)`.
   */
  get t_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SGDRegressor must call init() before accessing t_");
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_t_ = bridgeSGDRegressor[${this.id}].t_`;
      return this._py`attr_SGDRegressor_t_.tolist() if hasattr(attr_SGDRegressor_t_, 'tolist') else attr_SGDRegressor_t_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_n_features_in_ = bridgeSGDRegressor[${this.id}].n_features_in_`;
      return this._py`attr_SGDRegressor_n_features_in_.tolist() if hasattr(attr_SGDRegressor_n_features_in_, 'tolist') else attr_SGDRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SGDRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SGDRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SGDRegressor_feature_names_in_ = bridgeSGDRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_SGDRegressor_feature_names_in_.tolist() if hasattr(attr_SGDRegressor_feature_names_in_, 'tolist') else attr_SGDRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/TheilSenRegressor.ts
import crypto35 from "node:crypto";
var TheilSenRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TheilSenRegressor${crypto35.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TheilSenRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import TheilSenRegressor
try: bridgeTheilSenRegressor
except NameError: bridgeTheilSenRegressor = {}
`;
    await this._py.ex`ctor_TheilSenRegressor = {'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'max_subpopulation': ${this.opts["max_subpopulation"] ?? void 0}, 'n_subsamples': ${this.opts["n_subsamples"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_TheilSenRegressor = {k: v for k, v in ctor_TheilSenRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTheilSenRegressor[${this.id}] = TheilSenRegressor(**ctor_TheilSenRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTheilSenRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit linear model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before fit()");
    }
    await this._py.ex`pms_TheilSenRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_TheilSenRegressor_fit = {k: v for k, v in pms_TheilSenRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_fit = bridgeTheilSenRegressor[${this.id}].fit(**pms_TheilSenRegressor_fit)`;
    return this._py`res_TheilSenRegressor_fit.tolist() if hasattr(res_TheilSenRegressor_fit, 'tolist') else res_TheilSenRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TheilSenRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TheilSenRegressor_get_metadata_routing = {k: v for k, v in pms_TheilSenRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_get_metadata_routing = bridgeTheilSenRegressor[${this.id}].get_metadata_routing(**pms_TheilSenRegressor_get_metadata_routing)`;
    return this._py`res_TheilSenRegressor_get_metadata_routing.tolist() if hasattr(res_TheilSenRegressor_get_metadata_routing, 'tolist') else res_TheilSenRegressor_get_metadata_routing`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before predict()");
    }
    await this._py.ex`pms_TheilSenRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_TheilSenRegressor_predict = {k: v for k, v in pms_TheilSenRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_predict = bridgeTheilSenRegressor[${this.id}].predict(**pms_TheilSenRegressor_predict)`;
    return this._py`res_TheilSenRegressor_predict.tolist() if hasattr(res_TheilSenRegressor_predict, 'tolist') else res_TheilSenRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TheilSenRegressor must call init() before score()");
    }
    await this._py.ex`pms_TheilSenRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TheilSenRegressor_score = {k: v for k, v in pms_TheilSenRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_score = bridgeTheilSenRegressor[${this.id}].score(**pms_TheilSenRegressor_score)`;
    return this._py`res_TheilSenRegressor_score.tolist() if hasattr(res_TheilSenRegressor_score, 'tolist') else res_TheilSenRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TheilSenRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TheilSenRegressor_set_score_request = {k: v for k, v in pms_TheilSenRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TheilSenRegressor_set_score_request = bridgeTheilSenRegressor[${this.id}].set_score_request(**pms_TheilSenRegressor_set_score_request)`;
    return this._py`res_TheilSenRegressor_set_score_request.tolist() if hasattr(res_TheilSenRegressor_set_score_request, 'tolist') else res_TheilSenRegressor_set_score_request`;
  }
  /**
    Coefficients of the regression model (median of distribution).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_coef_ = bridgeTheilSenRegressor[${this.id}].coef_`;
      return this._py`attr_TheilSenRegressor_coef_.tolist() if hasattr(attr_TheilSenRegressor_coef_, 'tolist') else attr_TheilSenRegressor_coef_`;
    })();
  }
  /**
    Estimated intercept of regression model.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_intercept_ = bridgeTheilSenRegressor[${this.id}].intercept_`;
      return this._py`attr_TheilSenRegressor_intercept_.tolist() if hasattr(attr_TheilSenRegressor_intercept_, 'tolist') else attr_TheilSenRegressor_intercept_`;
    })();
  }
  /**
    Approximated breakdown point.
   */
  get breakdown_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing breakdown_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_breakdown_ = bridgeTheilSenRegressor[${this.id}].breakdown_`;
      return this._py`attr_TheilSenRegressor_breakdown_.tolist() if hasattr(attr_TheilSenRegressor_breakdown_, 'tolist') else attr_TheilSenRegressor_breakdown_`;
    })();
  }
  /**
    Number of iterations needed for the spatial median.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_iter_ = bridgeTheilSenRegressor[${this.id}].n_iter_`;
      return this._py`attr_TheilSenRegressor_n_iter_.tolist() if hasattr(attr_TheilSenRegressor_n_iter_, 'tolist') else attr_TheilSenRegressor_n_iter_`;
    })();
  }
  /**
    Number of combinations taken into account from n choose k, where n is the number of samples and k is the number of subsamples.
   */
  get n_subpopulation_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_subpopulation_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_subpopulation_ = bridgeTheilSenRegressor[${this.id}].n_subpopulation_`;
      return this._py`attr_TheilSenRegressor_n_subpopulation_.tolist() if hasattr(attr_TheilSenRegressor_n_subpopulation_, 'tolist') else attr_TheilSenRegressor_n_subpopulation_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_n_features_in_ = bridgeTheilSenRegressor[${this.id}].n_features_in_`;
      return this._py`attr_TheilSenRegressor_n_features_in_.tolist() if hasattr(attr_TheilSenRegressor_n_features_in_, 'tolist') else attr_TheilSenRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TheilSenRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TheilSenRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TheilSenRegressor_feature_names_in_ = bridgeTheilSenRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TheilSenRegressor_feature_names_in_.tolist() if hasattr(attr_TheilSenRegressor_feature_names_in_, 'tolist') else attr_TheilSenRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/linear_model/TweedieRegressor.ts
import crypto36 from "node:crypto";
var TweedieRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `TweedieRegressor${crypto36.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TweedieRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import TweedieRegressor
try: bridgeTweedieRegressor
except NameError: bridgeTweedieRegressor = {}
`;
    await this._py.ex`ctor_TweedieRegressor = {'power': ${this.opts["power"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'link': ${this.opts["link"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_TweedieRegressor = {k: v for k, v in ctor_TweedieRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTweedieRegressor[${this.id}] = TweedieRegressor(**ctor_TweedieRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTweedieRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit a Generalized Linear Model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before fit()");
    }
    await this._py.ex`pms_TweedieRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TweedieRegressor_fit = {k: v for k, v in pms_TweedieRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_fit = bridgeTweedieRegressor[${this.id}].fit(**pms_TweedieRegressor_fit)`;
    return this._py`res_TweedieRegressor_fit.tolist() if hasattr(res_TweedieRegressor_fit, 'tolist') else res_TweedieRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TweedieRegressor_get_metadata_routing = {k: v for k, v in pms_TweedieRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_get_metadata_routing = bridgeTweedieRegressor[${this.id}].get_metadata_routing(**pms_TweedieRegressor_get_metadata_routing)`;
    return this._py`res_TweedieRegressor_get_metadata_routing.tolist() if hasattr(res_TweedieRegressor_get_metadata_routing, 'tolist') else res_TweedieRegressor_get_metadata_routing`;
  }
  /**
    Predict using GLM with feature matrix X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before predict()");
    }
    await this._py.ex`pms_TweedieRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TweedieRegressor_predict = {k: v for k, v in pms_TweedieRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_predict = bridgeTweedieRegressor[${this.id}].predict(**pms_TweedieRegressor_predict)`;
    return this._py`res_TweedieRegressor_predict.tolist() if hasattr(res_TweedieRegressor_predict, 'tolist') else res_TweedieRegressor_predict`;
  }
  /**
      Compute D^2, the percentage of deviance explained.
  
      D^2 is a generalization of the coefficient of determination R^2. R^2 uses squared error and D^2 uses the deviance of this GLM, see the [User Guide](../model_evaluation.html#regression-metrics).
  
      D^2 is defined as \\(D^2 = 1-\\frac{D(y\_{true},y\_{pred})}{D\_{null}}\\), \\(D\_{null}\\) is the null deviance, i.e. the deviance of a model with intercept alone, which corresponds to \\(y\_{pred} = \\bar{y}\\). The mean \\(\\bar{y}\\) is averaged by sample\_weight. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse).
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("TweedieRegressor must call init() before score()");
    }
    await this._py.ex`pms_TweedieRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TweedieRegressor_score = {k: v for k, v in pms_TweedieRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_score = bridgeTweedieRegressor[${this.id}].score(**pms_TweedieRegressor_score)`;
    return this._py`res_TweedieRegressor_score.tolist() if hasattr(res_TweedieRegressor_score, 'tolist') else res_TweedieRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TweedieRegressor_set_fit_request = {k: v for k, v in pms_TweedieRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_set_fit_request = bridgeTweedieRegressor[${this.id}].set_fit_request(**pms_TweedieRegressor_set_fit_request)`;
    return this._py`res_TweedieRegressor_set_fit_request.tolist() if hasattr(res_TweedieRegressor_set_fit_request, 'tolist') else res_TweedieRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TweedieRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TweedieRegressor_set_score_request = {k: v for k, v in pms_TweedieRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TweedieRegressor_set_score_request = bridgeTweedieRegressor[${this.id}].set_score_request(**pms_TweedieRegressor_set_score_request)`;
    return this._py`res_TweedieRegressor_set_score_request.tolist() if hasattr(res_TweedieRegressor_set_score_request, 'tolist') else res_TweedieRegressor_set_score_request`;
  }
  /**
    Estimated coefficients for the linear predictor (`X @ coef\_ + intercept\_`) in the GLM.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_coef_ = bridgeTweedieRegressor[${this.id}].coef_`;
      return this._py`attr_TweedieRegressor_coef_.tolist() if hasattr(attr_TweedieRegressor_coef_, 'tolist') else attr_TweedieRegressor_coef_`;
    })();
  }
  /**
    Intercept (a.k.a. bias) added to linear predictor.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_intercept_ = bridgeTweedieRegressor[${this.id}].intercept_`;
      return this._py`attr_TweedieRegressor_intercept_.tolist() if hasattr(attr_TweedieRegressor_intercept_, 'tolist') else attr_TweedieRegressor_intercept_`;
    })();
  }
  /**
    Actual number of iterations used in the solver.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_n_iter_ = bridgeTweedieRegressor[${this.id}].n_iter_`;
      return this._py`attr_TweedieRegressor_n_iter_.tolist() if hasattr(attr_TweedieRegressor_n_iter_, 'tolist') else attr_TweedieRegressor_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_n_features_in_ = bridgeTweedieRegressor[${this.id}].n_features_in_`;
      return this._py`attr_TweedieRegressor_n_features_in_.tolist() if hasattr(attr_TweedieRegressor_n_features_in_, 'tolist') else attr_TweedieRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TweedieRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TweedieRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TweedieRegressor_feature_names_in_ = bridgeTweedieRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TweedieRegressor_feature_names_in_.tolist() if hasattr(attr_TweedieRegressor_feature_names_in_, 'tolist') else attr_TweedieRegressor_feature_names_in_`;
    })();
  }
};
export {
  ARDRegression,
  BayesianRidge,
  ElasticNet,
  ElasticNetCV,
  GammaRegressor,
  HuberRegressor,
  Lars,
  LarsCV,
  Lasso,
  LassoCV,
  LassoLars,
  LassoLarsCV,
  LassoLarsIC,
  LinearRegression,
  LogisticRegression,
  LogisticRegressionCV,
  MultiTaskElasticNet,
  MultiTaskElasticNetCV,
  MultiTaskLasso,
  MultiTaskLassoCV,
  OrthogonalMatchingPursuit,
  OrthogonalMatchingPursuitCV,
  PassiveAggressiveClassifier,
  Perceptron,
  PoissonRegressor,
  QuantileRegressor,
  RANSACRegressor,
  Ridge,
  RidgeCV,
  RidgeClassifier,
  RidgeClassifierCV,
  SGDClassifier,
  SGDOneClassSVM,
  SGDRegressor,
  TheilSenRegressor,
  TweedieRegressor
};
//# sourceMappingURL=index.js.map