import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  RANSAC (RANdom SAmple Consensus) algorithm.

  RANSAC is an iterative algorithm for the robust estimation of parameters from a subset of inliers from the complete data set.

  Read more in the [User Guide](../linear_model.html#ransac-regression).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RANSACRegressor.html)
 */
export declare class RANSACRegressor {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          Base estimator object which implements the following methods:
         */
        estimator?: any;
        /**
          Minimum number of samples chosen randomly from original data. Treated as an absolute number of samples for `min\_samples >= 1`, treated as a relative number `ceil(min\_samples \* X.shape\[0\])` for `min\_samples < 1`. This is typically chosen as the minimal number of samples necessary to estimate the given `estimator`. By default a [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression "sklearn.linear_model.LinearRegression") estimator is assumed and `min\_samples` is chosen as `X.shape\[1\] + 1`. This parameter is highly dependent upon the model, so if a `estimator` other than [`LinearRegression`](sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression "sklearn.linear_model.LinearRegression") is used, the user must provide a value.
         */
        min_samples?: number;
        /**
          Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values `y`. Points whose residuals are strictly equal to the threshold are considered as inliers.
         */
        residual_threshold?: number;
        /**
          This function is called with the randomly selected data before the model is fitted to it: `is\_data\_valid(X, y)`. If its return value is `false` the current randomly chosen sub-sample is skipped.
         */
        is_data_valid?: any;
        /**
          This function is called with the estimated model and the randomly selected data: `is\_model\_valid(model, X, y)`. If its return value is `false` the current randomly chosen sub-sample is skipped. Rejecting samples with this function is computationally costlier than with `is\_data\_valid`. `is\_model\_valid` should therefore only be used if the estimated model is needed for making the rejection decision.
         */
        is_model_valid?: any;
        /**
          Maximum number of iterations for random sample selection.
    
          @defaultValue `100`
         */
        max_trials?: number;
        /**
          Maximum number of iterations that can be skipped due to finding zero inliers or invalid data defined by `is\_data\_valid` or invalid models defined by `is\_model\_valid`.
         */
        max_skips?: number;
        /**
          Stop iteration if at least this number of inliers are found.
         */
        stop_n_inliers?: number;
        /**
          Stop iteration if score is greater equal than this threshold.
         */
        stop_score?: number;
        /**
          RANSAC iteration stops if at least one outlier-free set of the training data is sampled in RANSAC. This requires to generate at least N samples (iterations):
    
          @defaultValue `0.99`
         */
        stop_probability?: number;
        /**
          String inputs, ‘absolute\_error’ and ‘squared\_error’ are supported which find the absolute error and squared error per sample respectively.
    
          If `loss` is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on `X\[i\]`.
    
          If the loss on a sample is greater than the `residual\_threshold`, then this sample is classified as an outlier.
    
          @defaultValue `'absolute_error'`
         */
        loss?: string;
        /**
          The generator used to initialize the centers. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit estimator using RANSAC algorithm.
     */
    fit(opts: {
        /**
          Training data.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Target values.
         */
        y?: ArrayLike;
        /**
          Individual weights for each sample raises error if sample\_weight is passed and estimator fit method does not support it.
         */
        sample_weight?: ArrayLike;
    }): Promise<any>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Predict using the estimated model.
  
      This is a wrapper for `estimator\_.predict(X)`.
     */
    predict(opts: {
        /**
          Input data.
         */
        X?: any[];
    }): Promise<any>;
    /**
      Return the score of the prediction.
  
      This is a wrapper for `estimator\_.score(X, y)`.
     */
    score(opts: {
        /**
          Training data.
         */
        X?: any[];
        /**
          Target values.
         */
        y?: ArrayLike;
    }): Promise<number>;
    /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
    set_fit_request(opts: {
        /**
          Metadata routing for `sample\_weight` parameter in `fit`.
         */
        sample_weight?: string | boolean;
    }): Promise<any>;
    /**
      Best fitted model (copy of the `estimator` object).
     */
    get estimator_(): Promise<any>;
    /**
      Number of random selection trials until one of the stop criteria is met. It is always `<= max\_trials`.
     */
    get n_trials_(): Promise<number>;
    /**
      Boolean mask of inliers classified as `true`.
     */
    get inlier_mask_(): Promise<any>;
    /**
      Number of iterations skipped due to finding zero inliers.
     */
    get n_skips_no_inliers_(): Promise<number>;
    /**
      Number of iterations skipped due to invalid data defined by `is\_data\_valid`.
     */
    get n_skips_invalid_data_(): Promise<number>;
    /**
      Number of iterations skipped due to an invalid model defined by `is\_model\_valid`.
     */
    get n_skips_invalid_model_(): Promise<number>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=RANSACRegressor.d.ts.map