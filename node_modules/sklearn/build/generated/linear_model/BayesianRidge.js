// src/generated/linear_model/BayesianRidge.ts
import crypto from "node:crypto";
var BayesianRidge = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BayesianRidge${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BayesianRidge.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.linear_model import BayesianRidge
try: bridgeBayesianRidge
except NameError: bridgeBayesianRidge = {}
`;
    await this._py.ex`ctor_BayesianRidge = {'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'alpha_1': ${this.opts["alpha_1"] ?? void 0}, 'alpha_2': ${this.opts["alpha_2"] ?? void 0}, 'lambda_1': ${this.opts["lambda_1"] ?? void 0}, 'lambda_2': ${this.opts["lambda_2"] ?? void 0}, 'alpha_init': ${this.opts["alpha_init"] ?? void 0}, 'lambda_init': ${this.opts["lambda_init"] ?? void 0}, 'compute_score': ${this.opts["compute_score"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}}

ctor_BayesianRidge = {k: v for k, v in ctor_BayesianRidge.items() if v is not None}`;
    await this._py.ex`bridgeBayesianRidge[${this.id}] = BayesianRidge(**ctor_BayesianRidge)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBayesianRidge[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before fit()");
    }
    await this._py.ex`pms_BayesianRidge_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_fit = {k: v for k, v in pms_BayesianRidge_fit.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_fit = bridgeBayesianRidge[${this.id}].fit(**pms_BayesianRidge_fit)`;
    return this._py`res_BayesianRidge_fit.tolist() if hasattr(res_BayesianRidge_fit, 'tolist') else res_BayesianRidge_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BayesianRidge_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BayesianRidge_get_metadata_routing = {k: v for k, v in pms_BayesianRidge_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_get_metadata_routing = bridgeBayesianRidge[${this.id}].get_metadata_routing(**pms_BayesianRidge_get_metadata_routing)`;
    return this._py`res_BayesianRidge_get_metadata_routing.tolist() if hasattr(res_BayesianRidge_get_metadata_routing, 'tolist') else res_BayesianRidge_get_metadata_routing`;
  }
  /**
      Predict using the linear model.
  
      In addition to the mean of the predictive distribution, also its standard deviation can be returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before predict()");
    }
    await this._py.ex`pms_BayesianRidge_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_predict = {k: v for k, v in pms_BayesianRidge_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_predict = bridgeBayesianRidge[${this.id}].predict(**pms_BayesianRidge_predict)`;
    return this._py`res_BayesianRidge_predict.tolist() if hasattr(res_BayesianRidge_predict, 'tolist') else res_BayesianRidge_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before score()");
    }
    await this._py.ex`pms_BayesianRidge_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BayesianRidge_score = {k: v for k, v in pms_BayesianRidge_score.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_score = bridgeBayesianRidge[${this.id}].score(**pms_BayesianRidge_score)`;
    return this._py`res_BayesianRidge_score.tolist() if hasattr(res_BayesianRidge_score, 'tolist') else res_BayesianRidge_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before set_fit_request()");
    }
    await this._py.ex`pms_BayesianRidge_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_fit_request = {k: v for k, v in pms_BayesianRidge_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_fit_request = bridgeBayesianRidge[${this.id}].set_fit_request(**pms_BayesianRidge_set_fit_request)`;
    return this._py`res_BayesianRidge_set_fit_request.tolist() if hasattr(res_BayesianRidge_set_fit_request, 'tolist') else res_BayesianRidge_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_BayesianRidge_set_predict_request = {k: v for k, v in pms_BayesianRidge_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_predict_request = bridgeBayesianRidge[${this.id}].set_predict_request(**pms_BayesianRidge_set_predict_request)`;
    return this._py`res_BayesianRidge_set_predict_request.tolist() if hasattr(res_BayesianRidge_set_predict_request, 'tolist') else res_BayesianRidge_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable\_metadata\_routing=True` (see [`sklearn.set\_config`](sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BayesianRidge_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BayesianRidge_set_score_request = {k: v for k, v in pms_BayesianRidge_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BayesianRidge_set_score_request = bridgeBayesianRidge[${this.id}].set_score_request(**pms_BayesianRidge_set_score_request)`;
    return this._py`res_BayesianRidge_set_score_request.tolist() if hasattr(res_BayesianRidge_set_score_request, 'tolist') else res_BayesianRidge_set_score_request`;
  }
  /**
    Coefficients of the regression model (mean of distribution)
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_coef_ = bridgeBayesianRidge[${this.id}].coef_`;
      return this._py`attr_BayesianRidge_coef_.tolist() if hasattr(attr_BayesianRidge_coef_, 'tolist') else attr_BayesianRidge_coef_`;
    })();
  }
  /**
    Independent term in decision function. Set to 0.0 if `fit\_intercept \= False`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_intercept_ = bridgeBayesianRidge[${this.id}].intercept_`;
      return this._py`attr_BayesianRidge_intercept_.tolist() if hasattr(attr_BayesianRidge_intercept_, 'tolist') else attr_BayesianRidge_intercept_`;
    })();
  }
  /**
    Estimated precision of the noise.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing alpha_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_alpha_ = bridgeBayesianRidge[${this.id}].alpha_`;
      return this._py`attr_BayesianRidge_alpha_.tolist() if hasattr(attr_BayesianRidge_alpha_, 'tolist') else attr_BayesianRidge_alpha_`;
    })();
  }
  /**
    Estimated precision of the weights.
   */
  get lambda_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing lambda_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_lambda_ = bridgeBayesianRidge[${this.id}].lambda_`;
      return this._py`attr_BayesianRidge_lambda_.tolist() if hasattr(attr_BayesianRidge_lambda_, 'tolist') else attr_BayesianRidge_lambda_`;
    })();
  }
  /**
    Estimated variance-covariance matrix of the weights
   */
  get sigma_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing sigma_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_sigma_ = bridgeBayesianRidge[${this.id}].sigma_`;
      return this._py`attr_BayesianRidge_sigma_.tolist() if hasattr(attr_BayesianRidge_sigma_, 'tolist') else attr_BayesianRidge_sigma_`;
    })();
  }
  /**
    If computed\_score is `true`, value of the log marginal likelihood (to be maximized) at each iteration of the optimization. The array starts with the value of the log marginal likelihood obtained for the initial values of alpha and lambda and ends with the value obtained for the estimated alpha and lambda.
   */
  get scores_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing scores_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_scores_ = bridgeBayesianRidge[${this.id}].scores_`;
      return this._py`attr_BayesianRidge_scores_.tolist() if hasattr(attr_BayesianRidge_scores_, 'tolist') else attr_BayesianRidge_scores_`;
    })();
  }
  /**
    The actual number of iterations to reach the stopping criterion.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BayesianRidge must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_iter_ = bridgeBayesianRidge[${this.id}].n_iter_`;
      return this._py`attr_BayesianRidge_n_iter_.tolist() if hasattr(attr_BayesianRidge_n_iter_, 'tolist') else attr_BayesianRidge_n_iter_`;
    })();
  }
  /**
    If `fit\_intercept=True`, offset subtracted for centering data to a zero mean. Set to np.zeros(n\_features) otherwise.
   */
  get X_offset_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_offset_ = bridgeBayesianRidge[${this.id}].X_offset_`;
      return this._py`attr_BayesianRidge_X_offset_.tolist() if hasattr(attr_BayesianRidge_X_offset_, 'tolist') else attr_BayesianRidge_X_offset_`;
    })();
  }
  /**
    Set to np.ones(n\_features).
   */
  get X_scale_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing X_scale_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_X_scale_ = bridgeBayesianRidge[${this.id}].X_scale_`;
      return this._py`attr_BayesianRidge_X_scale_.tolist() if hasattr(attr_BayesianRidge_X_scale_, 'tolist') else attr_BayesianRidge_X_scale_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_n_features_in_ = bridgeBayesianRidge[${this.id}].n_features_in_`;
      return this._py`attr_BayesianRidge_n_features_in_.tolist() if hasattr(attr_BayesianRidge_n_features_in_, 'tolist') else attr_BayesianRidge_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BayesianRidge instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianRidge must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianRidge_feature_names_in_ = bridgeBayesianRidge[${this.id}].feature_names_in_`;
      return this._py`attr_BayesianRidge_feature_names_in_.tolist() if hasattr(attr_BayesianRidge_feature_names_in_, 'tolist') else attr_BayesianRidge_feature_names_in_`;
    })();
  }
};
export {
  BayesianRidge
};
//# sourceMappingURL=BayesianRidge.js.map