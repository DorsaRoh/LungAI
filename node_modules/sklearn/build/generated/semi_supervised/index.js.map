{"version":3,"sources":["../../../src/generated/semi_supervised/LabelPropagation.ts","../../../src/generated/semi_supervised/LabelSpreading.ts","../../../src/generated/semi_supervised/SelfTrainingClassifier.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Label Propagation classifier.\n\n  Read more in the [User Guide](../semi_supervised.html#label-propagation).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelPropagation.html)\n */\nexport class LabelPropagation {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n\\_samples, n\\_features), and return a (n\\_samples, n\\_samples) shaped weight matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'knn' | 'rbf'\n\n    /**\n      Parameter for rbf kernel.\n\n      @defaultValue `20`\n     */\n    gamma?: number\n\n    /**\n      Parameter for knn kernel which need to be strictly positive.\n\n      @defaultValue `7`\n     */\n    n_neighbors?: number\n\n    /**\n      Change maximum number of iterations allowed.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      Convergence tolerance: threshold to consider the system at steady state.\n     */\n    tol?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `LabelPropagation${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelPropagation.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import LabelPropagation\ntry: bridgeLabelPropagation\nexcept NameError: bridgeLabelPropagation = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelPropagation = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_LabelPropagation = {k: v for k, v in ctor_LabelPropagation.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelPropagation[${this.id}] = LabelPropagation(**ctor_LabelPropagation)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelPropagation[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a semi-supervised label propagation model to X.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in `transduction\\_`.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelPropagation_fit = {k: v for k, v in pms_LabelPropagation_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_fit = bridgeLabelPropagation[${this.id}].fit(**pms_LabelPropagation_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_fit.tolist() if hasattr(res_LabelPropagation_fit, 'tolist') else res_LabelPropagation_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LabelPropagation_get_metadata_routing = {k: v for k, v in pms_LabelPropagation_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_get_metadata_routing = bridgeLabelPropagation[${this.id}].get_metadata_routing(**pms_LabelPropagation_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_get_metadata_routing.tolist() if hasattr(res_LabelPropagation_get_metadata_routing, 'tolist') else res_LabelPropagation_get_metadata_routing`\n  }\n\n  /**\n    Perform inductive inference across the model.\n   */\n  async predict(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict = {k: v for k, v in pms_LabelPropagation_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict = bridgeLabelPropagation[${this.id}].predict(**pms_LabelPropagation_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict.tolist() if hasattr(res_LabelPropagation_predict, 'tolist') else res_LabelPropagation_predict`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n\n    Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).\n   */\n  async predict_proba(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict_proba = {k: v for k, v in pms_LabelPropagation_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict_proba = bridgeLabelPropagation[${this.id}].predict_proba(**pms_LabelPropagation_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict_proba.tolist() if hasattr(res_LabelPropagation_predict_proba, 'tolist') else res_LabelPropagation_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LabelPropagation_score = {k: v for k, v in pms_LabelPropagation_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_score = bridgeLabelPropagation[${this.id}].score(**pms_LabelPropagation_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_score.tolist() if hasattr(res_LabelPropagation_score, 'tolist') else res_LabelPropagation_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LabelPropagation_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LabelPropagation_set_score_request = {k: v for k, v in pms_LabelPropagation_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_set_score_request = bridgeLabelPropagation[${this.id}].set_score_request(**pms_LabelPropagation_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_set_score_request.tolist() if hasattr(res_LabelPropagation_set_score_request, 'tolist') else res_LabelPropagation_set_score_request`\n  }\n\n  /**\n    Input array.\n   */\n  get X_(): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before accessing X_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_X_ = bridgeLabelPropagation[${this.id}].X_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_X_.tolist() if hasattr(attr_LabelPropagation_X_, 'tolist') else attr_LabelPropagation_X_`\n    })()\n  }\n\n  /**\n    The distinct labels used in classifying instances.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_classes_ = bridgeLabelPropagation[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_classes_.tolist() if hasattr(attr_LabelPropagation_classes_, 'tolist') else attr_LabelPropagation_classes_`\n    })()\n  }\n\n  /**\n    Categorical distribution for each item.\n   */\n  get label_distributions_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing label_distributions_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_label_distributions_ = bridgeLabelPropagation[${this.id}].label_distributions_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_label_distributions_.tolist() if hasattr(attr_LabelPropagation_label_distributions_, 'tolist') else attr_LabelPropagation_label_distributions_`\n    })()\n  }\n\n  /**\n    Label assigned to each item during [fit](../../glossary.html#term-fit).\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_transduction_ = bridgeLabelPropagation[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_transduction_.tolist() if hasattr(attr_LabelPropagation_transduction_, 'tolist') else attr_LabelPropagation_transduction_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_features_in_ = bridgeLabelPropagation[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_features_in_.tolist() if hasattr(attr_LabelPropagation_n_features_in_, 'tolist') else attr_LabelPropagation_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_feature_names_in_ = bridgeLabelPropagation[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_feature_names_in_.tolist() if hasattr(attr_LabelPropagation_feature_names_in_, 'tolist') else attr_LabelPropagation_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_iter_ = bridgeLabelPropagation[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_iter_.tolist() if hasattr(attr_LabelPropagation_n_iter_, 'tolist') else attr_LabelPropagation_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  LabelSpreading model for semi-supervised learning.\n\n  This model is similar to the basic Label Propagation algorithm, but uses affinity matrix based on the normalized graph Laplacian and soft clamping across the labels.\n\n  Read more in the [User Guide](../semi_supervised.html#label-propagation).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelSpreading.html)\n */\nexport class LabelSpreading {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n\\_samples, n\\_features), and return a (n\\_samples, n\\_samples) shaped weight matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'knn' | 'rbf'\n\n    /**\n      Parameter for rbf kernel.\n\n      @defaultValue `20`\n     */\n    gamma?: number\n\n    /**\n      Parameter for knn kernel which is a strictly positive integer.\n\n      @defaultValue `7`\n     */\n    n_neighbors?: number\n\n    /**\n      Clamping factor. A value in (0, 1) that specifies the relative amount that an instance should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.\n\n      @defaultValue `0.2`\n     */\n    alpha?: number\n\n    /**\n      Maximum number of iterations allowed.\n\n      @defaultValue `30`\n     */\n    max_iter?: number\n\n    /**\n      Convergence tolerance: threshold to consider the system at steady state.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.4.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `LabelSpreading${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelSpreading.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import LabelSpreading\ntry: bridgeLabelSpreading\nexcept NameError: bridgeLabelSpreading = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelSpreading = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }}\n\nctor_LabelSpreading = {k: v for k, v in ctor_LabelSpreading.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelSpreading[${this.id}] = LabelSpreading(**ctor_LabelSpreading)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelSpreading[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a semi-supervised label propagation model to X.\n\n    The input samples (labeled and unlabeled) are provided by matrix X, and target labels are provided by matrix y. We conventionally apply the label -1 to unlabeled samples in matrix y in a semi-supervised classification.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in `transduction\\_`.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelSpreading_fit = {k: v for k, v in pms_LabelSpreading_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_fit = bridgeLabelSpreading[${this.id}].fit(**pms_LabelSpreading_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_fit.tolist() if hasattr(res_LabelSpreading_fit, 'tolist') else res_LabelSpreading_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_LabelSpreading_get_metadata_routing = {k: v for k, v in pms_LabelSpreading_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_get_metadata_routing = bridgeLabelSpreading[${this.id}].get_metadata_routing(**pms_LabelSpreading_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_get_metadata_routing.tolist() if hasattr(res_LabelSpreading_get_metadata_routing, 'tolist') else res_LabelSpreading_get_metadata_routing`\n  }\n\n  /**\n    Perform inductive inference across the model.\n   */\n  async predict(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelSpreading_predict = {k: v for k, v in pms_LabelSpreading_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_predict = bridgeLabelSpreading[${this.id}].predict(**pms_LabelSpreading_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_predict.tolist() if hasattr(res_LabelSpreading_predict, 'tolist') else res_LabelSpreading_predict`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n\n    Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).\n   */\n  async predict_proba(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelSpreading_predict_proba = {k: v for k, v in pms_LabelSpreading_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_predict_proba = bridgeLabelSpreading[${this.id}].predict_proba(**pms_LabelSpreading_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_predict_proba.tolist() if hasattr(res_LabelSpreading_predict_proba, 'tolist') else res_LabelSpreading_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelSpreading_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LabelSpreading_score = {k: v for k, v in pms_LabelSpreading_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_score = bridgeLabelSpreading[${this.id}].score(**pms_LabelSpreading_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_score.tolist() if hasattr(res_LabelSpreading_score, 'tolist') else res_LabelSpreading_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable\\_metadata\\_routing=True` (see [`sklearn.set\\_config`](sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample\\_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_LabelSpreading_set_score_request = {'sample_weight': ${\n      opts['sample_weight'] ?? undefined\n    }}\n\npms_LabelSpreading_set_score_request = {k: v for k, v in pms_LabelSpreading_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelSpreading_set_score_request = bridgeLabelSpreading[${this.id}].set_score_request(**pms_LabelSpreading_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelSpreading_set_score_request.tolist() if hasattr(res_LabelSpreading_set_score_request, 'tolist') else res_LabelSpreading_set_score_request`\n  }\n\n  /**\n    Input array.\n   */\n  get X_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelSpreading must call init() before accessing X_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_X_ = bridgeLabelSpreading[${this.id}].X_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_X_.tolist() if hasattr(attr_LabelSpreading_X_, 'tolist') else attr_LabelSpreading_X_`\n    })()\n  }\n\n  /**\n    The distinct labels used in classifying instances.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_classes_ = bridgeLabelSpreading[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_classes_.tolist() if hasattr(attr_LabelSpreading_classes_, 'tolist') else attr_LabelSpreading_classes_`\n    })()\n  }\n\n  /**\n    Categorical distribution for each item.\n   */\n  get label_distributions_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing label_distributions_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_label_distributions_ = bridgeLabelSpreading[${this.id}].label_distributions_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_label_distributions_.tolist() if hasattr(attr_LabelSpreading_label_distributions_, 'tolist') else attr_LabelSpreading_label_distributions_`\n    })()\n  }\n\n  /**\n    Label assigned to each item during [fit](../../glossary.html#term-fit).\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_transduction_ = bridgeLabelSpreading[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_transduction_.tolist() if hasattr(attr_LabelSpreading_transduction_, 'tolist') else attr_LabelSpreading_transduction_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_n_features_in_ = bridgeLabelSpreading[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_n_features_in_.tolist() if hasattr(attr_LabelSpreading_n_features_in_, 'tolist') else attr_LabelSpreading_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_feature_names_in_ = bridgeLabelSpreading[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_feature_names_in_.tolist() if hasattr(attr_LabelSpreading_feature_names_in_, 'tolist') else attr_LabelSpreading_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This LabelSpreading instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelSpreading must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelSpreading_n_iter_ = bridgeLabelSpreading[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelSpreading_n_iter_.tolist() if hasattr(attr_LabelSpreading_n_iter_, 'tolist') else attr_LabelSpreading_n_iter_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Self-training classifier.\n\n  This [metaestimator](../../glossary.html#term-metaestimator) allows a given supervised classifier to function as a semi-supervised classifier, allowing it to learn from unlabeled data. It does this by iteratively predicting pseudo-labels for the unlabeled data and adding them to the training set.\n\n  The classifier will continue iterating until either max\\_iter is reached, or no pseudo-labels were added to the training set in the previous iteration.\n\n  Read more in the [User Guide](../semi_supervised.html#self-training).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.SelfTrainingClassifier.html)\n */\nexport class SelfTrainingClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An estimator object implementing `fit` and `predict\\_proba`. Invoking the `fit` method will fit a clone of the passed estimator, which will be stored in the `base\\_estimator\\_` attribute.\n     */\n    base_estimator?: any\n\n    /**\n      The decision threshold for use with `criterion='threshold'`. Should be in \\[0, 1). When using the `'threshold'` criterion, a [well calibrated classifier](../calibration.html#calibration) should be used.\n\n      @defaultValue `0.75`\n     */\n    threshold?: number\n\n    /**\n      The selection criterion used to select which labels to add to the training set. If `'threshold'`, pseudo-labels with prediction probabilities above `threshold` are added to the dataset. If `'k\\_best'`, the `k\\_best` pseudo-labels with highest prediction probabilities are added to the dataset. When using the ‘threshold’ criterion, a [well calibrated classifier](../calibration.html#calibration) should be used.\n\n      @defaultValue `'threshold'`\n     */\n    criterion?: 'threshold' | 'k_best'\n\n    /**\n      The amount of samples to add in each iteration. Only used when `criterion='k\\_best'`.\n\n      @defaultValue `10`\n     */\n    k_best?: number\n\n    /**\n      Maximum number of iterations allowed. Should be greater than or equal to 0. If it is `undefined`, the classifier will continue to predict labels until no new pseudo-labels are added, or all unlabeled samples have been labeled.\n\n      @defaultValue `10`\n     */\n    max_iter?: number\n\n    /**\n      Enable verbose output.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `SelfTrainingClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SelfTrainingClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import SelfTrainingClassifier\ntry: bridgeSelfTrainingClassifier\nexcept NameError: bridgeSelfTrainingClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelfTrainingClassifier = {'base_estimator': ${\n      this.opts['base_estimator'] ?? undefined\n    }, 'threshold': ${this.opts['threshold'] ?? undefined}, 'criterion': ${\n      this.opts['criterion'] ?? undefined\n    }, 'k_best': ${this.opts['k_best'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}}\n\nctor_SelfTrainingClassifier = {k: v for k, v in ctor_SelfTrainingClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelfTrainingClassifier[${this.id}] = SelfTrainingClassifier(**ctor_SelfTrainingClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelfTrainingClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Call decision function of the `base\\_estimator`.\n   */\n  async decision_function(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_decision_function = {k: v for k, v in pms_SelfTrainingClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_decision_function = bridgeSelfTrainingClassifier[${this.id}].decision_function(**pms_SelfTrainingClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_decision_function.tolist() if hasattr(res_SelfTrainingClassifier_decision_function, 'tolist') else res_SelfTrainingClassifier_decision_function`\n  }\n\n  /**\n    Fit self-training classifier using `X`, `y` as training data.\n   */\n  async fit(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Array representing the labels. Unlabeled samples should have the label -1.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_fit = {k: v for k, v in pms_SelfTrainingClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_fit = bridgeSelfTrainingClassifier[${this.id}].fit(**pms_SelfTrainingClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_fit.tolist() if hasattr(res_SelfTrainingClassifier_fit, 'tolist') else res_SelfTrainingClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelfTrainingClassifier_get_metadata_routing = {k: v for k, v in pms_SelfTrainingClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_get_metadata_routing = bridgeSelfTrainingClassifier[${this.id}].get_metadata_routing(**pms_SelfTrainingClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_get_metadata_routing.tolist() if hasattr(res_SelfTrainingClassifier_get_metadata_routing, 'tolist') else res_SelfTrainingClassifier_get_metadata_routing`\n  }\n\n  /**\n    Predict the classes of `X`.\n   */\n  async predict(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict = {k: v for k, v in pms_SelfTrainingClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict = bridgeSelfTrainingClassifier[${this.id}].predict(**pms_SelfTrainingClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict.tolist() if hasattr(res_SelfTrainingClassifier_predict, 'tolist') else res_SelfTrainingClassifier_predict`\n  }\n\n  /**\n    Predict log probability for each possible outcome.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_log_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_log_proba = bridgeSelfTrainingClassifier[${this.id}].predict_log_proba(**pms_SelfTrainingClassifier_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_log_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_log_proba, 'tolist') else res_SelfTrainingClassifier_predict_log_proba`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n   */\n  async predict_proba(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_proba = bridgeSelfTrainingClassifier[${this.id}].predict_proba(**pms_SelfTrainingClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_proba, 'tolist') else res_SelfTrainingClassifier_predict_proba`\n  }\n\n  /**\n    Call score on the `base\\_estimator`.\n   */\n  async score(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Array representing the labels.\n     */\n    y?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_score = {k: v for k, v in pms_SelfTrainingClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_score = bridgeSelfTrainingClassifier[${this.id}].score(**pms_SelfTrainingClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_score.tolist() if hasattr(res_SelfTrainingClassifier_score, 'tolist') else res_SelfTrainingClassifier_score`\n  }\n\n  /**\n    The fitted estimator.\n   */\n  get base_estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing base_estimator_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_base_estimator_ = bridgeSelfTrainingClassifier[${this.id}].base_estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_base_estimator_.tolist() if hasattr(attr_SelfTrainingClassifier_base_estimator_, 'tolist') else attr_SelfTrainingClassifier_base_estimator_`\n    })()\n  }\n\n  /**\n    Class labels for each output. (Taken from the trained `base\\_estimator\\_`).\n   */\n  get classes_(): Promise<NDArray | any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_classes_ = bridgeSelfTrainingClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_classes_.tolist() if hasattr(attr_SelfTrainingClassifier_classes_, 'tolist') else attr_SelfTrainingClassifier_classes_`\n    })()\n  }\n\n  /**\n    The labels used for the final fit of the classifier, including pseudo-labels added during fit.\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_transduction_ = bridgeSelfTrainingClassifier[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_transduction_.tolist() if hasattr(attr_SelfTrainingClassifier_transduction_, 'tolist') else attr_SelfTrainingClassifier_transduction_`\n    })()\n  }\n\n  /**\n    The iteration in which each sample was labeled. When a sample has iteration 0, the sample was already labeled in the original dataset. When a sample has iteration -1, the sample was not labeled in any iteration.\n   */\n  get labeled_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing labeled_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_labeled_iter_ = bridgeSelfTrainingClassifier[${this.id}].labeled_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_labeled_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_labeled_iter_, 'tolist') else attr_SelfTrainingClassifier_labeled_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_features_in_ = bridgeSelfTrainingClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_features_in_.tolist() if hasattr(attr_SelfTrainingClassifier_n_features_in_, 'tolist') else attr_SelfTrainingClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_feature_names_in_ = bridgeSelfTrainingClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_feature_names_in_.tolist() if hasattr(attr_SelfTrainingClassifier_feature_names_in_, 'tolist') else attr_SelfTrainingClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of rounds of self-training, that is the number of times the base estimator is fitted on relabeled variants of the training set.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_iter_ = bridgeSelfTrainingClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_n_iter_, 'tolist') else attr_SelfTrainingClassifier_n_iter_`\n    })()\n  }\n\n  /**\n    The reason that fitting was stopped.\n   */\n  get termination_condition_(): Promise<\n    'max_iter' | 'no_change' | 'all_labeled'\n  > {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing termination_condition_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_termination_condition_ = bridgeSelfTrainingClassifier[${this.id}].termination_condition_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_termination_condition_.tolist() if hasattr(attr_SelfTrainingClassifier_termination_condition_, 'tolist') else attr_SelfTrainingClassifier_termination_condition_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto","crypto"]}