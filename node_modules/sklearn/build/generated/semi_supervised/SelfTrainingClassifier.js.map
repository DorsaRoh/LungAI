{"version":3,"sources":["../../../src/generated/semi_supervised/SelfTrainingClassifier.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Self-training classifier.\n\n  This [metaestimator](../../glossary.html#term-metaestimator) allows a given supervised classifier to function as a semi-supervised classifier, allowing it to learn from unlabeled data. It does this by iteratively predicting pseudo-labels for the unlabeled data and adding them to the training set.\n\n  The classifier will continue iterating until either max\\_iter is reached, or no pseudo-labels were added to the training set in the previous iteration.\n\n  Read more in the [User Guide](../semi_supervised.html#self-training).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.SelfTrainingClassifier.html)\n */\nexport class SelfTrainingClassifier {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An estimator object implementing `fit` and `predict\\_proba`. Invoking the `fit` method will fit a clone of the passed estimator, which will be stored in the `base\\_estimator\\_` attribute.\n     */\n    base_estimator?: any\n\n    /**\n      The decision threshold for use with `criterion='threshold'`. Should be in \\[0, 1). When using the `'threshold'` criterion, a [well calibrated classifier](../calibration.html#calibration) should be used.\n\n      @defaultValue `0.75`\n     */\n    threshold?: number\n\n    /**\n      The selection criterion used to select which labels to add to the training set. If `'threshold'`, pseudo-labels with prediction probabilities above `threshold` are added to the dataset. If `'k\\_best'`, the `k\\_best` pseudo-labels with highest prediction probabilities are added to the dataset. When using the ‘threshold’ criterion, a [well calibrated classifier](../calibration.html#calibration) should be used.\n\n      @defaultValue `'threshold'`\n     */\n    criterion?: 'threshold' | 'k_best'\n\n    /**\n      The amount of samples to add in each iteration. Only used when `criterion='k\\_best'`.\n\n      @defaultValue `10`\n     */\n    k_best?: number\n\n    /**\n      Maximum number of iterations allowed. Should be greater than or equal to 0. If it is `undefined`, the classifier will continue to predict labels until no new pseudo-labels are added, or all unlabeled samples have been labeled.\n\n      @defaultValue `10`\n     */\n    max_iter?: number\n\n    /**\n      Enable verbose output.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `SelfTrainingClassifier${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SelfTrainingClassifier.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import SelfTrainingClassifier\ntry: bridgeSelfTrainingClassifier\nexcept NameError: bridgeSelfTrainingClassifier = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SelfTrainingClassifier = {'base_estimator': ${\n      this.opts['base_estimator'] ?? undefined\n    }, 'threshold': ${this.opts['threshold'] ?? undefined}, 'criterion': ${\n      this.opts['criterion'] ?? undefined\n    }, 'k_best': ${this.opts['k_best'] ?? undefined}, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}}\n\nctor_SelfTrainingClassifier = {k: v for k, v in ctor_SelfTrainingClassifier.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSelfTrainingClassifier[${this.id}] = SelfTrainingClassifier(**ctor_SelfTrainingClassifier)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSelfTrainingClassifier[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Call decision function of the `base\\_estimator`.\n   */\n  async decision_function(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_decision_function = {k: v for k, v in pms_SelfTrainingClassifier_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_decision_function = bridgeSelfTrainingClassifier[${this.id}].decision_function(**pms_SelfTrainingClassifier_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_decision_function.tolist() if hasattr(res_SelfTrainingClassifier_decision_function, 'tolist') else res_SelfTrainingClassifier_decision_function`\n  }\n\n  /**\n    Fit self-training classifier using `X`, `y` as training data.\n   */\n  async fit(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Array representing the labels. Unlabeled samples should have the label -1.\n     */\n    y?: ArrayLike | SparseMatrix\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_fit = {k: v for k, v in pms_SelfTrainingClassifier_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_fit = bridgeSelfTrainingClassifier[${this.id}].fit(**pms_SelfTrainingClassifier_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_fit.tolist() if hasattr(res_SelfTrainingClassifier_fit, 'tolist') else res_SelfTrainingClassifier_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest \"sklearn.utils.metadata_routing.MetadataRequest\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_get_metadata_routing = {'routing': ${\n      opts['routing'] ?? undefined\n    }}\n\npms_SelfTrainingClassifier_get_metadata_routing = {k: v for k, v in pms_SelfTrainingClassifier_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_get_metadata_routing = bridgeSelfTrainingClassifier[${this.id}].get_metadata_routing(**pms_SelfTrainingClassifier_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_get_metadata_routing.tolist() if hasattr(res_SelfTrainingClassifier_get_metadata_routing, 'tolist') else res_SelfTrainingClassifier_get_metadata_routing`\n  }\n\n  /**\n    Predict the classes of `X`.\n   */\n  async predict(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict = {k: v for k, v in pms_SelfTrainingClassifier_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict = bridgeSelfTrainingClassifier[${this.id}].predict(**pms_SelfTrainingClassifier_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict.tolist() if hasattr(res_SelfTrainingClassifier_predict, 'tolist') else res_SelfTrainingClassifier_predict`\n  }\n\n  /**\n    Predict log probability for each possible outcome.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_log_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_log_proba = bridgeSelfTrainingClassifier[${this.id}].predict_log_proba(**pms_SelfTrainingClassifier_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_log_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_log_proba, 'tolist') else res_SelfTrainingClassifier_predict_log_proba`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n   */\n  async predict_proba(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_SelfTrainingClassifier_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_SelfTrainingClassifier_predict_proba = {k: v for k, v in pms_SelfTrainingClassifier_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_predict_proba = bridgeSelfTrainingClassifier[${this.id}].predict_proba(**pms_SelfTrainingClassifier_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_predict_proba.tolist() if hasattr(res_SelfTrainingClassifier_predict_proba, 'tolist') else res_SelfTrainingClassifier_predict_proba`\n  }\n\n  /**\n    Call score on the `base\\_estimator`.\n   */\n  async score(opts: {\n    /**\n      Array representing the data.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Array representing the labels.\n     */\n    y?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SelfTrainingClassifier must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SelfTrainingClassifier_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_SelfTrainingClassifier_score = {k: v for k, v in pms_SelfTrainingClassifier_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SelfTrainingClassifier_score = bridgeSelfTrainingClassifier[${this.id}].score(**pms_SelfTrainingClassifier_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SelfTrainingClassifier_score.tolist() if hasattr(res_SelfTrainingClassifier_score, 'tolist') else res_SelfTrainingClassifier_score`\n  }\n\n  /**\n    The fitted estimator.\n   */\n  get base_estimator_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing base_estimator_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_base_estimator_ = bridgeSelfTrainingClassifier[${this.id}].base_estimator_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_base_estimator_.tolist() if hasattr(attr_SelfTrainingClassifier_base_estimator_, 'tolist') else attr_SelfTrainingClassifier_base_estimator_`\n    })()\n  }\n\n  /**\n    Class labels for each output. (Taken from the trained `base\\_estimator\\_`).\n   */\n  get classes_(): Promise<NDArray | any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_classes_ = bridgeSelfTrainingClassifier[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_classes_.tolist() if hasattr(attr_SelfTrainingClassifier_classes_, 'tolist') else attr_SelfTrainingClassifier_classes_`\n    })()\n  }\n\n  /**\n    The labels used for the final fit of the classifier, including pseudo-labels added during fit.\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_transduction_ = bridgeSelfTrainingClassifier[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_transduction_.tolist() if hasattr(attr_SelfTrainingClassifier_transduction_, 'tolist') else attr_SelfTrainingClassifier_transduction_`\n    })()\n  }\n\n  /**\n    The iteration in which each sample was labeled. When a sample has iteration 0, the sample was already labeled in the original dataset. When a sample has iteration -1, the sample was not labeled in any iteration.\n   */\n  get labeled_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing labeled_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_labeled_iter_ = bridgeSelfTrainingClassifier[${this.id}].labeled_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_labeled_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_labeled_iter_, 'tolist') else attr_SelfTrainingClassifier_labeled_iter_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_features_in_ = bridgeSelfTrainingClassifier[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_features_in_.tolist() if hasattr(attr_SelfTrainingClassifier_n_features_in_, 'tolist') else attr_SelfTrainingClassifier_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_feature_names_in_ = bridgeSelfTrainingClassifier[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_feature_names_in_.tolist() if hasattr(attr_SelfTrainingClassifier_feature_names_in_, 'tolist') else attr_SelfTrainingClassifier_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of rounds of self-training, that is the number of times the base estimator is fitted on relabeled variants of the training set.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_n_iter_ = bridgeSelfTrainingClassifier[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_n_iter_.tolist() if hasattr(attr_SelfTrainingClassifier_n_iter_, 'tolist') else attr_SelfTrainingClassifier_n_iter_`\n    })()\n  }\n\n  /**\n    The reason that fitting was stopped.\n   */\n  get termination_condition_(): Promise<\n    'max_iter' | 'no_change' | 'all_labeled'\n  > {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SelfTrainingClassifier instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SelfTrainingClassifier must call init() before accessing termination_condition_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SelfTrainingClassifier_termination_condition_ = bridgeSelfTrainingClassifier[${this.id}].termination_condition_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SelfTrainingClassifier_termination_condition_.tolist() if hasattr(attr_SelfTrainingClassifier_termination_condition_, 'tolist') else attr_SelfTrainingClassifier_termination_condition_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}